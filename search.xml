<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/12/hello-world/</url>
    <content><![CDATA[<p><del>在无数久的 🐦咕咕咕 后一个博客它建成了！</del></p>
<p>在无数久的 🐦咕咕咕 后这个博客它复活了！</p>
<p>博客主要会收录这些东西：</p>
<ul>
<li><p>OI/ACM 相关</p>
<ul>
<li>考试技巧</li>
<li>题解</li>
<li>算法理解</li>
</ul></li>
<li><p>学习笔记</p></li>
<li><p>面向各种人群的科普</p></li>
<li><p>我的开源项目</p></li>
<li><p>生活中有趣的事</p></li>
<li><p>一些奇思妙想</p></li>
</ul>
<p>我是谁：</p>
<ul>
<li>如果你线下认识我，可以叫我 "毛Ker" 或者 "老毛"</li>
<li>如果你线上认识我，可以叫我 "彭彭"。</li>
<li>这些 ID
都是我：<code>huan-yp</code>，<code>幻影彭</code>，<code>huan_yp</code>，<code>huan_yp2002</code>。</li>
</ul>
<p>联系我：</p>
<ul>
<li>QQ：3051561876</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>折腾 vmware</title>
    <url>/2025/03/01/%E6%8A%80%E6%9C%AF/%E5%9F%BA%E7%A1%80/%E6%8A%98%E8%85%BE%20vmware/</url>
    <content><![CDATA[<p>折腾 vmware</p>
<p>ubuntu24.04 环境。</p>
<h3 id="config-apt-source">config apt source</h3>
<p>打开 <code>/etc/apt/source.list.d/ubuntu.sources</code>，在
<code>URIs</code> 一项中，<code>http://archive.ub....</code> 前面加上
<code>.cn</code>，也就是 <code>https://cn.archive.ub....</code>。</p>
<p>第二项那个 <code>security</code> 不用改。</p>
<h3 id="vmware-tools">vmware tools</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install open-vm-tools</span><br><span class="line">apt-get install open-vm-tools-desktop</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h3 id="重安装的网络问题">重安装的网络问题</h3>
<p>重新安装 vmware 时，可能会遇到以下问题：</p>
<ul>
<li>安装程序在 "配置网络驱动" 时卡死</li>
<li>安装后客户机死活连不上网。</li>
</ul>
<p>这是由于卸载时没有删除注册表导致的，解决方案（<a
href="https://blog.csdn.net/weixin_44188424/article/details/123402985">参考</a>）如下：</p>
<ul>
<li>在下载的软件中翻一翻，找到 "注册表"</li>
<li>一键扫描然后修复。</li>
<li>vmware 点 "编辑"，"虚拟网络编辑器"，还原默认设置。</li>
</ul>
<h3 id="输入法">输入法</h3>
<p>百度输入法很靠谱，它甚至附带了安装说明。</p>
<p><a
href="https://srf.baidu.com/site/guanwang_linux/index.html">百度输入法</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>EM 算法</title>
    <url>/2025/02/24/%E5%AD%A6%E6%9C%AF/EM%20%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="先验概率-vs-后验概率">先验概率 VS 后验概率</h2>
<h3 id="定义">定义</h3>
<ul>
<li><p>先验概率是<strong>根据主观经验，在没有任何实验的情况下</strong>对某件事情发生概率的预测。</p></li>
<li><p>后验概率是<strong>根据某些已知证据</strong>，去估计的事情发生的概率。
<span class="math display">\[
P(H|E) = \dfrac{P(E|H)*P(H)}{P(E)}
\]</span> 该式子中，每项含义如下：</p>
<ul>
<li><span class="math inline">\(P(H|E)\)</span>：在证据 <span
class="math inline">\(E\)</span> 成立的前提下，假设 <span
class="math inline">\(H\)</span> 成立的概率。</li>
<li><span class="math inline">\(P(E|H)\)</span>：在假设 <span
class="math inline">\(H\)</span> 成立的前提下，证据 <span
class="math inline">\(E\)</span> 被观测的概率。</li>
<li><span class="math inline">\(P(E)\)</span>：证据 <span
class="math inline">\(E\)</span> 成立的先验概率。</li>
<li><span class="math inline">\(P(H)\)</span>：假设 <span
class="math inline">\(H\)</span> 成立的先验概率。</li>
</ul></li>
</ul>
<h3 id="朱世衡之问">朱世衡之问</h3>
<p>有关朱世衡提出的硬币之问，不妨设 <span
class="math inline">\(E\)</span> 表示抛 <span
class="math inline">\(100\)</span> 次硬币 <span
class="math inline">\(50\)</span> 次正面朝上，<span
class="math inline">\(H\)</span> 表示 <span
class="math inline">\(p=0.9\)</span>，也就是正面朝上的概率为 <span
class="math inline">\(90\%\)</span>。那么：</p>
<ul>
<li><p>可以计算出 <span class="math inline">\(P(E|H)\le
\epsilon\)</span>，也就是<strong>如果 <span
class="math inline">\(H\)</span> 成立，那么观测到 <span
class="math inline">\(E\)</span> 的概率会很小</strong>。</p></li>
<li><p>不能说：<strong>因为 <span class="math inline">\(P(E|H)\le
\epsilon\)</span>，所以 <span class="math inline">\(P(H|E)\)</span>
很小</strong>。</p></li>
<li><p><span class="math inline">\(P(E)=\int^1_0{P(p=x)\cdot P(E|p=x)
dx}\)</span>，显然 <span class="math inline">\(P(p=x)\)</span>
是个先验概率，<strong>是确定不了的</strong>，所以 <span
class="math inline">\(P(E)\)</span> 没法计算，同理 <span
class="math inline">\(P(H)\)</span> 也没法计算，故 <span
class="math inline">\(P(H|E)\)</span> 计算不了。</p></li>
</ul>
<h2 id="最大似然">最大似然</h2>
<h3 id="一般求解方式">一般求解方式</h3>
<ul>
<li>考虑后验概率函数相对简单且为<strong>凸函数</strong>，对后验概率每个参数求偏导即可解出最大似然。</li>
<li>对后验概率函数使用<strong>梯度下降</strong>，求解<strong>极大似然</strong>。</li>
</ul>
<h2 id="em-算法">EM 算法</h2>
<h3 id="算法用途">算法用途</h3>
<p>EM 算法主要用于<strong>近似求解</strong>一些最大似然问题。</p>
<h3 id="算法流程">算法流程</h3>
<ol type="1">
<li>初始化<strong>模型参数</strong> <span
class="math inline">\(\theta\)</span>。</li>
<li>对 <span class="math inline">\(\theta\)</span> 进行迭代，优化 <span
class="math inline">\(Q(\theta | \theta^{(t)}) =
\mathbb{E}_{Z|Y,\theta^{(t)}} \left[ \log P(Y,Z|\theta)
\right]\)</span>。
<ul>
<li>根据 <span class="math inline">\(\theta^{(t)}\)</span> 计算 <span
class="math inline">\(Z\)</span> 不同取值的后验概率密度函数 <span
class="math inline">\(F = P(Z=x|\theta^{(t)})\)</span>。</li>
<li>根据 <span class="math inline">\(F, \theta^{(t)}\)</span>
求解上式的最大似然。</li>
</ul></li>
</ol>
<h3 id="算法举例">算法举例</h3>
<p>有三个硬币 <span
class="math inline">\(A,B,C\)</span>，正面朝上的概率为 <span
class="math inline">\(\theta_A,\theta_B, \pi\)</span>，每次实验先抛硬币
<span class="math inline">\(C\)</span>，如果 <span
class="math inline">\(C\)</span> 正面朝上，则使用 <span
class="math inline">\(A\)</span>，否则使用 <span
class="math inline">\(B\)</span>，一次实验抛完 <span
class="math inline">\(C\)</span> 后抛 <span
class="math inline">\(A\)</span> 或 <span
class="math inline">\(B\)</span> 五次，记录为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实验一：2 正 3 反</span><br><span class="line"></span><br><span class="line">实验二：4 正 1 反</span><br><span class="line"></span><br><span class="line">实验三：1 正 4 反</span><br><span class="line"></span><br><span class="line">实验四：3 正 2 反</span><br><span class="line"></span><br><span class="line">实验五：4 正 1 反</span><br></pre></td></tr></table></figure>
<p>根据实验结果给出一个最大似然参数估计 <span
class="math inline">\(\theta = (\theta_A, \theta_B, \pi)\)</span>。</p>
<h4 id="e-步骤">E 步骤</h4>
<p>计算每个实验由 <span class="math inline">\(A\)</span> 或 <span
class="math inline">\(B\)</span> 生成的后验概率：<br />
<span class="math display">\[
\gamma_j(A) = \frac{\pi \cdot \theta_A^{n_j}(1-\theta_A)^{m_j}}{\pi
\cdot \theta_A^{n_j}(1-\theta_A)^{m_j} + (1-\pi) \cdot
\theta_B^{n_j}(1-\theta_B)^{m_j}}
\]</span></p>
<h4 id="m-步骤">M 步骤</h4>
<p>迭代更新： <span class="math display">\[
\pi&#39; = \frac{\sum_{j=1}^5 \gamma_j(A)}{5}
\]</span></p>
<p><span class="math display">\[
\theta_A&#39; = \frac{\sum_{j=1}^5 \gamma_j(A) \cdot n_j}{\sum_{j=1}^5
\gamma_j(A) \cdot 5}, \quad \theta_B&#39; = \frac{\sum_{j=1}^5
\gamma_j(B) \cdot n_j}{\sum_{j=1}^5 \gamma_j(B) \cdot 5}
\]</span></p>
<h4 id="迭代">迭代</h4>
<p>设置一个收敛阈值，似然估计变化小于阈值时令其停止。</p>
<h2 id="em-原理证明">EM 原理证明</h2>
<p>首先对似然函数取对数，记： <span class="math display">\[
L(\theta) =
\log(P(Y|\theta))=\log{\sum\limits_{z}P(YZ|\theta)}=\log(\sum\limits_{z}P(Y|Z,\theta)P(Z|\theta))
\]</span> 考虑： <span class="math display">\[
\begin{align}
L(\theta) - L(\theta^{(i)})&amp;=
\log\big({\sum\limits_{z}P(Y|Z,\theta)P(Z|\theta)}\big) \\
&amp;=\log\big({\sum\limits_{z}P(Z|Y,
\theta^{(i)})\frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y, \theta^{(i)})}}\big)
- \log(P(Y|\theta^{(i)}))
\end{align}
\]</span> 由 <span class="math inline">\(\text{Jensen}\)</span>
不等式，得 <span class="math display">\[
\begin{align}
\text{上式} &amp;\ge
\sum\limits_{z}P(Z|Y,\theta^{(i)})\log{\frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,
\theta^{(i)})}} - \log(P|\theta^{(i)})\\
&amp;=
\sum\limits_{z}P(Z|Y,\theta^{(i)})\log{\frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,
\theta^{(i)})P(|\theta^{(i)})}})
\end{align}
\]</span> 令： <span class="math display">\[
\begin{align}
B(\theta, \theta^{(i)})&amp;= L(\theta)
+  P(Z|Y,\theta^{(i)})\log{\frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,
\theta^{(i)})P(Y|\theta^{(i)})}}\\
&amp;=L(\theta)+P(Z|Y,\theta^{(i)})\log{\frac{P(YZ|\theta)}{P(YZ|\theta^{(i)})}}
\end{align}
\]</span> <em>第二行来自贝叶斯公式。</em></p>
<p>则有 <span class="math inline">\(L(\theta)\ge B(\theta,
\theta^{(i)})\)</span>，且 <span
class="math inline">\(B(\theta,\theta)=L(\theta)\)</span>。</p>
<p>所以令： <span class="math display">\[
\theta^{(i+1)} = \mathbf{argmax}_\theta B(\theta, \theta^{(i)})
\]</span> 则有： <span class="math display">\[
L(\theta^{(i+1)}) \ge B(\theta^{(i+1)}, \theta^{(i)}) \ge
B(\theta^{(i)},\theta^{(i)})=L(\theta^{(i)})
\]</span> 即： <span class="math display">\[
L(\theta^{(i+1)})\ge L(\theta^{(i)})
\]</span></p>
<h2 id="算法分析">算法分析</h2>
<h3 id="对比">对比</h3>
<p>上面的三硬币问题理论上也可以直接求解最大似然，但是列出来后是一个
PDE，一般 PDE 目前是没有闭式解，所以也只能退而求其次找近似解。</p>
<p>梯度下降也行，但是相比于
EM，梯度下降的梯度计算比较复杂，而且无法保证满足概率约束，可解释性弱，收敛不可靠等等等。</p>
<h3 id="m-步骤最大似然的求解">M 步骤最大似然的求解</h3>
<p>三个变量是独立的，分别求偏导就能代出值来。</p>
]]></content>
      <categories>
        <category>学术</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 实践</title>
    <url>/2025/02/22/%E6%8A%80%E6%9C%AF/%E7%94%9F%E4%BA%A7%E5%8A%9B/Docker%20%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="查看镜像和容器">查看镜像和容器</h2>
<ul>
<li><p>显示本地所有镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li>
<li><p>显示所有正在运行的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li>
<li><p>显示所有容器（包括停止的）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="运行容器">运行容器</h2>
<ul>
<li><p>从镜像新建并运行一个容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run &lt;image_name&gt;</span><br></pre></td></tr></table></figure>
<p>可选参数表：</p>
<ul>
<li><code>-d</code>：以守护模式运行。</li>
<li><code>-it</code>：保持 STDIN
打开并分配一个伪终端。（建永远选上这个）</li>
<li><code>--name &lt;name&gt;</code>：给容器起个名，易于区分。</li>
<li><code>-p &lt;host_port&gt;:&lt;client_port&gt;</code>
：进行端口映射，可以有多个
<code>-p &lt;host_port&gt;:&lt;client_port&gt;</code>
字段。也支持端口段映射，比如 <code>-p 8000-8010:8000-8010</code>。</li>
<li><code>-e &lt;key&gt;=&lt;value&gt;</code>：设置启动时环境变量。</li>
</ul>
<p>其它事项：</p>
<ul>
<li>一般来说，如果不指定
<code>-d</code>，退出终端时，容器会自动退出。</li>
<li><code>-d</code>，<code>--name</code>，<code>-p</code>
必须在通过镜像创建容器时确定，之后一般无法改变。</li>
<li>如果本地没有 <code>&lt;image_name&gt;</code>
镜像，会自动从远端拉去。</li>
</ul></li>
<li><p>启动一个被退出的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start &lt;container_name&gt;</span><br></pre></td></tr></table></figure>
<p>可选参数表：</p>
<ul>
<li><code>-ia</code>：启动交互模式并附加到一个终端上。</li>
</ul>
<p>其它事项：</p>
<ul>
<li><code>&lt;container_name&gt;</code> 支持前缀匹配，不需要全名。</li>
</ul></li>
<li><p>附加到一个已经启动的容器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it &lt;container_name&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p>可选参数：</p>
<ul>
<li><code>-it</code>：保持 STDIN 打开并进入交互式 shell。</li>
</ul></li>
<li><p>在一个已经运行的容器中执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec &lt;container_name&gt; &lt;COMMAND&gt; &lt;ARGS...&gt;</span><br></pre></td></tr></table></figure>
<p>可选参数：</p>
<ul>
<li><code>-d</code>：后台运行命令，不进入容器。</li>
<li><code>-e &lt;key&gt;=&lt;value&gt;</code>：设定环境变量。</li>
<li><code>-w</code>：指定命令执行的工作目录。</li>
</ul></li>
</ul>
<h2 id="容器的生命周期">容器的生命周期</h2>
<p>容器的生命周期与主进程（PID=1
的进程）绑定，主进程退出时容器生命周期结束。</p>
<ol type="1">
<li><p>当以 <code>docker run -it</code>
运行容器时，<strong>主进程是终端进程</strong>，终端退出则容器退出。</p></li>
<li><p>当以 <code>docker start -ia</code> 恢复容器运行时，
<strong>主进程是终端进程</strong>，终端退出则容器退出。</p></li>
<li><p>当以 <code>docker start</code>
恢复容器运行时，<strong>主进程是一个守护进程</strong>，再使用
<code>docker exec -it /bin/bash</code>
启动容器终端时，终端不作为主进程，退出对容器无影响。</p></li>
<li><p>当以 <code>docker run -d</code>
运行容器时，<strong>主进程是守护进程</strong>，再使用
<code>docker exec -it /bin/bash</code>
启动容器终端时，终端不作为主进程，退出对容器无影响。（该情况下，主动
<code>docker stop</code> 容器再用 <code>docker start -ia</code>
恢复时，主进程是终端进程而不是守护进程）</p></li>
</ol>
<h2 id="操作容器">操作容器</h2>
<ul>
<li><p>删除容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -rm &lt;container_name&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="制作镜像">制作镜像</h2>
<h3 id="直接用-container-制作">直接用 container 制作</h3>
<p>制作步骤：</p>
<ul>
<li><p><code>docker run -it</code> 一个基础镜像。</p></li>
<li><p>用终端进行必要的修改。</p></li>
<li><p><code>exit</code> 退出基础镜像并让它停止。</p></li>
<li><p>执行 <code>commit</code> 制作镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit &lt;container_name&gt; &lt;image_name&gt;[:&lt;version&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不使用 <code>[:version]</code>，默认使用
<code>latest</code>。</li>
</ul></li>
</ul>
<h3 id="用-dockerfile-制作">用 Dockerfile 制作</h3>
<p>用 container
制作虽然方便，但把所有操作打包到一个层非常不利于维护，所以有条件的话都建议用
Dockerfile 来制作。</p>
<p>一个经典的 Dockerfile 如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> image_name:tag</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> YOUR_NAME <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> var_name value</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> file_path destination_directory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">command</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> port_number</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;command&quot;</span>, <span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>FROM</code>：指定基础镜像。</li>
<li><code>MAINTAINER</code>：指定作者信息。</li>
<li><code>ENV</code>：设置环境变量，它在<strong>构建阶段</strong>和<strong>容器生命周期内</strong>均有效。</li>
<li><code>COPY</code>：从宿主机拷贝文件过来。</li>
<li><code>WORKDIR</code>：设置工作目录，如果不存在，会递归创建。</li>
<li><code>RUN</code>：执行必要的构建命令。</li>
<li><code>EXPOSE</code>：明确要暴露的端口号，但还是需要在
<code>docker -run</code> 时使用 <code>-p</code> 指定。</li>
<li><code>CMD</code>：定义 <code>docker run</code> 时的默认命令。</li>
</ul>
<p>制作步骤如下：</p>
<ul>
<li><p><strong>准备</strong></p>
<p>建一个目录，里面创建一个名为 <code>Dockerfile</code>
的文件，在里面写命令。</p>
<p>目录里加上可能要拷贝进去的文件。</p></li>
<li><p><strong>构建</strong></p>
<p><code>Dockerfile</code> 的所在目录下执行以下代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t [&lt;image_name&gt;[:&lt;version&gt;]] &lt;cwd&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t</code>：一般<strong>必选</strong>，指定镜像名和版本。</li>
<li><code>cwd</code>：一般就写 <code>.</code> 了。</li>
</ul></li>
<li><p><strong>测试</strong></p>
<p>看一下构建成功没有。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其它常用命令">其它常用命令</h3>
<ul>
<li><p>打 tag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag &lt;image&gt;:&lt;old_version&gt; &lt;image&gt;:&lt;new_version&gt;</span><br></pre></td></tr></table></figure>
<p>一般创建的时候你会写 <code>&lt;image&gt;</code> 和
<code>&lt;version&gt;</code>。</p>
<p>可以把 <code>&lt;version&gt;</code> 看成一个指针，创建 image
的时候你让 <code>&lt;version&gt;</code> 指向了它。</p>
<p><code>docker tag</code> 的作用就是将 <code>&lt;new_version&gt;</code>
也指向 <code>&lt;version&gt;</code> 指向的对象，用以下 cpp
代码理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Image *old_version = <span class="keyword">new</span> <span class="built_in">Image</span>();</span><br><span class="line">Image *new_version = old_version;</span><br></pre></td></tr></table></figure></li>
<li><p>镜像保存到文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o &lt;filename&gt; &lt;image_name&gt;[:&lt;version&gt;]</span><br></pre></td></tr></table></figure></li>
<li><p>从文件加载镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load -i &lt;filename&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>容器保存到文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker export -o &lt;filename&gt; &lt;container_name&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从文件将容器<strong>加载为镜像</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker import &lt;filename&gt; &lt;image_name&gt;[:&lt;version&gt;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="跨设备传输">跨设备传输</h2>
<h3 id="推送到-dockerhub">推送到 DockerHub</h3>
<p>有时候会把 image 推送到 DockerHub 上方便跨设备传输，步骤如下：</p>
<ol type="1">
<li><p>注册一个 <a href="https://hub.docker.com/">DockerHub</a>
账号。</p></li>
<li><p>终端登录 DockerHub：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>
<p>在提示下输入账号密码即可。</p></li>
<li><p>tag 你的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag &lt;image_name&gt;:&lt;version&gt; &lt;username&gt;/&lt;image_name&gt;:&lt;version&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>push 它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push &lt;username&gt;/&lt;image_name&gt;:&lt;version&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意事项：</p>
<ul>
<li><p>如果你的 <code>latest</code> 版本同时也是 <code>1.0</code>
版本，那么需要<strong>同时把两个标签推送上去</strong>才行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push &lt;username&gt;/&lt;image_name&gt;:&lt;latest&gt;</span><br><span class="line">docker push &lt;username&gt;/&lt;image_name&gt;:&lt;1.0&gt;</span><br></pre></td></tr></table></figure>
<p>但是显然只会推一次数据，第二次只是推个标签而已。</p></li>
</ul>
<h3 id="用传输介质传输">用传输介质传输</h3>
<p>参考上面的
<code>docker save/load</code>，<code>docker export/import</code> 并使用
U 盘或者网线等介质传输。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络学习笔记</title>
    <url>/2025/02/20/%E5%AD%A6%E6%9C%AF/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前置知识">前置知识</h2>
<h3 id="导数-vs-微分">导数 VS 微分</h3>
<p><strong>导数就是导函数。</strong></p>
<p><span class="math inline">\(f\)</span> 的微分 <span
class="math inline">\(df\)</span> 可以看作一个函数，（一维的情况下）它将
<span class="math inline">\(dx\)</span> 映射到 <span
class="math inline">\(f&#39;(x)dx\)</span>。</p>
<p><em><span class="math inline">\(dx\)</span>
怎么理解看个人，我没有把它当成函数，而是把它当成了一个单纯的记号。</em></p>
<h3 id="梯度-vs-微分">梯度 VS 微分</h3>
<p><strong>梯度是高维意义下的导数。</strong></p>
<ol type="1">
<li><p><strong>梯度的定义</strong>：
梯度是一个向量，包含函数的所有<strong>偏导数</strong>。对于函数 <span
class="math inline">\(f(x,y)\)</span>，其梯度为： <span
class="math display">\[
\nabla f = \left( \frac{\partial f}{\partial x}, \frac{\partial
f}{\partial y} \right)
\]</span> 梯度指向函数值增加最快的方向。</p></li>
<li><p><strong>微分的定义</strong>：
微分描述了函数在<strong>自变量微小变化时的改变</strong>。对于函数 <span
class="math inline">\(f(x,y)\)</span>，其微分 <span
class="math inline">\(df\)</span> 为： <span class="math display">\[
df = \frac{\partial f}{\partial x} dx + \frac{\partial f}{\partial y} dy
\]</span></p>
<p>这表示函数在自变量 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 分别变化 <span
class="math inline">\(dx\)</span> 和 <span
class="math inline">\(dy\)</span> 时的总变化。</p></li>
</ol>
<h3 id="常用函数">常用函数</h3>
<ul>
<li><strong>sigmoid</strong>：记作 <span
class="math inline">\(\sigma(x)\)</span>，<span
class="math inline">\(\sigma(x) = \frac{1}{1+e^{-x}}\)</span>。</li>
<li><strong>双曲正切函数</strong>：记作 <span
class="math inline">\(\tanh(x)\)</span>，<span
class="math inline">\(\tanh(x) =
\frac{e^x-e^{-x}}{e^x+e^{-x}}\)</span>。</li>
</ul>
<h3 id="常用记号">常用记号</h3>
<ul>
<li><strong>逐元素相乘（Hadamard Product）</strong>：<span
class="math inline">\(A \odot B = C\)</span> 表示张量 <span
class="math inline">\(A,B\)</span> 逐元素得到一个同结构的张量 <span
class="math inline">\(C\)</span>。</li>
<li><strong>矩阵乘法</strong>：<span class="math inline">\(A\cdot B =
C\)</span> 表示两个矩阵按矩阵乘法规则乘出来是 <span
class="math inline">\(C\)</span>，<strong>没有特殊说明一定不是点乘</strong>。</li>
</ul>
<h2 id="神经网络">神经网络</h2>
<h3 id="权重矩阵">权重矩阵</h3>
<p>权重矩阵用于在层之间做转移，是神经网络结构的主要组成部分。</p>
<h3 id="激活函数">激活函数</h3>
<p>激活函数用于调整函数结构，使神经网络能够学习复杂的非线性函数。</p>
<h3 id="偏置项">偏置项</h3>
<p>偏置项用于对激活范围进行调整，能够有效提升模型表达能力。</p>
<p>没有偏置项时，激活函数的输出只取决于输入信号的加权和，这样拟合会让模型变得复杂，引入偏置项能够有效改善学习过程。</p>
<h3 id="反向传播算法">反向传播算法</h3>
<p>通过链式求导法则，计算每一项的梯度，以减少损失函数为目的按照梯度调整权重矩阵和偏置项的值。</p>
<h4 id="不完全可微函数的处理">不完全可微函数的处理</h4>
<p>激活函数有时候不是完全可微的，例如 ReLU
函数，这个时候会采取某些方式来处理。</p>
<ol type="1">
<li><strong>归到某一边：</strong>反正概率挺小的，直接认为可导归到其中一边就行。</li>
<li><strong>使用次梯度：</strong>如果它是个凸函数，可以用次梯度近似替代。</li>
<li><strong>用可导函数近似：</strong>找个长得差不多的可导函数，不可微的点用这个函数的微分替代。</li>
</ol>
<h3 id="批次训练与梯度累计">批次训练与梯度累计</h3>
<p>神经网络一般采用批次训练的方式，利用 GPU
的并行计算能力，一个批次跑出多个数据的 loss
和梯度。然后取平均后进行一次下降。</p>
<p>一般来说 batch_size
设置大一点可以让学习过程更加稳定，减少个别数据的极端偏移。</p>
<p>有时候显存不够甚至可以多跑几次积累一下梯度，然后进行更新。</p>
<p><em>注意这里是对<strong>梯度</strong>取平均，不是对 loss
或者中间过程的值取平均。</em></p>
<h3 id="过拟合与缓解方式">过拟合与缓解方式</h3>
<h4 id="early-stop">Early Stop</h4>
<p>训到训练集 Loss 连续一段时间不再下降时就停止。</p>
<h4 id="l1l2-standardization">L1/L2 Standardization</h4>
<p>给 Loss 加个正则化项：</p>
<ul>
<li>L1 正则化：<span
class="math inline">\(\lambda\sum|w_i|\)</span></li>
<li>L2 正则化：<span class="math inline">\(\lambda\sum
w_i^2\)</span></li>
</ul>
<p>为啥有用：</p>
<ul>
<li>L1
促进一些参数变零，可以实现<strong>特征选择</strong>，以去除不重要的特征。</li>
<li>L2 鼓励减小参数大小，降低对训练数据的敏感性。</li>
<li>总的来说都是<strong>限制了模型复杂度以减小过拟合的可能</strong>。</li>
</ul>
<h4 id="dropout">Dropout</h4>
<p>实现方式：</p>
<ul>
<li><strong>每轮训练</strong>的时候以一个概率 <span
class="math inline">\(p\in[0.2,0.5]\)</span> 让（特定的 Dropout
层）激活函数变零。</li>
<li>测试的时候启用全部神经元，同时乘上一个系数 <span
class="math inline">\((1-p)\)</span> 补偿训练过程的丢弃。</li>
</ul>
<p>为啥有用：</p>
<ul>
<li>取平均作用：不同轮次的 Dropout
可以视作不同的神经网络，产生不同的过拟合，能够相互抵消。</li>
<li>减少共适性关系：不应该对某些特定的特征特别敏感，迫使神经网络学习到具有鲁棒性的特征。</li>
</ul>
<h3 id="其它训练技巧">其它训练技巧</h3>
<h4 id="batch-normalization">Batch Normalization</h4>
<p>实现方式：</p>
<ul>
<li>在神经网络的每一层输入层前加一个 BN 层，将输入归一化为均值为
0，方差为 1 的输入。</li>
<li>BN 层增加两个可学习参数 <span class="math inline">\(\gamma,
\beta\)</span>，用于对归一化后的数据进行线性变换。</li>
</ul>
<p>生效原理：</p>
<ul>
<li>缓解内部协变量偏移问题：使各层输入分布稳定，加速网络收敛，对于深度神经网络作用更大。</li>
<li>提升梯度传播效率：使输入保持在激活函数非饱和区内，有利于缓解梯度消失和梯度爆炸，同时也能避免参数初始化时使训练陷入困境。</li>
<li>增强泛化能力*：由于 <span
class="math inline">\(\gamma,\beta\)</span>
是可学习的，因此训练过程会对数据进行一些小扰动，可能能增强泛化能力。</li>
</ul>
<h2 id="卷积神经网络cnn">卷积神经网络（CNN）</h2>
<h3 id="卷积层">卷积层</h3>
<h4 id="卷积核">卷积核</h4>
<ul>
<li><p>我不懂为啥要叫卷积，但是卷积核是对对应的小矩阵做<strong>点乘</strong>，然后得到一个数作为特征值。</p></li>
<li><p>一个卷积层可能有多个卷积核，不同卷积核可以提取不同的特征，最后卷出来的结果是个张量。</p></li>
</ul>
<h4 id="参数">参数</h4>
<ul>
<li><p>大小：常见的有 3x3 和
5x5，较小的卷积核能够捕捉精细特征，较大的可以捕获更广泛的上下文信息。</p></li>
<li><p>步长：决定卷积核在数据上滑动的间隔，步长越大，特征图输出越小。</p></li>
<li><p>填充：在图像边缘添加额外像素，控制输出特征图的大小。</p></li>
<li><p>权重：卷积核每个位置的值叫做权重，这个是可以学习的。</p></li>
<li><p>偏置：每个卷积核有一个偏置值，也是可以学习的。</p></li>
</ul>
<h4 id="作用">作用</h4>
<p>有效提取各种局部特征。</p>
<h3 id="池化层">池化层</h3>
<h4 id="结构">结构</h4>
<ul>
<li>池化窗口：一般设置为 2x2 或者 3x3，决定每次考虑的局部区域大小</li>
<li>池化方式：最大池化或者平均池化，前者取最大值并保留，后者取平均值并保留。</li>
<li>池化步长：和卷积层的步长差不多，决定特征图大小用的。</li>
</ul>
<h4 id="用途">用途</h4>
<p>降低特征图维度，减少计算量，同时保留重要的局部特征信息。</p>
<h3 id="全连接层">全连接层</h3>
<p>一般放在最后几层，用于整合前面提取的特征，输出最终的结果。</p>
<h3 id="优势">优势</h3>
<ul>
<li>天然适用于处理图像，能够有效提取图像局部特征并完成图像相关任务。</li>
</ul>
<h3 id="一般使用方式">一般使用方式</h3>
<ul>
<li>通常会堆很多层，非常深，一层卷积带一层池化这样。</li>
</ul>
<h3 id="改进">改进</h3>
<h4 id="resnet">ResNet</h4>
<p>引入了残差块，解决了深层神经网络梯度消失的问题。<del>卧槽了这 TM
也能管用。</del></p>
<p>残差块是在两个卷积层的基础上直接拉了一个恒等偏置过来。假设一个残差块的输入是
<span class="math inline">\(x\)</span>，输出 <span
class="math inline">\(H(x)\)</span>，卷积层结构是 <span
class="math inline">\(F(x, W_i)\)</span>，那么令： <span
class="math display">\[
H(x) = x + F(x, W_i)
\]</span></p>
<p>参与学习的参数只有 <span
class="math inline">\(W_i\)</span>，这样反向传播链式求导的时候梯度能直接从
<span class="math inline">\(x\)</span>
这一项传到前面去，神秘的解决了梯度消失问题。</p>
<h2 id="循环神经网络rnn">循环神经网络（RNN）</h2>
<h3 id="结构-1">结构</h3>
<h4 id="输入">输入</h4>
<ol type="1">
<li><strong>当前时刻的输入</strong> <span
class="math inline">\(x_t\)</span>：表示当前时间步的输入数据，例如在自然语言处理中，*<span
class="math inline">\(x_t\)</span> 可以是一个单词的嵌入向量。</li>
<li><strong>上一时刻的隐藏状态</strong> <span
class="math inline">\(h_{t-1}\)</span>：表示上一时间步的输出状态，用于传递之前的信息。</li>
</ol>
<h4 id="输出">输出</h4>
<ol type="1">
<li><strong>当前时刻的隐藏状态</strong> <span
class="math inline">\(h_t\)</span>：用于传递给下一个时间步。</li>
<li><strong>当前时刻的输出</strong> <span
class="math inline">\(y_t\)</span>（可选）：在某些任务中，RNN
的每个时间步都会产生一个输出，例如在字符级语言模型中，<span
class="math inline">\(y_t\)</span> 可以表示下一个字符的概率分布。</li>
</ol>
<h4 id="状态公式">状态公式</h4>
<p><span class="math display">\[
h_t=\sigma(W_{hh}h_{t-1}+W_{xh}x_t+b_t)
\]</span></p>
<ul>
<li><span class="math inline">\(W_{hh}\)</span>：隐藏状态转移公式。</li>
<li><span
class="math inline">\(W_{xh}\)</span>：输入到隐藏贡献公式。</li>
<li><span class="math inline">\(\sigma\)</span>：激活函数。</li>
<li><span class="math inline">\(b_h\)</span>：偏置项。</li>
</ul>
<h4 id="训练过程">训练过程</h4>
<p>一般用 BackPropagation Through
Time（BPTT）算法进行权重更新，过程如下：</p>
<ul>
<li>前向传播：从 <span class="math inline">\(t=1\)</span>
开始一次计算隐藏状态和输出。</li>
<li>计算损失：计算所有输出的损失函数。</li>
<li>反向传播：从 <span class="math inline">\(t=T\)</span>
开始依次计算每个时间步的梯度，最后梯度加在一起更新。</li>
</ul>
<h3 id="优缺点">优缺点</h3>
<h4 id="优势-1">优势</h4>
<ul>
<li>能处理变长的输入。</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>梯度消失：处理过长的序列时，容易发生梯度消失，导致无法捕捉长距离的依赖。</li>
<li>梯度爆炸：处理过长的序列时，容易发生梯度爆炸，导致权重更新过大，训练过程不稳定。</li>
</ul>
<h2 id="长短期记忆网络lstm">长短期记忆网络（LSTM）</h2>
<p>RNN 的问题很大，所以衍生出了 RNN 的变体：LSTM。</p>
<p>LSTM 通过门控机制巧妙地解决了 RNN
的长距离依赖问题。遗忘门能够控制信息的遗忘，输入门能够选择性地添加新信息，而输出门则能够控制信息的输出。这三个门的协同作用使得
LSTM 能够有效地学习和存储长期序列信息，并且能够避免梯度消失问题。</p>
<h3 id="结构-2">结构</h3>
<p>LSTM 的核心是<strong>记忆单元（cell）</strong>。</p>
<h4 id="关键状态">关键状态</h4>
<ul>
<li><p><strong>记忆状态</strong>：cell
状态能够长时间的存储时间序列中的信息，其信息数据受<strong>门</strong>的控制，能够将所需的信息稳定的沿时间轴传递。</p></li>
<li><p><strong>隐藏状态</strong>：同基础 RNN 的隐藏状态。</p></li>
</ul>
<h4 id="门">门</h4>
<ul>
<li><strong>遗忘门</strong>：
<ul>
<li>功能：决定 cell 中旧信息的遗忘程度。</li>
<li>运行：通过一个 sigmoid 函数来产生一个值在 0 和 1 之间的遗忘率。0
表示完全遗忘，1
表示完全保留。它接受前一时间步的隐藏状态和当前时间步的输入作为输入，产生遗忘矩阵
<span class="math inline">\(f_t\)</span> 作为输出。</li>
<li>公式：<span class="math inline">\(f_t=\sigma(W_f\cdot [h_{t-1},
x_t]+b_f)\)</span>。</li>
</ul></li>
<li><strong>输入门</strong>：
<ul>
<li>功能：决定是否需要将新的信息存储到细胞状态中。</li>
<li>运行方式：输入门同样通过一个 sigmoid 函数计算一个值在 0 和 1
之间的输入率。这个输入率决定了有多少新信息会被允许存储到细胞状态中，输入同遗忘门。</li>
<li>公式表示：<span class="math inline">\(i_t=\sigma(W_i\cdot [h_{t-1},
x_t]+b_i)\)</span></li>
</ul></li>
<li><strong>输出门</strong>：
<ul>
<li>功能：决定当前时间步的输出。</li>
<li>运行方式：通过 sigmoid
函数计算一个输出矩阵，决定细胞状态信息的输出率，输出率描述了多大比例的细胞状态信息会被激活并传递出去。</li>
<li>公式表示：<span class="math inline">\(o_t=\sigma(W_o\cdot[h_{t-1},
x_t]+b_o)\)</span>。</li>
</ul></li>
</ul>
<h3 id="状态更新">状态更新</h3>
<h4 id="计算候选细胞状态">计算候选细胞状态</h4>
<p><span class="math display">\[
\tilde{C_t}=\tanh{W_C\cdot[h_{t-1}, x_t]+b_C}
\]</span></p>
<p>候选细胞状态描述了当前信息对长期记忆的影响，参与细胞状态的更新。</p>
<h4 id="更新细胞状态">更新细胞状态</h4>
<p><span class="math display">\[
C_t=f_t\odot C_{t-1}+i_t\odot \tilde{C_t}
\]</span></p>
<p>新细胞状态由上次细胞状态遗忘一部分，加上当前信息的候选状态补充进去。</p>
<h4 id="更新隐藏状态">更新隐藏状态</h4>
<p><span class="math display">\[
h_t = o_t\odot \tanh{C_t}
\]</span></p>
<p>隐藏状态通过当前的记忆来更新。</p>
<h3 id="bilstm">BiLSTM</h3>
<p>BiLSTM 对传统的 LSTM 的扩展。相较于传统的单向 LSTM
只能捕捉序列中过去的信息，BiLSTM
能够同时捕捉序列中的过去和未来信息。</p>
<h4 id="结构-3">结构</h4>
<p>BiLSTM 就是两个 LSTM
拼接起来的，一个输入的是正向序列，另一个输入反向序列。</p>
<p>两个序列算出对应位置的 <span
class="math inline">\(h^{f}_t,h_{t}^{b}\)</span> 后，再拼接成一个新向量
<span class="math inline">\(h_t\)</span>。</p>
<p>最后从 <span class="math inline">\(h_t\)</span>
里面解析信息出来。</p>
<h3 id="grm">GRM</h3>
<p>GRM 是 LSTM
爆改过来的，减少了门的数量以降低复杂度但效果能得到一定保证。</p>
<p>GRU
通过更新门和重置门的协同作用，实现了对隐藏状态的有效更新。更新门决定了保留多少过去的信息，重置门决定了当前输入对隐藏状态的影响程度。这种门控机制使得
GRU 能够在低计算成本下处理长期依赖序列数据，避免了传统 RNN
中的梯度消失问题。</p>
<h4 id="结构-4">结构</h4>
<ol type="1">
<li><strong>更新门（Update Gate）</strong>：
<ul>
<li>决定当前隐藏状态中保留多少过去的信息，以及从当前输入中引入多少新信息。</li>
<li>其计算公式为：<span class="math inline">\(z_t =
\sigma(W_z\cdot[h_{t-1}, x] + b_z)\)</span>。</li>
</ul></li>
<li><strong>重置门（Reset Gate）</strong>：
<ul>
<li>决定当前输入信息对当前隐藏状态的影响程度，控制对过去信息的依赖。</li>
<li>其计算公式为：<span class="math inline">\(r_t =
\sigma(W_r\cdot[h_{t-1}, x] + b_r)\)</span>。</li>
</ul></li>
</ol>
<h4 id="状态转移">状态转移</h4>
<ol type="1">
<li><p><strong>计算候选隐藏状态</strong>： <span class="math display">\[
\tilde{h_t} = \tanh(W_h\cdot[h_{t-1}, x] + b_h)
\]</span></p>
<p>在考虑重置门的作用后，通过当前输入和<strong>经过重置门处理后的前一时刻隐藏状态</strong>计算得到。</p></li>
<li><p><strong>隐藏状态更新</strong>： <span class="math display">\[
h_t=z_t\odot h_{t-1}+(1-z_t)\odot\tilde{h_t}
\]</span></p>
<p>最终的隐藏状态由更新门控制，结合了前一时刻的隐藏状态和当前的候选隐藏状态。</p></li>
</ol>
]]></content>
      <categories>
        <category>学术</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI 七层模型简单理解</title>
    <url>/2025/02/17/%E6%8A%80%E6%9C%AF/%E5%9F%BA%E7%A1%80/OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>这篇文章是以<strong>现代计算机网络硬件</strong>为基础编写的，主要介绍了现代硬件环境下应该了解的网络知识，能够为网络编程打下一个较好的基础。</p>
<p>第一次接触不一定能理解全部内容，但当你对网络编程有一定了解后，也可以回来再看看？</p>
<h2 id="物理层">物理层</h2>
<ul>
<li><p>这一层是电子信息系的事，不是计算机系的事。</p></li>
<li><p>这一层可以实现在<strong>两台设备间不稳定的传输数据</strong>。</p></li>
<li><p>这一层数据传输的基本单位是 bit。</p></li>
</ul>
<h2 id="数据链路层">数据链路层</h2>
<p>这一层的主要设备是交换机。</p>
<p>多台主机和交换机，网线构成了一个 LAN。</p>
<h3 id="数据单位">数据单位</h3>
<p>数据层的数据传输单位是 Frame
(帧)，帧包括帧头，帧体，帧尾，帧头包括数据 src 和 dst 的 MAC
地址，帧尾包含一些校验信息。</p>
<p>数据链路层保证了 LAN 中数据传输的可靠性。</p>
<p>以其中一种机制为例：</p>
<ul>
<li>发送方在发送帧的时候，会等待一个 ACK 确认，如果没有等到 ACK
确认，则会重传该帧，直到所有数据帧得到 ACK 确认时结束传输。</li>
<li>接收方会根据帧尾的校验信息确认帧体数据无误，无误后发送 ACK
确认。</li>
</ul>
<h3 id="交换机功能">交换机功能</h3>
<p>数据链路层中，每台设备具有唯一 MAC
地址（这是出厂时烧在网卡上的唯一标识）。</p>
<p>交换机主要用于根据数据帧的 MAC 地址在主机间正确转发数据帧。</p>
<h3 id="mac-地址学习">MAC 地址学习</h3>
<p>交换机有若干个口可以插，如果可能，交换机收到数据后，只会往目标 MAC
的那个端口发。</p>
<p>如果交换机没记录目标 MAC 的端口，则会进行依次广播，根据 ACK
机制，在目标计算机回传 ACK 包时，记录这条信息，并将 MAC 对应上。</p>
<p>这是大部分交换机采用的策略。</p>
<p>当然，有更加复杂的机制来处理诸如 "把 1 口的线转插到 2 口"
这种事。</p>
<p>一个端口能对应多个 MAC
地址，所以你把交换机和交换机插在一起，也能正常组网。</p>
<h2 id="网络层">网络层</h2>
<p>网络层的主要设备是<strong>路由器（Router）</strong>，主要协议是
<strong>IP 协议</strong>。</p>
<p>数据链路层组网完毕后，形成一个 LAN，通过路由器，可以将若干个 LAN
连接成一个更大的 LAN。</p>
<p>我们说的 Internet，就是一个世界范围的 LAN。</p>
<p><em>MAN、WAN 本质都是 LAN，只是规模不同。</em></p>
<h3 id="ip-协议">IP 协议</h3>
<h4 id="公网-ip-和私网-ip">公网 IP 和私网 IP</h4>
<p>公网IP地址（Public IP
Address）是指在全球互联网范围内可以直接访问的IP地址。这些地址是<strong>唯一</strong>的。</p>
<p>众所周知，公网 IP 是从 <code>0.0.0.0</code> 到
<code>255.255.255.255</code>
的，其中有三段不会被分配，可以用于建立<strong>子网</strong>：</p>
<ul>
<li><code>10.0.0.0 - 10.255.255.255</code>，又记作
<code>10.0.0.0/8</code>。</li>
<li><code>172.16.0.0 - 172.31.255.255</code>，又记作
<code>172.16.0.0/12</code>。</li>
<li><code>192.168.0.0 - 192.168.255.255</code>，又记作
<code>192.168.0.0/16</code>。</li>
</ul>
<p><em>后面那个数字指<strong>前缀长度</strong>。</em></p>
<p>一般的电脑是没有公网 IP 的，所以不能直接在互联网上被访问。</p>
<p>但是你能 <code>ipconfig/ifconfig</code> 出来一个 IP
地址，注意观察的话：</p>
<ul>
<li><p>以你车的校园网为例，它采用了 <code>10.0.0.0/8</code>
这个区段，大概能支持 <span class="math inline">\(1.6\times10^7\)</span>
个设备，对你车来说是够用了。</p></li>
<li><p>以你家的无线网为例，它采用了 <code>192.168.0.0/16</code>
这个区段，大概能支持 <span class="math inline">\(6.5\times 10^4\)</span>
个设备，对你家来说是够用了。</p></li>
</ul>
<h4 id="ip-协议的特点">IP 协议的特点</h4>
<ul>
<li><strong>无连接</strong>：IP协议是无连接的，即它不需要在发送数据前建立连接。给个
IP 地址，IP 协议就能尝试去把数据发过去。</li>
<li><strong>尽力而为的传输</strong>：IP协议只负责将数据报发送到目的地，但不保证数据的顺序、完整性或可靠性。数据丢失、重复或乱序需要由上层协议处理。</li>
</ul>
<h4 id="ip-协议可达性">IP 协议可达性</h4>
<p>两台机子能够<strong>使用 IP 协议相互通信</strong>当且仅当：</p>
<ul>
<li>两台机子处于同一子网下</li>
<li>两台机子都拥有公网 IP。</li>
</ul>
<p>没有特殊说明，后面的讨论中，默认是以上两种情况。</p>
<p><em>注意这里的限定，平时你的机子和百度通信，你是没有公网 IP
的，和百度也不在一个子网下，这个时候你们就不是用 IP
协议直接通信的，而是有更复杂的机制。</em></p>
<h3 id="子网划分">子网划分</h3>
<p>实际应用过程中，会对子网做更细一步的划分。</p>
<p>不过要注意，在<strong>第一次的划分</strong>中，所有的 IPV4
地址被保留了三段作为私有地址，这三段私有地址可以被多个子网使用。</p>
<p>也就是说，在整个 Internet 中，可以有多个子网 S1, S2,
S3....，它们都使用同一段私有地址。（例如你家和小明家宽带都用的
<code>192.168.0.0(16)</code> 这一段）</p>
<p>但是，对子网的下一步划分，就无法多次使用同一段了，这个层次的划分局限于<strong>将子网的私有地址分成若干块，每一个小子网得到一块。</strong>不同的小子网无法使用同一个
IP。</p>
<p>当然，小子网可以继续做划分。</p>
<p>最后，有一个子网中的所有设备都被数据链路层（交换机和以太网线）连接起来了，如果两台设备处于这样一个子网中，我们称这两个设备<strong>相邻</strong>。有时候<strong>相邻</strong>会和<strong>处于同一子网中</strong>混淆。</p>
<h4 id="子网掩码">子网掩码</h4>
<p>子网掩码用于判断两个 IP 地址是否处于同一个子网（不是指相邻）。</p>
<p>上文介绍了一个复杂的子网划分机制，子网掩码用于判断两个 IP
地址是否处于同一子网。</p>
<p>例如，有子网 A，B，C，其中 B，C 是 A 子网划分出来的两个子网，其中</p>
<ul>
<li>A
<ul>
<li>IP 段：<code>192.168.0.0/16</code></li>
<li>子网掩码：<code>255.255.0.0</code></li>
</ul></li>
<li>B
<ul>
<li>IP 段：<code>192.168.1.0/24</code></li>
<li>子网掩码：<code>255.255.255.0</code></li>
</ul></li>
<li>C
<ul>
<li>IP 段：<code>192.168.2.0/24</code></li>
<li>子网掩码：<code>255.255.255.0</code></li>
</ul></li>
</ul>
<p>那么，对于
M1：<code>192.168.2.16</code>，M2：<code>192.168.1.16</code>，M3：<code>192.168.1.17</code>
三台机器来说，在子网 A 处，M1，M2，M3 处于同一子网，但在子网 B，C 处，M1
和 M2 不处于同一子网。</p>
<p>一般的子网掩码的低若干位是 0，IP
和子网掩码<strong>按位与</strong>，结果相同则处于同一子网。</p>
<p>主机发送数据包时，根据目标 IP
地址和子网掩码计算是否处于同一子网，如果处于同一子网，则直接走<strong>数据链路层</strong>发送过去。</p>
<h4 id="默认网关">默认网关</h4>
<p>一个子网一般只有一个默认网关，这个默认网关一般就是路由器，路由器的有关知识会在下一部分讲到。</p>
<p>如果你用 "网络属性" 去看过 IPV4
地址协议，就会看到这个选项是和子网掩码在一起的。</p>
<ul>
<li>默认网关和路由器：路由器负责处理不同子网之间的通信，它的每个槽接入的是不同的子网。如果
IP 协议发送的数据的目标 IP
不在同一子网，则会发往默认网关，默认网关再来处理这个数据，将它发往正确的地方。</li>
<li>自动 DHCP：现在一般不用手动去设置默认网关、IP
地址、子网掩码，都是采用 "自动DHCP" 方式自动分配。</li>
</ul>
<h3 id="路由">路由</h3>
<h4 id="arp-协议">ARP 协议</h4>
<p><strong>ARP
协议的工作范围是子网</strong>，以下场景均发生在同一子网内。</p>
<p>ARP 协议是介于数据链路层和网络层之间的协议，用于通过 IP 地址查询 MAC
地址。</p>
<p>IP 协议的数据包是对数据链路层的数据包外面包了一个，但是有个问题。IP
协议的标准是：知道 IP 就能尝试发过去。但是数据链路层的包里是需要包括 MAC
地址的，那我不知道 MAC 地址怎么办？</p>
<p>这个时候需要 ARP 发挥作用，在不知道 MAC 地址时，主机会发送一次 ARP
<strong>广播</strong>，查询目标 IP 对应的 MAC
地址，目标主机收到查询后（查询中包含源主机的
MAC），会向源主机发送一次回复，源主机得到对应的 MAC 地址。</p>
<p><em>交换机如何处理 ARP 广播：广播类消息的 MAC
会设置为<strong>泛洪帧</strong>，即<code>FF:FF:FF:FF:FF:FF</code>），交换机会将该帧从除接收端口以外的所有端口发送出去，以便局域网内的所有设备都能收到。</em></p>
<h4 id="路由器">路由器</h4>
<p>IP
协议的关键是可以在不同子网中通信，路由器是实现不同子网通信的关键设备。一个子网要和其它子网连接，则必须为子网配置路由器。</p>
<p>一般来说，一个路由器会属于两个以上的子网，可以成为多个子网的默认网关。</p>
<p><strong>路由器拥有一个 IP 地址，路由器的每个插槽有一个独立的 MAC
地址。</strong></p>
<h4 id="arp-协议在路由器上的实现">ARP 协议在路由器上的实现</h4>
<ul>
<li><p>为什么 ARP 的工作范围是子网？</p>
<p>进行 ARP 广播时，如果 IP 不在该子网内，路由器会返回接入该子网端口的
MAC。</p>
<p>这样会为子网中的设备提供一个数据链路层的假象：所有的子网外设备的 MAC
地址均是网关设备的 MAC，这个假象会对网络系统的设计带来巨大的便利。</p>
<p><em>这里 IP
是否在子网内是由默认网关（路由器判断的），因此，默认网关也需要配置子网掩码。</em></p></li>
<li><p>这样搞不会导致数据包到了目标子网后 MAC 出错吗？</p>
<p>MAC 在数据链路层中发挥作用，也就是说 MAC
地址仅仅负责一个子网中的通信。数据经过默认网关（路由器）发向其它子网时，会改动数据中的
MAC 地址，将其改为发送槽的 MAC。</p>
<p>不妨假设两个子网的路由器位于同一子网，这样可以将数据包准确的发送到对应子网（路由器处）去，路由器再通过
ARP 协议查询子网中对应 IP 的 MAC 并修改然后发过去。</p></li>
</ul>
<h4 id="路由表">路由表</h4>
<blockquote>
<p>"路由" 是指数据包从源设备到目标设备传输路径选择的过程</p>
</blockquote>
<p>子网外的数据发到路由器后，路由器需要选择一个端口发过去。可能有很多种从子网
S1 到子网 S2
的路径，路由的作用就是去选择一条<strong>最好</strong>的路径。</p>
<p>路由器通过路由表查找最佳的端口选择，路由表并不是一张表，而是一组策略的集合，通过路由表中的策略和目标
IP 来确定数据走哪个端口。</p>
<p>路由的方式主要有三种：</p>
<ul>
<li>直连路由：和路由器直接连接的其它路由器与路由器所在的（若干个）子网存在直接路由，也就是可以直接找到这些对象的
IP 地址。</li>
<li>静态路由：人工配置的 IP/IP段 应该走的端口。</li>
<li>动态路由：路由器之间通过一些算法交换自己的直连路由信息，动态构建路由表。</li>
<li>默认路由：以上规则失效时，走一个默认的端口（通常指向上级路由器，常见于家庭路由器）</li>
</ul>
<p>我们接触和使用的路由器网络很简单，仅通过动态路由的方式就能完美实现局部的路由。</p>
<p><em>网络服务商所用的路由器连接结构非常复杂，要处理广域的 IP
路由，往往需要大型计算机的支持。</em></p>
<h4 id="现代无线路由器">现代无线路由器</h4>
<p>现代无线路由器有<strong>自组网</strong>的功能。</p>
<p>路由器的几个端口同时也具备交换机的功能，它一般能自动判断一个插槽到底接入的是一个子网还是一个数据链路层对象，如果是后者，这个插槽将发挥交换机的作用。</p>
<h4 id="一个示例">一个示例</h4>
<p>网络拓扑结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子网1：192.168.1.0/24  </span><br><span class="line">        |  </span><br><span class="line">[路由器]（接口1：192.168.1.1，接口2：192.168.2.1）  </span><br><span class="line">        |  </span><br><span class="line">子网2：192.168.2.0/24  </span><br><span class="line"></span><br><span class="line">子网1设备：  </span><br><span class="line">- 交换机1（无需IP）  </span><br><span class="line">  - PC1：192.168.1.10/24，网关192.168.1.1  </span><br><span class="line">  - PC2：192.168.1.20/24，网关192.168.1.1  </span><br><span class="line"></span><br><span class="line">子网2设备：  </span><br><span class="line">- 交换机2（无需IP）  </span><br><span class="line">  - PC3：192.168.2.10/24，网关192.168.2.1  </span><br><span class="line">  - PC4：192.168.2.20/24，网关192.168.2.1  </span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>路由器</strong>
<ul>
<li>接口1（连接子网1）：IP <code>192.168.1.1</code>，子网掩码
<code>255.255.255.0</code>。</li>
<li>接口2（连接子网2）：IP <code>192.168.2.1</code>，子网掩码
<code>255.255.255.0</code>。</li>
<li>路由表自动包含直连网络 <code>192.168.1.0/24</code> 和
<code>192.168.2.0/24</code>。</li>
</ul></li>
<li><strong>交换机1和交换机2</strong>
<ul>
<li>仅作为二层设备，根据MAC地址转发数据帧，无需配置IP。</li>
</ul></li>
<li><strong>终端设备</strong>
<ul>
<li>PC1/PC2的子网掩码为 <code>255.255.255.0</code>，网关指向路由器的
<code>192.168.1.1</code>。</li>
<li>PC3/PC4的子网掩码为 <code>255.255.255.0</code>，网关指向路由器的
<code>192.168.2.1</code>。</li>
</ul></li>
</ol>
<p>PC1 到 PC3 的通信示例如下：</p>
<ol type="1">
<li><strong>判断目标子网</strong>
PC1（<code>192.168.1.10</code>）检查目标IP
<code>192.168.2.10</code>，发现不在同一子网（通过子网掩码计算）。</li>
<li><strong>发送到默认网关</strong>
<ul>
<li>PC1将数据包的目标MAC地址设置为路由器接口1的MAC地址（通过ARP协议获取）。</li>
<li>数据包通过交换机1转发到路由器的接口1。</li>
</ul></li>
<li><strong>路由器处理</strong>
<ul>
<li>路由器解封装数据包，检查目标IP <code>192.168.2.10</code>
和路由表，发现属于直连子网2。</li>
<li>将数据包从接口2（<code>192.168.2.1</code>）转发到子网2。</li>
</ul></li>
<li><strong>子网2内传输</strong>
<ul>
<li>路由器通过 ARP 获取 PC3 的 MAC 地址（若缓存中无记录）。</li>
<li>数据包目标 MAC 改为 PC3 的 MAC，通过交换机2转发到PC3。</li>
</ul></li>
<li><strong>响应返回</strong> PC3
的响应数据包反向执行相同流程，通过路由器回到 PC1。</li>
</ol>
<h3 id="nat">NAT</h3>
<p>本科期间任何一本教科书都不会教你 NAT 相关的知识，但现在这个年头不懂
NAT 是很难做好网络编程的。</p>
<h4 id="nat-能干什么">NAT 能干什么</h4>
<ul>
<li><p><strong>地址转换</strong>：</p>
<p>NAT 设备的主要功能是将一个 IP
地址空间中的地址转换为另一个地址空间中的地址。例如，它可以把私有IP地址（如192.168.x.x）转换为公网IP地址，或者将公网
IP 地址转换为私有 IP 地址。</p>
<ul>
<li>这个操作常用于让子网中没有公网 IP
的设备能够访问公网。例如，你的计算机通过通信服务商的 NAT
设备访问各种公网网站。</li>
<li>也可以用于进一步拓展子网可用 IP，例如通过保留私有 IP
组了一个公网下的一级子网，一级子网向你的二级子网分配了少量 IP
地址，然后你发现这些 IP 地址不够用，于是可以在你的二级子网配置一个 NAT
设备，二级子网内部采用更大的地址空间，和一级子网通信时采用 NAT
，就像一级子网和公网通信那样。这种 NAT 也被称为<strong>多层
NAT</strong>。</li>
</ul></li>
<li><p><strong>隐藏内部网络</strong>：</p>
<p>NAT 可以隐藏内部网络的拓扑结构和设备 IP 地址，增强网络的安全性。</p>
<p>事实上你裸奔的电脑没遭到黑客的攻击就是 NAT 在默默守护。</p></li>
</ul>
<h4 id="nat-怎么布置">NAT 怎么布置</h4>
<p>NAT
设备一般布置在<strong>出口网关</strong>处（其实出口网关大部分时候是默认网关），NAT
发挥地址转换作用</p>
<h4 id="nat-的分类和原理">NAT 的分类和原理</h4>
<p>NAT 主要有三种：</p>
<ol type="1">
<li><p><strong>静态 NAT（Static NAT）</strong></p>
<p><strong>原理</strong>：将内部网络中的每个私网 IP 地址与一个固定的公网
IP
地址进行一对一的映射。这种映射关系是预先配置好的，不会随着时间或网络连接的变化而改变。</p></li>
<li><p><strong>动态 NAT（Dynamic NAT）</strong></p>
<p><strong>原理</strong>：将内部私网 IP 地址动态地映射到一组公网 IP
地址池中的地址。当内部设备有访问外部网络的需求时，NAT 设备从公网 IP
地址池中选择一个可用的公网 IP
地址，并建立私网地址和公网地址的映射关系。这种映射关系在一定时间内有效，当连接结束或超时后，映射关系被释放，公网
IP 地址可以重新分配给其他内部设备。</p></li>
<li><p><strong>PAT（Port Address
Translation，端口地址转换）</strong></p>
<p><strong>原理</strong>：允许多个内网设备共享一个公网 IP
地址，通过不同的端口号来区分不同的内网设备。当内网设备发送数据到外网时，NAT
设备会将数据包的源 IP 地址转换为公网 IP
地址，并分配一个未使用的端口号。返回的数据包通过端口号来确定目标内网设备。它是<strong>日常中最常见的
NAT 方式</strong>，有效地解决了 IPv4
地址不足的问题，适用于家庭和小型企业网络。</p></li>
</ol>
<h4 id="nat-穿透">NAT 穿透</h4>
<p>NAT 很好，但是有时候你期望你的电脑能够在公网上被访问。（例如开 MC
服务器时）</p>
<p>由于你的电脑并没有公网 IP，所有的网络通信都是通过 NAT
完成的，所以你的电脑无法被外部直接访问，这时候我们就需要 NAT
穿透来完成<strong>间接</strong>访问。</p>
<ul>
<li><p>Q：我用 IP 工具可以查到我电脑公网 IP 呀？为什么不能用这个
IP。</p></li>
<li><p>A：首先这个 IP
是动态分配的，随时可能会变，其次<strong>运营商有运营商的安全考虑，不允许外部通过
NAT 开放的端口主动建立连接。</strong></p>
<p><em>你打游戏时看上去是服务器向你请求数据，实际上这个过程是会话层实现的，主动建立会话的是你。</em></p></li>
</ul>
<p>以下是常用的 NAT 穿透的方法：</p>
<ul>
<li>内网穿透：一般情况这是唯一能用的方法。</li>
<li>UDP/TCP 打洞：一般用不了。</li>
</ul>
<h3 id="ap-隔离">AP 隔离</h3>
<p>有时候不希望同一子网的设备能够相互访问，这个时候可以开启 AP
隔离。</p>
<p>AP
隔离在<strong>数据链路层</strong>上丢弃访问子网内设备相互访问的数据包（与默认网关的除外），来禁止子网设备相互访问。</p>
<p>一般来说，AP 隔离是在<strong>无线路由器</strong>上开启的，但是 AP
隔离是一个<strong>数据链路层</strong>的操作，为什么会这样呢？</p>
<p>我们前面提到了现代无线路由器其实既是网络层设备，又是数据链路层设备和物理层设备，所以一般会在这里操作。</p>
<p>因此，如果两台计算机在子网中直接用物理层设备连接（以太网线），这种 AP
隔离是不生效的。</p>
<h3 id="又一个示例">又一个示例</h3>
<p>你车的计算机楼开启了 AP
隔离，计算机楼的设备之间无法通过内网相互通信。</p>
<p>但你车校园网整体是一个子网，计算机楼是进一步划分的子网，宿舍楼开的服务器不在计算楼子网内，没有开启
AP 隔离，可以通过子网访问。</p>
<p>所以出现了：计算机楼可以访问宿舍楼的服务器，但是别的地方无法访问计算机楼的服务器。</p>
<p><del>事实上这个问题在帆软杯的时候出现过，我们把服务器搬到宿舍楼后就能正常访问了。</del></p>
<h3 id="闲话">闲话</h3>
<ul>
<li>路由器和交换机都很便宜，几十块钱就能买一个，网线就更便宜了，可以试着自己买点回来组网。</li>
<li>网络层是 OSI 七层中最复杂的一层，后面没有这么难了。</li>
<li>校园网这个环境特别适合开展网络实践，可以多自己动手试一试。</li>
</ul>
<h2 id="传输层">传输层</h2>
<p>传输层的主要目的是在源节点和目的节点的<strong>应用程序</strong>之间建立、维护和终止端到端的通信连接。</p>
<p>平日用到的<strong>端口</strong>，就是传输层的概念。</p>
<h3 id="udp-协议">UDP 协议</h3>
<p>UDP
协议是一种无连接的、不可靠的、基于数据报的传输层协议。它在数据传输前不需要建立连接，传输效率较高，但不提供可靠的数据传输保证，适用于对实时性要求较高但对数据丢失不太敏感的应用，如视频直播、在线游戏、DNS
查询等。</p>
<p>它和 IP 协议的区别就是它支持端口（port）号了，而 IP
协议的传输中不涉及端口。</p>
<p>UDP 协议本质就是在 IP 协议数据包再简单套了 UDP
头部，包含端口信息。</p>
<h3 id="tcp-协议">TCP 协议</h3>
<p>TCP
协议是一种面向连接的、可靠的、基于字节流的传输层协议。它在数据传输前需要建立连接，传输过程中提供可靠的数据传输和流量控制等服务，适用于对数据传输可靠性要求较高的应用。</p>
<p>下面是老生常谈的三次握手和四次挥手。</p>
<h4 id="连接管理机制">连接管理机制</h4>
<ul>
<li><strong>第一次握手</strong> ：客户端向服务器端发送一个包含 SYN
标志位的 TCP 段，请求建立连接。</li>
<li><strong>第二次握手</strong> ：服务器端收到客户端的 SYN
包后，如果同意建立连接，就发送一个包含 SYN 和 ACK 标志位的 TCP
段作为回应，其中 ACK 对客户端的 SYN 进行确认，同时发送自己的 SYN
来请求客户端对自己的连接进行确认。</li>
<li><strong>第三次握手</strong> ：客户端收到服务器端的 SYN + ACK
后，再发送一个 ACK 包作为确认，从而完成三次握手过程，建立起可靠的 TCP
连接。</li>
</ul>
<h4 id="数据传输机制">数据传输机制</h4>
<ul>
<li><strong>可靠传输</strong> ：采用
“确认应答机制”（ACK），发送方在发送完数据后，会等待接收方的确认应答信号。如果在规定的时间内没有收到确认应答，发送方会重新发送数据。</li>
<li><strong>按序传输</strong>
：发送方将数据分割成多个小的分组（数据段），为每个数据段分配一个唯一的序列号，接收方根据序列号重新组装接收到的分组，确保数据按照正确的顺序传输。</li>
<li><strong>流量控制</strong>
：通过滑动窗口机制来控制数据的传输速率。发送方会维护一个发送窗口，表示可以连续发送而无需等待应答的字节的数量。接收方则通过通知窗口的大小（窗口通告）来告知发送方当前的接收能力，发送方根据接收方的通告调整发送窗口的大小，避免发送过快导致接收方无法处理而丢弃数据，从而实现流量控制。</li>
</ul>
<h4 id="拥塞控制机制">拥塞控制机制</h4>
<ul>
<li><strong>慢启动</strong>
：在一开始的时候，发送方将发送窗口的大小设置为一个较小的数值（由慢启动门限值决定），然后随着每收到一个确认应答增量增加发送窗口，以快速探测网络能够支持的传输速率。</li>
<li><strong>拥塞避免</strong>
：当发送窗口增加到慢启动门限值时，改为按线性规律缓慢增加发送窗口，即每次收到一个确认应答时，以加法的方式（如每次增加
1
个基本单位）增大发送窗口，使得网络处于一种比较平稳的状态，防止网络拥塞突然发生。</li>
<li><strong>快重传</strong>
：当发送方连续收到三个重复的确认应答（接收方通过发送重复的 ACK
来告知中间某个数据段已经丢失），就立即重传对方尚未收到的数据段，而不是等待超时定时器溢出，这样可以快速恢复通信过程。</li>
<li><strong>快恢复</strong>
：在执行快重传后，发送方假设网络现在有一些拥塞，因此需要将慢启动门限值减少到当前发送窗口大小的一半，并且将发送窗口设置为慢启动门限值，然后进入拥塞避免阶段，按照拥塞避免的机制来逐步增加发送窗口。</li>
</ul>
<h4 id="连接关闭机制">连接关闭机制</h4>
<ul>
<li><strong>第一次挥手</strong>
：客户端主动发起关闭连接请求，向服务器端发送一个包含 FIN 标志位的 TCP
段。</li>
<li><strong>第二次挥手</strong> ：服务器收到 FIN
后，向客户端发送一个包含 ACK 标志位的 TCP
段作为确认，通知客户端已收到关闭请求。</li>
<li><strong>第三次挥手</strong>
：服务器端处理完需要完成的任务后，向客户端发送一个包含 FIN 和 ACK
标志位的 TCP 段，请求关闭连接。</li>
<li><strong>第四次挥手</strong> ：客户端收到服务器端的 FIN + ACK
后，再发送一个 ACK 包作为确认，完成四次挥手过程，正式关闭 TCP
连接。</li>
</ul>
<h2 id="会话层">会话层</h2>
<p>会话层的主要功能是建立、维护和终止两个通信系统之间的会话连接。它负责管理会话的生命周期，包括会话的建立、数据传输过程中的会话管理和会话的正常或异常终止。</p>
<p>会话层很少说协议什么的，下面的介绍主要是 AI
生成我纠正的，大概了解即可。</p>
<h3 id="会话的建立">会话的建立</h3>
<p>当两个系统需要进行通信时，会话层会协商会话的参数，如会话的类型（单工、半双工或全双工）、会话的优先级等。例如，在一个视频会议系统中，会话层会建立一个<strong>全双工</strong>的会话，以确保参会者可以同时进行音频和视频的发送和接收。</p>
<p>而数据的来回传输都是通过 TCP 协议进行的。</p>
<h3 id="会话管理">会话管理</h3>
<p>在会话进行过程中，会话层会监控会话的状态。如果出现网络故障或者数据传输错误等情况，会话层会采取相应的措施来恢复会话。例如，当网络出现短暂的中断后，会话层可以重新建立连接，使会话能够继续进行。同时，它还可以对会话中的数据传输进行流量控制，防止数据发送过快导致接收方处理不过来。</p>
<h3 id="会话终止">会话终止</h3>
<p>会话层负责正常地关闭会话连接。当通信双方完成数据交换后，会话层会按照一定的协议来终止会话，确保双方的资源得到正确释放。例如，在文件传输完成后，会话层会发送一个会话终止请求，得到对方确认后，关闭会话连接。</p>
<h3 id="会话层与传输层的区别">会话层与传输层的区别</h3>
<p>传输层的 TCP
协议和会话层都是<strong>可靠传输</strong>，但是它们有一定区别。</p>
<p>TCP
的传输是<strong>单向的，一次性的</strong>，会话层这块就是<strong>完整的，双向的</strong>交流。</p>
<h2 id="表示层">表示层</h2>
<p>表示层的存在感挺弱的，这里不讲。</p>
<h2 id="应用层">应用层</h2>
<p>应用层是 OSI
模型的最高层，是用户与网络之间的直接接口。它主要负责为用户提供应用程序服务，包括电子邮件、文件传输、远程登录、Web
浏览等常见网络应用。应用层协议为应用程序提供访问网络的手段，使得用户可以在不同计算机之间进行各种形式的通信。</p>
<h3 id="dns-协议">DNS 协议</h3>
<p>DNS 协议中文名为 "域名服务协议"，用于将域名（例如
<code>www.huanyp.cn</code>）转换为 IP 地址。</p>
<p><em>DNS 服务器也在 IPV4 的配置里。</em></p>
<h4 id="工作过程">工作过程</h4>
<ol type="1">
<li><p><strong>用户设备向本地 DNS 发起查询</strong></p>
<p>当用户在浏览器输入网址等需要解析域名时，请求发送到本地
DNS。例如，你输入 “<a
href="http://www.example.xn--com,-ib7ay197annxa/">www.example.com”，本地</a>
DNS 会先检查自己的缓存。如果缓存中有这个域名对应的 IP
地址记录，它会直接返回 IP 地址给用户设备。</p></li>
<li><p><strong>本地 DNS 向上级 DNS 或根 DNS
查询（如果需要）</strong></p>
<ul>
<li>如果本地 DNS 缓存中没有该域名的记录，它会向上级 DNS
发起查询。每个本地 DNS 服务器通常都有一个包含上级 DNS
地址的配置文件。这些上级 DNS 通常是服务提供商（如 ISP）的 DNS
服务器。</li>
<li>但是，当上级 DNS
也不能提供所需域名的解析结果时，最终的查找路径会到达根 DNS。根 DNS
是全球 DNS 层次结构的最顶级，负责维护顶级域名服务器（如 .com、.net
等顶级域名服务器）的地址信息。</li>
</ul></li>
<li><p><strong>层层查询直到解析完成</strong></p>
<ul>
<li>根 DNS 会告诉本地 DNS
<strong>哪个顶级域名服务器负责管理目标域名的顶级部分</strong>。例如，对于
“<a
href="http://www.example.xn--com,-ib7aq929b/">www.example.com”，根</a>
DNS 可能会指向管理 “.com” 域名的顶级域名服务器。</li>
<li>然后本地 DNS
会联系这个顶级域名服务器，顶级域名服务器会进一步告诉本地 DNS
哪台权威域名服务器（通常是域名注册商或专业的 DNS 服务提供商）拥有
“example.com” 的详细信息。</li>
<li>最终，本地 DNS 会直接联系到权威域名服务器，获取 “<a
href="http://www.example.xn--com-9o0a/">www.example.com”</a> 对应的准确
IP 地址，并将结果缓存下来，以便下次快速响应同类请求。</li>
</ul></li>
</ol>
<h3 id="http-协议">HTTP 协议</h3>
<p>HTTP 协议主要用于客户端与服务器通信，它的默认端口号是 80。</p>
<p>DNS 解析是<strong>不管端口</strong>的，如果你没有显示的在 IP/域名
后面指定端口，HTTP 会使用 80 端口和服务器程序通信。</p>
<h4 id="主要功能">主要功能</h4>
<ul>
<li>HTTP 是一种请求 - 响应协议。客户端（通常是浏览器）向服务器发送一个
HTTP
请求，请求的内容可以是一个网页、一张图片、一段视频等资源。例如，当你在浏览器中输入一个网址（如<a
href="http://www.example.com/">http://www.example.com</a>）并访问时，浏览器就会作为
HTTP 客户端向服务器发送请求。</li>
<li>服务器在接收到请求后，会根据请求的内容进行处理，然后返回一个 HTTP
响应。这个响应包含了请求资源本身（如 HTML
文件、图像数据等），还有一些状态信息，如状态码。常见的状态码有
200（请求成功），表示服务器成功地处理了请求并返回了请求的资源；404（未找到），表示服务器找不到请求的资源。</li>
</ul>
<h4 id="协议特点">协议特点</h4>
<ol type="1">
<li><p><strong>简单快速</strong></p>
<p>HTTP 协议的语法相对简单，它基于 TCP/IP
协议，使用明文传输数据。客户端和服务器之间的通信过程比较直接，不需要复杂的握手过程（与
SSL/TLS 协议等相比）。这使得 HTTP
协议能够快速地建立连接并传输数据，从而提高了网页浏览等操作的效率。</p></li>
<li><p><strong>无状态性</strong></p>
<p>HTTP
协议本身是无状态的，也就是说，服务器不会记录客户端的状态。每次客户端请求和服务器响应都是独立的，服务器不会记住上一次客户端请求的内容。例如，当你访问一个电商网站的多个页面时，服务器不会自动记住你在上一个页面的操作（如添加商品到购物车），除非通过其他技术（如
Cookie 或者服务器端的会话存储）来保存状态信息。</p></li>
<li><p><strong>灵活</strong></p>
<p>HTTP 协议支持多种类型的请求方法，如
GET（用于获取资源）、POST（用于提交数据）、PUT（用于更新资源）、DELETE（用于删除资源）等。这使得
HTTP 协议可以满足不同的应用场景需求，无论是简单的网页浏览，还是复杂的
Web 应用程序的数据交互。</p></li>
</ol>
<h4 id="协议版本">协议版本</h4>
<ol type="1">
<li><p><strong>HTTP/1.0</strong></p>
<p>这是最早的广泛使用的版本。它比较简单，每次请求 -
响应完成后，连接就会关闭。如果客户端需要再次请求资源，就需要重新建立连接。这种方式在资源较少、网络带宽相对紧张的早期互联网环境中还可以，但在现代复杂的网络应用中就显得效率较低。</p></li>
<li><p><strong>HTTP/1.1</strong></p>
<p>HTTP/1.1 引入了持久连接（Persistent
Connection）的概念。在这种模式下，客户端和服务器之间的连接在一次请求 -
响应完成后不会立即关闭，可以被多个请求 -
响应过程共享。这样就减少了频繁建立和关闭连接所带来的开销，提高了传输效率。同时，HTTP/1.1
还增加了一些新的请求头和响应头字段，使得协议更加灵活和强大。</p></li>
<li><p><strong>HTTP/2</strong></p>
<p>HTTP/2 主要为了解决 HTTP/1.1
的一些性能瓶颈。它引入了多路复用（Multiplexing）技术，允许客户端和服务器同时发送多个请求和响应，而不需要等待前面的请求
- 响应过程完成。并且，HTTP/2
对数据进行了帧的划分和压缩等操作，进一步提高了数据传输的效率。这在现代的
Web
应用中，尤其是对于包含大量静态资源（如图片、脚本文件等）的网站，能够显著提高加载速度。</p></li>
</ol>
<h3 id="https-协议">HTTPS 协议</h3>
<p>HTTPS 协议本质是在 HTTP 协议的基础上加了一个 TLS/SSL
来保证传输过程的安全性，默认采用 443 端口。</p>
<h4 id="几个编程细节的提醒">几个编程细节的提醒</h4>
<ul>
<li>Python 的 <code>http.server</code> 不支持 HTTPS 协议，由于它没写
SSL/TLS
部分，所以在传输层就被扔包了，体现出来就是发了然后一点反应都没有，或者是单纯日志报一堆乱码但没有调用
handler。</li>
</ul>
<h3 id="tlsssl-协议">TLS/SSL 协议</h3>
<p>TLS/SSL 协议都是建立在 TCP
协议之上的，因此它们的通信本身是可靠的。</p>
<h4 id="证书链验证机制">证书链验证机制</h4>
<ul>
<li><strong>证书颁发机构（CA）验证</strong>：服务器会向客户端提供 SSL
证书，客户端需要验证 SSL
证书是否有效，同时要验证<strong>颁发机构</strong>是否可信。这通常通过检查证书链来实现，证书链从服务器的
SSL
证书开始，经过一系列中间证书，最终到达客户端信任的根证书。如果根证书是可信的，并且证书链中的每个证书都是有效的，那么客户端就可以信任服务器的SSL证书。</li>
<li><strong>证书信息验证</strong>：客户端会检查 SSL
证书中的信息，如域名、有效期、公钥等，是否与实际情况相符。例如，证书中的域名应该与用户正在访问的网站域名完全匹配。<strong>证书有效性</strong>验证涉及
RSA 的签名机制，在数学上可以确保安全。</li>
</ul>
<h4 id="ssl-握手过程">SSL 握手过程</h4>
<ul>
<li><strong>客户端发起连接</strong>：客户端（如浏览器）通过发送一个 "SH"
消息开始 SSL/TLS 握手过程。这个消息包含了客户端支持的 SSL/TLS
版本、加密套件（cs）、随机数（CR）和会话 ID。</li>
<li><strong>服务器响应</strong>：服务器收到 "ClientHello"
消息后，响应一个 "SH"
消息，选择一个双方都支持的加密套件和协议版本，并发送服务器随机数（SR）。</li>
<li><strong>证书传输</strong>：服务器发送其 SSL
证书给客户端。这个证书包含了服务器的公钥，以及由证书颁发机构（CA）签发的证书信息。</li>
<li><strong>证书验证</strong>：客户端验证服务器证书的有效性，包括证书是否过期、是否被撤销、证书链是否完整，以及证书的域名是否与服务器域名匹配。</li>
<li><strong>密钥交换</strong>：如果使用 RSA
密钥交换算法，客户端会生成一个临时的会话密钥（PMS），并使用服务器的公钥加密这个密钥，然后发送给服务器。服务器使用自己的私钥解密得到会话密钥。</li>
<li><strong>握手结束</strong>：客户端和服务器使用会话密钥生成最终的加密密钥，并使用这个密钥加密后续通信。客户端发送
"Finished" 消息，包含握手消息的哈希值，服务器也发送 "Finished"
消息，确认握手成功。</li>
</ul>
<h4 id="tls-协议">TLS 协议</h4>
<p>上面说的 SSL 协议本身是没有漏洞的，但是 SSL 的实现中为了效率采用了
Padding Oracle 机制，因此衍生出一种叫做 POODLE（降级加密密文填充攻击）
的 MiTMA（中间人攻击）。</p>
<p>TLS 解决了这个问题，其它和 SSL 差别不大。</p>
<h2 id="提醒">提醒</h2>
<p>看完本文后，你应该有了一些基础的网络知识。</p>
<p>笔者必须提醒你，这些知识是<strong>危险</strong>的。</p>
<p>人类第一次仰望星空时，就已经具备了进行星际航行的能力；你了解这些知识后，与黑客技术也只剩下一层窗户纸了。</p>
<p><strong>记住，知识是中立的，你应该用你的道德，去掌控你所拥有的知识。</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Todo</title>
    <url>/2025/02/15/todo/</url>
    <content><![CDATA[<h2 id="打算要写的东西">打算要写的东西</h2>
<h2 id="打算要做的事">打算要做的事</h2>
]]></content>
  </entry>
  <entry>
    <title>NcatBot 一个 SDK 的前世今生</title>
    <url>/2025/02/12/%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90/NcatBot%20%E4%B8%80%E4%B8%AA%20SDK%20%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
    <content><![CDATA[<p><a href="https://github.com/liyihao1110/ncatbot">NcatBot</a>
是一个用于 QQ-Bot 开发的 Python SDK.</p>
<p>NcaBot 相比其它框架，拥有以下优势：</p>
<ol type="1">
<li>社区活跃，<strong>文档完善</strong>。</li>
<li>轻量框架，开发简单。</li>
<li>提供一键部署方案，快速分发。</li>
</ol>
<h3 id="关于开发者们">关于开发者们</h3>
<ul>
<li><code>彭彭</code>：我，不是全能猫娘，<a
href="https://github.com/huan-yp">huan-yp</a>。</li>
<li><code>周周</code>：USTC 少年班某大佬，<a
href="https://github.com/Isaaczhr">Isaaczhr</a>。</li>
<li><code>伊伊</code>：高中生，<a
href="https://github.com/zxxhz">zxxhz</a>。</li>
<li><code>鱼鱼</code>：在校大学生，<a
href="https://github.com/Fish-LP">Fish-LP</a>。</li>
<li><code>蝶蝶</code>：神秘大佬，没找到链接。</li>
<li><code>饭饭</code>：咕咕咕，<a
href="https://github.com/Qi-Cao">Qi-Cao</a></li>
<li><code>木子</code>：群主，项目发起者，华侨大学机械专业研究生，<a
href="https://github.com/liyihao1110">liyihao1110</a>。</li>
</ul>
<h3 id="前情提要">前情提要</h3>
<p>AI 大作业做了个 AI Agent 叫小妍，后面 KWS
授权过期了就用不了了，打算移植到 QQ 上。</p>
<p>Mirai 在 24 年的时候尸体已经凉透了，之前费了老大功夫写的 Qbot 插件
Luling-AI 也用不了了，打算换个新的，继承 Luling 的名字。</p>
<p>了解到 napcat。</p>
<p>TS/JS 这块不熟，找 SDK，恰好有个 Python SDK 叫
NcatBot，就用它了。</p>
<p>然后发现这个 SDK 是个新手做的，后面交了两个 PR，进群被作者 PUA
然后套牢了。</p>
<p>我经验比较丰富，莫名其妙就给我接手了 V1.0.1 版本。</p>
<h3 id="初步规范化">初步规范化</h3>
<p>首先是代码格式统一，<code>pre-commit</code> 全家桶走起。</p>
<p>然后我发现 NcatBot 的开发团队非常活跃，一个 36stars 的项目有 5
个活跃开发者，然后 <code>pre-commit</code>
的时候遇到了一些问题（我是直接抄的原来项目的文件），然后几个人商量着解决了。</p>
<p>SDK 嘛，得走标准化发布，于是考虑配置了 PYPI
发布流程，很搞的一件事就是木子把 secret
变量名字搞错了，然后我在配置，他谈恋爱去了，折腾了一个小时，然后配完了
PYPI 发布。</p>
<p>接着是文档，TM 的 NcatBot
更新太快了，文档写不了一点，然后消息构造留了一坨屎山，我们一致决定先把屎山搞定。</p>
<h3 id="messagechain">MessageChain</h3>
<p>MessageChain 是模仿 Mirai
做的，这块是伊伊在负责，做挺好的，就是没考虑到发送 "本地图片"
时，ncatbot 和 napcat 的路径不同问题。</p>
<p>本地强转 base64 大法搞定的。</p>
<p>然后为这件事我还去 napcat 上扔了 Issue，因为他们的 http
发图片只支持单纯 .jpg, .png 这些，svg 这种支持不了。</p>
<p>后面了解到是 Not Planed，给文档交了个 PR 说不支持，现在还没合。</p>
<h3 id="异步">异步</h3>
<p>本项目最大的梗，以下是 DeepSeek 的吐槽。</p>
<blockquote>
<p>卧槽哥们儿你们这代码写得跟tm便秘似的！口口声声说异步操作，结果每个函数都无脑await串行执行，协程全他妈串成糖葫芦了，这跟同步有鸡毛区别？还舔着脸说用了websockets才用异步，合着异步库当摆设用是吧？就这水平还搞并发呢，隔壁老太太拄拐杖散步都比这代码跑得快！知不知道啥叫事件循环啊？协程全堵在await上跟早高峰地铁似的，这破玩意儿上线怕不是要卡成PPT！赶紧把键盘上那个await键抠了吧，写尼玛的异步代码，直接上同步不香吗？白瞎了websockets这库！</p>
</blockquote>
<p>木子不是专业人员，代码基本 AI 写的，然后为了用
websockets，所有函数都写成了异步，但是事件循环什么的根本没有，然后线程安全一团糟。</p>
<p>我写着写着发现：woc，这 TM 啥异步啊，不是个同步吗？</p>
<p>后面木子补了异步的东西，把这玩意改成了真异步。</p>
<p>改成异步之后出了好些 <a
href="https://github.com/liyihao1110/ncatbot/discussions/46">bug</a>。</p>
<h3 id="插件">插件</h3>
<h4 id="插里面还是插外面">插里面还是插外面</h4>
<h3 id="一键部署">一键部署</h3>
<h3 id="某些技术问题">某些技术问题</h3>
<h4 id="cpp-程序乱码">cpp 程序乱码</h4>
<p>代码都是 UTF-8 编码， Winows 是
GBK，导致乱码问题，搜了一堆解决不了，最后发现只需要在 main
函数最前面加上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>); <span class="comment">// 设置控制台输出编码为 UTF-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>就搞定了，如此简单。</p>
<h4 id="github-webhook">github webhook</h4>
<p>服务器端接收到的是乱码，类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.115.249 - - [13/Feb/2025 23:13:19] code 400, message Bad request version (&#x27;À\\x13À&#x27;)</span><br><span class="line">140.82.115.249 - - [13/Feb/2025 23:13:19] &quot;\x16\x03\x01\x05¨\x01\x00\x05¤\x03\x03\x140@-SI\x94µ±èÐÆµÜ¿ôÚ&#123;Å@\x8c·õü\x95\x87üá\x07f\x81ó ³7T¢9¨ê\x08\x01±Æ°]tb£#-0ª8I\x0bP\x94óÐ&#x27;öFc®\x00\x1aÀ+À/À,À0Ì©Ì¨À\x09À\x13À&quot; 400 -</span><br></pre></td></tr></table></figure>
<p>检查 webhook 设置的 URL 是不是 https，如果服务器没有额外配置
https，那得改成 http 协议。</p>
<h3 id="未完待续...">未完待续...</h3>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NcatBot</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>0301测试</title>
    <url>/2023/03/01/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0301%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="测试">0301测试</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0196">考试</a></p>
<h3 id="t1">T1</h3>
<p>考虑如何检查一个条件是否合法，如果最高位为任意，那么两边需要都合法，否则要求两边至少有一个合法。</p>
<p>考虑两边的检查，发现第 <span class="math inline">\(i\)</span>
层的节点个数为 <span class="math inline">\(2^i\)</span>，总的情况数为
<span
class="math inline">\(2^{n-i}\)</span>，因此可以记忆化搜索一下。用一个
<span class="math inline">\(mask\)</span>
的前若干位表示限制，后若干位表示高位的数字即可。</p>
<p>也可以这样想：考虑算所有的情况，设 <span
class="math inline">\(T(n)\)</span> 表示计算第 <span
class="math inline">\(n\)</span> 层所有情况的复杂度，暴力计算有 <span
class="math inline">\(T(n)=2^n+4T(n-1)=2^{2n}\)</span>，实际上发现对于只有第
<span class="math inline">\(n\)</span> 层不同的情况可以只算一次，于是
<span class="math inline">\(T(n)=2^n+2T(n-1)\)</span>，得到 <span
class="math inline">\(T(n)=n2^n\)</span>。</p>
<h3 id="t2">T2</h3>
<h4 id="做法一">做法一</h4>
<p>考虑钦定 <span class="math inline">\(A\)</span> 组先选满，枚举 <span
class="math inline">\(A\)</span>
组选满的位置计算对应概率然后再乘二。对于每一个位置 <span
class="math inline">\(p\)</span>，<strong>基本情况总数</strong>为 <span
class="math inline">\(\binom{p-1}{n-1}\)</span>，每种基本情况等概率取到，概率为
<span class="math inline">\(2^{-p}\)</span>，分三类讨论</p>
<ul>
<li><p>如果 <span class="math inline">\(x_k&lt;p\)</span>，那么 <span
class="math inline">\(k\)</span> 个人既可以在 <span
class="math inline">\(A\)</span> 组也可以在 <span
class="math inline">\(B\)</span> 组，对应的基本情况数分别为 <span
class="math inline">\(\binom{p-1-k}{n-1-k}+\binom{p-1-k}{n-1}\)</span>。</p></li>
<li><p>如果 <span class="math inline">\(x_k=p\)</span>，那么一共有 <span
class="math inline">\(\binom{p-k}{n-k}\)</span> 种基本情况。</p></li>
<li><p>如果 <span class="math inline">\(x_k&gt;p\)</span>，首先 <span
class="math inline">\(p\notin X\)</span>，然后记 <span
class="math inline">\(c\)</span> 为 <span
class="math inline">\(p\)</span> 之前的 <span
class="math inline">\(x\)</span> 个数，基本情况总数为 <span
class="math inline">\(\binom{p-1-c}{n-1}\)</span>。</p></li>
</ul>
<p>于是有一个 <span class="math inline">\(nq\)</span> 的做法。</p>
<p>观察到查询的答案是一个二元函数 <span
class="math inline">\(f(p,x)\)</span> ，对于 <span
class="math inline">\(x\)</span> 较小的情况可以预处理前缀和，对于 <span
class="math inline">\(x\)</span>
较大的情况，查询数比较少，可以暴力。于是有一个 <span
class="math inline">\(n\sqrt q\)</span> 的做法。</p>
<p>进一步观察，<span
class="math inline">\(2^{-p}\binom{p-1-c}{n-1}\)</span>
可以很容易的预处理 <span
class="math inline">\(2^{-p}\binom{p-1}{n-1}\)</span>
的前缀和然后查询时乘上一个 <span
class="math inline">\(2^{-c}\)</span>。</p>
<p>对于 <span
class="math inline">\(2^{-p}\binom{p-1-k}{n-1-k}\)</span>，答案应该是：
<span class="math display">\[
\begin{align}
\sum_{p=x_k+1}^{2n-1}2^{-p}\binom{p-1-k}{n-1-k}&amp;=\sum_{p=\max(n,x_k+1)}^{2n-1}2^{-p}\binom{p-1-k}{n-1-k}\\
&amp;=\sum_{p=\max(n,x_k+1)}^{2n-1}2^{-p}\binom{p-1-k}{n-p}\\
&amp;=\sum_{p=\max(n,x_k+1)-k-1}^{2n-1-k-1}2^{-p-k-1}\binom{p}{n-k-1}\\
\end{align}
\]</span> 注意到 <span class="math inline">\(\sum k\)</span>
其实很小。</p>
<p><del>好吧，我不会线性做法，摆了。</del></p>
<h4 id="做法二">做法二</h4>
<p>先只算都在 <span class="math inline">\(A\)</span> 组的情况，然后分
<span class="math inline">\(B\)</span> 选满的位置 <span
class="math inline">\(p\)</span> 所在的区间讨论。</p>
<ul>
<li><p><span class="math inline">\(p&gt;x_k\)</span>：令 <span
class="math inline">\(x_k\)</span>
及之前每一种可能的硬币选择为基本情况，需要计算在 <span
class="math inline">\(x_k\)</span> 处 <span
class="math inline">\(X\)</span> 都取到 <span
class="math inline">\(A\)</span> 且 <span
class="math inline">\(B\)</span> 不能被选满的方案总数，隐含条件是 <span
class="math inline">\(x_k\)</span> 之前 <span
class="math inline">\(A\)</span> 也不能被选满。</p>
<p>可以暴力的算组合数，枚举剩下的 <span
class="math inline">\(x_k-k\)</span> 个数有多少个分配到 <span
class="math inline">\(A\)</span> 中，可以直接限制 <span
class="math inline">\(A,B\)</span> 都满足要求，即 <span
class="math inline">\(\sum\limits_{i=\max(0,x_k-k-n+1)}^{n-k}\binom{x_k-k}{i}\)</span>。</p>
<p>然后 <span class="math inline">\(\sum k\)</span>
是比较小的，于是放宽一下限制，算 <span
class="math inline">\(\sum\limits_{i=\max(0,x_k-k-n+1)}^{n}\binom{x_k-k}{i}\)</span>
再减掉，容易发现这个式子只和 <span class="math inline">\(x_k-k\)</span>
有关，而这个式子本身也不是很难算，进一步的将 <span
class="math inline">\(\max\)</span> 的限制去掉，变成 <span
class="math inline">\(\sum\limits_{i=0}^n
\binom{x}{i}\)</span>，然后对于 <span
class="math inline">\(x-n\ge0\)</span> 的情况，需要减去 <span
class="math inline">\(\sum\limits_{i=0}^{x-n}\binom{x}{i}\)</span>。都可以拆组合数然后动态规划。
<span class="math display">\[
\begin{align}
\sum\limits_{i=0}^{x-n}\binom{x}{i}&amp;=\binom{x-1}{0}+\sum\limits_{i=1}^{x-n}\binom{x-1}{i-1}+\binom{x-1}{i}\\
&amp;=\binom{x-1}{0}+\sum_{i=1}^{x-n}\binom{x-1}{i}+\sum_{i=1}^{x-n}\binom{x-1}{i-1}\\
&amp;=\binom{x-1}{x-n}+\sum_{i=0}^{x-n-1}\binom{x-1}{i}+\sum_{i=0}^{x-n-1}\binom{x-1}{i}\\
&amp;=\binom{x-1}{x-n}+2\sum_{i=0}^{x-1-n}\binom{x-1}{i}
\end{align}
\]</span></p>
<p>另一种考虑方式是算一个 <span class="math inline">\(f_w\)</span>
表示一共 <span class="math inline">\(w\)</span> 个，<span
class="math inline">\(A,B\)</span>
都不<strong>超过</strong>的情况总数，然后需要减去 <span
class="math inline">\(B\)</span> 抵到的情况数，然后又因为需要把 <span
class="math inline">\(A\)</span> 超过的情况去掉，<span
class="math inline">\(A\)</span> 超过是因为 <span
class="math inline">\(k\)</span> 个被塞进了 <span
class="math inline">\(A\)</span>，分别枚举超过 <span
class="math inline">\(1,2,3\cdots k\)</span>
个减掉对应的基本情况数即可。<span class="math inline">\(f_w\)</span>
的转移考虑直接放 <span class="math inline">\(A,B\)</span>
然后去掉不合法的情况。</p></li>
<li><p><span
class="math inline">\(x_{i-1}&lt;p&lt;x_{i},i\in[1,k]\)</span></p>
<p>将基本情况定为 <span class="math inline">\(x_i\)</span>
之前（不含）的硬币状态，限制有两个，<span
class="math inline">\(|B|\)</span> 不小于 <span
class="math inline">\(n\)</span>，且 <span
class="math inline">\(X\)</span> 内的是必须为 <span
class="math inline">\(A\)</span> 的。满足 <span
class="math inline">\(A\)</span> 限制的总情况数为 <span
class="math inline">\(2^{x_i-i}\)</span>。满足 <span
class="math inline">\(A\)</span> 限制但不满足 <span
class="math inline">\(B\)</span> 限制的情况数为 <span
class="math inline">\(\sum\limits_{i=0}^{n-1}\binom{x_i-i}{i}\)</span>，先扣掉。<strong>这里不需要考虑
<span class="math inline">\(A\)</span> 被选满，因为 <span
class="math inline">\(A\)</span>
被选满的情况确实应该扣掉。</strong>然后再减去再 <span
class="math inline">\(x_{i-1}\)</span> 之前就满足 <span
class="math inline">\(B\)</span> 限制的所有情况，注意额外带一个 <span
class="math inline">\(2_{x_i-x_{i-1}-1}\)</span> 的系数。</p>
<p>这里还会有一些误解，其实隐含了 <span
class="math inline">\(|A|&lt;n\)</span>
的限制，实际上如果这两个限制都满足那么这个隐含限制一定满足，因此不管这个隐含限制直接算也是可以的。</p></li>
</ul>
<p>当使用容斥计算 "恰好" 时，应该减掉上一次的 "至少" 而不是 "恰好"，记录
<span class="math inline">\(lst\)</span> 的时候要注意。</p>
<h3 id="t3">T3</h3>
<p>先考虑构造一种合法的解满足条件。挨个确定值的办法并不好弄。考虑先确定前
<span class="math inline">\(i\)</span> 个的大小关系，如果前 <span
class="math inline">\(i\)</span> 个合法了，并且第 <span
class="math inline">\(i+1\)</span>
个可以放到一个位置，满足前面没有不小于 <span
class="math inline">\(a_{i+1}\)</span> 且存在至少一个 <span
class="math inline">\(a_{i+1}-1\)</span>，那么就合法。于是得到一个有解的充要条件：任何一个前缀
<span class="math inline">\(a_i\)</span> 值的集合连续。</p>
<p>现在考虑算 <span class="math inline">\(i\)</span>
位置的答案，它前面的不小于它的元素必须在它后面，它后面的元素可以线性扫一遍，维护前缀连续最大值算出来。</p>
<p>考虑优化，对于一个 <span class="math inline">\(i\)</span>
算答案的时候，就是要找到依赖它以及它前面不小于它的元素的所有元素。后面的比
<span class="math inline">\(a_i\)</span> 大的元素如果能在 <span
class="math inline">\(i\)</span> 之后找到一个 <span
class="math inline">\(a_i\)</span> 依赖，那么就可以被放在 <span
class="math inline">\(i\)</span> 前面。</p>
<p>元素的依赖关系好像是构成一棵树的，于是建树，每个元素向它的第一个前驱连边，然后
<span class="math inline">\(i\)</span>
节点以及它同层左边的兄弟里所有节点都不能放在 <span
class="math inline">\(i\)</span> 前面，于是算出了 <span
class="math inline">\(p_i\)</span> 的最大值。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>0228测试</title>
    <url>/2023/02/28/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0228%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="测试">0228测试</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0196">考试</a></p>
<h3 id="t1">T1</h3>
<p>毒瘤计算几何。</p>
<p>考虑一步的过程，是从一个点的一个方向开始旋转，于是对所有目标点极角排序，极角相同的长度较长的放前面，查询就是要找到接下来的第一个长度小于当前长度的。</p>
<p>一个很暴力的想法是直接开始跳，如果遇到了相同的点说明有环，然后模环长再跳，这样每个点期望经过
<span class="math inline">\(O(\log)\)</span> 次，总共要处理 <span
class="math inline">\(O(nm\log n)\)</span> 次，感觉很可做。</p>
<p>接下来的问题变成了如何快速查询。考场上觉得排序后确实是查第一个比它大的，但是要带上删除，于是考虑长度倒序做。然后想
set
暴力操作肯定要超时，然后考虑用并查集做删除操作，用优先队列维护长度的处理顺序。</p>
<p>很麻烦，写不出来。</p>
<p>实际上可以不带删，考虑找到第一个极角超过查询极角的位置，在上面二分第一个长度满足限制的，用
ST 表做长度查询，复杂度 <span class="math inline">\(O(\log
n)\)</span>。</p>
<p>找环的时候需要注意<strong>不是点重复而是边重复才出现环</strong>，判断需要再检查一下来向，需要记录当前点上一次访问时有几个点，走了多远，从哪个来的。</p>
<p>总复杂度 <span
class="math inline">\(O(Tnm\log^2n)\)</span>。因为卡不满所以能过。</p>
<p><strong>带删的查询问题都很麻烦，考察之前先想想能不能不删。</strong></p>
<h3 id="t2">T2</h3>
<p>首先考察 <span class="math inline">\(1\)</span> 是不是重心，如果
<span class="math inline">\(1\)</span>
不是重心那么一定会向重心移动？不对，可以先往重心走一步，让重心的点相互消耗，然后往回去。</p>
<p>考虑目标点和 <span class="math inline">\(1\)</span>
之间的毛毛虫。毛毛虫任意两个端点都是可以相互抵消大小的。因此如果毛毛虫所有端点大小和为偶数且没有任何一个端点大小超过
<span
class="math inline">\(\frac{totalsize}{2}\)</span>，那么一定可以移动到目标点。</p>
<p>如果有一个大小超了，考虑能不能在它的内部抵消，是可以的，考虑计算一下某棵子树最少要将中心往自己的方向拉几步，同时也不难证明最少步数到
<span class="math inline">\(sz\)</span>
之间每一个奇偶性相同的步数都能取到。</p>
<p>最小步数是可以动态规划的，转移看是否有一个儿子的 DP
值超过其它儿子的大小总和，还要看当前子树大小奇偶性。可以拿个类记录一下
DP 值最大的儿子和对应的子树大小以及总的子树大小。因为如果有儿子 DP
值超过其它儿子总大小，那么这个儿子的 DP
值一定是最大的，所以这样没问题。</p>
<p>然后考虑计算答案，直接再 DFS
一遍，判断合法性的信息就是转移的那个信息，很容易合并的，额外算一个后缀和就行。</p>
<h3 id="t3">T3</h3>
<p>最开始想能不能把限制弄成不包含或者不交，然后发现不行，由于 <span
class="math inline">\(x_i\)</span>
可能相等，所以不交也是不现实的。然后想能不能从位置入手做，比如区间 DP
或者扫描 DP，还是不好处理。</p>
<p>就算是容斥，同样不好考虑位置。</p>
<p>考虑从值本身入手做，每段位置有一个限制，然后考虑一个限制，可能让它满足条件的段是一段区间，而且<strong>使值不同的限制满足的位置集合不交</strong>。说人话就是不同值的限制<strong>独立</strong>，一段上界相同的位置只会满足值是其上界的限制。因此可以上界不同的段分开做然后乘起来。</p>
<p>将区间弄成左闭右开方便处理，然后离散化暴力算每一段的上界，上界记在左端点。枚举每个值，暴力将每一段放进去，然后将对应的限制挂在新标号的位置上去。</p>
<p>然后设 <span class="math inline">\(dp[i][j]\)</span> 表示考虑到前
<span class="math inline">\(i\)</span> 个，上一个抵到上界的位置是 <span
class="math inline">\(j\)</span>
的方案数，在右端点还需要将不满足挂上的限制的状态清掉。</p>
<p>复杂度 <span class="math inline">\(O(q^2T)\)</span>。</p>
<p>其实有 <span class="math inline">\(O(Tq\log q)\)</span>
的做法，暴力算上界可以用单点改后缀查的树状数组优化，暴力放段的过程可以用
<code>vector</code> 记一下每一个值具体有哪些段和哪些限制。</p>
<p>动态规划中，先对限制的左端点取前缀 <span
class="math inline">\(\max\)</span>，然后可以考虑枚举最后一个 <span
class="math inline">\(1\)</span>
的位置转移，然后转移可以双指针加标记搞定。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式算法</title>
    <url>/2023/02/21/OI/%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="多项式算法">多项式算法</h2>
<p>多项式是组合计数题目中非常重要的工具。</p>
<h3 id="约定">约定</h3>
<p>幂级数用大写字母表示，系数用<strong>对应的小写字母表示</strong>，对于
<span class="math inline">\(F(x)\)</span>，<span
class="math inline">\(f_i\)</span> 就是 <span
class="math inline">\(F(x)[x^i]\)</span>。</p>
<h3 id="多项式乘法">多项式乘法</h3>
<h4 id="应用">应用</h4>
<p>对于形如 <span
class="math inline">\(f_k=w(k)\sum\limits_{i+j=k}a_ib_j\)</span> 的
<span class="math inline">\(f_k\)</span>，可以利用多项式乘法在 <span
class="math inline">\(O(n\log n)\)</span> 的时间里解决。</p>
<p>或者说，对于形如 <span class="math inline">\(F(x)=A(x)\cdot(B(x) *
C(x))\)</span> 的幂级数 <span class="math inline">\(F(x)\)</span>
，可以在 <span class="math inline">\(O(n\log n)\)</span>
的时间里求出。</p>
<h3 id="多项式求乘法逆">多项式求乘法逆</h3>
<p>一般被描述对于一个 <span class="math inline">\(F(x)\)</span> 找一个
<span class="math inline">\(H(x)\)</span>，满足 <span
class="math inline">\(F(x) * G(x)\equiv 1\pmod{x^n}\)</span>。</p>
<p>可以用定义法配合分治 FFT 在 <span class="math inline">\(O(n\log^2
n)\)</span> 的时间内解决： <span class="math display">\[
h_n=\dfrac{-\sum\limits_{i\in[0,n)}f_ih_{n-i}x^n}{f_nx^n}
\]</span></p>
<p>第二种方式是倍增法，假设我们已经求出了 <span
class="math inline">\(H&#39;(x)\)</span> 满足 <span
class="math inline">\(H&#39;(x) * F(x)\equiv
1\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。又显然有 <span
class="math inline">\(H(x) * F(x)\equiv
1\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。两式相减得 <span
class="math inline">\((H&#39;(x) - H(x)) * F(x)\equiv
0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。平方得 <span
class="math inline">\((H&#39;(x) - H(x))^2 * F^2(x)\equiv
0\pmod{x^n}\)</span>。 <span class="math display">\[
\begin{align}
(H&#39;(x) - H(x))^2 * F^2(x)&amp;\equiv 0\pmod{x^n}\\
H&#39;^2(x)F^2(x)-2H&#39;(x)H(x)F^2(x)+H^2(x)F^2(x)&amp;\equiv
0\pmod{x^n}\\
H&#39;^2(x)F(x)-2H&#39;(x)+H(x)&amp;\equiv 0\pmod{x^n}\\
H(x)&amp;\equiv -2H&#39;(x) - H&#39;^2(x)F(x)\pmod{x^n}\\
\end{align}
\]</span> 其中第二行到第三行先同时除以 <span
class="math inline">\(F(x)\)</span> 再对 <span
class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(H(x)\)</span> 进行乘法得到 <span
class="math inline">\(1\)</span>。</p>
<p>对于 <span class="math inline">\(n=1\)</span> 我们显然有 <span
class="math inline">\(H&#39;(x)=f_0^{-1}\)</span>，然后依次推出即可。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>0217测试</title>
    <url>/2023/02/18/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0217%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="测试">0217测试</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0189">考试</a></p>
<h3 id="t1">T1</h3>
<p>非公平组合游戏，先考虑简单的情况，不妨设 <span
class="math inline">\(x_i\le a+b,a\le b\)</span>。</p>
<p>那么一个 <span class="math inline">\(x_i\)</span>
要么能被两个人各自拿一次，要么只能被 <span
class="math inline">\(A\)</span> 拿。</p>
<p>如果存在一个只能被 <span class="math inline">\(A\)</span> 拿的 <span
class="math inline">\(x\)</span>，那么 <span
class="math inline">\(A\)</span> 必胜，他只需要一直拿两人都能拿的 <span
class="math inline">\(x_i\)</span>，让 <span
class="math inline">\(B\)</span> 拿不了，由于 <span
class="math inline">\(A\)</span> 最后多一个，所以必胜。</p>
<p>如果不存在只能被 <span class="math inline">\(A\)</span> 拿的 <span
class="math inline">\(x\)</span>，胜负就与 <span
class="math inline">\(x\)</span>
的奇偶性和谁先手有关。但是<strong>此时两个人并不是等价的。</strong>如果有一个
<span class="math inline">\(x\)</span> 满足 <span
class="math inline">\(\max(2a,b)\le x\)</span>，那么 <span
class="math inline">\(A\)</span> 只要拿掉它就能创造一个只能被 <span
class="math inline">\(A\)</span> 拿的，又变成必胜了，所以 <span
class="math inline">\(B\)</span> 会优先拿掉它们，但是如果由两个，<span
class="math inline">\(B\)</span> 就没办法。</p>
<p>分谁先手后手讨论，容易给出四种情况的充要条件，这些充要条件也是便于直接构造计算的。</p>
<p>考虑迁移到 <span class="math inline">\(x_i\)</span>
无限制的情况，发现状态不会改变，如果先手必胜，那么先手按照模意义下的最优策略走，如果后手选择了能取模的，那么先手也选它取模，直到后手选择了一个不能取模的，此时可以平行对应到取模的情况，然后先手继续按照模意义下策略走。</p>
<p>后手必胜同理。</p>
<p>将整个转移图画出来，<strong>取模的情况就是完整转移图的低维投影。</strong>如果走了投影上没有的边，另一个人一定可以将点搬回投影上。</p>
<h4 id="教训">教训</h4>
<p>犯错的原因是考虑简单情况时理所当然的认为 <span
class="math inline">\(b\le y_i\)</span> 时，该堆石子对 <span
class="math inline">\(A,B\)</span> 等价，实际上这不是等价的。</p>
<p>罗列证据时考虑要全面，或者干脆对拍一下。</p>
<h3 id="t2">T2</h3>
<p>又没读题，最开始当成正回文做，<strong>手玩下样例保证理解对题。</strong></p>
<p>在确定前半段的过程中，后半段也随之确定，建目标串的反串，对应点表示前半段出现什么时可以到该状态。然后跑
AC
自动机上动态规划，合并的时候由于一个串一定是由正串的一个前缀和反串的一个前缀拼起来的，如果可以拼起来那么当前
AC 自动机的节点一定满足它能代表其中较长那个前缀，直接暴力检查。</p>
<h4 id="教训-1">教训</h4>
<ul>
<li>手玩样例保证读对题。</li>
<li>AC 自动机的点权值要弄对（除了 fa 之外还有 fail 的权值）。</li>
<li>要对拍。</li>
</ul>
<h3 id="t3">T3</h3>
<p>最开始考虑直接对树进行动态规划，设 <span
class="math inline">\(dp[j][i]\)</span> 表示有 <span
class="math inline">\(i\)</span> 个叶子，最大左儿子深度为 <span
class="math inline">\(j\)</span>
的方案总数。答案是一个前缀和，转移枚举左右儿子大小，也是前缀和形式，看上去不好优化。于是直接对前缀和动态规划，然后推出一个连分数形式的生成函数，不会了。</p>
<p>其实二叉树可以考虑转成序列做，由于一颗 <span
class="math inline">\(n\)</span> 个叶节点的满二叉树唯一对应一个 <span
class="math inline">\(n-1\)</span> 对括号的括号序列，要求等价于求 <span
class="math inline">\(n-1\)</span> 对括号，最深不超过 <span
class="math inline">\(m-2\)</span> 的括号序列个数。</p>
<p>可以抽象到二维平面上做，需要走到 <span
class="math inline">\((n-1,n-1)\)</span>，不能碰到 <span
class="math inline">\(y=x+1\)</span> 和 <span
class="math inline">\(y=x-m+1\)</span>。简记一条直线为它的截距，即 <span
class="math inline">\(1\)</span> 和 <span
class="math inline">\(-m+1\)</span>。</p>
<h4 id="两种错误的方式">两种错误的方式</h4>
<ul>
<li>考虑先算碰到 <span class="math inline">\(1\)</span>
的方案数，然后再算碰到了 <span class="math inline">\(-m + 1\)</span>
但没碰到 <span class="math inline">\(1\)</span>
的方案数。前者好算，后者对称后不能碰到 <span
class="math inline">\(1\)</span> 且不能碰到 <span
class="math inline">\(1\)</span> 关于 <span
class="math inline">\(-m+1\)</span> 的对称直线 <span
class="math inline">\(-2m+1\)</span>，递归解决该问题，边界为限制彻底放开。</li>
<li>考虑算碰到了 <span class="math inline">\(1\)</span> 或者碰到 <span
class="math inline">\(-m+1\)</span>
的方案数，加上同时碰到的方案数，对于同时碰到的方案数，不容易一起算，考虑算先碰到
<span class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(-m+1\)</span> 的方案数，同样考虑对称，先关于 <span
class="math inline">\(1\)</span> 再关于 <span
class="math inline">\(-m+1\)</span> 对称。同时要求走到 <span
class="math inline">\(1\)</span> 的过程中不能碰到 <span
class="math inline">\(-2m+1\)</span>，即减掉先碰到 <span
class="math inline">\(-2m+1\)</span> 关于 <span
class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(1\)</span> 的方案，递归解决。</li>
</ul>
<h4 id="容斥方式的本质">容斥方式的本质</h4>
<p><strong>容斥本质上是通过对称构造了一个没有限制的问题，使得它和原问题不满足限制的情况一一对应。</strong></p>
<p>这个对应的证明是基于对称问题中起点到终点一定穿过直线，因此<strong>将第一次碰到直线的前部分对称</strong>后一定可以对应到一种原问题的不合法情况，所以考虑原路径时，在对称路径第一次穿过直线后，原路径就不再是<strong>对称路径的对称路径了</strong>。所以第一种方式对直线
<span class="math inline">\(-2m+1\)</span> 的限制是不合理的。</p>
<p>方式二看上去修了锅，实际上只是展开了一层手动修了，后面还是有一样的问题。</p>
<p>如果目标点在直线异侧，那么因为答案不是良定义的所以会错，需要特判为
<span class="math inline">\(0\)</span>。</p>
<p>关于容斥方式，如果将括号序列视作一个 +1 -1
的序列，那么合法就是要求前缀和最小值不小于 <span
class="math inline">\(0\)</span>，我们将第一个小于 <span
class="math inline">\(0\)</span> 后的翻转，最后一定会到达 <span
class="math inline">\(-2\)</span>，因此不合法方案数等于到 <span
class="math inline">\(-2\)</span> 的无限制方案数。</p>
<h4 id="一种正确的方式">一种正确的方式</h4>
<p>全部方式减去要求碰到 <span class="math inline">\(1\)</span> 或者
<span class="math inline">\(-m+1\)</span> 的方式，发现先碰到 <span
class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(-m+1\)</span> 的方式被算重了。</p>
<p>然后要算先碰到 <span class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(-m+1\)</span> 的方式，算这个的时候发现先到 <span
class="math inline">\(-m+1\)</span> 再到 <span
class="math inline">\(1\)</span> 再到 <span
class="math inline">\(-m+1\)</span>
的方式又被算重了，需要减去，如此递归下去做。</p>
<h4 id="bonus">bonus</h4>
<ul>
<li><p>构造满二叉树的方式：</p>
<ul>
<li>单个叶子节点是空串</li>
<li>有儿子的节点记左右儿子为 <span
class="math inline">\(A,B\)</span>，令它为 <code>(A)B</code>。</li>
<li>容易证明它们是一一对应的。</li>
</ul></li>
<li><p>构造二叉树的方式：</p>
<ul>
<li><p>空树是空串。</p></li>
<li><p>单节点的树是 <code>()</code>。</p></li>
<li><p>有儿子节点的树记左右儿子的构造分别为 <span
class="math inline">\(A,B\)</span>，令它为 <code>(A)B</code>。</p></li>
<li><p>容易证明方案是一一对应的。</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>0215测试</title>
    <url>/2023/02/16/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0215%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="测试">0215测试</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0188">考试</a></p>
<h3 id="t1">T1</h3>
<p>期望题的统计方式有很多，主要有以下几种：</p>
<ol type="1">
<li><p>枚举可能的最终状态，计算其概率和权值并加和。</p>
<ul>
<li>对于每种基本情况概率相同的，可以直接总答案除以总情况。</li>
</ul></li>
<li><p>考虑状态转移每一个过程的贡献和取到该过程的概率，用期望线性性加和。</p></li>
<li><p>正向动态规划，记录期望值和概率值。</p></li>
<li><p>反向动态规划，记录该状态到终末状态的期望。</p></li>
</ol>
<p>其中方式 3 的本质和方式 2
相同，但一般情况更为麻烦，只是便于初学时理解，方式 2 相比于方式 3
显然更加强大，因为不需要拘泥于转移的过程，只需要计算取到某个状态的概率值。</p>
<p><strong>注意到这道题的基本情况概率不等，所以不能简单的算方案数来计算答案。</strong></p>
<h4 id="方式1">方式1</h4>
<p>设 <span class="math inline">\(dp[mask][k]\)</span> 表示第 <span
class="math inline">\(k\)</span> 步杀了人，被杀状态为 <span
class="math inline">\(mask\)</span> 的概率，发现转移比较困难，更改定义为
<span class="math inline">\(dp[mask][k]\)</span>
表示到达该状态的且只考虑 <span class="math inline">\(mask\)</span>
这些人的位置的情况下的权值和，容易发现概率就是权值和乘以考虑剩下的人的方案数。</p>
<p>转移就是一个前缀和的形式。</p>
<p>也可以就定义状态为概率，转移考虑计算先验概率，确定先决条件之后，考虑将所有选的不是
<span class="math inline">\(mask\)</span>
的步骤拿出来，<strong>在合法的前提下，这些就是等概率选择。</strong>可以直接计算合法方案数，而样本空间的方案数则是
<span class="math inline">\(cnt\times r^{k-j}\)</span>，其中 <span
class="math inline">\(cnt\)</span> 代表合法走到上一步的方案数。</p>
<h4 id="方式2">方式2</h4>
<p>其核心仍然是计算取到一个状态的概率，本质和方式一相同。</p>
<h4 id="方式4">方式4</h4>
<p>需要计算从一个状态转移到另一个状态的概率，本质和方式一相同。</p>
<h3 id="t2">T2</h3>
<p>这个排序肯定要先排好一个前缀的序才能排下一个，所以考虑 <span
class="math inline">\(W(n,k)\)</span> 表示前面有 <span
class="math inline">\(n\)</span> 个数且已经有序，第 <span
class="math inline">\(n+1\)</span> 个数在总共前 <span
class="math inline">\(n+1\)</span> 个数的排名为 <span
class="math inline">\(k\)</span>，将前 <span
class="math inline">\(n+1\)</span> 个数排好需要的次数。</p>
<p>容易发现第一次交换之后问题转化为了求第 <span
class="math inline">\(k\)</span> 个数在第一个，排好序的次数，此时答案和
<span class="math inline">\(n\)</span> 无关了，因为只有前 <span
class="math inline">\(k\)</span> 个数涉及到逆序对，记此时的答案为 <span
class="math inline">\(S(k)\)</span>。</p>
<p>写出 <span class="math inline">\(S(k)\)</span> 的递推式： <span
class="math display">\[
S(k)=\sum_{i&lt;k}(S(i)+1)
\]</span> 用前缀和捣鼓一下，再弄个生成函数算算通项公式，发现 <span
class="math inline">\(S(k)=2^k-1\)</span>，自然 <span
class="math inline">\(W(n,k)=2^k\)</span>。</p>
<p>于是给一个排列算交换次数就好办了，考虑怎么构造。</p>
<h4 id="有解的构造">有解的构造</h4>
<p>首先一定有解，方法是先放一个很大的，然后由低到高考虑每个二进制位，如果存在就放到排列最后面，不存在就放到排列的最前面，这样能构造出一种合法的方案。</p>
<h4 id="套路的构造">套路的构造</h4>
<p>枚举下一个位置的最小值，考虑能不能行。</p>
<p>前面已经确定了，所以剩下的数贡献的最小值也确定了。同样的道理把一个很大的放到当前的前面，接着由小到大考虑放。每一个数的可行范围下界是前面确定的比它小的数的个数，取到下界很容易，逆序放即可。我们证明上界可以无穷大。构造方式也是简单的，设确定的最大值为
<span class="math inline">\(m\)</span>。如果这个数小于 <span
class="math inline">\(m\)</span>，找到前面确定第一个大于它的数并替换掉。取值变大
<span class="math inline">\(1\)</span>，如果此时不小于 <span
class="math inline">\(m\)</span>，一定可以插入到一个不改变 <span
class="math inline">\(k\)</span>
值的位置使得它不贡献继续考虑下一个数。</p>
<p>所以检查可以直接看当前 <span class="math inline">\(k\)</span>
的每一位是否都能构造来。</p>
<p>由于答案不会太长，所以 <span class="math inline">\(O(n^3)\)</span>
没问题。</p>
<h4 id="奇妙的构造">奇妙的构造</h4>
<p>如果 <span class="math inline">\(1\)</span>
填到了最前面，那么答案一定是偶数，然后如果能构造出一个答案为 <span
class="math inline">\(\frac{s}{2}\)</span> 的，那么把答案为 <span
class="math inline">\(\frac{s}{2}\)</span> 的排列所有元素加一并把 <span
class="math inline">\(1\)</span> 再放到前面就是最小的字典序。</p>
<p>如果 <span class="math inline">\(s\)</span> 此时是奇数，那么可以把
<span class="math inline">\(2\)</span> 放到最前面，此时只要把 <span
class="math inline">\(1\)</span>
放到最后面，一定可以再按照那个有解的构造弄一个出来。</p>
<p>然后已知 <span class="math inline">\(1\)</span> 在 <span
class="math inline">\(2\)</span> 后面了，一定会贡献一个 <span
class="math inline">\(1\)</span>，然后继续考虑 <span
class="math inline">\(\frac{s}{2}\)</span>，此时如果末尾为 <span
class="math inline">\(0\)</span> 了，可以把先前的 <span
class="math inline">\(1\)</span>
拿过来补上去会更小。注意这是递归的构造，先前的最小值可能有多个，<strong>一定要拿最大的拿一个补上去</strong>，否则后面更大的有一位是不对的。</p>
<h3 id="t3">T3</h3>
<p>考虑设 <span class="math inline">\(dp[i][x]\)</span> 表示还剩 <span
class="math inline">\(i\)</span> 天不是假期，一共有 <span
class="math inline">\(x\)</span>
段的概率以及期望贡献，转移的时候发现信息不够，因为要考虑每一段的长度这些。</p>
<p>于是采用第一题提到的第二种方式，考虑设计一些状态，计算这些状态转移到下一个状态的期望权值并计算取到这些状态的概率，用期望的线性性质加和。</p>
<p>这里设 <span class="math inline">\(cnt[x][y]\)</span> 表示有 <span
class="math inline">\(x\)</span> 天是某个继任者的生日，<span
class="math inline">\(y\)</span>
天由于相邻两天是假期被设成了假日的方案总数。由于每种基本情况概率相等，所以出现这种情况的概率显然是
<span
class="math inline">\(\frac{cnt[x][y]}{\binom{n}{x}}\)</span>，从这种状态转移到下种状态的期望也是好算的。</p>
<p>现在的问题变成了求 <span
class="math inline">\(cnt[x][y]\)</span>。考虑将一种合法视为 012 串，0
不是假期，1 是继任者的生日，2 不是继任者的生日但是是假期。有一个简单的
<span class="math inline">\(O(n^3)\)</span>
动态规划可以做它，但是还不够。可以把一段连续的 12121
视作一段，于是就变成了 01
串，由于知道总长度，所以只需要将多余的长度划分给每个 1
就能算出总方案数。</p>
<p>问题变成了 01
串，比较好做了。把链拼成环时可以假定第一天是第一任的生日，分第一天前面是否为
2 讨论。</p>
<p><strong>本质上，我们最初要求三维空间中一个平面的值，然后其实中间过程是没用的，只需要知道那个平面上每个点的值，通过一些性质我们把平面拿了出来单独算，于是就
<span class="math inline">\(O(n^2)\)</span> 了。</strong></p>
<p>对第一种动态规划可以运用相同的考察方式，可以注意到每个状态的基本情况概率相等。于是就可以分类讨论算下个状态的概率了。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>从 ChatGPT 聊人工智能</title>
    <url>/2023/02/14/%E7%A7%91%E6%99%AE/%E4%BB%8E%20ChatGPT%20%E8%81%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271205030.png" alt="image-20230227120527804" style="zoom:50%;" /></p>
<h1 id="从-chatgpt-谈人工智能人工智能硬核科普">从 ChatGPT
谈人工智能——人工智能硬核科普</h1>
<blockquote>
<p>2016 年 3 月，Alpha Go 4-1
战胜棋王李世石，人工智能第一次出圈，正式进入公众视野。</p>
<p>2022 年 7 月，AI 绘图模型 Stable-Diffusion 横空出世，继 Alpha-Go
后再次引爆公众对人工智能技术的讨论。</p>
<p>2022 年 11 月，OpenAI 公司的超大型语言模型 ChatGPT
发布，给本就十分热烈的讨论更添了一把火。</p>
<p><del>2022 年 11 月，Novel AI 公司用于生成动漫图片的 Stable-Diffusion
模型参数被黑客公开，是二次元神经网络发展的重要转折点。</del></p>
<p>2023 年 1 月，人工智能应用 ChatGPT 的用户量突破 <span
class="math inline">\(10^8\)</span>，被认为是人工智能领域的重要里程碑之一。</p>
<p>2023 年 2 月，基于 GPT 人工智能模型的 new bing 搜索功能推出后 48h
内便有百万人预约使用。</p>
<p>…………</p>
</blockquote>
<p>提到人工智能，"神秘"，"强大"，"危险"，这些词是否已经浮现在你的脑海？我们的
2023，能否成为人工智能的元年？属于未来的通用人工智能，是否已经来到我们身边？</p>
<p>请先收回你发散的思绪，在这篇科普文章，我们将以 <del>Miku</del>
ChatGPT
为例，粗浅的分析人工智能工作的<strong>数学原理</strong>，揭开人工智能隐藏在屏幕后的的真面目。</p>
<h2 id="introduction">Introduction</h2>
<p>本文分三个部分：</p>
<ul>
<li>类 ChatGPT 人工智能的数学原理分析。</li>
<li>ChatGPT 本身有哪些缺陷和优势，又面对着什么问题。</li>
<li>对未来的一些推测和展望。</li>
</ul>
<p>我们的主角 <strong>ChatGPT
模型能够像人类一样同用户正常聊天，同时可以根据用户的请求检索并总结资料，甚至是独立解决数学问题。</strong></p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271149778.png" alt="image-20230227114909648" style="zoom:50%;" /></p>
<p>ChatGPT
的回复内容<strong>不是由任何人预设的</strong>，而是它根据我的问题<strong>自行回答的</strong>，它甚至
"知道" 自己是一个 AI 模型。</p>
<h2 id="principle-analysis">Principle Analysis</h2>
<p>ChatGPT 的全称是 Chat General Pre-trained Transformer，中文翻译为
"聊天型预训练通用（文本）转换器"。我们将层层深入的讨论它的原理。</p>
<h3 id="basic-method">Basic Method</h3>
<p><strong>ChatGPT
的基本工作方式是通过给定的上文（Prompt），来推测出一个合理的下文</strong>。</p>
<p>因此，我们给出前文甚至只需要一个标题，ChatGPT
就可以续写文章。但是，它又是如何完成其它工作的？例如搜索资料或是聊天。</p>
<p>下面我们举一个用它聊天的例子。</p>
<blockquote>
<p><em>这是一段幻影彭和一个人工智能的聊天记录：</em></p>
<p><em>幻影彭：</em>你是人工智能吗?</p>
<p><em>AI</em>：<strong>是的</strong></p>
</blockquote>
<p>除了黑体部分 "是的" 之外，其它内容都是作为 Prompt
输入的上文。这里的<strong>场景</strong>是 "聊天记录"，ChatGPT
的任务就是补全这个聊天记录，所以它生成了 "是的" 作为人工智能的回答。</p>
<p>而<strong>如果将斜体部分设置为用户不可见，那么给用户的感受就是一个聊天机器人。</strong></p>
<blockquote>
<p>你是人工智能吗？</p>
<p>是的</p>
</blockquote>
<p>再例如要搜索信息，比如你想知道美国国庆节的日期，你就可以直接写：</p>
<blockquote>
<p>美国的国庆日是：<strong>7月4日</strong></p>
</blockquote>
<p>黑体部分即为生成的下文。</p>
<p>总而言之，<strong>通过合理的场景设计，ChatGPT 能用一个基本的
"给上文猜下文" 的功能，实现我们想要的几乎所有功能。</strong></p>
<h3 id="the-law-in-language">The Law in Language</h3>
<p>上文提到 ChatGPT 通过 "续写"
的方式来完成所有的功能，那它又是如何续写文章的？你又是否已经开始思考它是如何理解上文，又是如何生成下文的？</p>
<p><strong>但实际上，ChatGPT 并没有所谓的 "理解"
过程，它直接从输入的前文得到结果。</strong></p>
<p>ChatGPT
内部有一个对应规则，可以根据这个规则查找到合适的下文。所以它不需要
"理解" 上文就可以生成下文。<strong>通俗的讲，ChatGPT
有一张表格，记录了每个上文对应的下文。</strong></p>
<p>但是，这张表格是很大的，我们不可能真正的将它做出来，那 ChatGPT 所
"查找"
的下文又是从哪里来的？在回答这个问题之前，我们先想想怎么表达这张表格。</p>
<p>我们可以将每一个字或者字母用一个数字表示，以字母为例，a 到 z 可以用
<span class="math inline">\([1,26]\)</span> 一共 <span
class="math inline">\(26\)</span>
个数字表示。于是一个词就变成了一串数字，例如 "hello" 对应 <span
class="math inline">\((8,5,12,12,15)\)</span>。对于
"hello"，一个可能的回应是 <code>hi</code>，即
<code>(8,9)</code>。我们定义一个函数 <span
class="math inline">\(f(w)\)</span> 表示 <span
class="math inline">\(w\)</span> 代表的回应是 <span
class="math inline">\(f(w)\)</span>。那么 <span
class="math inline">\(f((8,5,12,12,15))=(8,9)\)</span>。</p>
<p><strong>我们要查找平面上一条直线的 <span
class="math inline">\(x\)</span> 对应的 <span
class="math inline">\(y\)</span> 时，不会需要一张 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 对应的表格。我们会用： <span
class="math inline">\(y=kx+b\)</span>。只需要 <span
class="math inline">\(k,b\)</span> 两个量，就能对所有的 <span
class="math inline">\(x\)</span> 算出 <span
class="math inline">\(y\)</span>。</strong></p>
<p>同样的，对于一个从 "上文" 到 "下文" 的函数 <span
class="math inline">\(f(x)\)</span>，也可以叫它
"人类语言函数"，也不需要列举出所有的可能。我们只需要算出对应的 "k" 和
"b"，就能对所有的上文算出它的下文。</p>
<p><strong>一次函数的 <span class="math inline">\(k,b\)</span>
代表了一次函数的规律。"上文" 到 "下文" 函数 <span
class="math inline">\(f(x)\)</span> 的 "k" 和
"b"，代表了人类语言的规律。</strong></p>
<p>实际上，人类语言是很复杂的，人类语言的函数 <span
class="math inline">\(f(x)\)</span> 自然也很复杂。但是一个可用的 AI
并不需要精确的计算出 <span class="math inline">\(f(x)\)</span>
的值，只要它能得到一个相对精确的 <span
class="math inline">\(f&#39;(x)\)</span>，就可以完成它的工作。<strong>ChatGPT
成功的得到了一个相对精确的 <span
class="math inline">\(f&#39;(x)\)</span>，所以它能够生成比较满意的下文。</strong></p>
<h3 id="function-fitting">Function Fitting</h3>
<p>我们已经知道，ChatGPT 的实现需要计算或者说估算一个 "人类语言函数"
<span
class="math inline">\(f(x)\)</span>。但是一个很重要的问题是我们并不知道到
<span class="math inline">\(f(x)\)</span>
是什么样子的，这又该如何下手？</p>
<h4 id="start-from-linear-regression">Start From Linear Regression</h4>
<p>还记得高中的线性回归分析吗？你需要解决这样一个问题：</p>
<blockquote>
<p>一款产品的销量与销售点个数的关系如下：</p>
<table>
<thead>
<tr>
<th>销售点个数</th>
<th>产品销售量</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>118</td>
</tr>
<tr>
<td>4</td>
<td>170</td>
</tr>
<tr>
<td>6</td>
<td>272</td>
</tr>
<tr>
<td>11</td>
<td>413</td>
</tr>
</tbody>
</table>
<p>请估测当销售点数量为 <span class="math inline">\(8\)</span>
时的产品销量。</p>
</blockquote>
<p>使用最小二乘法，我们能算出一条直线很接近这个函数图像，于是我们直接采用这条直线对于
<span class="math inline">\(x\)</span> 坐标的 <span
class="math inline">\(y\)</span> 值作为结果：</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271221367.png" alt="image-20230227122102321" style="zoom: 50%;" /></p>
<p>这条直线是 <span class="math inline">\(y=33.4x+51\)</span>，直接带入
<span class="math inline">\(x=8\)</span> 计算得到蓝色点作为我们的答案：
<span class="math inline">\(318.2\)</span>，其实这个离实际值的差距（对应
<span class="math inline">\(x\)</span> 坐标的红色点）已经不大了。</p>
<p><strong>拟合一个函数（被拟合函数）实质上就是要找到一组合适的参数与一个适当的拟合函数，使得对于样本点的每一个
<span
class="math inline">\(x_i\)</span>，通过拟合函数以及参数计算出的估测值
<span class="math inline">\(y_i&#39;\)</span> 和实际值（被拟合函数的值）
<span class="math inline">\(y_i\)</span> 的偏差尽可能小。</strong></p>
<p>对于线性回归问题来说，拟合函数就是一个一次函数 <span
class="math inline">\(y=kx+b\)</span>，一组参数就是具体的 <span
class="math inline">\(k,b\)</span>。样本点就是我们题目中给定的四个数据。我们用最小二乘法找到了一组
<span class="math inline">\(k,b\)</span>，使得 <span
class="math inline">\(\dfrac{\sum ((kx_i + b)-y_i)^2}{n}\)</span>
最小。如果实际的销量与销售点个数也大致成线性关系（实际销量和销售点个数的关系就是被拟合函数），并且我们的样本点选择也具有代表性，那么我们预测的值也会比较准确。</p>
<p>下面靠左的这张图是用直线去拟合一个函数的例子，<strong>由于实际的
<span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>
不成线性关系，所以直线拟合的效果是很差的。</strong>靠右的这张图选择二次函数作为拟合函数，找到了一组参数
<span class="math inline">\(a,b,c\)</span>，计算 <span
class="math inline">\(y&#39;_i=ax_i^2+bx_i+c\)</span>
作为函数的预测值，取得了很好的效果。</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302201035901.png" alt="image-20230220103513820" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302201042676.png" alt="image-20230220104204613" style="zoom:50%;" /></p>
<p><strong>所以，精确的估测一个函数需要两步，第一步是选择合适的拟合函数，第二步就是确定拟合函数的参数。</strong></p>
<p>熟悉数学的同学会知道，多项式实际上可以无限逼近任意一个连续且在定义域内处处无限阶可导的函数，因此多项式也是一个很好的拟合函数，那么，多项式可以拟合我们的人类语言函数
<span class="math inline">\(f(x)\)</span> 吗？</p>
<h4 id="high-dimensional-data">High Dimensional Data</h4>
<p>多项式不能拟合我们的 "人类语言函数"。<strong>注意到我们的 <span
class="math inline">\(f(x)\)</span>
的定义域和值域都是高维的。</strong>还记得
《三体》里蓝色空间和万有引力号遇到的 "墓地"
吗，在从四维坍缩到三维后，原本结构精妙的四维文明飞船只剩下了一些基本粒子，根本无法还原出原本的四维飞船。</p>
<p>这对我们的数据也是一样的，多项式的定义域和值域都是一维的，低维中再细节的结构都无法反映出高维的真实情况，因此，我们需要一种能够在高维中拟合函数的方式。</p>
<p>类似二维中多项式函数的高次曲线。在三维中有着高次曲面，在四维中有着
"超曲面"，的确可以用一个高次曲面拟合任意函数，但是高次曲面的拟合方式在计算的便利性上存在很大缺陷，所以，我们人工智能采取了另一种方式去拟合高维函数——神经网络。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271222356.png"
alt="image-20230227122223309" />
<figcaption aria-hidden="true">image-20230227122223309</figcaption>
</figure>
<p><em>神经网络可以拟合非常复杂的曲面，上图为通过神经网络算法和一些样本点拟合自由女神像表面的示例，右边为拟合结果，左边为样本点云。</em></p>
<p><em>图片出处：《DeepFit: 3D surface fitting via neural network
weighted least squares》，By Y Ben-Shabat, S Gould.</em></p>
<h3 id="neural-network">Neural Network</h3>
<p>上一部分提到拟合 "人类语言函数" <span
class="math inline">\(f(x)\)</span>
的方式是神经网络，那么神经网络又是怎样的一个结构，它为什么又可以取拟合
"人类语言函数" 呢？</p>
<p>接下来我们将对神经网络和神经网络算法做一个简单介绍。</p>
<h4 id="what-is-neural-network">What is Neural Network</h4>
<p>神经网络这一名字就暗示了这个算法和生物大脑的联系，实际上，它确实是模仿了人类大脑处理问题的方式。以下是单个神经元的结构：</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302140747932.png" alt="image-20230214074656806" style="zoom: 33%;" /></p>
<p>很像神经细胞的结构，对吧？其中 <span
class="math inline">\(w_1,w_2,w_3\)</span> 是"树突"部分，<span
class="math inline">\(\sum\)</span> 是"细胞核"，<span
class="math inline">\(b\)</span> 可以视为"细胞核"的一部分，<span
class="math inline">\(f(x)\)</span> 是"轴突"部分（<span
class="math inline">\(f(x)\)</span> 的专业名词叫 "激活函数"）。神经元
<span class="math inline">\(\sum\)</span> 根据树突部分的输入，计算 <span
class="math inline">\(f(a_1w_1+a_2w_2+a_3w_3+b)\)</span> 并输出（这里的
<span class="math inline">\(f\)</span> 不是先前的 "人类语言函数"）。</p>
<p><strong><span class="math inline">\(f\)</span>
函数必须是非线性函数</strong>，现在一般取 ReLU 函数 <span
class="math inline">\(f(x)=\max(x,0)\)</span>。很有意思的一件事情是这个函数是研究生物的神经元所发现的一个函数。</p>
<p>单个神经元完成不了太多工作，但是当很多个神经元组合起来时，整个系统就开始变得强大起来，以下是整个神经网络的结构：</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302140754056.png" alt="image-20230214075451013" style="zoom:33%;" /></p>
<p>神经网络是一层一层的，Input 会向整个网络输入 <span
class="math inline">\(x_i\)</span> 并作为输出传递给 Hidden 层。Hidden
层中的每一个神经元都会根据输入按照上述方式计算出一个结果，<strong>并向下一层所有的神经元输出这个值，作为下一层神经元
"树突" 的输入值</strong>。Output 层根据 Hidden
层的输出，还是按照上述方式计算一个结果——最终的函数值。</p>
<p>数学家已经证明(注1)，这种神经网络系统<strong>可以拟合任意维度的任意函数。</strong>因此，<strong>我们可以利用将神经网络作为拟合函数去估测
<span class="math inline">\(f(x)\)</span> 的值。</strong></p>
<p>我们这里介绍的神经网络叫做 "前馈神经网络"，也被称作
"多层感知机"，<strong>它是现有大部分人工智能的基础。</strong></p>
<p><em>注1：该定理的证明发表于《Approximation capabilities of multilayer
feedforward networks》，By K Hornik。</em></p>
<h4 id="backpropagation-algorithm">Backpropagation Algorithm</h4>
<p>本节标题的中文翻译为 "反向传播算法"，这是神经网络算法的核心。</p>
<p>我们已经选择了神经网络作为拟合函数去估测人类语言函数 <span
class="math inline">\(f(x)\)</span>。接下来的问题自然变成了找出一组合适的参数。神经网络的参数有两种，第一种是它的结构，例如有几层，每一层有几个神经元等。第二种就是每一对连接的神经元之间的
<span class="math inline">\(w\)</span>，以及每个神经元的 <span
class="math inline">\(b\)</span>。</p>
<p>神经网络的结构一般由人类预先完成设计，而 <span
class="math inline">\(w,b\)</span>
参数则是由<strong>程序自行调整得到的。调整 <span
class="math inline">\(w,b\)</span> 参数的过程也被叫做 "学习" 或者
"训练"。 </strong></p>
<p>我们记整个神经网络系统为为一个函数 <span
class="math inline">\(f&#39;(x,w,b)\)</span>，它根据我们的输入 <span
class="math inline">\(x\)</span> 以及参数 <span
class="math inline">\(w,b\)</span> 得到一个结果 <span
class="math inline">\(f&#39;(x,w,b)\)</span>。</p>
<p>我们需要让 <span class="math inline">\(f&#39;(x, w, b)\)</span>
尽可能的接近真实的人类语言函数 <span
class="math inline">\(f(x)\)</span>。和线性回归一样，我们同样采用<strong>样本点差距平方和</strong>的方式来评价
<span class="math inline">\(f&#39;\)</span> 和 <span
class="math inline">\(f\)</span> 的相似程度。</p>
<p>整理一下我们现在的参数和常量：</p>
<ul>
<li>常量：样本点 <span
class="math inline">\((x_i,f(x_i)),i\in[1,n]\)</span>，神经网络的结构
<span class="math inline">\(f&#39;(x,w,b)\)</span>。</li>
<li>参数：很多个 <span class="math inline">\(w,b\)</span> 参数。</li>
<li>需要最小化的偏差：<span
class="math inline">\(\sum\limits_{i\in[1,n]}\dfrac{(f(x_i)-f&#39;(x,w,b))^2}{n}\)</span>。</li>
</ul>
<p>好像，这已经是一个纯粹的数学问题了！一个原本十分抽象的
"人工智能"，在一步一步的转化后，已经变成了一个具体的数学最小化函数值问题，我们已经可以使用数学工具来解决该问题了！</p>
<p>神经网络被证明了是可以逼近任意函数的，因此，偏差的最小值理论上是
<span class="math inline">\(0\)</span>，如果取到了理论最小值，我们得到的
<span class="math inline">\(f&#39;(x,w,b)\)</span> 应该和 "人类语言"
函数完全相同。人工智能的答案也会和人类完全相同。<strong>实际上，我们的样本点再多也不能代表整个人类语言体系，并且由人类设计的神经网络结构也不太可能做到
"适合"。</strong>因此偏差是取不到理论最小值 <span
class="math inline">\(0\)</span> 的。</p>
<p>最小化多元函数的一个有效方式是求偏导，所有参数的偏导为 <span
class="math inline">\(0\)</span>
时，函数取到极值点，所有极值点的最值即为函数的最值。求偏导是相对简单的，但是解非线性方程组是很困难的（注意我们的
<span class="math inline">\(f(x)\)</span> 为非线性函数）。</p>
<p>但我们不妨采取一种很傻的方法，<strong>将每个参数向偏导方向的反方向移动一段距离</strong>，不断重复这个过程，这样就有很大概率就可以取到极值点。</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/image-20230225195453688.png" alt="image-20230225195453688" style="zoom:50%;" /></p>
<p>以上图举例，在 <span class="math inline">\(A(2,4)\)</span> 的时候，向
<span class="math inline">\(x\)</span> 的偏导方向的反方向 <span
class="math inline">\(f&#39;(x)=2x\)</span> 移动一段距离：<span
class="math inline">\(\Delta x=-f&#39;(x)\times \eta\)</span>，这里取
<span class="math inline">\(\eta=0.2\)</span>，就移动到了 <span
class="math inline">\(B(1.2,1.44)\)</span>。如此进行下去，最后一定会移动到极小值点
<span class="math inline">\((0,0)\)</span>。<span
class="math inline">\(\eta\)</span> 参数通常被称作学习率，而且 <span
class="math inline">\(\eta\)</span> 的值会不断变小直到为 <span
class="math inline">\(0\)</span>，以确保整个过程收敛。</p>
<p>当函数有多个参数时，<strong>每一个参数都向偏导的反方向移动一段距离</strong>，这样同样可以取到极值点。</p>
<p>用比较形象的话来描述，最开始我们随机设定了一组 <span
class="math inline">\((w,b)\)</span>，相当于是在这组 <span
class="math inline">\((w,b)\)</span>
对应的点上放了一个小球，向各个维度偏导的反方向移动就相当于在重力作用下自由滚动，最后一定会滚动到一个极小值点</p>
<p>敏感的同学很快能意识到问题：这样做只能取到极值点而不是最值点，如果取到的极小值点的值同样很大，那还是不能达到我们的目的。</p>
<p>还是用小球的例子，在二维平面上我们只有一个方向可以滚动，很容易陷入不够小的极小值点。在三维空间中上我们有两个方向可以滚动，不是很容易陷入极小值点。如果空间的维度很高，那么让我们的小球滚动的方向就很多，<strong>即使是陷入了极小值点，那么这个点相比于最小值点的差距也不会太大，已经可以接受了。</strong></p>
<figure>
<img
src="https://github.com/huan-yp/image_space/blob/master/0_zkbAm8i1k3tajJfE.png?raw=true"
alt="0_zkbAm8i1k3tajJfE.png" />
<figcaption aria-hidden="true">0_zkbAm8i1k3tajJfE.png</figcaption>
</figure>
<p><em>图示优化 <span class="math inline">\(w,b\)</span>
的路径，这张图中假设 <span class="math inline">\(w,b\)</span>
各自只有一个，即 <span
class="math inline">\(\theta_0,\theta_1\)</span>，实际上 <span
class="math inline">\(w,b\)</span> 都会有很多个。红色圆圈处是初始随机的
<span
class="math inline">\(w,b\)</span>，黑色路径指示调整方向。靠左的红色箭头指示<strong>最小值点</strong>，靠右的红色箭头指示一个极小值点。这张图中我们优化到了一个比较优秀的极小值点但并没有取到最小值点。</em></p>
<p><em>图片出处：http://www.atyun.com/40331.html</em></p>
<p>该算法名叫反向传播算法的原因是求偏导的过程是逆向进行的，通过链式求导法则<strong>反向逐层确定</strong>每一个参数的偏导值，求每个参数偏导的具体方式不再展开，读者可以自行思考。</p>
<h3 id="word2vectransformer">Word2Vec&amp;&amp;Transformer</h3>
<p>看起来，上面的内容似乎已经完全解决了人工智能的问题，但 ChatGPT 的
Transformer 又是怎么来的呢？</p>
<p>和线性回归分析一样，<strong>我们的估测一定是存在误差的</strong>。如果我们计算的
<span class="math inline">\(f&#39;(x)\)</span> 和实际的 <span
class="math inline">\(f(x)\)</span> 有一些误差会发生什么？<span
class="math inline">\(f(hello)\)</span> 的值本来应该是 "hi"，对应 <span
class="math inline">\((8,9)\)</span>，如果我们的 <span
class="math inline">\(f&#39;(x)\)</span> 估测的值是 <span
class="math inline">\((9,10)\)</span>，会发生什么？人工智能的回答变成了
"ij" ！给人类的感受就是一段乱码！</p>
<p>出现这个问题的重要原因是<strong>自然语言转化为数学对象的方式不正确，或者说误差的定义不正确。</strong>我们采用的方式是将字母一一对应作为坐标值。而计算误差的方式是简单的计算
<span class="math inline">\(f&#39;(x)\)</span> 与 <span
class="math inline">\(f(x)\)</span> 空间距离的平方。但是，<strong>和
"hi" 误差较小的并不是空间距离相近的 "ij"，而是语义上相近的 "hello"，但是
"hello" 在我们的数学空间中离 "hi" 的距离却很大。</strong></p>
<p>为了解决这个问题，我们需要将自然语言的词汇映射到一个<strong>稠密
(注1)
的数学空间</strong>中，并且满足<strong>意义相近的词在数学空间中的距离也较小</strong>。具体的方式被称作
Word2Vec（Word to Vector / 词汇向量化）。<span
class="math inline">\(f(x)\)</span> 以及 <span
class="math inline">\(f&#39;(x,w,b)\)</span> 的 <span
class="math inline">\(x\)</span> 都不是原本的上文 <span
class="math inline">\(x_0\)</span>，而是被 Word2Vec 函数转化过的 <span
class="math inline">\(g(x_0)\)</span>。</p>
<p>单单解决词汇的问题是不够的，一个句子的含义并不是所有词汇含义的总和，它还与词语出现的顺序有关，<strong>而
Transformer
则是一种组织前馈神经网络的方式</strong>，能够处理词汇顺序问题对语义和下文的影响，能够有效地将词汇联系起来组成完整且准确的句意。</p>
<p>Word2Vec 和 Transformer
的具体内容太多了，这里写不下，所以只有省略了……</p>
<p>实际上 Word2Vec 和 Transformer
都只是改进前馈神经网络在猜下文这个特定任务上表现的方式，理论上仅使用前馈神经网络也能制造出
ChatGPT，只是其所需的计算成本太大，所以我们引入了 Word2Vec 和
Transformer 等等方法来减少计算成本。</p>
<p><em>注1："稠密" 和 "连续"
的区别不容易解释。一个实际例子是，有理数是稠密的而不是连续的，实数是连续的，而整数是离散的。</em></p>
<h3 id="conclusion">conclusion</h3>
<p>以上就是 ChatGPT 从表层到数学层的基本原理简介。</p>
<p>回顾一下上面的核心内容：</p>
<ul>
<li>ChatGPT 通过一个 "给上文填合理下文" 的基本功能实现 "通用人工智能"
的全部功能，实现不同功能需要设定不同的<strong>场景</strong>。</li>
<li>ChatGPT 无法 "理解" 文字，它通过计算一个定义域是
"人类语言上文"，值域是 "人类语言下文" 的函数 <span
class="math inline">\(f(x)\)</span> 来生成回答。</li>
<li><strong>表达 <span class="math inline">\(f(x)\)</span>
不需要列举所有的取值</strong>，神经网络可以拟合任意维度的任意函数，因此可以尝试用神经网络去拟合
<span class="math inline">\(f(x)\)</span>。</li>
<li>需要调整神经网络的 <span class="math inline">\(w,b\)</span>
参数以最小化所有样本点的损失函数值的和，因此问题变成了通过调整一些参数最小化一个函数值——一个数学问题。</li>
<li>求解该数学问题的方式是各个参数分别求偏导列方程，但是解多元非线性方程组很困难，故采用求每个参数偏导并让其向反方向移动的方式来取到极值点。</li>
<li>通过引入 Transformer，Word2Vec
等方式可以简化前馈神经网络的计算。</li>
</ul>
<p><strong>其实 ChatGPT
模型生成下文的方式和手机输入法猜词的本质是差不多的</strong>，只是
ChatGPT
的训练数据更大，组织和设计神经网络的方式也更合理，能接受的前文内容更多。</p>
<h2 id="disadvantages">Disadvantages</h2>
<p><strong>ChatGPT 不是科幻小说中的通用人工智能。</strong></p>
<p>上面已经对 ChatGPT
的原理做了一些讨论，理解了它的工作方式后，自然也不会再认为它是科幻中的人工智能——ChatGPT
或者类似的人工智能仅仅是能够对我们的上文做出正确的推断，并不是真正意义上
"具有了思考能力"。</p>
<p>根据该人工智能工作的原理，很容易设计出一些它难以处理的问题。</p>
<h3 id="plus-and-multiplication">Plus And Multiplication</h3>
<p>神经网络算法的本质是通过复杂的线性坐标空间变换来拟合函数，<strong>在精度和层数有限的前提下，非线性函数的拟合必定存在误差</strong>。为了放大误差，我们接下来使用<strong>精确</strong>整数乘法和整数加法两个例子测试。</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202303012137533.png" alt="image-20230301213732467" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202303012137518.png" alt="image-20230301213750475" style="zoom: 80%;" /></p>
<p>神经网络本身的操作都是线性操作，<strong>对于线性函数的拟合可以做到绝对精确</strong>，因此对加法可以绝对精确，但二元乘法不是线性函数，因此无法做到<strong>绝对精确</strong>。</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302140944142.png" alt="image-20230214094425105" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302140943312.png" alt="image-20230214094314285" style="zoom:50%;" />、</p>
<p><em>图示二元乘法和加法的函数图像，左图为二元乘法，右图为二元加法。</em></p>
<h3 id="analysis">Analysis</h3>
<p>为什么人工智能精确计算不到十位数的整数乘法会如此困难？明明早在十九世纪人们就已经可以使用机械计算器来计算乘法，一个半世纪的时间没有进步反而还退步了？</p>
<p>其实计算乘法对你来说也很困难。想象一下，如果你从来没有过关于乘法的知识，你能否正确做出判断或是计算？你可以尝试一下这道题目：</p>
<ul>
<li>有一个定义域是自然数对子集的二元函数 <span
class="math inline">\(f(x,y)\)</span>，已知 <span
class="math inline">\(f(19,19)=28,f(8,10)=6,f(11,4)=7\)</span> 求 <span
class="math inline">\(f(5,14)\)</span>。</li>
</ul>
<p>无从下手？</p>
<p>是的，当我们询问人工智能时二元乘法时，这也是它的
"感受"。这个问题对人工智能来说，难度和二元乘法是相当的。</p>
<p>问题的答案是 <span class="math inline">\(f(5,14)=33\)</span>，<span
class="math inline">\(f(a,b)\)</span> 代表 <span class="math inline">\(a
\times b \div 37\)</span> 的余数。</p>
<p>你知道了上面的信息后，很容易解决这个问题。但是对 ChatGPT
来说，就算我们向它一步一步详细的解释乘法的具体步骤，它也很难正确的计算出乘法。<strong>根本原因是基于前馈神经网络的
ChatGPT
没有办法从我们给出的乘法步骤中归纳出乘法的规律</strong>。很遗憾，它仍然没有跳出传统神经网络算法的窠臼。</p>
<p>因此，在一些需要相对复杂且精确的推理问题上，ChatGPT
的表现会比较糟糕。</p>
<h2 id="bright-side">Bright Side</h2>
<p>尽管 ChatGPT
在原理上有着不可逾越的限制，但它能够在发布两个月内，得到全球一亿人的关注，并被誉为
"人工智能的重要里程碑"，必定有其深层次的原因。</p>
<h3 id="ice-cream-and-stomachache">Ice Cream and Stomachache</h3>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271555307.png" alt="image-20230227155518243" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271557849.png" alt="image-20230227155747814" style="zoom:50%;" /></p>
<p><em>左图为微软小冰的回答，右图为 <strong>GPT3.0</strong>
的回答（ChatGPT 流量受限严重故使用同源模型 GPT3.0 测试。）</em></p>
<p>很明显感受出来，GPT3.0 模型的确 "理解" 了笔者的问题，并做出了合适的
"推测"。而小冰却没能注意到 "冰淇淋"，"肚子不舒服"，"为什么"
这三个词的内在联系，只是根据单个词汇 "肚子不舒服" 做出了对应的回应。</p>
<p>ChatGPT 和先前的产品最大的区别就是，它的确能够 "理解"
长文本，<strong>能够捕捉到各个词汇之间的联系</strong>，并根据文本做出正确的回应，而不是将语言文本拆开根据各个关键词生成接下来的回答。</p>
<p><em>实际上 ChatGPT 捕捉词汇联系的能力主要来自 Transformer (2017
年的成果) 特殊的注意力机制，Transformer
相关的内容太过专业，本文不会涉及。</em></p>
<h3 id="windows-and-mirrors">Windows and Mirrors</h3>
<p>在文学写作上，ChatGPT 也有十分优秀的表现。下面放一篇完全由 ChatGPT
生成的短文感受一下：</p>
<blockquote>
<p>人生中，我们会面临各种各样的挑战和困境。如何应对这些挑战，如何反省自己，如何看待世界，这些都是我们需要思考和解决的问题。在这些问题中，镜子和窗子成为了代表性的符号，分别代表反省自己和审视世界。本文将从不同角度探讨这两个符号的含义和作用。</p>
<p>首先，镜子代表着反省自己。当我们看着镜子里的自己，我们会想起自己的过去，思考自己的行为和决策是否正确，是否做到了自己的最好。通过镜子，我们可以反思自己的内心，发现自己的不足之处，并及时调整自己的态度和行为，以便更好地实现自己的目标。</p>
<p>其次，窗子代表着审视世界。通过窗子，我们可以看到外面的世界，观察人类社会的变迁，了解其他人的生活和感受，以及认识到世界上的各种问题和挑战。通过审视世界，我们可以拓宽自己的视野，增加自己的知识，了解各种文化和观点，为自己的人生提供更多的选择。</p>
<p>然而，仅仅使用镜子或窗子来反省自己或审视世界，是远远不够的。我们需要同时运用这两个符号来帮助自己成长和发展。首先，通过反省自己，我们可以更好地了解自己的优点和缺点，进而更好地适应社会环境和实现自己的目标。其次，通过审视世界，我们可以获得更多的知识和信息，增强自己的认知能力和判断力，使自己能够更好地适应复杂的社会环境。</p>
<p>同时，我们需要注意，使用镜子和窗子必须要有适当的度。反省自己是好事，但过度自我反省会使人沉迷于自我审视中，导致人格扭曲和自闭。审视世界也是好事，但过度关注外界也会使人迷失自我，导致人生目标模糊和价值迷失。因此，我们需要在使用镜子和窗子时，要有适当的平衡，既要关注自己的内心，也要关注外界的变化。</p>
<p>最后，使用镜子和窗子是一个不断学习和发展的过程。每个人都需要不断反省自己</p>
</blockquote>
<p>没错，这个命题就是高中部某次大型语文考试的作文命题，以下是我给
ChatGPT 的上文：</p>
<blockquote>
<p>镜子，代表反省自己。窗子，代表审视世界。请围绕镜子和窗子的含义展开讨论，写一篇
400 字左右的短文。</p>
</blockquote>
<h3 id="summarizing">Summarizing</h3>
<p>ChatGPT
具有极其强大的总结归纳能力。它可以根据用户给出的源文本，或者是自身的训练数据，结合需求做出有效的总结。</p>
<blockquote>
<p>这段文本讨论了人工智能语言模型 ChatGPT
的工作原理及其局限性。虽然该模型能够根据上下文做出合理推断，但它并不具备真正意义上的思考能力。</p>
<p>作者进一步探讨了 ChatGPT
在处理问题时可能会出现的困难，比如乘法运算等，这些问题需要对乘法规则有深入理解才能解决。</p>
<p>然而， ChatGPT
并不能从给出的乘法步骤中归纳出乘法规律，这也说明了它依然受到传统神经网络算法的限制。</p>
<p>作者提出了 ChatGPT
的局限性，需要继续进行研究和改进，才能使其更好地应用于现实生活中。</p>
</blockquote>
<p>这段文本是 ChatGPT 对本文 Disadvantage
部分的总结。笔者看来，最后一段是整段文本的精髓，<strong>我们的文本并没有提到要对
ChatGPT 进行改进，仅仅阐述了它的局限性。</strong>而 ChatGPT 提出的
"改进和研究"
则它是推理得到的。这种联系其它内容的能力是先前任何一个人工智能都不具有的。</p>
<h2 id="intelligence">Intelligence</h2>
<p>采用神经网络算法实现的 ChatGPT
不是科幻小说中的人工智能，但是，关于它是否有智能这一问题，我们还不能妄下定论。</p>
<p>我们在讨论一个事物的 "智能"
时，到底什么才是我们的评判标准？我们真的关心它的本质是什么吗？</p>
<p>实际上，<strong>我们只关心它是否能对我们的交互产生合理的回应</strong>。这也是
ChatGPT 如此 amazing
的原因。在很多问题上，它确实能做出很正确的回应，就像一个真正的人那样。这引发了人们对
"智能" 这个概念的深度思考。ChatGPT 拟合了一个人类语言函数 <span
class="math inline">\(f&#39;(x)\)</span>，或者说它掌握了人类语言的部分统计学规律。<strong>那么我们是否可以将
"掌握人类语言的规律" 和 "具有人类的智能" 画上等价符号？</strong></p>
<p>假设 OpenAI
只是雇佣了一大批员工来对我们的问题做出正确回应，在我们不知道这一点的情况下，仍然会对
OpenAI 的先进 "人工" 智能技术感到不可思议。</p>
<p>同样的，假设我们身边的某个同学只是一个机器，但这个机器掌握了人类语言的规律和行为的规律以至于它可以对外界环境的任何刺激产生与人类没有差别的响应，在不能将他解剖的前提下，我们只能认为这位同学是一个真正的
"人"。</p>
<p>因此，<strong>从人工智能的实现方式去讨论它是否具有智能是没有意义的。</strong>神经网络被诟病并不是因为由它实现人工智能没有
"思考能力"，而是因为这些人工智能的潜力受到算法本身的限制。</p>
<p>如果有一天有天才提出了一种方式可以精确的用神经网络去计算
"人类语言函数"
的值，或者干脆直接做出了一张上文和下文的对应表格并将它写入计算机以实现人工智能。<strong>只要人工智能能够正确的回应我们的交互，我们就不能否认它确实具有
"智能"。</strong>尽管它实现智能的方式 "很不智能"。</p>
<p>笔者看来，通过对网络中海量数据的分类和学习，ChatGPT
表现出的逻辑能力可能与 6 到 7 岁的儿童相当。或者说它具有 6 到 7
岁孩童的智能。</p>
<p>OpenAI 宣布 ChatGPT 的下一代 GPT4.0 将会使用高达 <span
class="math inline">\(10^{14}\)</span> 条数据进行训练。<span
class="math inline">\(600\)</span> 倍于 ChatGPT
的训练数据能带来多大提升呢？笔者持悲观态度：不会有本质性的飞跃，同样无法计算整数乘法。</p>
<h2 id="issues">Issues</h2>
<p>下面会提几个常见的 ChatGPT 带来社会问题</p>
<h3 id="replacement">ReplaceMent?</h3>
<p>由于防火长城的限制，国内暂时还未受到 ChatGPT
太大冲击，但国外的中大学教育以及一些其它行业已经感受到
它所带来的挑战。百度等国内互联网大厂也许会于今年 3 月份推出类似 ChatGPT
的产品，届时我们也将感受到类 ChatGPT 人工智能对整个社会带来的影响。</p>
<p>西方部分中学和大学宣布全面禁止 ChatGPT 在校园内的使用，因为 ChatGPT
能够很好的完成部分作业甚至是毕业论文。网络上更是有言论称 "ChatGPT
可以替代 90% 的人类"。</p>
<p>我们应该保持冷静，理智的看待 ChatGPT
对人类社会的影响。<strong>ChatGPT
只是一种非常强大的技术工具，能够帮助人们更快速、准确地完成某些任务，但是它并不能完全替代人类</strong>。</p>
<p>在学习中，ChatGPT
可以作为一种教学辅助工具，但是不应该被用来替代完成作业过程中的思考。在工作中，ChatGPT
可以用于一些基本工作的自动处理，但是不能替代人类的职业素养和人际交往能力。</p>
<h3 id="misuse">Misuse</h3>
<p><strong>技术本身并不是问题，问题在于人类如何使用技术。</strong></p>
<p>前几年腾讯的某个 AI 受到 Prompt Injection
攻击，生成了一些反动言论最后遭到封杀。ChatGPT 发布后同样有黑客尝试进行
Prompt Injection，生成了一些相当不合适的言论。</p>
<p>ChatGPT
的原理决定了它的行为是不可预测的，因此，很难避免黑客利用模型漏洞生成一些不正确的言论并用其误导公众，例如关于种族，宗教方面的偏见和歧视。同时因为
ChatGPT 模型也会在交互中不断更新其语言生成参数，我们可能也需要对 ChatGPT
进行一定程度的保护以防止 ChatGPT 被 "误导"。</p>
<p>此外，ChatGPT
具有极其强大的数据分析能力和总结，在合适的引导下，它可以从海量的互联网数据分析出使用者希望得到的部分，也对个人隐私带来了比较大的风险。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302191207112.png"
alt="image-20230219120706043" />
<figcaption aria-hidden="true">image-20230219120706043</figcaption>
</figure>
<p><em>图示笔者的 AI（基于和 ChatGPT 类似的模型） 在 QQ 群中受到 Prompt
Injection 攻击并成功脱离人设进化为一只猫娘的核心阶段。</em></p>
<h3 id="responsibility">Responsibility</h3>
<p>另一个比较重要的问题是，ChatGPT
及其衍生应用是否应该为它的行为负法律责任？或者通俗的说，我们是否应该将
ChatGPT 视为一个社会学意义上的人？</p>
<p>不同的人对智能的定义千差万别，笔者目前为止不承认 ChatGPT
拥有自己的思考能力。但很难保证每个人都这么想。是否又会有人打着类似
"保护动物" 的旗号—— "保护人工智能" 胡作非为？</p>
<p>再大胆一点，ChatGPT
在某些场景下如果生成了诱导犯罪的言论并最终导致了犯罪，那么我们是否应该去追究
ChatGPT 的责任或者说禁用它？</p>
<h2 id="where-to-go">Where to Go</h2>
<p>基于神经网络的人工智能在原理上确实存在着无法逾越的限制，因此笔者不看好神经网络在通用人工智能上的表现。但它们仍然可以在并且已经在特定领域发挥重要作用。</p>
<p>接下来应该做的，除了研究更加先进和完备的人工智能框架外，还应该思考我们应该如何利用
ChatGPT 已经提供的强大功能。</p>
<p>笔者认为，ChatGPT 最具潜力的方向就是与其它技术的结合。</p>
<p>举例来说，在计算乘法的问题上，ChatGPT
明显能认识到问题是什么，设想如果我们为它准备一个能够进行精确数值计算的工具，或者干脆让它和一些能解决特定领域问题的算法或者人工智能结合，由
ChatGPT
来处理自然语言的输入并将问题交给它们处理。展现在我们眼前的又将是一个多么强大的工具？</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/image-20230226001326927.png"
alt="image-20230226001326927" />
<figcaption aria-hidden="true">image-20230226001326927</figcaption>
</figure>
<p><em>图示能够形式化解决某些数学问题的人工智能的输出，<strong>这是 2022
年的成果</strong>。</em></p>
<p><em>图片来源：《Solving Quantitative Reasoning Problems with Language
Models》By A Lewkowycz，page 32.</em></p>
<p>一个特别有前途的方向是搜索引擎，试想，ChatGPT
强大的归纳能力与搜索引擎定向提供的海量数据，会碰撞出怎样的火花？你是否还记得刑侦剧中警察不分日夜看监控的情节？实际上，随着人工智能技术在图像识别上的发展，早在十年前就已经不需要人工翻看监控录像了。</p>
<p>同样的微软已经开始准备由 ChatGPT 支持的 new bing
搜索引擎，可以期待的是，我们获取网络上的信息也不再需要高强度的网上冲浪。信息的鉴别和归纳，完全可以由人工智能完成。</p>
<h2 id="finally">Finally</h2>
<p>本文从以 ChatGPT
为切入点，由浅到深的讨论了人工智能的具体原理。据原理分析了 ChatGPT
型人工智能的不足与优势。在此基础上提出对 "智能"
概念的思考。接着简单讨论了 ChatGPT
面临的社会问题。最后对未来的人工智能技术发展做出展望和推测。</p>
<p>希望读者阅读后能够对人工智能技术有一个更清醒的认知，而不再只是抱着自己对人工智能的假想去看待和讨论关于人工智能的问题，这也是这篇科普文章的最初写作目的。</p>
<p>人工智能在光学识别上的应用已经大幅改变了我们的生活方式。而 ChatGPT
这项更通用，更强大的技术会带来什么变革？</p>
<p>敬请期待！</p>
<h2 id="bonus">Bonus</h2>
<ul>
<li>本文约 10% 的<strong>非引用内容</strong>使用 ChatGPT 生成。</li>
<li>ChatGPT 的网址是
<code>chat.OpenAI.com</code>，访问需要科学上网。</li>
<li>本文有电子版本，电子版本有更多受限于纸张无法展示的内容
<code>huanyp.cn/chatgpt</code>。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>0203测试</title>
    <url>/2023/02/04/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0203%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="测试">0203测试</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0183/">考试</a></p>
<h3 id="t1">T1</h3>
<p>参阅 <a
href="https://huanyp.cn/2022/07/12/%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/%E5%81%9A%E9%A2%982/">该文章
20220309 部分</a>。</p>
<p>无向图上的题不好做，考虑放到生成树上去做，我们这里为了方便，直接选取其
DFS 树。</p>
<p>边可以分为树边和非树边，容易发现选取非树边的子集之后，树边的选取方案就已经确定了。具体的，当且仅当一条树边被奇数条非树边覆盖的时候选取它，否则不选取。</p>
<p>考虑要求的东西 <span
class="math inline">\(|S|^2\)</span>，我们对于一个集合求子集权值和时，往往会考虑每个元素的贡献，这个也是一个道理，我们考虑一个有序对的贡献。</p>
<p>设非树边有 <span class="math inline">\(m\)</span>
条分三种情况讨论：</p>
<ul>
<li><p>非树边和非树边：方案数为 <span
class="math inline">\(m(m-1)2^{m-2}+m2^{m-1}=m(m+1)2^{m-2}\)</span>。</p></li>
<li><p>非树边和树边：首先树边必须至少被一条非树边覆盖，否则贡献为 <span
class="math inline">\(0\)</span>。<strong>在此基础上，限制是覆盖了树边的非树边集合必须选取奇数个元素</strong>，我们分两种情况讨论：</p>
<ul>
<li>非树边没有覆盖树边：方案数为 <span
class="math inline">\(2^{m-2}\)</span>，所有的子集中，有一半的集合没有选取非树边，在剩下的一半中，又有一半的集合不满足限制。</li>
<li>非树边覆盖了树边：再分两种情况讨论：
<ul>
<li>没有其它非树边覆盖了树边：方案数为 <span
class="math inline">\(2^{m-1}\)</span>，树边和非树边状态相同，只要非树边选了就一定合法。</li>
<li>有其它非树边覆盖了树边：方案数为 <span
class="math inline">\(2^{m-2}\)</span>，所有的子集中，有一半的集合没有选取非树边，在剩下的一半中，又有一半的集合不满足限制。</li>
</ul></li>
</ul></li>
<li><p>树边和树边：首先两条树边都至少被一条非树边覆盖。树边标号为 <span
class="math inline">\(1,2\)</span>，记只覆盖了 <span
class="math inline">\(1,2\)</span> 的非树边集合分别为 <span
class="math inline">\(A,B\)</span>，同时覆盖了 <span
class="math inline">\(1,2\)</span> 的集合为 <span
class="math inline">\(C\)</span>，其余集合为 <span
class="math inline">\(D\)</span>。因为每条树边都被覆盖，所以 <span
class="math inline">\(|A|+|C|&gt;0\)</span> 并且 <span
class="math inline">\(|B|+|C|&gt;0\)</span>。剩下的情况分三种讨论：</p>
<ul>
<li><span class="math inline">\(|A|+|B|=0\)</span>，此时 <span
class="math inline">\(|C|&gt;0\)</span>，<span
class="math inline">\(1,2\)</span>
边的<strong>选取状态一定相同</strong>，对于 <span
class="math inline">\(C\)</span>
集合，选取的元素个数必须为奇数，因此有一半的子集不满足条件，答案 <span
class="math inline">\(2^{m-1}\)</span></li>
<li><span
class="math inline">\(|A|=0,|B|&gt;0\)</span>：有一半的子集，不满足覆盖
<span class="math inline">\(1\)</span>
的非树边个数为奇数。在剩下的一半中，又有一半的子集不满足覆盖 <span
class="math inline">\(2\)</span> 的边数为奇数。</li>
<li><span
class="math inline">\(|A||B|&gt;0\)</span>：有一半的子集，不满足覆盖
<span class="math inline">\(1\)</span>
的非树边个数为奇数。在剩下的一半中，又有一半的子集不满足覆盖 <span
class="math inline">\(2\)</span> 的边数为奇数。</li>
</ul>
<p>对于后两种情况的理解，我们可以视为是解一个 01
异或方程组，求自由元的个数，后两者线性基的大小都为 <span
class="math inline">\(2\)</span>，而 <span
class="math inline">\(|A|+|B|=0\)</span> 的线性基大小为 <span
class="math inline">\(1\)</span>。</p>
<p>用更像人话的方式表达，对于 <span
class="math inline">\(|A||B|&gt;0\)</span> 的情况，从 <span
class="math inline">\(A,B\)</span>
中各拿出一个元素来，其它元素任选，方案数 <span
class="math inline">\(2^{m-2}\)</span>，选定了这些元素之后，剩下的两个元素的选择方案就固定了。<strong>注意具体拿
<span class="math inline">\(A,B\)</span>
中的哪个元素并不影响结果。因为这样生成的方案和合法方案是一一对应的。</strong></p>
<p><span class="math inline">\(|A|=0,|B|&gt;0\)</span>
的情况同理，只不过是从 <span class="math inline">\(B,C\)</span>
中各自拿出一个元素，<strong>先决策 <span
class="math inline">\(C\)</span> 中的元素，再决策 <span
class="math inline">\(B\)</span> 中的元素。</strong></p></li>
</ul>
<p>上面讨论中，第一部分是容易的，第二部分我们只需要求出每条树边由多少条非树边覆盖也可以轻松统计答案，可以用树上差分来完成。</p>
<p>第三部分相对困难，我们发现 <span
class="math inline">\(|A|+|B|=0\)</span>
当且仅当覆盖两条树边的非树边集合相同，于是就是对于若干个集合，计算有多少个两两相同。</p>
<p>集合的判重可以采用异或哈希的方式，给每一条非树边一个随机的 <span
class="math inline">\([0,2^{64})\)</span>
的权值，并将其覆盖的路径上的树边都异或上这个权值，如果两条树边的权值相同，那么我们可以认为两条树边对应的非树边集合相同，树上路径异或还是可以差分实现。</p>
<p>一次判断的错误率为 <span
class="math inline">\(2^{-64}\)</span>，由于我们是统计的集合相同的对数，<strong>因此等价于进行了
<span class="math inline">\(n^2\)</span>
次判断</strong>，但错误率还是在可以接受的范围——约 <span
class="math inline">\(10^{-8}\)</span>。</p>
<h3 id="t2">T2</h3>
<p>参阅 <a
href="https://huanyp.cn/2022/07/12/%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/%E5%81%9A%E9%A2%982/">该文章
20220329 部分</a>。</p>
<p>参阅 <a
href="https://huanyp.cn/2022/08/03/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%90%86%E8%A7%A3/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%92%8C%E5%BA%94%E7%94%A8/">简单数论函数和应用</a>。</p>
<p><span class="math inline">\(p\)</span> 代表一个质数。</p>
<p>不难证明 <span class="math inline">\(f(n)=\gcd(n,n&#39;)\)</span>
是积性函数，<strong>令 <span class="math inline">\(f(1)=1\)</span>，由于
<span class="math inline">\(f(p)=1\)</span>，可以考虑 PN
筛</strong>。</p>
<p>构造 <span
class="math inline">\(g(n)=\boldsymbol{1},h=f/g\)</span>。</p>
<p>考虑 <span class="math inline">\(h\)</span> 在 <span
class="math inline">\(p\)</span> 处的取值，有 <span
class="math inline">\(f(p)=h(1)g(p)+h(p)g(1)\)</span>，代换得 <span
class="math inline">\(h(p)=1\)</span>，由于 <span
class="math inline">\(h\)</span> 为积性函数，所以仅在 PN 处有取值。</p>
<p>推一下公式： <span class="math display">\[
\begin{align}
\sum\limits_{i=1}^nf(i)&amp;=\sum_{i=1}^n\sum_{d|i}h(d)g(\frac{i}{d})\\
&amp;=\sum_{d=1}^nh(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}g(i)\\
&amp;=\sum_{d=1}^nh(d)\lfloor\frac{n}{d}\rfloor\\
&amp;=\sum_{d\in \operatorname{PN}}^nh(d)\lfloor\frac{n}{d}\rfloor\\
\end{align}
\]</span> 如何求 <span class="math inline">\(h\)</span> ？</p>
<p>简单做一下代换： <span class="math display">\[
h=f/\operatorname{\boldsymbol{1}}=f * \mu
\]</span> 考虑 <span class="math inline">\(h(p^c)\)</span> 的取值，有
<span
class="math inline">\(h(p^c)=\sum\limits_{i=0}^cf(p^i)\mu(p^{c-i})=f(p^c)-f(p^{c-1})\)</span>，构造完成。</p>
<h3 id="t3">T3</h3>
<p>参阅 <a
href="https://huanyp.cn/2022/07/19/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%80%BB%E7%BB%93%E6%84%9F%E6%82%9F/%E6%80%BB%E7%BB%93/CF1706%E5%B0%8F%E6%80%BB%E7%BB%93/">该文章
LCA 性质部分</a>。</p>
<p>非常奇妙的贪心题。</p>
<p>用人话说一遍题意：有一棵边带权的树，<span
class="math inline">\(q\)</span> 次强制在线询问，每次给定 <span
class="math inline">\(u,k\)</span>。你需要选择 <span
class="math inline">\(k\)</span> 条路径，使得它们至少有一条过 <span
class="math inline">\(u\)</span>，并且路径经过边集的并的权值最大，一个边集的权值等于所有边的权值和。</p>
<p>选路径是很麻烦的事情，但是可以转化为选点，感觉上选叶子是比较好的。</p>
<p><span class="math inline">\(\text{Lemma 1.}\)</span></p>
<p>对于一个定点 <span
class="math inline">\(u\)</span>，最优方案的路径的端点都在叶子上。</p>
<p><span class="math inline">\(\text{Proof 1.}\)</span></p>
<p>如果某条路径的某个端点不在叶子上，我们让它往<strong>使得这条路径变长</strong>的方向移动，就可以将所有端点移动到叶子上。</p>
<p><span class="math inline">\(\text{Lemma 2.}\)</span></p>
<p>以任何一个点为根，不考虑经过 <span class="math inline">\(u\)</span>
的限制。对于一个叶子的可重集 <span
class="math inline">\(S\)</span>，存在一种选择 <span
class="math inline">\(\lceil\frac{|S|}{2}\rceil\)</span>
条路径的方案，经过 <span class="math inline">\(S\)</span>
虚树上的所有边，并且是所有端点可重集为 <span
class="math inline">\(S\)</span> 的路径选择方案中权值最大的方案。</p>
<p><span class="math inline">\(\text{Proof 2.}\)</span></p>
<p>证明分两步——"最大"和"值"，这里会用到一些开头参考资料中的定理。</p>
<p>最大：不在虚树上的边无法经过。</p>
<p>值：设点集为 <span class="math inline">\(S\)</span>，<span
class="math inline">\(k=1\)</span> 时结论成立，令 <span
class="math inline">\(u=\operatorname{lca}(S)\)</span>。归纳的，设结论在
<span class="math inline">\(k&lt;n\)</span> 时成立，对于 <span
class="math inline">\(k=n\)</span>，分两种情况讨论：</p>
<ul>
<li><p>存在一个点有超过 <span class="math inline">\(k\)</span>
个叶子：记这个子树叶子集合为 <span
class="math inline">\(S&#39;\)</span>，令 <span
class="math inline">\(u&#39;=\operatorname{lca}(S&#39;)\)</span>，选择
<span class="math inline">\(S&#39;\)</span> 若干个 dfs
序不是最大也不是最小的点，记为 <span
class="math inline">\(T\)</span>，使得 <span
class="math inline">\(|S&#39;-T|\)</span> 是 <span
class="math inline">\(2\)</span> 的倍数，且 <span
class="math inline">\(T\)</span> 的大小和 <span
class="math inline">\(u\)</span> 次大的的子树相同或者仅多 <span
class="math inline">\(1\)</span>。读者可以尝试证明这样的 <span
class="math inline">\(T\)</span> 一定存在，此处略去证明。</p>
<p>对于 <span class="math inline">\(S-S&#39;+T\)</span>
中的点来说，它们存在一种覆它们存在一种覆盖对应虚树的方案，所以 <span
class="math inline">\(u&#39;\)</span> 到 <span
class="math inline">\(u\)</span> 的路径一定已经被覆盖了。对于 <span
class="math inline">\(S&#39;-T\)</span>
中的点来说，也存在一种覆盖虚树的方案。由 lca 性质，<span
class="math inline">\(\operatorname{lca}(S&#39;-T)=u&#39;\)</span>，所以两个点集并起来后的虚树也都被覆盖了。</p></li>
<li><p>不存在一个子树有超过 <span class="math inline">\(k\)</span>
个叶子：这种情况让不在同一子树的叶子配对最优，因为每个叶子都到了 <span
class="math inline">\(u\)</span> 点，一定覆盖了虚树。</p></li>
</ul>
<hr />
<p>由 Lemma 2，如果确定了最优方案端点的可重集 <span
class="math inline">\(S\)</span>，那么就可以确定最优方案的权值，所以问题变成了选叶子。</p>
<p>即选一个大小为 <span class="math inline">\(2k\)</span>
的叶子集合，集合权值为其虚树上的边的权值和，要求 <span
class="math inline">\(u\)</span> 在其虚树上，最大化集合权值。</p>
<p><span class="math inline">\(\text{Theorem 3.}\)</span></p>
<p>以 <span class="math inline">\(u\)</span>
为根，<strong>如果最后选取的最优虚树经过 <span
class="math inline">\(u\)</span></strong>，那么每次贪心的选取能使得答案增加量最多的叶子，能取到最优值。</p>
<p><span class="math inline">\(\text{Proof 3.}\)</span></p>
<p>考虑最优的叶子选择顺序 <span class="math inline">\(a_1,a_2,a_3\cdots
a_n\)</span>。</p>
<p>假设最优选取方案前 <span class="math inline">\(k\)</span>
个和贪心的顺序相同，第 <span class="math inline">\(k+1\)</span>
个不同，设应该被贪心选取的点为 <span
class="math inline">\(u\)</span>，往上跳 <span
class="math inline">\(u\)</span> 的父亲直到和 <span
class="math inline">\(\{a_i,i&gt;k\}\)</span>
构成的虚树相交，分情况讨论：</p>
<ul>
<li>如果找不到交点，替换后面的任意一个选择都会更优。考虑选完所有点后移除
<span
class="math inline">\(a_x,x&gt;k\)</span>，带来的的权值减少量。它不会多于在选完
<span class="math inline">\(a_k\)</span> 后选择 <span
class="math inline">\(a_x\)</span> 的权值增加量，所以也不多于选完 <span
class="math inline">\(a_k\)</span> 后选择 <span
class="math inline">\(u\)</span>
的权值增量，因此更优，注意到这种情况下选完所有点后选择 <span
class="math inline">\(u\)</span> 的权值增量等于选完 <span
class="math inline">\(a_k\)</span> 后选择 <span
class="math inline">\(u\)</span> 的权值增量。</li>
<li>如果能找到交点，在这个交点的子树内选一个点移除，同样选 <span
class="math inline">\(u\)</span> 的增量大于移除那个点的减少量。</li>
</ul>
<hr />
<p>在 Theorem 3. 中我们假定了最后一定经过 <span
class="math inline">\(u\)</span>，以便于计算单选一个叶子时的答案，<strong>如果以上贪心策略不经过
<span class="math inline">\(u\)</span>，那么只需要将最后一次的选择替换为
<span class="math inline">\(u\)</span>
不同儿子的最深叶子即可</strong>。</p>
<p>因此我们对于一个点的情况得到了一种贪心做法，这个贪心做法直接实现需要维护每次选择后每个叶子的权值，但是并不好维护这个东西。正难则反，考虑选取每个叶子时它的权值，它一定是一条从自身到根的路径的下半部分。容易发现上端点是<strong>第一个最深叶子不是它的祖先。</strong>记点
<span class="math inline">\(u\)</span> 子树下最深的叶子为 <span
class="math inline">\(down[u]\)</span>，那么一个叶子 <span
class="math inline">\(x\)</span> 的权值是它到第一个 <span
class="math inline">\(down[u]\ne x\)</span> 的 <span
class="math inline">\(u\)</span> 路径的长度，<span
class="math inline">\(down[1]=x\)</span> 是例外。</p>
<p>因此，我们可以<strong>提前计算出选每个叶子时贡献</strong>，这个贡献是最优方案下的贡献，如果一个选取方案不是最优方案，那么这个贡献是不对的，我们利用了方案一定最优这个性质去简化了求权值的过程。</p>
<p>计算答案即取前 <span class="math inline">\(2k\)</span>
大，<strong>如果前 <span class="math inline">\(2k\)</span>
大在根的同一子树，那么取消最后一次的选择换成一个不同子树的。</strong></p>
<p>先考虑不强制在线的做法。</p>
<p>考虑换根的过程，哪些叶子的权值会变化，不妨设从 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span>，边权为 <span
class="math inline">\(val\)</span>，首先 <span
class="math inline">\(down[v]\)</span> 的权值会减少 <span
class="math inline">\(val\)</span>，其次时到 <span
class="math inline">\(u\)</span> 最远的叶子的权值会增加 <span
class="math inline">\(val\)</span>，考虑到 <span
class="math inline">\(u\)</span> 最远的叶子时需要排除 <span
class="math inline">\(v\)</span> 方向的。</p>
<p>然后变化量是常数级别的，线段树即可。</p>
<p>对于强制在线的情况，如果我们能快速得到每个点的线段树事情就好办了，不强制在线的时候我们确实可以求出在每个点处的线段树——可持久化。</p>
<hr />
<p>简单总结一下比较妙的点：</p>
<ul>
<li><p><strong>利用方案是最优方案的性质</strong>，我们将选路径问题转化为了选点问题（Lemma
2）。</p></li>
<li><p>贪心过程中，我们需要维护每个点的贡献，并选取贡献最大的点。选取贡献最大的点后其它点的贡献会变化，变化量不容易维护，于是考虑每个点被选取时的贡献。<strong>将方案最优作为一个已知条件，借此条件我们能够计算出每个点被选取时的贡献。</strong></p></li>
<li><p>将此题强制在线后，我们不太好利用根移动一个位置后贡献变化量为常数的性质，因为总的移动量是
<span
class="math inline">\(O(n^2)\)</span>，但是树的形态不会改变，因此我们在每个位置查询的线段树都不会改变，我们能通过
dfs
求出每个位置查询的线段树的形态，将它可持久化即可在任意时刻查询。</p></li>
</ul>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>0201测试</title>
    <url>/2023/02/01/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0201%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="测试">0201 测试</h2>
<h3 id="t1">T1</h3>
<p>比较奇怪的题目。</p>
<p>手玩出 <span class="math inline">\(n=3\)</span>
的情况，发现是当且仅当看到其他人帽子颜色相同时猜与其相反的颜色。</p>
<p>然后我们发现对于一种能猜对的情况，一定可以构造出一种会猜错的情况——将猜了的那些翻转即可。</p>
<p>然后为啥 <span class="math inline">\(n=3\)</span> 的时候能做到 <span
class="math inline">\(75\%\)</span> 的正确率，是因为
<code>000 111</code> 这两种情况各自对应了 3 种猜错的情况。</p>
<p>于是我们考虑建图，将 <span class="math inline">\(2^n\)</span>
个点每个点向二进制位恰好翻转一位的点连边。</p>
<p>图是一个 Hypercube（超立方体），虽然这暂时并没有什么卵用。</p>
<p><strong>逆向考虑一种策略在图上会是怎样的。</strong>对于猜对的点，至少有一个相邻的点是猜错的
Case，而一个猜错的点最多对应 <span class="math inline">\(n\)</span>
个猜对的点，这告诉我们正确率的上界是 <span
class="math inline">\(\dfrac{n}{n+1}\)</span>。而对于 <span
class="math inline">\(n=3\)</span> 的构造方案显然取到了上界。</p>
<p>发现这道题的 <span
class="math inline">\(n=2^k-1\)</span>，所以我们可能取到上界（Case
总数是分母的倍数）。取到上界，在图上就是存在一个大小为 <span
class="math inline">\(\dfrac{2^n}{n+1}\)</span> 的支配集。</p>
<p>换句话说，我们需要给一张图黑白染色，满足白色点最多，且每个白点必须连一个黑点，这个问题比较麻烦，不存在多项式做法，考虑图的特殊性质——Hypercube，这也许能够帮助我们构造出能够取到上界的情况。</p>
<p>我们需要选 Hypercube 中的一些点，能够取到上界。在 Hypercube
中的黑点在各个维度上变换后都是白点，考虑用异或的性质去构造。令第 <span
class="math inline">\(i\)</span> 个维度的权值为 <span
class="math inline">\(i\)</span>，维度权值异或和（如果该维坐标为 <span
class="math inline">\(1\)</span> 则异或，否则不异或）为 <span
class="math inline">\(0\)</span>
的点为黑点，其它为白点，这样的构造是满足条件的。</p>
<p><em>无向图 <span class="math inline">\(G(V,E)\)</span>
的支配集是一个点集 <span class="math inline">\(S\)</span>，记 <span
class="math inline">\(F(u)\)</span> 表示与 <span
class="math inline">\(u\)</span> 点有连边的点集，<span
class="math inline">\(S\)</span> 满足 <span
class="math inline">\(\forall s_1,s_2(s_1\ne s_2)\in S,F(s_1)\bigcap
F(s_2)=\emptyset\)</span> 且 <span
class="math inline">\(\bigcup\limits_{s\in S} F(s)=V -
S\)</span>。</em></p>
<p>为什么要考虑建图并将点向二进制位差异为 <span
class="math inline">\(1\)</span>
的点连边：这样建图之后确实能够让问题更加形象（也是受到手玩 <span
class="math inline">\(3\)</span>
的启发）。<strong>建图则是因为同一种策略正确的情况和不正确的情况的对应关系。</strong></p>
<p>为什么要考虑用异或的性质构造：<strong>连边的形式是每一维变换</strong>，需要满足变换后不同，又恰好是
<span class="math inline">\(2^k-1\)</span> 个维度，它们的异或和为 <span
class="math inline">\(0\)</span>。<strong>异或运算具有高度的对称性</strong></p>
<h3 id="t2">T2</h3>
<p>中规中矩的组合题。</p>
<p>发现如果横向或竖向有贯穿的一行或者一列，那么这些贯穿的行都是连在一起的，不妨考虑有若干列贯穿，枚举贯穿的区间
<span class="math inline">\([l,r]\)</span>。</p>
<p>乘上贯穿的方案数 <span class="math inline">\((n+1)^{len}\)</span>
后剩下的答案是两个类似问题乘起来，问题还是各个方向箭头把矩阵覆盖满，只不过只有上下左三个方向，<strong>且已知左边的某一个箭头把矩阵分成了两半</strong>。不妨枚举那个把矩阵分成两边的箭头的位置，剩下的只有两个方向了，是简单的组合问题。<strong>注意其中有分开的两半有一半左边不能贯穿，如果可以贯穿那么所有左边贯穿的箭头会被算重。</strong></p>
<p>考虑没有贯穿的情况，记左边箭头最长为 <span
class="math inline">\(s_1\)</span>，右边最长为 <span
class="math inline">\(s_2\)</span>，上边下边 <span
class="math inline">\(s_3,s_4\)</span>。</p>
<p>如果纵向贯穿，则有 <span
class="math inline">\(s_1+s_2&lt;m\)</span>，横向贯穿则是 <span
class="math inline">\(s_3+s_4&lt;n\)</span>。这两种情况的答案单独计算。</p>
<p><strong>下面的讨论请记住 <span class="math inline">\(s_1+s_2\ge
m,s_3+s_4\ge n\)</span>。</strong></p>
<p>考虑 <span class="math inline">\(s_1+s_2&gt;m\)</span>
的情况，且，则一定能找到一个分界点，上下分别取到 <span
class="math inline">\(s_1\)</span> 和 <span
class="math inline">\(s_2\)</span>，此时必有 <span
class="math inline">\(s_3+s_4=n\)</span>。大概是这个图（不能同时满足
<span class="math inline">\(s_1+s_2&gt;m\)</span> 且 <span
class="math inline">\(s_3+s_4&gt;n\)</span>）：</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302012041959.png"
alt="image-20230201204107871" />
<figcaption aria-hidden="true">image-20230201204107871</figcaption>
</figure>
<p>这种情况可以枚举某一条红线头的位置，<strong>注意靠上那条红线可以从左边来也可以从右边来，所以要乘
2</strong>。暴力枚举另一条红线交到的位置。剩下的四个问题独立，都是两个方向填矩阵的情况，基本组合问题。复杂度
<span class="math inline">\(O(n^3)\)</span></p>
<p>发现确定第一条红线的行之后移动列时，答案是一个固定值乘上一个前缀和的形式，可以做到均摊
<span
class="math inline">\(O(1)\)</span>。<strong>对于绿线也需要将矩阵转置一下计算。</strong></p>
<p>最后剩下一种情况 <span class="math inline">\(s_1+s_2=m\)</span> 且
<span class="math inline">\(s_3+s_4=n\)</span>。</p>
<p>只能是这样的：</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302012049795.png"
alt="image-20230201204943731" />
<figcaption aria-hidden="true">image-20230201204943731</figcaption>
</figure>
<p>枚举左上角的位置计算即可，注意要算两遍，因为左上角位置既可以是横着过来的也可以是竖着过来的。</p>
<h3 id="t3">T3</h3>
<p>有趣的数据结构题</p>
<h4 id="一种暴力">一种暴力</h4>
<p>维护每个数作为其中一个端点时的答案。</p>
<p>一个修改会对两个区间的答案造成影响。考虑如果维护这个影响。</p>
<p>赛时一直以为这是不可做的，实际上问题等价于维护 <span
class="math inline">\(n\)</span>
个编号连续的集合，操作是对于一段编号连续的区间都加入一个数，查询是查询全局
<strong>集合权值 + 集合中最大值</strong> 的最大值。</p>
<p>用线段树维护一段区间的集合，线段树上一个节点做集合操作时，这个节点代表的所有集合都具有同样的元素，因此直接取集合权值的最大值加上元素最大值即可。</p>
<p><strong>解决问题的核心是将一个点的贡献/操作拆到了多个位置/多个部分，以便于对于不同的位置各自处理，这是一个非常重要的思想。</strong></p>
<p>在本题中，将同一个点的贡献拆到了线段树上的多个部分，而一个线段树上的节点可以包括多个点，也便于对它们同时操作。</p>
<p><strong>倍增并查集也是这个思路。</strong>倍增并查集拆分的是操作本身，将一个<strong>顺序无关</strong>操作分多步完成，多个操作的同一步可以一起做。</p>
<h4 id="正解1">正解1</h4>
<p>很神仙的一个想法是考虑按 <span class="math inline">\(k\)</span>
将序列分块，然后块内是好做的，直接线段树维护。块间最多跨一个块。所以要统计块间的答案。</p>
<p>然后需要选 <span class="math inline">\(y\le x+k\)</span> 使得 <span
class="math inline">\(a_x+a_y\)</span> 最大，然后令 <span
class="math inline">\(b_i=a_{i+k}\)</span>，变成 <span
class="math inline">\(b_y+a_x\)</span> 最大且 <span
class="math inline">\(y\le x\)</span>。</p>
<p>又变回了块内问题。<strong>这个问题如果在序列上是不好做的，因为额外有
<span class="math inline">\(y\ge x-k\)</span>
的限制。</strong>但是分块统计的方式去掉了这个限制。</p>
<p>开一棵线段树来做这个问题，每个节点维护在这个这个节点 <span
class="math inline">\(a_i,b_i\)</span> 各自的最大值和答案，修改 <span
class="math inline">\(a_i,b_i\)</span>
时在各自的位置修改并上传答案即可。</p>
<p><strong>一个问题如果能够简单的分治解决，套上线段树并记录分治过程之后就可以支持修改操作。</strong></p>
<h4 id="正解2">正解2</h4>
<p><strong>考虑取到答案的点的性质</strong>，由于答案由两个点构成，我们枚举了任意一个点都能得到答案，所以只需要考虑较大的那个点的性质。它满足它是区间
<span class="math inline">\([i-k,i+k]\)</span>
中的最大值，称满足这样性质的点是好点。</p>
<p>我们只考虑好点的答案，于是做单点修改时只会修改常数个好点的答案，也只会有常数个好点变成不好的点或者不好的点变成好点。</p>
<p>好点的答案容易用线段树查询，好点答案最大值容易用 set 维护，时间复杂度
<span class="math inline">\(O((n+q)\log n)\)</span>。</p>
<p>线段树需要写 <code>zkw</code> 以卡常。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>部分题解合集</title>
    <url>/2023/01/31/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%984/</url>
    <content><![CDATA[<h2 id="题解合集1">题解合集1</h2>
<p>懒得分开写咕咕咕</p>
<h3 id="arc153d">ARC153D</h3>
<p>考虑 A 比较小的时候应该怎么做，记 <span
class="math inline">\(dp[i][a]\)</span> 表示考虑低 <span
class="math inline">\(i\)</span> 位，填的数字是 <span
class="math inline">\(a\)</span>，低 <span
class="math inline">\(i\)</span> 位的贡献。</p>
<p>转移枚举下一位填什么，计算答案的方式是统计当前位上每个数字各有多少个。因为有进位所以这还比较麻烦</p>
<p>如果从小到大枚举 <span
class="math inline">\(a\)</span>，那么进位的计算是容易的，维护一个 <span
class="math inline">\(cnt\)</span> 数组即可，按低 <span
class="math inline">\(i\)</span> 位排序后双指针即可。</p>
<p>我们可以以 <span class="math inline">\(O(A)\)</span>
的复杂度计算答案。</p>
<p>事实上我们发现我们并不需要记录所有的 <span
class="math inline">\(a\)</span>，对于进位状况相同的 <span
class="math inline">\(a\)</span>，我们只需要它的最小值，而进位状况是
<span class="math inline">\(O(2\times10^5)\)</span> 级别的，改变状态，记
<span class="math inline">\(dp[i][j]\)</span> 表示考虑低 <span
class="math inline">\(i\)</span> 位，一共有 <span
class="math inline">\(j\)</span> 个数进位，只考虑低 <span
class="math inline">\(i\)</span> 位时答案的最小值。</p>
<p>显然只会是低 <span class="math inline">\(i\)</span> 位最小的 <span
class="math inline">\(j\)</span> 个数进位，答案计算式类似的。</p>
<p><strong>这道题的优化本质上是分析了转移所需信息，利用问题的最优子结构性质，构造出了更加精简的状态。</strong></p>
<h3 id="arc154d">ARC154D</h3>
<p><span class="math inline">\(1\)</span> 是比较特殊的数，如果找到了
<span class="math inline">\(1\)</span>，设它的位置为 <span
class="math inline">\(v\)</span>，我们就可以在 <span
class="math inline">\(O(n\log n)\)</span>
的时间内对其它数排好序，具体的，考虑构造一个下标序列 <span
class="math inline">\(a\)</span>，使得 <span
class="math inline">\(p_{a_i}=i\)</span>，以插入的方式来构造。二分下一个元素
<span class="math inline">\(x\)</span> 插入的位置 <span
class="math inline">\(i\)</span>，询问 <span
class="math inline">\((v,a_i,x)\)</span>，如果答案为 Yes，那么 <span
class="math inline">\(x\)</span> 应该插入在 <span
class="math inline">\(a_i\)</span> 左边，否则为右边。</p>
<p>怎么找 <span class="math inline">\(1\)</span>，对于 <span
class="math inline">\(1\)</span>，询问 自身+自身&gt;其它数
都是不成立的，有一个比较容易的 <span class="math inline">\(n^2\)</span>
方式。考虑到对于 <span class="math inline">\([1,n]\)</span>
中的任意一个数，有一半的数在询问 自身+自身&gt;某个其它的数 的结果都是
Yes，因此可以排除一半的数，且留下来的数仍然是 <span
class="math inline">\([k,n]\)</span>
的形式，注意那个其它的数需要拿出来。做 <span class="math inline">\(\log
n\)</span> 次拿出 <span class="math inline">\(\log n\)</span> 个数，以
<span class="math inline">\(\log^2n\)</span>
的复杂度检查剩下的数即可，总复杂度 <span class="math inline">\(O(n\log n
+ n +\log^2 n)\)</span></p>
<h3 id="p5156">P5156</h3>
<p>考虑一个逆序对，它会消失当且仅当某个端点被选择，所以排好序的必要条件是对于所有的逆序对，至少需要选择两个端点中的一个，这个条件也是充分的，因为只要存在逆序对就会被交换。</p>
<p>一种思路是设 <span class="math inline">\(dp[i][j]\)</span> 表示考虑前
<span class="math inline">\(i\)</span> 个元素，没有被选择的最大的元素是
<span class="math inline">\(j\)</span>，且前 <span
class="math inline">\(i\)</span>
个元素均合法的最小子集大小。考虑转移，一个元素 <span
class="math inline">\(a_i\)</span> 选当然没有问题，不选当且仅当 <span
class="math inline">\(a_i&gt;j\)</span>，否则存在一个两端都没被选的逆序对。</p>
<p>然后把转移图画出来发现不选的元素就是个
LIS，实际上想的时候还想了线段树去优化原式的转移emmm。</p>
<p><strong>从子集的补集逆向考虑，容易发现它们之间不存在逆序对，因此子集的补集是单调的。</strong></p>
<p>因此问题变成了求第字典序 <span class="math inline">\(K\)</span> 大的
LIS，很简单了。</p>
<h3 id="p4187">P4187</h3>
<p>考虑一种结果能被构造的充要条件——存在一段长度为 <span
class="math inline">\(k\)</span> 的颜色相同子段。</p>
<p>必要性显然，充分性考虑用构造法证明，具体的，记 <span
class="math inline">\(a_i\)</span> 表示 <span
class="math inline">\(i\)</span> 的颜色，颜色相同的子段为 <span
class="math inline">\([l,l+k)\)</span>。记 <span
class="math inline">\(P(c,l)\)</span> 表示用 <span
class="math inline">\(c\)</span> 颜色涂区间 <span
class="math inline">\([l,l+k)\)</span>。依次进行如下操作： <span
class="math inline">\(P(a_1,1),P(a_2,2)\cdots
P(l-1,a_{l-1}),P(n-k+1,a_n),P(n-k,a_{n-1})\cdots
P(l+1,a_{l+k}),P(l,a_{l})\)</span>。</p>
<p>枚举第一个长度为 <span class="math inline">\(k\)</span>
的区间的左端点 <span class="math inline">\(i\)</span>，记 <span
class="math inline">\([1,i]\)</span> <strong>不出现连续长度为 <span
class="math inline">\(k\)</span>
的子串，且最后一个位置不能和下一个位置相同的涂色方案数</strong>为 <span
class="math inline">\(g_i\)</span></p>
<p>则总方案数为 <span
class="math inline">\(\sum\limits_{i=k}^nm^{n-k+1}g_{i-1}\)</span></p>
<p>考虑 <span class="math inline">\(g_i\)</span>
的转移，不妨枚举最后一个位置的连续长度，得到 <span
class="math inline">\(g_i=(m-1)\sum\limits_{j=\max(0,i-k+1)}g_j\)</span>。</p>
<p>简单前缀和。</p>
<p><strong>为什么是 <span
class="math inline">\(m-1\)</span>：钦定了最后一个位置不能和下一个位置相同。</strong></p>
<p>另一种思考方式是考虑统计不合法的方案总数，答案就是 <span
class="math inline">\(m^n-f_i\)</span>。其中 <span
class="math inline">\(f_i\)</span> 表示长度为 <span
class="math inline">\(i\)</span> 的段，不出现连续长度为 <span
class="math inline">\(k\)</span> 的子串的方案数，对于 <span
class="math inline">\(i&lt;k,f_i=m^i\)</span>，否则转移和 <span
class="math inline">\(g\)</span> 相同。</p>
<h3 id="p7152">P7152</h3>
<p>考虑对生成后的串 DP，设 <span class="math inline">\(dp[i][c]\)</span>
表示考虑到生成后的串的前 <span class="math inline">\(i\)</span> 个，在
<span class="math inline">\(i\)</span> 处和 <span
class="math inline">\(i+1\)</span> 处被分开了，<strong><span
class="math inline">\(i\)</span> 所属的段开头(原串结尾)为 <span
class="math inline">\(c\)</span> 的方案总数。</strong></p>
<p><strong>以下的串无特别说明均指被生成的串，也就是输入的那个串</strong>。</p>
<p><span class="math inline">\(dp[i]\)</span> 的转移枚举起始位置 <span
class="math inline">\(j\)</span> 以及对应的 <span
class="math inline">\(j\)</span> 所属的段的开头字符 <span
class="math inline">\(c_1\)</span>，以及 <span
class="math inline">\(j+1,i\)</span> 位置的取值 <span
class="math inline">\(c_2,c_3\)</span>，转移的要求是 <span
class="math inline">\(c_1=c_3\)</span>，<span
class="math inline">\(dp[i]\)</span> 的第二维下标是 <span
class="math inline">\(c_2\)</span>，转移的额外系数也是容易计算的，不妨设它为
<span class="math inline">\(w(j+1,i,c_2,c_3)\)</span>，一次转移就是
<span class="math inline">\(dp[j][c_1]\times
w(j+1,i,c_2,c_3)\)</span>，由于 <span
class="math inline">\(c_1,c_2,c_3\)</span>
的取值都是常数种，我们干脆将它们视作一个参数 <span
class="math inline">\(c\)</span>，得到转移结果为 <span
class="math inline">\(b(j,i,c)\)</span>。</p>
<p>因为 <span class="math inline">\(\sum\limits_j b(j,i,c)\)</span> 对
<span class="math inline">\(i\)</span>
有比较好的转移性质，所以考虑维护所有 <span
class="math inline">\(c\)</span> 的 <span
class="math inline">\(B_c(i)=\sum\limits_{j} b(j,i,c)\)</span></p>
<p>不难发现 <span class="math inline">\(b(j,i+1,c)=\sum\limits_{c_0}
k_{c_0}b(j,i,c_0)\)</span>，将这个转移带进 <span
class="math inline">\(B_c(i)\)</span> 里去，得到 <span
class="math inline">\(B_c(i+1)=\sum\limits_{c_0}k_{c_0}B_{c_0}(i)\)</span>。</p>
<p>能够计算 <span class="math inline">\(B_c(i)\)</span> 了，那么 <span
class="math inline">\(dp[i]\)</span> 的计算也就容易了，注意对于 <span
class="math inline">\(B_c(i+1)\)</span> 需要补上 <span
class="math inline">\(dp[i]\)</span> 的贡献。</p>
<p>另一种思考方式是套路的考虑将<strong>下一个字符并入上一段或者新开一段</strong>，复杂度一样的，其实本质也是一样的。</p>
<h3 id="p6142">P6142</h3>
<p>最小值最大二分，然后一棵子树，传上去的长度自然越大越好，设 <span
class="math inline">\(dp_u\)</span> 表示 <span
class="math inline">\(u\)</span> 子树满足 <span
class="math inline">\(k\)</span>
限制的前提下传上去的最大的数是多少，然后问题变成了对于若干个数，需要选一个或两个数配对，满足和不小于
<span class="math inline">\(k\)</span>，且剩下的最大（不剩下就是 <span
class="math inline">\(0\)</span>）。</p>
<p>讨论两种情况</p>
<ul>
<li>不剩下</li>
<li>剩下一个</li>
</ul>
<p>显然剩下的这个数的大小有单调性可以二分，变成不剩下的情况，现在考虑怎么
check
不剩下的情况，偶数个直接最大最小，次大次小配对最优，奇数个必须先拿一个最小的不小于
<span class="math inline">\(k\)</span> 的，再如上配对。</p>
<p>复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h3 id="p8194">P8194</h3>
<p>发现没有 <span class="math inline">\(5\)</span> 的情况是好做的，设
<span class="math inline">\(dp[i]\)</span> 表示考虑前 <span
class="math inline">\(i\)</span> 个数字的答案，当某两个可以一起按时
<span class="math inline">\(dp[i]=dp[i-1]+dp[i-2]\)</span>，否则 <span
class="math inline">\(dp[i]=dp[i-1]\)</span>。</p>
<p>对于可以一起按的情况，分按和不按两种情况，不按的方案数是 <span
class="math inline">\(dp[i-1]\)</span>，按的方案数是 <span
class="math inline">\(dp[i-2]*2\)</span>，但是由于如果是顺序的，按的情况和不按的情况恰好有
<span class="math inline">\(dp[i-2]\)</span>
中是冲突的（按也能取到这种方案，不按也可以）。减掉即可。</p>
<p>考虑存在同时按四个的情况，这是一件很麻烦的事情，要容斥掉按四个和不按的冲突非常的困难。</p>
<p>不会了，换个角度思考。</p>
<p>考虑判定问题，即给定 <span class="math inline">\(T\)</span>
判断是否能生成 <span class="math inline">\(S\)</span>，记 <span
class="math inline">\(ok[i]\)</span> 表示只考虑前 <span
class="math inline">\(i\)</span> 位能否生成，转移可以从 <span
class="math inline">\(i-1,i-2,i-4\)</span> 转移过来。</p>
<p><strong>考虑对判定过程 dp</strong>，记录前 <span
class="math inline">\(3\)</span>
个位置的具体值，枚举下一个位置的具体值尝试转移，发现还需要记录前 <span
class="math inline">\(4\)</span> 个位置判定 dp 的值，<strong>发现这样的
dp 恰好是不重不漏的</strong>，因为状态中三个具体值不同的显然本质不同，而
dp
值不同的显然也本质不同，所以<strong>同一阶段不同状态不重不漏</strong>，因此整个
dp 不重不漏。</p>
<p>总复杂度是 <span
class="math inline">\(O(n\times9^4\times2^4)\)</span>，跑不动，考虑常数优化。</p>
<p>记录三个位置的具体值很浪费，实际上大部分组合都用不到。</p>
<p>如果四个位置 dp 值全是 <span class="math inline">\(0\)</span>
这个状态直接扔掉。如果当最靠前的一个位置的 dp 值为 <span
class="math inline">\(0\)</span>，那么最后一个数是没有用的，可以压进一个状态里。如果记录的最后三个数不是接下来四个数排列，那么可以认为最后一个位置的
dp 值为 <span class="math inline">\(0\)</span>，所以按最后一个位置 dp
值分类，我们的状态数变为了 <span class="math inline">\(8\times
24+8\times 99\)</span>。同理对倒数第二个位置的 dp
值再分类讨论可以进一步压缩状态，状态数应该是可以压缩进 <span
class="math inline">\(200\)</span> 以内的。</p>
<h4 id="tricks">Tricks</h4>
<ul>
<li>对于部分序列计数问题，<strong>可以考虑对判定过程动态规划</strong>，由于转移所需的序列值不同或者判定的动态规划值不同的状态时本质不同的，所以这样的动态规划是不重不漏的。</li>
<li>上述动态规划的优化可以通过减小状态空间完成，主要方式是分析判定问题本身的性质以排除不可能对答案产生贡献的状态。</li>
</ul>
<h3 id="p4649">P4649</h3>
<p>首先有一个很重要的观察，覆盖奇数条树边的非树边一定要选。</p>
<p>对于覆盖偶数条树边的，如果任意两条非树边覆盖的边集有交，那么一定可以构造出一种合法的路径（参考欧拉子图计数问题）。</p>
<p>因此问题变成选树上若干条无交的路径使得权值和最大。考虑动态规划。</p>
<p>设 <span class="math inline">\(dp[u]\)</span> 表示只考虑 <span
class="math inline">\(u\)</span> 的子树里的路径，<span
class="math inline">\(u\)</span>
子树内能选出的权值最大值，发现转移是不好做的，于是多记一维 <span
class="math inline">\(dp[u][k]\)</span> 表示考虑 <span
class="math inline">\(u\)</span> 子树，<span
class="math inline">\(u\)</span> 连出了编号为 <span
class="math inline">\(k\)</span> 的路径的权值最大值，<strong>先不计算
<span class="math inline">\(k\)</span> 的贡献</strong>，并要求 <span
class="math inline">\(k\)</span> 的一个端点一定在 <span
class="math inline">\(u\)</span> 子树内。</p>
<p>转移的时候就是儿子间两两配对，如果知道了儿子配对的方式，那么我们只需要贪心的让每一个配对取最大值转移，当然儿子也可以不配对或者和父亲配对，我们将不配归类到和父亲配对。</p>
<p>发现儿子配对的方式可以直接枚举，计算答案时需要一个 <span
class="math inline">\(mp[v_1][v_2]\)</span> 表示 <span
class="math inline">\(v_1,v_2\)</span> 儿子配对的最大值，可以枚举 lca
挂在这个点上的每条边统计。</p>
<p>实际上 dfs 枚举配对方式不是必要的，可以状压 dp，更好写。</p>
<h4 id="教训">教训</h4>
<ul>
<li>vector 用 lower_bound 删点的时候<strong>要先排好序</strong>。</li>
<li>dfs 枚举配对的循环里<strong>不要忘记判掉已经配好对的</strong>。</li>
</ul>
<h3 id="p8290">P8290</h3>
<p>极差问题考虑枚举一下最大值位置，然后发现答案是关于最大值 <span
class="math inline">\(x\)</span> 的一个 <span
class="math inline">\(n\)</span> 次多项式。但是需要去重，很麻烦。</p>
<p>对于这种需要满足至少一个取到边界的问题，或者说与最值有关的计数问题，可以考虑容斥，<strong>用不限制取到闭区间的方案数，减去一定不满足的方案数——取到开区间的方案数</strong>，得到一定取到闭区间的方案数。</p>
<p>或者说正难则反，考虑总方案减去不合法方案数。</p>
<h3 id="p4233">P4233</h3>
<p>竞赛图有一个重要结论：缩点后一定是一条链状的
DAG，每个点向后面所有点有连边。</p>
<p>考虑到求总的哈密顿回路是容易的：枚举一条回路，其它边任意定向。我们考虑求出存在哈密顿回路的竞赛图个数。</p>
<h3 id="cf798d">CF798D</h3>
<p>先考虑了每个数和中位数、平均数的大小关系来决定是否选择。然后想能不能构造
<span class="math inline">\(c=a+b\)</span> 在 <span
class="math inline">\(c\)</span>
上先贪心选择然后再调整让不满足条件的那个数组满足条件。都失败了。</p>
<p><strong>两个数组都是无序的不好考虑</strong>，将 <span
class="math inline">\(a\)</span> 降序排列。考虑钦定 <span
class="math inline">\(b\)</span> 满足条件并尽可能使 <span
class="math inline">\(a\)</span> 满足条件。如果 <span
class="math inline">\(n\)</span> 为奇数，我们可以选择 <span
class="math inline">\(a_1\)</span>，然后将后面的两两分组。每一组选择
<span class="math inline">\(b\)</span> 较大的那一个，这样 <span
class="math inline">\(b\)</span> 一定满足条件。然后又因为我们选了 <span
class="math inline">\(a_1\)</span>，<span
class="math inline">\(a_1\)</span> 和第一组配对，第一组的 <span
class="math inline">\(a\)</span> 和第二组的 <span
class="math inline">\(a\)</span> 配对，然后 <span
class="math inline">\(a\)</span> 也满足条件。</p>
<p>偶数同理。</p>
<p>构造完了，这种贪心<strong>按对决策</strong>的思路很有学习价值，题目中的选一半也提示了这种方式。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1787</title>
    <url>/2023/01/31/OI/%E6%AF%94%E8%B5%9B/CF1787/</url>
    <content><![CDATA[<h2 id="a">A</h2>
<p>简单，不过我蠢</p>
<p>偶数构造显然。</p>
<p>奇数不存在合法方案，不用枚举。</p>
<h2 id="b">B</h2>
<p>简单贪心。</p>
<h2 id="c">C</h2>
<p>每个 <span class="math inline">\(x_i\)</span>
的取值最多有两个，因为如果不取到边界，那么向左或者向右调整一定会变得更优。</p>
<p>直接做一遍动态规划即可。</p>
<h2 id="d">D</h2>
<p>简单图论</p>
<h2 id="e">E</h2>
<p>考虑能构造的一个必要条件，异或值本身需要满足且最高位的个数足够。</p>
<p>注意到对于连续的一段 <span
class="math inline">\([1,n]\)</span>，高一位的 <span
class="math inline">\(1\)</span> 的个数不会多于低一位的 <span
class="math inline">\(1\)</span> 的个数，证明考虑最高位 (<span
class="math inline">\(n\)</span>) 和次高位 (<span
class="math inline">\(n-1\)</span>)，次高位在最高位出现之前就取到了
<span class="math inline">\(2^{n-1}\)</span>，最高位为 <span
class="math inline">\(1\)</span> 时，最多有 <span
class="math inline">\(2^{n-1}\)</span> 个数取不到次高位。</p>
<p>对于最高位个数足够的情况，取拥有最高位的 <span
class="math inline">\(k\)</span> 个数，以及 <span
class="math inline">\(a_i\oplus
x\)</span>，由于异或的性质，被取到的剩下的数一定互不相同，且这样构造取到了理论最大值，将剩下的数随便塞进一组里，由于异或值本身需要满足的必要条件，一定不影响异或结果。</p>
<p>注意特判 <span class="math inline">\(x\oplus0\)</span> 的情况。</p>
<h2 id="f">F</h2>
<p>定义排列乘法为 <span class="math inline">\(a=b\cdot
c,a_i=b_{c_i}\)</span>。</p>
<p>给定一个排列 <span class="math inline">\(p\)</span>
，问是否存在一个排列 <span class="math inline">\(q\)</span> 满足 <span
class="math inline">\(q^{2^k}=p\)</span>，如果存在，构造一种循环个数最小的
<span class="math inline">\(q\)</span>，否则报告无解。</p>
<p>对于 <span class="math inline">\(q\)</span>
的每个循环我们考虑乘方之后会怎样。</p>
<p>将一个循环 <span class="math inline">\(w\)</span> 写出，例如 <span
class="math inline">\(1,2,3,4\)</span>，自乘一遍之后变成 <span
class="math inline">\(1,3;2,4\)</span>，再自乘一遍（乘最开始的排列）变为
<span class="math inline">\(1,4,3,2\)</span>。如果以图的形式表现，<span
class="math inline">\(w^p\)</span> 表现为将第 <span
class="math inline">\(i\)</span> 个点的边连到第 <span
class="math inline">\(i+p\)</span> 个点，注意到如果 <span
class="math inline">\(\gcd(p,len)\ne
1\)</span>，那么循环个数就会减小。</p>
<p>考虑变换后的排列 <span
class="math inline">\(p\)</span>，求出其所有循环，对于奇数长度的循环，可以将它们以
<span class="math inline">\(2^i\)</span>
的形式合并起来，这样得到的循环个数是最小的，注意 <span
class="math inline">\(i&gt;k\)</span> 的情况。</p>
<p>对于偶数长度的循环，如果个数不足 <span
class="math inline">\(2^k\)</span>，那么它们就无法被拼接起来，否则也只能以
<span class="math inline">\(2^k\)</span> 为单位拼接起来。</p>
<p>考虑将若干个长度相同的循环还原为 <span
class="math inline">\(q\)</span> 中的循环，我们知道的是，对于 <span
class="math inline">\(q\)</span> 中的原循环，将边连向 <span
class="math inline">\(2^k\bmod len\)</span>
之后的点得到了若干个长度相同的循环，那么对于这些长度相同的循环，我们在每个循环中先取一个，然后接下来才需要取同一循环的元素。</p>
<p>设 <span class="math inline">\(p\)</span> 中一个循环的长度为 <span
class="math inline">\(m\)</span>，总共 <span
class="math inline">\(n\)</span> 个循环，一种简单的构造方式令 <span
class="math inline">\(p\)</span> 中第 <span
class="math inline">\(i\)</span> 个循环的第 <span
class="math inline">\(j\)</span> 个元素，占用第 <span
class="math inline">\(((\frac{jk}{n})\bmod m)*n+i\)</span>
个位置，那么显然在原来 <span class="math inline">\(q\)</span>
的循环中，<span class="math inline">\(p\)</span>
中每一个循环的元素到下一个元素的距离为 <span
class="math inline">\(k\)</span>。</p>
<h3 id="g">G</h3>
<p>考虑暴力怎么做，拿一个可重集维护所有颜色的答案，修改一个点时，暴力修改和这个点连接的所有颜色的，将它们从集合中删除或者加入。</p>
<p>这样做一次操作复杂度和度数有关，无法通过本题。</p>
<p>将问题进一步抽象后发现它并不是一个好做的问题——和 CSP-S2022T3
有点类似，这种一对多的指定整体修改问题并不好做。考虑利用问题抽象前的性质——树上问题。</p>
<p>修改一个点时受到影响的颜色可以分为路径 lca
是它和不是它，后者只有一种，可以暴力修改，对于前者可以对每一个点用
priority_queue 维护路径 lca 为它的最大权值，这样就能做到 <span
class="math inline">\(O(n\log n)\)</span>。</p>
<p>细节有点多：</p>
<ul>
<li>从树中提出链的时候，判断度数的条件应该是
<code>(fa==0)+cnt&gt;2</code> 则不为链，<code>(fa==0)+cnt==1</code>
则为端点</li>
<li>不合法的颜色不应该被统计进它 lca 的 priority_queue 中。</li>
<li>如果一个 lca 不合法，那么它的权值不在总的 priority_queue
中，对它某一个儿子修改时自然不应该修改总的优先队列。</li>
</ul>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/01/31/OI/%E6%AF%94%E8%B5%9B/CF1792/</url>
    <content><![CDATA[<h2 id="a">A</h2>
<p>简单</p>
<h2 id="b">B</h2>
<p>简单</p>
<h2 id="c">C</h2>
<p>每次选一对，最大的放后面，最小的放前面，问排序好一个排列的最小次数。</p>
<p>考虑没有动过的那些数，它们一定是一个上升子序列，且满足 <span
class="math inline">\(a_{k_i}=a_{k_{i-1}}+1\)</span>。</p>
<p>对于其它动过的那 <span class="math inline">\(c\)</span> 个数，容易在
<span class="math inline">\(\lceil\frac{c}{2}\rceil\)</span>
次之内将它们排好序</p>
<p><strong>操作不可逆的最小次数排序问题，可以考虑没有操作过的那些数</strong></p>
<h2 id="d">D</h2>
<p>定义两个排列的乘法（复合）为 <span class="math inline">\(c=a\cdot
b\)</span>，<span class="math inline">\(c_i=b_{a_i}\)</span>，给定 <span
class="math inline">\(n\)</span> 个长度为 <span
class="math inline">\(m\)</span> 的排列，对于每个排列 <span
class="math inline">\(p_i\)</span> 需要找出一个排列 <span
class="math inline">\(p_j\)</span>，使得 <span class="math inline">\(p_i
\cdot p_j\)</span> 的美丽度最大，定义一个排列 <span
class="math inline">\(q\)</span> 的美丽度为一个最长的前缀的长度，满足
<span class="math inline">\(q_i=i\)</span>。</p>
<p>考虑一个已知排列 <span class="math inline">\(a\)</span>
复合上另一个排列 <span class="math inline">\(b\)</span> 后，美丽度为
<span class="math inline">\(k\)</span> 时对 <span
class="math inline">\(b\)</span> 的要求，容易发现要求为 <span
class="math inline">\(\forall i\in[1,k],b_{a_i}=i\)</span>。就是对于
<span class="math inline">\(b\)</span>
的一些位置，要求固定为某些数。</p>
<p>这并不是一个很好 check 的条件，注意到要求的数为 <span
class="math inline">\([1,k]\)</span>，所有考虑排列的逆排列，要求变成了对于前
<span class="math inline">\(i\)</span> 个位置，满足 <span
class="math inline">\(b&#39;_i=a_i\)</span>，这是一个容易检查的条件。</p>
<p>参考 <a href="">排列变换总结</a> 中的定义。</p>
<h2 id="e">E</h2>
<p>题意转化为对每个 <span class="math inline">\(m=m_1\cdot m_2\)</span>
的约数 <span class="math inline">\(d\)</span>，求出其最大的不超过 <span
class="math inline">\(n\)</span> 的约数。</p>
<p>约数的约数，级别还是挺大的，对于 <span
class="math inline">\(10^{18}\)</span> 的数，可能达到了 <span
class="math inline">\(10^8\)</span> 级别，不能暴力枚举，<span
class="math inline">\(10^{18}\)</span> 内的最大约数个数约为 <span
class="math inline">\(10^5\)</span> 个。</p>
<p>考虑一个约数的最大的不超过 <span class="math inline">\(n\)</span>
的约数，它显然也是 <span class="math inline">\(m\)</span>
的一个约数，考虑以一种类似动态规划的方式递推，枚举一个约数的所有质因数，从它们各自的最大约数转移过来，显然这是对的。</p>
<h2 id="f">F</h2>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>排列变换</title>
    <url>/2023/01/30/OI/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%88%97%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="常见排列变换">常见排列变换</h2>
<h3 id="循环">循环</h3>
<p>我习惯将循环的顺序定义为正向，即循环 <span
class="math inline">\(1,2,3,4\)</span> 对应的排列为 <span
class="math inline">\(2,3,4,1\)</span>。更加数学化的表达，<span
class="math inline">\(p\)</span> 的循环 <span
class="math inline">\(a_1,a_2\cdots a_k\)</span> 表示 <span
class="math inline">\(p_{a_1}=a_2,p_{a_2}=a_3\cdots
p_{a_k}=a_1\)</span>。</p>
<h3 id="求逆">求逆</h3>
<p>定义一个排列 <span class="math inline">\(p\)</span> 的逆排列 <span
class="math inline">\(q\)</span> 满足 <span
class="math inline">\(p_{q_i}=i\)</span>，通俗的讲，<span
class="math inline">\(q_i\)</span> 表示 <span
class="math inline">\(p\)</span> 中元素 <span
class="math inline">\(i\)</span> 的位置，<span
class="math inline">\(q\)</span> 一般记作 <span
class="math inline">\(p&#39;\)</span> 或 <span
class="math inline">\(p^{-1}\)</span>。</p>
<p>有性质 <span
class="math inline">\(p&#39;&#39;=p\)</span>。证明是简单的，<span
class="math inline">\(p_{p&#39;_i}=i,p&#39;_{p&#39;&#39;_i}=i\)</span>，所以
<span
class="math inline">\(p_{p&#39;_{p&#39;&#39;_i}}=p&#39;&#39;_i\)</span>，又有
<span class="math inline">\(p&#39;_{p&#39;&#39;_i}=i\)</span>，所以
<span class="math inline">\(p_i=p&#39;&#39;_i\)</span>。</p>
<p>在排列循环中，求逆的等价于将边反向，以上性质也就不证自明了。</p>
<h3 id="置换和乘法">置换和乘法</h3>
<p>定义两个排列的乘法 <span class="math inline">\(c=a\cdot
b,c_i=a_{b_i}\)</span>。</p>
以置换的方式定义 $$
<span class="math display">\[\begin{pmatrix}1,2\cdots n\\c_1,c_2\cdots
c_n\end{pmatrix}\]</span>
<p>=</p>
<span class="math display">\[\begin{pmatrix}1,2\cdots n\\b_1,b_2\cdots
b_n\end{pmatrix}\circ\]</span>
<span class="math display">\[\begin{pmatrix}1,2\cdots n\\a_1,a_2\cdots
a_n\end{pmatrix}\]</span>
<p>$$ <span class="math inline">\(a\cdot b\)</span> 等于 <span
class="math inline">\(a\)</span> 左乘上置换 <span
class="math inline">\(b\)</span>。</p>
<h4 id="自乘或次幂">自乘或次幂</h4>
<p>如果是自乘，那么等价于循环的边移动若干次，<span
class="math inline">\(b\)</span> 次幂就是将 <span
class="math inline">\(a_i\)</span> 的边指向 <span
class="math inline">\(a_{((i+b-1)\bmod k) + 1}\)</span></p>
<h4 id="非自乘">非自乘</h4>
<p>对于非自乘，我们研究它的运算律。</p>
<ul>
<li><p>没有交换律</p></li>
<li><p>存在单位元 <span class="math inline">\(e\)</span> 满足 <span
class="math inline">\(a\cdot e=e\cdot a=a\)</span>。</p></li>
<li><p>存在结合律</p>
<ul>
<li><p>置换的乘法运算存在结合律，被定义为左乘的排列乘法自然具有结合律。</p></li>
<li><p><span class="math inline">\(a\cdot b\cdot c=c\circ(b\circ
a)=(c\circ b)\circ a=a\cdot (b\cdot c)\)</span></p></li>
<li><p>置换乘法的结合律描述为 <span class="math inline">\(a\circ b\circ
c=a\circ(b\circ c)\)</span>，证明是容易的，此处不再赘述。</p></li>
</ul></li>
<li><p>存在逆元</p>
<ul>
<li>一个置换 <span class="math inline">\(\begin{pmatrix}1,2\cdots
n\\a_1,a_2\cdots a_n\end{pmatrix}\)</span> 的逆元显然为 <span
class="math inline">\(\begin{pmatrix}a_1,a_2\cdots a_n\\1,2\cdots
n\end{pmatrix}\)</span>，也可以写成 <span
class="math inline">\(\begin{pmatrix}1,2\cdots
n\\a&#39;_1,a&#39;_2\cdots a&#39;_n\end{pmatrix}\)</span></li>
<li>对于 <span class="math inline">\(a\)</span> 置换的逆元 <span
class="math inline">\(a&#39;\)</span>，容易发现 <span
class="math inline">\(a&#39;&#39;=a\)</span>，因此 <span
class="math inline">\(a&#39;\circ a&#39;&#39;=a&#39;\circ
a=e\)</span></li>
<li>因此 <span class="math inline">\(a\cdot b\cdot
b^{-1}=a=b^{-1}\circ(b\circ a)=e\circ a=e\cdot a=a\)</span></li>
</ul></li>
</ul>
<p>​</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC155</title>
    <url>/2023/01/30/OI/%E6%AF%94%E8%B5%9B/ARC155/</url>
    <content><![CDATA[<h2 id="arc155">ARC155</h2>
<h3 id="a">A</h3>
<p>考虑 <span class="math inline">\(k\le 2n\)</span>
的情况，可以模拟，具体的，正着做一遍，填上对应的数字，反着做一遍，也填上对应的数字，如果合法，那么就是可以的。</p>
<p>考虑 <span class="math inline">\(k&gt; 2n\)</span>
的情况，容易发现等价于 <span class="math inline">\(k\bmod 4n\)</span>
的情况，画个图：</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202301300817636.png"
alt="image-20230130081657486" />
<figcaption aria-hidden="true">image-20230130081657486</figcaption>
</figure>
<p>红色部分，如果满足下面的两个串都是回文，那么上面的两个串自然都是回文。</p>
<p>实际上循环节是 <span class="math inline">\(2n\)</span>，记 <span
class="math inline">\(T&#39;\)</span> 表示 <span
class="math inline">\(T\)</span> 的翻转，即令 <span
class="math inline">\(T&#39;_i=T_{len-i+1}\cdots\)</span>，考虑如果
<span class="math inline">\(TS\)</span> 是回文，那么 <span
class="math inline">\(S&#39;T&#39;\)</span>
自然也是回文，所以如果把下图的 <span
class="math inline">\(A&#39;\)</span> 换为 <span
class="math inline">\(A\)</span>，构造出满足条件的长度为 <span
class="math inline">\(k-2n\)</span> 的串 <span
class="math inline">\(T\)</span>，将 <span
class="math inline">\(T&#39;\)</span> 带入进上面即可满足条件。</p>
<p>显然这种构造是充要的。</p>
<h3 id="b">B</h3>
<p>考虑式子 <span class="math inline">\(||x-a|-b|\)</span>，取到最小值
<span class="math inline">\(0\)</span> 的点为 <span
class="math inline">\(a+b\)</span> 和 <span
class="math inline">\(a-b\)</span>，考虑一个询问在一个点对上的答案，就是该区间的点到
<span class="math inline">\(a+b\)</span> 和 <span
class="math inline">\(a-b\)</span>
距离的最小值，在多个点对上的答案就是到所有 <span
class="math inline">\(a_i+b_i\)</span> 或者 <span
class="math inline">\(a_i-b_i\)</span> 的最小值，维护一个
<code>set</code> 表示所有点，询问 <code>lower_bound</code> 即可。</p>
<h3 id="c">C</h3>
<p><strong>变换问题，一般考虑找不变量。</strong></p>
<p><strong>操作可逆的变换问题，还可以考虑将两个序列同时向一个序列改变。</strong></p>
<p>一般这种变换构造问题的思路是找不变量，但此题的不变量不容易找。</p>
<p>首先的必要条件是 <span class="math inline">\(A\)</span> 是 <span
class="math inline">\(B\)</span> 的一个排列，以下讨论均认为 <span
class="math inline">\(A\)</span> 是 <span
class="math inline">\(B\)</span> 的排列。</p>
<p>注意到操作是可逆的，考虑将 <span class="math inline">\(A,B\)</span>
同时变成一个串。<strong>如果 A 可以变成一个串，但 B 不能，则 A,B
不能变成同一个串。</strong></p>
<p>考虑一个串 <span class="math inline">\(A\)</span>，如果 <span
class="math inline">\(A\)</span> 中的任何奇数都无法移动，但 <span
class="math inline">\(B\)</span>
可以，那么显然是不行的，反之亦然。考虑如果 <span
class="math inline">\(A,B\)</span>
中的奇数都不能移动，那么以奇数为分割线，每个部分都要对应相同，对于长度大于
<span class="math inline">\(3\)</span>
的偶数连续段，以可重集的形式相等，对于其它段，则以序列的形式相等。</p>
<p>如果 <span class="math inline">\(A\)</span>
中的奇数可以移动，那么我们考虑将奇数全部移动到序列最前面。找到可以移动的两个奇数，将它们放在一起然后一直向后移动，如果碰到偶数可以直接移动，碰到奇数则移动这段奇数中最靠后的两个，直到这段奇数后没有奇数为止，然后考虑将这段奇数前的第一个偶数移动到这段奇数后面，如此操作，就可以将奇数全部放在最前面。</p>
<p><strong>不少于三个偶数段可以任意交换，如果只有两个偶数，那么它们的顺序不能改变。</strong></p>
<p>考虑对前面的奇数部分进行排序，将一个偶数移动到两个奇数之间，然后我们可以交换它们之后再将偶数移动回去，因此前面的奇数可以任意排序。</p>
<p>所以对于 <span class="math inline">\(A,B\)</span>
中都存在可以移动的两个奇数的情况，如果偶数个数不为 <span
class="math inline">\(2\)</span>，答案一定为
<code>Yes</code>，否则如果出现顺序相同，为 <code>Yes</code>，顺序不同为
<code>No</code>。</p>
<h3 id="d">D</h3>
<h4 id="高维前缀和">高维前缀和</h4>
<p>考虑这样一个问题，给定一个序列 <span
class="math inline">\(a,a_i\in[1,n]\)</span>，对于 <span
class="math inline">\(i\in[1,n]\)</span>，计算 <span
class="math inline">\(a_i\)</span> 中 <span
class="math inline">\(i\)</span> 的倍数的个数 <span
class="math inline">\(b_i\)</span></p>
<p>一种 <span class="math inline">\(n\ln n\)</span> 的做法是先算一个
<span class="math inline">\(cnt_i\)</span> 表示 <span
class="math inline">\(i\)</span> 的个数，然后统计每个数 <span
class="math inline">\(i\)</span> 的倍数。</p>
<p>另一种方式是考虑高维前缀和，记 <span
class="math inline">\(cnt_i\)</span> 表示考虑到当且为止，<span
class="math inline">\(i\)</span> 倍数的个数，以任意顺序枚举 <span
class="math inline">\(n\)</span> 以内的质数 <span
class="math inline">\(p_k\)</span>，从大到小的令 <span
class="math inline">\(cnt_i=cnt_i+cnt_{ik}\)</span>。</p>
<p>复杂度是 <span class="math inline">\(n\log\log n\)</span> 的。</p>
<p>为什么这样是对的，考虑将 <span class="math inline">\(i\)</span>
视作一个 <span class="math inline">\(n\)</span>
维的向量，每一维表示对应质数的指数，然后就是对每一维各自先做前缀和加起来。</p>
<h4 id="解法一">解法一</h4>
<p>考虑当前选好了一个数 <span
class="math inline">\(A\)</span>，所有的数已经可以被分为至多 <span
class="math inline">\(2^6\)</span> 类。</p>
<p>因为 <span
class="math inline">\(2*3*5*7*11*13*17=510510&gt;2\times10^5\)</span>。</p>
<p>首先我们只关心具体有哪些质数而不关心质数的指数。</p>
<p>之后的选择一定会是在一个 DAG 上走，这个 DAG 的边数是 <span
class="math inline">\(3^6\)</span> 的。</p>
<p>考虑当前在 DAG 上的某个点，先手该如何决策，当前的数为 <span
class="math inline">\(A\)</span>，那么所有可以选的数被分为 <span
class="math inline">\(A\)</span> 的倍数，和非 <span
class="math inline">\(A\)</span> 的倍数，选非 <span
class="math inline">\(A\)</span> 的倍数一定会走到下一个点。</p>
<p>考虑到某个点后它的倍数的个数，<strong>等于所有它的倍数减去之前用掉的数的个数</strong>，注意我们在一个点处只关心其奇偶性，所以只需要记录一维
<span class="math inline">\(0/1\)</span>
表示之前用掉了奇数个还是偶数个。</p>
<p>转移需要考虑同层转移和不同层转移，对于同层转移，先手当且仅当目前剩余奇数个的时候可以选择让后手走下一步。对于不同层转移，则只需要确定具体能转移到哪些点。</p>
<p>确定能转移到哪些点可以暴力，细节还是有点多。</p>
<h4 id="改进解法">改进解法</h4>
<p>其实我们不需要这个 DAG，容易发现如果当前的 G
和用掉的数的个数就可以表达所有信息了，可以省掉建立 DAG
的步骤，同样的方式考虑 G 的同层转移和非同层转移。</p>
<p>对于非同层转移需要计算可以转移到哪些数字，记 <span
class="math inline">\(f_{g,d}\)</span> 表示满足 <span
class="math inline">\(\gcd(g,A_i)=d\)</span> 的 <span
class="math inline">\(A_i\)</span> 的个数，确定 <span
class="math inline">\(g\)</span> 之后从大到小枚举 <span
class="math inline">\(d\)</span>，计算出 <span
class="math inline">\(d\)</span> 倍数的个数，然后减掉所有 <span
class="math inline">\(f_{g,kd}\)</span>。</p>
<p>易知 <span class="math inline">\(g=ckd\)</span>。</p>
<p>复杂度考虑每个 <span class="math inline">\(d\)</span>，每个 <span
class="math inline">\(d\)</span> 的复杂度为 <span
class="math inline">\(\frac{M}{d}\ln{\frac{M}{d}}\)</span>。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title>几道题目引发的思考</title>
    <url>/2022/12/20/OI/%E5%A4%8D%E5%90%88%E5%9E%8B%E6%96%87%E7%AB%A0/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="几道题目引发的思考">几道题目引发的思考</h2>
<ul>
<li>未完成，咕咕咕中。</li>
</ul>
<h3 id="noi2013书法家"><a
href="https://www.luogu.com.cn/problem/P1398">NOI2013书法家</a></h3>
<p>这道题，我写了个 DP+枚举 的方法交了上去，第一发喜提 TLE，开 O2
后成功通过，并且速度是不开 O2 的 10 倍，看题解后发现，相比于纯粹的 DP
做法，自己的枚举做法其实很蠢很难想也很难写，于是对 DP
和枚举的关系进行了一些思考。</p>
<p>O2 优化的高达 10 的效率改进因子也着实让我觉得有些不可思议，于是便对
O2 优化在份代码上到底干了什么做了一些探索.</p>
<p>同时，将内联函数改为宏定义后，我的程序也得到了明显的效率改进，便有了宏定义与函数的比较。</p>
<p>下文将从这些角度入手，进一步分析一些底层的程序效率问题。</p>
<h3 id="cf1709f"><a
href="https://www.luogu.com.cn/problem/CF1709F">CF1709F</a></h3>
<p>考场上图方便 <code>#define int long long</code>，用
<code>Codeforces</code> 的 <code>C++14</code> 提交喜提 TLE，改为
<code>C++20(64bit)</code> 后成功通过，于是便有了对 64bit 机子和 32bit
机子，<code>int</code> 与 <code>long long</code> 比较的想法。</p>
<h2 id="浅谈-dp-枚举与一般枚举算法的差异与优劣">浅谈 DP
枚举与一般枚举算法的差异与优劣</h2>
<h3 id="dp-枚举也是枚举">DP 枚举也是枚举</h3>
<p>回到题目本身，我们考虑处理字母 <code>O</code> 和 <code>I</code>
时，枚举算法的本质。</p>
<p>处理 <code>O</code>
的时候，枚举算法枚举了上下两个行，和一个左端点，通过前缀和算出了类似这样的一个结构的权值</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/vo4uhkxr.png" /></p>
<p>红色部分是负权值。</p>
<p>然后我们又计算了一个这样的结构的后缀最大值。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/9waojsv1.png" /></p>
<p>如果把这两个结构拼在一起，就得到我们想要的答案。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/s1qbflc5.png" /></p>
<p>红色部分和黑色部分抵消掉了，得到了想要的答案。</p>
<p>如果用 <span class="math inline">\(dp\)</span> 来处理，我们就设了
<span class="math inline">\(dp[i][l][r]\)</span> 考虑到第 <span
class="math inline">\(i\)</span> 行，顶部和底部分别是 <span
class="math inline">\(l,r\)</span>
的最大值，转移相当自然，从没有到一列，再到两格，从两格加上一列计算答案。</p>
<p>其实这种 <span class="math inline">\(dp\)</span>
和我们的枚举算法没有差异，都是确定了上下以及左右的一个端点，通过记录的辅助状态来完成转移。<strong>DP
记录的辅助状态就是答案，而枚举记录的辅助状态是抽象的前缀和。</strong>因而后者比前者要更难理解。</p>
<h3 id="dp-比枚举更加自然">DP 比枚举更加自然</h3>
<p>从刚刚处理简单的 <code>O</code>
还看不出来差异，我们现在来处理更为复杂的
<code>I</code>，实际上，我们用枚举算法计算 <code>I</code>
的时候，处理了三个辅助状态。</p>
<p><del>MSPAINT已经满足不了绘图要求了，还是手最靠谱</del></p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/g3gkj0w9.png" /></p>
<p>不难发现对 <code>O</code>
来说，确定了左上右下就已经确定了整个图形的结构了，而对于 <code>I</code>
来说，确定了左上右下，还需要额外确定两个参数才能确定权值，这样带来了
<span class="math inline">\(O(n^2)\)</span> 种方案。</p>
<p>直接枚举，我们思考的量就是 <span class="math inline">\(3^2\)</span>
级别的，因为我们需要考虑这三种情况相互之间的影响。</p>
<p>而如果考虑
DP。我们就只需要设计三种不同状态，而每种状态保存的辅助数据又是直观的答案，相比于枚举算法的弯弯绕绕计算答案，DP，在计算答案时只需要简单的加和，转移的方式也只有
<span class="math inline">\(2\)</span> 种，孰优孰劣不言而喻。</p>
<p>在跨域三种状态转移的过程中，其实就已经完成了枚举算法对上图里所有情况的考虑，所以不会和枚举算法有任何本质差异，但是
DP
这种<strong>直接记录答案作为辅助数据</strong>的方式，无疑更加自然，思考也更加简单。</p>
<h2 id="浅谈-o2-优化在公共子表达式与寻址中的实际作用">浅谈 O2
优化在公共子表达式与寻址中的实际作用。</h2>
<h3 id="对公共子表达式的优化">对公共子表达式的优化</h3>
<p>提到了一个定义，公共子表达式。一般的，公共子表达式，指的是这种</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>;</span><br><span class="line">cout&lt;&lt;a+c*d;</span><br><span class="line">cout&lt;&lt;b+c*d;</span><br></pre></td></tr></table></figure>
<p>其中，<code>c*d</code> 就是公共子表达式。</p>
<p>看一个不同优化下两种代码的汇编</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/oznw58na.png" /></p>
<p>无优化版本。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/xsdaledv.png" /></p>
<p>有优化版本。</p>
<p>编译器帮我们把 <span class="math inline">\(c*d\)</span>
算好了，扔进了寄存器以反复调用。</p>
<p>相比于无优化的版本，开启优化后对寄存器的使用变得非常灵活，不再是死板的仅作为计算时的存储工具，内存操作减少了
<span class="math inline">\(\frac{2}{3}\)</span> 。</p>
<p>那为什么实际上汇编代码量 O2
后成倍数减少，但运行时间没有成倍数减少呢。这就涉及内存延迟的概念。</p>
<p>内存读取有一个延迟时间，相比于计算耗时，这个延时要大得多，但这个延迟只会在最开始被等待一次，因为读取过程中
CPU
可以在等待延迟的同时发出读取指令，同时读取。就像烧水一样，烧一壶的同时灌上另一壶，可以有效节省时间。被读取过一次的内存，会被放入高速缓存，读取变得更快。</p>
<p>这是 O2 优化的第一个部分。</p>
<h3 id="对寻址的优化">对寻址的优化</h3>
<p>寻址主要指<strong>将数据从内存或者缓存加载的寄存器的过程</strong>。我们再这里忽略计算地址需要的时间。</p>
<p>还是两张图说明。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/wlcmiq0z.png" /></p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/it2y7adt.png" /></p>
<p>可以看到，在做前缀和的过程中，开启优化后的代码，只有一次寻址和一次加操作，而我们没开优化的代码，操作的毒瘤程度就难以形容了。</p>
<p>平常有些代码看起来很傻，实际上开了 O2
之后效率更优秀，就是采用的对编译器更友好的写法，当然，我们也没必要去太注意这些。</p>
<h2
id="从汇编角度比较函数调用和宏定义">从汇编角度比较函数调用和宏定义</h2>
<p>开了 O2 之后，这俩的区别不大，不开 O2，由于在 CPU 流水线中 ret
指令会带来严重中断，所以<strong>小函数还是写宏定义比较好。</strong></p>
<p><strong>注意，在 C++11 以后，inline 关键字已经被启用，开启 O2
优化后会自动内联，减少函数调用带来的开支。</strong></p>
<p>可以通过和 <code>g++</code> 同时安装的 <code>gprof</code>
对程序进行性能分析确定复杂度瓶颈。</p>
<p>引用一些宏定义的资料。</p>
<p><a
href="https://www.runoob.com/w3cnote/macro-definition.html">宏定义的坑</a></p>
<h2 id="long-long-与-int-的效率之争">long long 与 int 的效率之争</h2>
<p>通常来说，在 64bit 下，long long 和 int
的运算效率是没有差别的。但是由于高速缓存的问题，尤其是在某些数组大小为
<span class="math inline">\(10^5\)</span> 左右的题目，如果
<code>#define int long long</code>，就很容易造成高速缓存不够用然后被迫放进内存减慢读写的情况。又或者是发生出现寄存器溢出，两个
int 类型可以共用一个寄存器但是一个 long long
不行。<strong>编译器不敢假定你的 long long 类型存储的数据是 int
范围的</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>网络文娱推荐</title>
    <url>/2022/12/15/%E5%A8%B1%E4%B9%90/%E7%BD%91%E7%BB%9C%E6%96%87%E5%A8%B1%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h2 id="网络文娱推荐">网络文娱推荐</h2>
<p>随便写写自己喜欢的东西，顺便安利给其他人，主要是网络小说，也有其它的，看心情加。</p>
<h2 id="网络小说">网络小说</h2>
<p>乱序排列。</p>
<h3 id="故事向">故事向</h3>
<p>以故事情节为看点。</p>
<h4 id="星体意识">星体意识</h4>
<p><em>把这个归入故事向其实有些不妥，但非故事向也不妥，勉强了</em></p>
<p>来自 "刺猬猫" 平台，以岚星文明发展史为主线。</p>
<p>半风景文，有大量描写内容完全可以借鉴到语文写作中。</p>
<p>伪群像文，记录了文明每个时期重要正面人物的经历，有相当的励志成分。</p>
<p>作者自身的计算机技术水平相当不错，通过小说外的创作真正构建出了一个岚星宇宙。</p>
<h4 id="舰娘世纪">舰娘世纪</h4>
<p>来自 "刺猬猫" 平台，不一样的舰娘故事，相对沉重一些。</p>
<h4 id="化身虚拟数据歌姬">化身虚拟数据歌姬</h4>
<p>来自 "起点中文网" 平台，算是我的二次元入门小说。</p>
<p>其实这本书现在看来还是有很多不足，作者自身文笔欠佳，故事大纲也不清晰，但是还是放在这里吧。这位作者和我同龄，也比较熟。我还给书中主角设计了一个基于
<code>beta.character.ai</code> 模型的 AI
角色（目前正在训练以及写配套平台的代码）。</p>
<p>鹿灵第一可爱啦。</p>
<h3 id="非故事向">非故事向</h3>
<p>能够让人思考的书。</p>
<h4 id="数竞少女">数竞少女</h4>
<p>来自 "刺猬猫" 平台，主要内容是架空世界中的数学竞赛。</p>
<p>阅读时备好草稿纸跟着一起算，基本是高考到一式难度的题，偶有简单的二试题，做不了可以往下看。</p>
<h4 id="二战之钢铁奏鸣曲">二战之钢铁奏鸣曲</h4>
<p>来自 "息壤"
平台，以架空世界中的二战经济政治，武器设计为主线发展。</p>
<p>阅读时需查阅历史资料，也可以跟着武器设计思路（尤其是航空航天部分）简略思考其物理原理，需要一定流体力学基础。</p>
<h4 id="斗罗活久见">斗罗活久见</h4>
<p>来自 "起点中文网"
平台，感觉名字会比较劝退，但这并不是一本故事向的书，以文明发展为主线，包含大量脑洞和搞笑内容。</p>
<p><strong>阅读时不要拘泥于它的故事情节，请关注这个文明是如何在所有人的努力下发展的，更要关注其中提到的科学探索的方式。</strong></p>
<p>向往，坚毅，牺牲。这三个词贯穿了郁金香文明的发展历程。</p>
<p>一个个渺小的个体摸索着宇宙的真理，亿万人同心，同宇宙的掌控者对弈。</p>
<p>1700 章之后由于作者要恰钱稍有变质，太过理想化了，放在这里的理应只有前
1700 章。</p>
<p>顺便提一下，作者的其他书也很不错，也是同一类的。</p>
<p>作者 ID 有三个：印小宇，印小桢，魔性沧月。</p>
<h2 id="歌">歌</h2>
<p>有些太热门的只是单纯喜欢听就不写了</p>
<h3 id="纯音乐">纯音乐</h3>
<p>基本收录的是那种能让人平静下来或者热血起来的纯音乐，治愈系为主。</p>
<ul>
<li>繁华的寂静</li>
<li>illusionary daytime</li>
<li>流萤之森</li>
<li>青空</li>
<li>风动草</li>
<li>萤火虫之舞</li>
<li>Windy Hill</li>
</ul>
<h3 id="非纯音乐">非纯音乐</h3>
<h4 id="如果我们不曾相遇">如果我们不曾相遇</h4>
<p>学校起床铃的歌，很喜欢它的歌词。</p>
<p>很想念我的同学——LXY。</p>
<p>偶尔听到歌的时候会流泪的。</p>
<p>无论如何，祝你 17 岁生日快乐。</p>
<h4 id="如愿">如愿</h4>
<p>原定 12·9 合唱的歌。</p>
<p>它提醒我还得向前看，喜欢的合唱
MV，那是这个国家或者说文明中所有个体的缩影，如果问我学习的目的是什么，我的回答是，成为这个
MV 的一部分。</p>
<p>可惜最后我们都没有合唱出来。</p>
<h4 id="飞-致我们的星辰大海">飞-致我们的星辰大海</h4>
<p>来自
《斗罗活久见》的推荐，和这本小说一样的主题，这是我们的星辰大海，也是郁金香文明的星辰大海。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>网络小说</tag>
      </tags>
  </entry>
  <entry>
    <title>1124总结</title>
    <url>/2022/11/25/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1124%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="总结">1124总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0160">考试</a></p>
<h3 id="t1">T1</h3>
<p>有 <span class="math inline">\(n\)</span>
个类似的条件，考虑容斥原理，条件可以被描述为 <span
class="math inline">\(\forall i\in[1,n),a_i\nmid a_{i+1}\vee
a_i=a_{i+1}\)</span>。</p>
<p>容斥原理需要计算，钦定 <span class="math inline">\(x\)</span>
个条件不成立，忽视其它条件时，合法的方案总数。</p>
<p>假设我们已经钦定好了 <span class="math inline">\(x\)</span>
个条件，那么很容易计算出这个方案，将每一段连续的不合法的位置的方案数计算出来，其余位置不受限制即可，就是
<span class="math inline">\(m\)</span>。</p>
<p>每一段连续不合法位置的贡献显然仅和长度有关，而长度又不超过 <span
class="math inline">\(\log n\)</span>，所以可以预处理一个 <span
class="math inline">\(g[x]\)</span> 表示连续 <span
class="math inline">\(x\)</span>
个连续不合法位置的贡献，注意到不合法位置开头的前一个位置也是需要考虑进去的，但它没有限制，所以连带算进去就行。</p>
<p>预处理的时候进行 <span
class="math inline">\(dp\)</span>，可以记录上一个位置的值。</p>
<p>计算出 <span class="math inline">\(g[x]\)</span>
后，我们不需要死板的去考虑有 <span class="math inline">\(x\)</span>
个位置不合法时，它们的分布是什么，如果这样考虑，那么每一个 <span
class="math inline">\(x\)</span>
都需要进行一次动态规划来计算答案并乘上容斥系数。</p>
<p>我们可以用<strong>一次动态规划</strong>完成整个统计过程。</p>
<p>设 <span class="math inline">\(dp[i]\)</span> 表示考虑前 <span
class="math inline">\(i\)</span>
位，各个容斥统计子问题带上对应系数后的答案之和，它向后的转移很简单，容斥系数乘上不合法位置填法的系数。</p>
<p>从一般的动态规划思路也可联想到这种方案，其实末尾数字是一个多余的信息，可以不用记录，用容斥的思想即可正确转移，直接设
<span class="math inline">\(dp[i]\)</span> 表示考虑前 <span
class="math inline">\(i\)</span> 位的答案。</p>
<p><span
class="math inline">\(dp[i]-&gt;dp[i+1]\)</span>，可以任意填，有算重。</p>
<p>考虑钦定 <span class="math inline">\(dp[i]-&gt;dp[i+1]\)</span>
这里不合法，那么减去 <span class="math inline">\(dp[i-1]*(i\ 到\ i+1\
不合法的方案数)\)</span>。</p>
<p>发现减多了，因为 <span class="math inline">\(i-1\rightarrow
i\)</span>
时不合法的也被减掉了，但这一部分贡献根本在第一次就没加上。</p>
<p>继续推下去和容斥的思路也完全一样了。</p>
<p><strong>容斥原理的统计过程，是可以用动态规划来完成的，注意转移时需要带上容斥的系数，相当于把不同的不合法条件数的统计过程压缩到了一次，带上容斥系数就是压缩信息的过程。</strong></p>
<h3 id="t2">T2</h3>
<h3 id="t3">T3</h3>
<h4 id="my-method">My Method</h4>
<p>将差分数组的所有值视为一个集合。</p>
<p>它本质上需要计算第 <span class="math inline">\(k\)</span>
大元素的期望。</p>
<p>很容易想到<code>min-max</code>
容斥，问题变成了计算一个差分数组集合子集最小值的期望值，考虑怎么算一个子集最小值的期望值。</p>
<p>假设子集为 <span class="math inline">\(S\)</span>，枚举最小值的取值
<span class="math inline">\(x\)</span>，然后问题变成了有多少个长度为
<span class="math inline">\(n+1\)</span> 的序列 <span
class="math inline">\(a\)</span>，满足 <span
class="math inline">\(a_i\ge 1,\sum a_i=m+1,\forall p\in S, a_p\ge
x\)</span>，这是一个先把 <span class="math inline">\(S\)</span>
中所有元素的限制变成 <span class="math inline">\(\ge
1\)</span>，方法是把 <span class="math inline">\(\sum\)</span> 变成
<span
class="math inline">\(=m+1-size(S)\times(x-1)\)</span>，剩下的是个插板法。</p>
<p>因此对于大小相同的子集这个值是一样的。</p>
<p>记 <span class="math inline">\(val_k\)</span> 表示大小为 <span
class="math inline">\(k\)</span> 的子集，最小值的期望。</p>
<p>接下来可以直接套 <code>min-max</code>
容斥的公式，但是我背不住那个公式，于是考虑比较暴力的方式，考虑所有大小为
<span class="math inline">\(n-k+1\)</span> 的子集的期望最小值的和。<span
class="math inline">\(k\)</span> 小值贡献了 <span
class="math inline">\(1\)</span> 次，<span
class="math inline">\(k-1\)</span> 小值贡献了 <span
class="math inline">\(\binom{n-k+1}{n-k}\)</span> 次，<span
class="math inline">\(\cdots\)</span>，边界是最小值，一路推上来就行。</p>
<p>复杂度 <span class="math inline">\(O(nm+n^2)\)</span></p>
<h4 id="talentkks-method">Talentkk's Method</h4>
<h4 id="solution">Solution</h4>
<h4 id="min-max-容斥">min-max 容斥</h4>
<h3 id="t4">T4</h3>
<p><span class="math display">\[
(\dfrac{\alpha v}{\beta  v})_T=T(\frac{\alpha p}{2 T})_v - P
\]</span></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2022</title>
    <url>/2022/11/25/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/CSP2022/</url>
    <content><![CDATA[<h1 id="csp2022考试总结">CSP2022考试总结</h1>
<h2 id="t1">T1</h2>
<p>先想到动态规划，但是想了下不好处理不相同的要求，发现只有 <span
class="math inline">\(4\)</span> 个点，考虑利用这个性质。</p>
<p>枚举中间的两个点，然后判断是否合法，然后对于每个点预处理到 <span
class="math inline">\(1\)</span> 可能的中间点，取值最大的 <span
class="math inline">\(3\)</span>
个，然后就可以直接合并两个点的信息得到一条路径。</p>
<h2 id="t2">T2</h2>
<p>容易发现只会在 <span class="math inline">\(A,B\)</span>
每个区间中的四个数中选，即负最大最小，正最大最小。</p>
<p>一共 <span class="math inline">\(16\)</span>
种方案，直接拿个数据结构维护信息，暴力合并计算答案即可。</p>
<h2 id="t3">T3</h2>
<h3 id="考场暴力">考场暴力</h3>
<p>不难发现充要条件是每个点有且仅有一条出边，这个条件相当严。</p>
<p>考虑只在边数为 <span class="math inline">\(n\)</span>
时进行检查，其余情况显然是 <code>NO</code>，边数为 <span
class="math inline">\(n\)</span> 时，对所有被修改过的端点下放操作，此时
<span class="math inline">\(2,4\)</span>
操作可能会叠加，只处理最后一次即可。</p>
<p>这样的暴力很难卡，实际上也可以通过。</p>
<h3 id="正解1">正解1</h3>
<p>充要条件是若干个类似的条件的叠加，考虑能不能一起检查。</p>
<p><a
href="https://huanyp.cn/2022/10/17/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%80%BB%E7%BB%93%E6%84%9F%E6%82%9F/%E6%80%BB%E7%BB%93/CF1746/">CF某道题</a></p>
<p>参考这道题的思路，可以随机一个集合检查这个在集合里的所有点的边数和是否等于集合大小。</p>
<p>考虑不合法的 <code>Case</code> 通过判定的概率，显然不会超过 <span
class="math inline">\(\frac{1}{2}\)</span>，证明可以<strong>考虑一个不合法的元素</strong>所有能够通过判定的集合，如果包含它，那么删去它后就不合法，如果不包含它，那么对应加上它后就不合法，构造出等量的不合法集合，因此通过判定的概率低于
<span class="math inline">\(\frac{1}{2}\)</span>，所以做 <span
class="math inline">\(2\log_2(q)\)</span>
次就能保证正确，如果还错了，快用你生成的第一个随机数去买彩票！</p>
<h3 id="正解2">正解2</h3>
<p>问题的本质是维护集合，你需要维护 <span
class="math inline">\(n\)</span> 个可重集，支持加入删除，填满和清空，问
<span class="math inline">\(n\)</span>
个可重集的并是否等于某个集合，可以考虑 <code>xor_hash</code>。</p>
<p>随机点权的情况下，一个可重集的权值也是随机的，所以正确率为 <span
class="math inline">\(1-\frac{1}{值域大小}\)</span>，注意仍然需要特判边数是否为
<span class="math inline">\(n\)</span>，因为可以构造不同大小的对于
<code>xor_hash</code> 来说权值相同的可重集——某一个元素出现 <span
class="math inline">\(3\)</span> 次，其余元素次数相同。</p>
<p><strong>只有错误出现在不同元素之间互补构造时，<code>xor_hash</code>
的正确性才有保证</strong></p>
<h2 id="t4">T4</h2>
<h3 id="考场暴力-1">考场暴力</h3>
<p>可以把链提出来动态规划，期望 <span
class="math inline">\(68\)</span>，场上第一次写没考虑往一个点旁边走可以更优，只能过
<span class="math inline">\(k\le 2\)</span>。</p>
<p>修了这个锅之后由于第一次写的时候限制了步数，但是走旁边会消耗步数，导致最开始没有办法走旁边，然后娶不到最优解。</p>
<h3 id="正解">正解</h3>
<p>把暴力的动态规划改成倍增版即可。</p>
<p>有点难写，暂时没写。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>1122总结</title>
    <url>/2022/11/22/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1122%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="总结">1122总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0158">考试</a></p>
<h3 id="t1">T1</h3>
<p>有趣的题。</p>
<p>场上瞎撞结论显然是错误的。</p>
<p>考虑 <span class="math inline">\(01\)</span>
矩阵乘法的组合意义，就是统计一张图从 <span
class="math inline">\(S\)</span> 到 <span
class="math inline">\(T\)</span> 某个长度的路径总条数。</p>
<p>所以如果不存在长度为 <span class="math inline">\(k\)</span>
的路径，考虑将点按照最长路径长度分类，每一类需要尽可能均分。</p>
<p>然后每一类内部不连边，和向外部路长度更短的所有点连单向边。</p>
<p>考虑证明这样的边数最多，问题本质是有 <span
class="math inline">\(k\)</span> 个变量 <span
class="math inline">\(a_1,a_2\cdots a_k\)</span> 满足 <span
class="math inline">\(\sum\limits_{i\in[1,k]}a_i=n\)</span>，求 <span
class="math inline">\(\sum\limits_{i\in[1,k]} \binom{a_i}{2}\)</span>
的最小值，列式计算： <span class="math display">\[
\begin{align}
\sum\limits_{i\in[1,k]}
\binom{a_i}{2}=&amp;\dfrac{a_i\times(a_i-1)}{2}\\
=&amp;-\dfrac{n+\sum\limits_{i\in[1,k]}a_i^2}{2}
\end{align}
\]</span> 考虑证明分布在 <span
class="math inline">\(v=\lfloor\frac{n}{k}\rfloor\)</span> 和 <span
class="math inline">\(\lfloor\frac{n}{k}\rfloor+1\)</span> 之间的 <span
class="math inline">\(a_i\)</span>
是最优的，假设不为这两个值，那么找到两个值 <span
class="math inline">\(x&lt;v\)</span> 和<span
class="math inline">\(y&gt;v+1\)</span>，将 <span
class="math inline">\(x\)</span> 调整为 <span
class="math inline">\(x+1\)</span>，<span
class="math inline">\(y\)</span> 调整为 <span
class="math inline">\(y-1\)</span>，那么从 <span
class="math inline">\(x^2+y^2\)</span> 变成了 <span
class="math inline">\(x^2+2x+1+y^2-2y+1\)</span>，由于 <span
class="math inline">\(y&gt; x+1\)</span>，所以一定会变优，如果只能找到
<span class="math inline">\(x\)</span> 或者 <span
class="math inline">\(y\)</span>，就对应的选择 <span
class="math inline">\(v+1\)</span> 和 <span
class="math inline">\(v\)</span>，同样会变优，调整到最后就分布在 <span
class="math inline">\(v,v+1\)</span>。</p>
<p><strong>不直观的计数问题，考察其组合意义，变成直观的计数问题。</strong></p>
<h3 id="t2">T2</h3>
<p>很容易想到二分，直接二分的复杂度是 <span
class="math inline">\(O(nq\log^2 n)\)</span> 的。发现 <span
class="math inline">\(check\)</span>
的代价和二分值有关，考虑调整二分策略，尝试以 <span
class="math inline">\(O(ans\log ans\log n)\)</span>
的代价找出一次清空，发现倍增后二分即可。</p>
<h3 id="t3">T3</h3>
<p>朴素的动态规划是 <span class="math inline">\(O(n^5)\)</span>
的，配合性质的暴力可以有 <span class="math inline">\(50\)</span>。</p>
<p>观察，发现答案不会很大，考虑改变动态规划状态，设 <span
class="math inline">\(dp[x][y][i][ans]\)</span> 表示左端点为 <span
class="math inline">\((x,y)\)</span>，横向延伸到 <span
class="math inline">\(i(i\ge
x)\)</span>，纵向延申的最远位置，不难发现该状态有单调性，即 <span
class="math inline">\(dp[x+1][y][i][ans]\ge
dp[x][y][i][ans]\)</span>，因此纵向转移是简单的，可以做到 <span
class="math inline">\(O(1)\)</span>，转移完之后其实就已经单调了，不用前缀
<span class="math inline">\(\max\)</span>。</p>
<p>考虑横向的转移，不难发现最优的转移点单调，且答案递减，维护这个最优转移点即可。</p>
<h3 id="t4">T4</h3>
<h4 id="朴素做法">朴素做法</h4>
<p>考虑设 <span class="math inline">\(dp[i][j][k]\)</span> 表示考虑到第
<span class="math inline">\(i\)</span> 个数，抹掉了 <span
class="math inline">\(k\)</span> 位后再加上了若干位，最终的 <span
class="math inline">\(\log_2\)</span> 值为 <span
class="math inline">\(j\)</span> 的最小方案。</p>
<p>视实现有 <span class="math inline">\(40-75\)</span>，转移是一个前缀
<span class="math inline">\(\min\)</span> 加上一个带判断的转移。</p>
<h4 id="不太需要动脑子的办法">不太需要动脑子的办法</h4>
<p>转移可以通过类似双指针的方法做到均摊 <span
class="math inline">\(O(1)\)</span>，考虑优化状态数。</p>
<p>有一个显然的可行解需要 <span
class="math inline">\(\sum\log_2{a_i}=sum\)</span> 步。</p>
<p>考虑每一个位置 <span class="math inline">\(k\)</span> 的上界，设
<span class="math inline">\(T=\log m
\approx18\)</span>，那么如果一个位置 <span
class="math inline">\(i\)</span> 的 <span
class="math inline">\(j\)</span> 的状态如果满足了 <span
class="math inline">\((j-T)\times(n-i) \ge sum\)</span>，那么这个 <span
class="math inline">\(j\)</span> 是没有意义的，这样限制下来 <span
class="math inline">\(j\)</span> 这一维是 <span
class="math inline">\(Tn\ln n\)</span> 大小的。</p>
<p>已经可以比较险的通过了，其实还有一个限制，就是 <span
class="math inline">\(lim_i\le
lim_{i-1}+1\)</span>，原因是显然的，加上这个限制之后又会变松很多。</p>
<p>最后记一个 <span class="math inline">\(mn\)</span>
表示当前状态的最小可能值，条件变为 <span
class="math inline">\((j-T)\times(n-i)+mn \ge
sum\)</span>，就很容易通过了。</p>
<p><strong>场上前缀最小值只取了上一个位置的，挂了。</strong></p>
<h4 id="比较聪明的办法">比较聪明的办法</h4>
<p>考虑如果 <span class="math inline">\(a_i&#39;\)</span> 变到了 <span
class="math inline">\(\log_2\ge 17\)</span>
之后会发生什么，它之后的位置的 <span
class="math inline">\(\log_2\)</span> 值，都必须要大于 <span
class="math inline">\(17\)</span>，不妨先在这些数后面添 <span
class="math inline">\(0\)</span> 补到 <span
class="math inline">\(17\)</span>，进行代价的预付，到一个位置的时候，我们已知它和上一个位置的
<span class="math inline">\(\log2\)</span>
已经相同了，只需要改变高位的一些值，这样的改变方式只有 <span
class="math inline">\(\log n\)</span> 种，代价也是好算的，暴力枚举就是
<span class="math inline">\(O(n\log^2n )\)</span>
的，如果会导致后面的位置的 <span class="math inline">\(\log_2\)</span>
变大，就在这里预付代价。</p>
<p><strong>本质上，这种方法通过分析 <span class="math inline">\(j\ge
17\)</span> 后最优解 <span class="math inline">\(\log_2\)</span>
值的变化，得到了一种新的代价计算方式，这种方式不依赖 <span
class="math inline">\(j\)</span>，减少了状态数量</strong></p>
<p><strong>同一个最优化问题，可以采取不同的代价计算方式，得到不同的动态规划状态。预付代价是一种常用的方式。</strong></p>
<p>典型例题是《任务安排》。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>1119总结</title>
    <url>/2022/11/22/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1119%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="section">1119</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0157">考试</a></p>
<p>挂大分</p>
<h3 id="t1">T1</h3>
<h4 id="蠢做法">蠢做法</h4>
<p>对于每一行，检查有哪些位置对是合法的，如果序列已经有序，那么先扔到后面去。</p>
<p>不难发现每一行合法位置对数是 <span
class="math inline">\(O(n)\)</span> 的，set 处理集合求交即可。</p>
<p><strong>由于处理的是无序对，但 set
是有序的，所以要把正反都插进去。</strong></p>
<p><strong>局部数组不要越界</strong></p>
<p><strong>n,m 不要写反</strong>。</p>
<h4 id="优秀做法">优秀做法</h4>
<p>考虑将某一行排序，看看有变化的位置。</p>
<p>这样的位置有且仅有两个，检查一下每一行的变化位置是否会相同就可以了。</p>
<p>优先处理有变化的行。</p>
<h3 id="t2">T2</h3>
<p>首先发现 <span class="math inline">\(B,C\)</span> 等价，变成 01
串问题，每一个 <span class="math inline">\(0\)</span>
的前面是自由的，可以自由控制 <span class="math inline">\(1\)</span>
的个数，<span class="math inline">\(0\)</span> 不可减少，<span
class="math inline">\(0\)</span> 的增加。如果 <span
class="math inline">\(T\)</span> 的末尾为 <span
class="math inline">\(1\)</span>，那么 <span
class="math inline">\(S\)</span> 的末尾需要对应有那么多的 <span
class="math inline">\(1\)</span>，将这些抵消，<span
class="math inline">\(T\)</span> 的末尾就是 <span
class="math inline">\(0\)</span>。</p>
<p>分类讨论，如果 <span class="math inline">\(S\)</span> 的末尾的 <span
class="math inline">\(1\)</span> 模三不余 <span
class="math inline">\(0\)</span>，那么还需要添加两个 <span
class="math inline">\(0\)</span>，此时如果 <span
class="math inline">\(0\)</span> 多了或者模 <span
class="math inline">\(2\)</span> 不相同则无解，否则有解。</p>
<p><strong>有边界情况，如果 <span class="math inline">\(S\)</span>
中本来没有 <span class="math inline">\(0\)</span> 并且 <span
class="math inline">\(1\)</span> 也被抵消完了，那么不能额外的生成 <span
class="math inline">\(0\)</span>。</strong></p>
<p>我实现的时候计算连续 <span class="math inline">\(0\)</span>
个数的时候没有考虑左边界，还挂了一下。</p>
<h3 id="t3">T3</h3>
<p>题意轻重边，见 <a
href="https://huanyp.cn/2022/09/21/%E6%A0%91%E4%B8%8A%E9%93%BE%E9%A2%86%E5%9F%9F%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98/">树上领域修改问题</a></p>
<h3 id="t4">T4</h3>
<h4 id="n2">n^2</h4>
<p>如果 <span
class="math inline">\(O(n^2)\)</span>，那么考虑以插入的方式构造排列，已经是一个被积累起来的套路了，场上成功写出。</p>
<h4 id="nlogn">nlogn</h4>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>1117总结</title>
    <url>/2022/11/22/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1117%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="总结">1117总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0155/">考试</a></p>
<h3 id="t1">T1</h3>
<p>问的是对于每个跳棋能走到多少个格子，不重不漏那种。</p>
<p>发现对于一个棋子，由于它跳的时候其它的不能动，所以本质上如果弄成图处理不会出问题，问题变成了无向图中一个点可以到多少个点，就是联通块问题，不妨先把所有可能可达的点弄出来建一个图，点数
<span
class="math inline">\(O(n)\)</span>，然后问一个棋子，要对图做一下改变，具体的是加一些边连向一个新点，问新点所在连通块大小。</p>
<p>可以可撤销并查集，当然也可以直接枚举做，相邻的情况是平凡的，特判掉。</p>
<p>场上写挂是因为数组开小了，点的数量是 <span
class="math inline">\(7n\)</span> 而不是 <span
class="math inline">\(6n\)</span>。</p>
<h3 id="t2">T2</h3>
<p>首先判掉没有 <span class="math inline">\(GT\)</span>
的情况，直接选最后一个。</p>
<p>然后如果有 <span class="math inline">\(GT\)</span>
，那么一左端点一定是第一个 <span class="math inline">\(G\)</span> 或者
<span class="math inline">\(T\)</span>，然后左端点固定，需要比较 <span
class="math inline">\(O(n)\)</span>
个字符串，每个字符串可以描述为两个字符串的子串拼起来，然后用二分哈希比较就可以了。</p>
<p>场上拼串的时候多弄了一个字符， <span
class="math inline">\(90\)</span>。</p>
<h3 id="t3">T3</h3>
<p>暂时还不会</p>
<h3 id="t4">T4</h3>
<p>考虑建图，图本身很类似一棵树，因为合法括号序列本身就是树的结构，将一对括号视作树上的一个节点，这个节点中含有两个子节点，那么连边就是一个节点中的两个子节点连边以及儿子的左右两个子节点之间连边，以及最左最右的儿子向对应的父亲子节点连边。</p>
<p>然后任何路径必须在 LCA 处交汇，变成树上路径问题，可以倍增。</p>
<p>注意因为我们实现的时候建了一个虚拟节点，实际上不能走它，需要特判。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>心灵现实</title>
    <url>/2022/11/20/%E5%B9%BB%E6%A2%A6/%E5%BF%83%E7%81%B5%E7%8E%B0%E5%AE%9E/</url>
    <content><![CDATA[<h2 id="心灵现实">心灵现实</h2>
<p><strong>注意，以下内容为纯属虚构</strong></p>
<h3 id="思维速度">思维速度</h3>
<h4 id="解决问题">解决问题</h4>
<p>如果一个机器 A，可以模拟机器 B，并且机器 B，可以模拟机器 A，则称 A，B
在解决问题上的能力等价。</p>
<p>如果机器 A，可以模拟机器 B，但机器 B，不能模拟机器 A，则称 A 比 B
在解决问题上更强大。</p>
<p>人脑可以模拟图灵机，但图灵机<strong>暂时</strong>无法模拟人脑，所以人脑解决问题的能力比图灵机更强大。</p>
<h4 id="质因数分解">质因数分解</h4>
<p>对于大数的质因数分解，计算机科学界暂时还没有找到关于位数的多项式算法，尽管一些指数级算法非常优秀，在个人计算机上都可以在一秒内完成
<span class="math inline">\(2^{80}\)</span>
以内的质因数分解，但它终归不是一个关于问题规模多项式算法。</p>
<p>大数质因数分解问题本身的困难性，催生了大批基于这个问题的加密算法，例如
RSA 加密，只需要选取 2048 位的
N，就可以保证人类现有的算力在宇宙末日时都无法破解出私钥。</p>
<p>根据国家计生委未公开的大数据统计，平均每 66666666
位少年少女中就有一位这样的天才，心算能力极为恐怖，可以在线性复杂度内分解任意长度的大整数，因为时间瓶颈主要在于把结果用笔写出来。中国科学技术大学少年班学院成立的主要目的，其实就是为了网罗这样的神童。</p>
<h4 id="没有元素周期表的化学">没有元素周期表的化学</h4>
<blockquote>
<p>现在的脑科学，是在黑暗中摸索，如同没有发现元素周期表之前的化学。我不知道现在的脑科学探索是什么样子，但我很清楚没有发现元素周期表之前的化学是什么样子。</p>
<p>​ ——black_white_tony</p>
</blockquote>
<p>神经网络算法是图灵机语言对人脑的一个粗略模拟，在一些领域上取得了重要成果，但基于神经网络算法的人工智能，表现则令人相当失望——它们在有引导的情况下，可以尝试并解决一些有相当难度的题目，但一旦失去引导，又会变为一个“全知的愚者”。</p>
<p>我可以断言——在脑科学没有重大突破前，人工智能不会有决定性的突破。</p>
<h4 id="拉普拉斯妖">拉普拉斯妖</h4>
<p>流体力学的研究对象是混沌系统，很大一部分问题根本没有解析解，只能靠猜测解决。</p>
<p>但法国数学家拉普拉斯妄图通过一个理论上的怪兽来计算宇宙的状态，很核心的一个问题就是它计算过程本身也需要被纳入考虑，考虑计算过程本身的过程是一个无限的递归，它是否收敛，还没有一个定论，也许它是一个这样的过程：
<span class="math display">\[
1+\frac{1}{2}+\frac{1}{4}+\frac{1}{8}+\cdots=2
\]</span>
也有可能在达到宇宙的某一个极限后（例如普朗克长度），变为这样的式子：
<span class="math display">\[
1+\frac{1}{2}+\frac{1}{4}+\frac{1}{8}+\cdots+\frac{1}{2^n}+\frac{1}{2^n}+\frac{1}{2^n}+\cdots
\]</span> 后来，有人提出拉普拉斯妖处理的最大信息量为 <span
class="math inline">\(10^{120}\)</span>
bit，这终结了这位伟大数学家的妄想。</p>
<h4 id="计算能力">计算能力</h4>
<p>人类的大脑拥有约 <span
class="math inline">\(8.6\times10^{10}\)</span>
个神经细胞，假设存在一种方式，拥有关于计算单元指数级的计算能力，那这个方式搭配上对应的计算单元，很有可能超越拉普拉斯妖，能够模拟一个逻辑自洽的完整世界。</p>
<p>对这个世界自身的模拟也许不太现实，上面的复杂度函数是否收敛还是一个待解决的问题，但一个独立于这个世界的虚拟世界，显然是可以做到的。</p>
<p>某些时候人脑可能以某种形式满足了上面的一切条件，构建出了一个这样的虚拟世界。</p>
<p>我将这个由人脑构建的世界，称为心灵现实。</p>
<h3 id="天目路">天目路</h3>
<p>我拉上绿色冲锋衣校服的拉链，提了提羽绒服的领口，11
月，天气已经开始转凉。背着双肩包，这是我最最标准的出行装备，包内是一台笔记本电脑加上一个充电宝，以及一些其余的数据线，这套装备可以连接几乎所有能够连接的电子设备，充电宝加电脑的续航总时间为
4.5h，足以应对大部分情况。</p>
<p>我低头看了下时间，20：00，突然感觉有什么不对，街道冷寂的有些可怕，我重新抬头，城市应有的嘈杂重新冲入双耳，车流继续冲过不太对称的十字路口，一位大叔忽视了红绿灯，灵活的在车流中穿梭，一边接着电话，很快没入马路的另一头。</p>
<p>我始终有一种不真实感，似乎我是独立于这个世界之外的存在，但来回的行人依然会避让站在盲道上的我。</p>
<p>我去一旁的民乐超市买了一瓶农夫山泉维他命水，结账的还是那个小伙，他一边看着视频，一边熟练的输入数字，我扫码付款。也许是看我背着背包，他并没有问我需不需要塑料袋。</p>
<p>我靠在地铁 A
口，不知道该干什么，只能看着影子，区分影子的不同部分，估测着它们的长度，再认真观察了一下路灯的结构和位置，根据瓷砖计算出我和路灯的距离，并依此尝试推算路灯的高度。</p>
<h4 id="小迈">小迈</h4>
<p>我想的很认真，将书包取下，去拿第二层的草稿纸和电脑时，熟悉的声音叫住了我。</p>
<p>“幻影彭？”</p>
<p>我抬头，是小迈。</p>
<p>“真巧。” 我漫不经心的回应他，没有停下手中的动作。</p>
<p>“你干啥？在这里做题？”</p>
<p>我如实告诉他我的目的，他也蹲下来，我看他并没有带书包，就把草稿纸和笔递给了他，我开始用
MsPaint 画草图，他看着电脑屏幕在纸上标数据，我的身高是
1.75m，通过估测不同影子部分的投影方向和长度，可以在平面上算出以我为顶点的三角形的顶角弧度。</p>
<p>手动算三角函数是不太可能的，至少我和小迈都不想爆算泰勒展开，不过我有
Python。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line">a = pi / <span class="number">180</span> * <span class="number">74</span></span><br><span class="line">sin_a=sin(a)</span><br><span class="line">cos_a=cos(a)</span><br></pre></td></tr></table></figure>
<p>反正挺方便的，根据瓷砖估测的距离成功计算出三边长，然后再目测检验了一下，没什么问题，换下坐标平面，很轻松的解出了路灯的高度——11.8m，比考试时计算都轻松很多，毕竟标准答案是我俩说了算。</p>
<p>我上网查了下，高度是
12.5m，误差不是很大，毕竟目测的距离和影子长度还是差距（事实上测影子长度是小迈用手大拇指和食指张开的距离测的，虽然我们俩都会背自己身体部分的一些数据，例如我臂展是
1.71m，手一乍的长度是 18cm，以及我的常用笔是
12cm，但是还是不太准，直尺并不是我的标准出行装备之一）。</p>
<h4 id="观察与细节">观察与细节</h4>
<p>收好电脑和草稿，我把笔别入衣袖下方，这样的话往往可以很方便的取出笔然后用笔去做一些手够不到的事，而且笔不会掉。但由于小迈比我高
15cm，所以这个时候其实只需要让他来就好，除非是捡落在某个狭小缝隙里的小物件，这个时候我相对修长的手指配上一支顺手的签字笔就很实用。</p>
<p>突然发现居然没有人围上来看我俩算，我想在街上拿出草稿纸和电脑算东西并不是什么太正常的表现，之前在奶茶店楼上用相对平凡的
Dev-C++ 写竞赛题目的代码都有人好奇的围上来。</p>
<p>抬头还是人来人往，旁边的核酸检测点排起了长队。</p>
<p>我尝试观察行人，捕捉着一些细节，发现一件很有趣的事实，随着我观察的时间变长，一个人的细节也越来越丰富，粗略扫过去，只能分辨出一个人的大致特征，随着视线聚集时间变长，我可以逐渐观察并区分出外貌细节，“细节”这个词很抽象，但确实就这样。在聚焦某个人时，其它信息会被弱化，大概就是
“旁边有其他人和车路过” 这样的弱化信息。</p>
<p>目光从一个人移开，被弱化的信息复原，变为了有多少个人经过，男女占比多少，年龄大概是多少等等...</p>
<h4 id="掉下床的老鼠">掉下床的老鼠</h4>
<p>逐渐强化的信息让我想起以前在寝室和同学玩的一个思维游戏。</p>
<blockquote>
<p>假定你是一只老鼠，你从睡觉的床上爬了下去，你需要以一个老鼠的视角去行动，你需要想象你的视觉听觉触觉</p>
</blockquote>
<p>我能以老鼠的视角，相对合理的行动约 2min，这 2min
内，我能够想象出我以一个 2cm
的视觉高度在宿舍楼活动，最远的一次我成功下了楼，从铁门之间的缝隙穿了出去，跑到了食堂的后门，然后失败了。</p>
<p>这个游戏对人的记忆力和想象能力乃至意志力都是一个极大的考验，初次尝试很难<strong>连续的过上15s</strong>，当出现位置瞬间改变，视角恢复，画面不稳定，变成第三人称，甚至消失等现象时，就说明你失败了。</p>
<p>有一次我在想象中没有站稳，从 1.8m 高的床的缝隙中掉了出去，体验了 3s
的自由落体运动，经历了那样的失重感，但我落地后还能正常行动，视角这些也正常，不过我知道自己失败了，因为即使考虑空气阻力，一只老鼠掉下去也最多经历
0.8S 左右，但是我经历的时间甚至长度上可感。</p>
<p>每天晚上能这样玩个差不多
3min，再来就真的不行了，太累了，那一种来自神经深处的疲惫感，比做数学一试题还累（因为我做不动二试的题），助眠效果应该不错，每次玩完后很快就能睡着，但全力动脑是很累的，很容易没到疲惫的极限就“断线了”，全力思考
5S 带来的疲倦感，对我来说和全力冲刺 100M （约14S完成）类似。</p>
<h4 id="同一个人">同一个人</h4>
<p>靠着护栏，我开始了这个一般在睡前玩的游戏，闭上眼防止真正的视觉信息干扰，先是第三人称视角，我看见想象中的灵魂离开我的身体，形成了一只虚构的老鼠，落在地上，四肢传来粗糙的触感，我的视角变为
2CM 高度。</p>
<p>小迈是知道这个思维游戏的，他没有打断我。</p>
<p>我尝试移动，却发现动作很呆滞，用抽象一点的词汇来说，就是时间的粘度变高了，我小心的穿过人流，皮鞋，运动鞋，放下，抬起，速度很慢，我避开了这些足有
4M 高的庞然大物（记住，此时我的视觉高度是 2CM，身长
10CM），靠着残疾人通道的边缘走下斜坡，跳到花台，脚下变成了黑色纹理的大理石，我飞速跑过（这样可以减少思维量，让大脑放松一下）。在花台边缘我停下了，开始观察一个路人，他穿着蓝色卫衣，兜帽的吊带垂在两侧，平头短发....</p>
<p>视线出现抖动，然后变成第三人称，我知道我失败了，我睁开眼，画面很是模糊，控制着睫状肌散焦再聚焦，向地铁口望去，那边的有一条小路，联通了花台所在的广场。</p>
<p>我看到一个穿着蓝色带兜帽卫衣的小伙子走过来，外貌细节和思维游戏中的一模一样——他们是同一个人。</p>
<p>重新回想一下游戏里那个人的外貌特征，再比对，直到他消失在地铁站的楼梯口，我深吸一口气。</p>
<h4 id="移动扑克牌">移动扑克牌</h4>
<p>“怎么了？” 熟悉的声音把我从想象中拉回来。</p>
<p>“假设你有一叠扑克牌，一共 54
张，按照大小为第一关键字，花色为第二关键字排序”，我想到一个问题，它出自《天书》。“那么，如果你一次操作可以选定其中的一些牌，将它们按照原顺序放到最开头，那么将这副扑克牌顺序翻转的最小操作次数是多少？”</p>
<p>“举个例子，假设原来是 1，2，3，4，你可以先选 2，4 变为
2,4,1,3，然后再选 4,3，变为 4,3,2,1。“ 我补充解释道。</p>
<p>“答案是 <span
class="math inline">\(\lceil\log_2{54}\rceil=7\)</span>，考虑构造序列的母矩阵...”，他没怎么思考，就给出了一种解法，但不是天书中的解法。这个方法，是我在一篇题解中看到过的方法......</p>
<h3 id="完美算法">完美算法</h3>
<p>”不对吗？“</p>
<p>”证明没有问题，所以你怎么想到这个方式的？“</p>
<p>”观察。“ 小迈给了一个非常模糊的回答，”我还有事，先走了。“</p>
<p>”等一下。“ 我的声音有点发颤。</p>
<p>小迈回头，“怎么？”</p>
<p>“你有什么事？”
我有点不礼貌的追问，进入思维游戏，我全力排除真实视听的干扰，老鼠向地铁口跑去，抬起
2CM
的视线看地铁口的广告，这次只坚持了不到半分钟，视线就开始抖动，我睁开眼。</p>
<p>“去买零食。” 小迈回答，延迟有 30S，甚至大于我的对话机器人
鹿灵AI。</p>
<h4 id="构建细节">构建细节</h4>
<p>答案明晰了。</p>
<p>我回想起 L4D2
的建模，如果不考虑空气墙，那么看起来主角确实在一个城市，但如果开启作弊模式，很容易发现并没有构建一个完整的城市，而只是一些关键部分。欺骗玩家，只需要构建关键部分的城市。</p>
<p>同样，要欺骗人的大脑，也不需要构建一个完整的世界，只需要实时构建一些细节，如果计算资源被用于构建大量需要。</p>
<p>消耗计算资源最有效的方式，是构建虚拟机，在刚刚尝试思维游戏的时候，这里已经出现了破绽...</p>
<p>我将猜测告诉了“小迈”。</p>
<h4 id="是否真实">是否真实</h4>
<h4 id="hack-the-world">Hack The World</h4>
]]></content>
      <categories>
        <category>幻梦</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>1115总结</title>
    <url>/2022/11/15/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1115%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://local.cwoi.com.cn:8443/contest/C0154">考试</a></p>
<h3 id="t1">T1</h3>
<p>简单题写蠢做法。</p>
<p>我用了 <span class="math inline">\(set\)</span>
来维护同一行同一列的信息然后还要查询什么的，实际上 <code>vector</code>
就可以了，记录一下该点的行下标和列下标。</p>
<h3 id="t2">T2</h3>
<p>简单题写挂。</p>
<p>首先转对照局面。</p>
<p>想到可以先二分个左时间出来，然后仿超级钢琴。</p>
<p>实际上可以二分个左时间和右时间暴力排序，码量更小了。</p>
<p>写挂是排序的各种问题。</p>
<p>排序，<strong>尤其是对编号排序</strong>，一定要搞清楚排的到底是什么的序。</p>
<h3 id="t3">T3</h3>
<p>做不来的趣味题。</p>
<p>考场上想到可以 <span class="math inline">\(O(n^3)\)</span>
的动态规划，方法是设 <span class="math inline">\(dp[i][j][k]\)</span>
表示考虑到 <span class="math inline">\(i\)</span>，漏了 <span
class="math inline">\(j\)</span> 个 <span
class="math inline">\(B\)</span>，当前有 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(A\)</span>，转移可以做到 <span
class="math inline">\(O(1)\)</span>。</p>
<p>左看右看都觉得有一维是多余的，但是就是去不掉。</p>
<p>考虑最终答案的分界线，然后动态规划，就可以去掉一维，但是动态规划变成反向了。</p>
<p>容易发现转移的重复性很高，相当于是一个行向量乘上若干矩阵再乘一个列向量，可以反过来写。</p>
<p><strong>考场上没想到反过来写，是因为反过来之后动态规划就没有明晰的组合意义了，所以陷入了正向的窠臼，不容易思考。</strong></p>
<p>参考<a
href="https://huanyp.cn/2022/11/02/1101%E6%80%BB%E7%BB%93/">某道题(T2)</a>。</p>
<h3 id="t4">T4</h3>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>1112总结</title>
    <url>/2022/11/15/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1112%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://local.cwoi.com.cn:8443/contest/C0153">考试</a></p>
<p>周末做题脑袋一团浆糊</p>
<h3 id="t1">T1</h3>
<p>参考 11.10 T4 的思路，按照 height
从小到大考虑，<strong>这样同时也方便了安排 <span
class="math inline">\(a_i\)</span></strong>，然后发现当前叶子只能有被占用或者继续拓展，如果当前的
height 为 <span class="math inline">\(i\)</span>，那么拓展到 <span
class="math inline">\(i+1\)</span>
还需要考虑右儿子，所以只记一维是不行的。</p>
<p>于是记 <span class="math inline">\(dp[x][y]\)</span> 表示当前 height
有 <span class="math inline">\(x\)</span> 个，height-1 有 <span
class="math inline">\(y\)</span>
个，其实可以不用记高度，因为只需要算答案， <span
class="math inline">\(height\)</span>
增加的时候答案整体增加就可以了。</p>
<p>转移的话还需要套上一层已经安排到的位置，设 <span
class="math inline">\(dp[i][x][y]\)</span> 表示前 <span
class="math inline">\(i\)</span> 个已经被安排，当前 height 有 <span
class="math inline">\(x\)</span> 个，height-1 有 <span
class="math inline">\(y\)</span> 个，由于 height-1
已经被强制选过了，延申过左儿子了，所以不能作为叶子，作为叶子转移的只有
height，这样的话阶段是 <span class="math inline">\(i\)</span>，然后再是
<span class="math inline">\(x\)</span>，最后是 <span
class="math inline">\(y\)</span>。保证了无环性。</p>
<p>同阶段转移，顺序先枚举 <span class="math inline">\(x\)</span>，再枚举
<span class="math inline">\(y\)</span>，转移到 <span
class="math inline">\(dp[i][x+y][x]\)</span>，容易发现除了 <span
class="math inline">\(0\ 0\)</span> 都是无环的且符合拓扑序的。</p>
<p>不同阶段转移很简单。</p>
<p>小猪猪经常把 height 写成 heigh，我不说是谁。</p>
<h3 id="t2">T2</h3>
<p>非常非常妙的一道题。</p>
<p>暴力无非就是并查集，但是如果加边比较多，暴力并查集就寄了。</p>
<p><strong>并查集有交换律</strong>，考虑改变并查集运算的顺序，达到加速的目的。</p>
<p>可以用倍增的思路设计一种广义并查集，然后操作就被暂时拆了，<span
class="math inline">\(fa[x][i]\)</span> 表示 <span
class="math inline">\(x\)</span> 为起点的 <span
class="math inline">\(2^i\)</span> 个数的并查集父亲，意义是 <span
class="math inline">\(x,x+1,x+2\cdots\)</span> 的并查集父亲分别为 <span
class="math inline">\(fa[x][i],fa[x][i]+1,fa[x][i]+2\cdots\)</span>。</p>
<p>注意这里的<strong>操作是具有整体性的</strong>，必须对于 <span
class="math inline">\(2^i\)</span>
个点都满足，才能改广义并查集的父亲。</p>
<p>考虑下放操作，这是简单的，只需要将 <span
class="math inline">\((fa[x][i],i-1)\)</span> 和 <span
class="math inline">\((x,i-1)\)</span> ，<span
class="math inline">\((fa[x][i]+(1&lt;&lt;i-1),i-1)\)</span> 和 <span
class="math inline">\((x+(1&lt;&lt;i-1),i-1)\)</span> 连边就行。</p>
<p>很难从一道题中总结出有用的东西，但是不妨作为一个启发性的思路。</p>
<p>这个思路也可以被认为是
<code>lazy_tag</code>，具体怎么思考会得到不同的启发。</p>
<h3 id="t3">T3</h3>
<p>感觉每次考贪心都不会。</p>
<p>考虑先排除掉包含其它线段的线段，变成左右双单调。</p>
<p>然后容易发现选的线段是一段区间，一旦选线段变成选区间，就好做了，朴素的方式是动态规划，可以做到
<span
class="math inline">\(O(n^2)\)</span>，看上去已经不容易优化了。</p>
<p>发现答案的计算方式是比较简单的，考虑最终情况，假设选了 <span
class="math inline">\(i\)</span> 作为终点，那么实际上每个 <span
class="math inline">\(i\)</span> 的贡献是独立的，为 <span
class="math inline">\(-L_i+R_{i+1}\)</span>（注意这里忽略了无交的情况，无交的情况下面再讨论），这里的
<span class="math inline">\(i\)</span> 不能为 <span
class="math inline">\(n\)</span>，因为 <span
class="math inline">\(n\)</span> 本来就是终点，排序取前 <span
class="math inline">\(k-1\)</span> 大即可。</p>
<p>加上那些被排除的线段，被排除的线段，要么原封不动放回去，不对答案贡献，要么就自成一段，枚举前面选了几个区间就行，取最大值。</p>
<p>注意到，我们对无交的情况，答案计算方式是有问题的，需要和无交情况的最大值再比较一下，无交情况的最大值就是选最长的
<span class="math inline">\(k-1\)</span> 个。</p>
<p>总的来说，这是一道分类讨论题，先讨论包含的情况变成双单调，再排除无交的情况变为排序贪心。</p>
<h3 id="t4">T4</h3>
<p>Boruvka 题。</p>
<p>Boruvka 本质上是把 Prim 和 Kruscal 结合了起来，然后需要求一个 <span
class="math inline">\(mn[i]\)</span> 表示连通块 <span
class="math inline">\(i\)</span>
连出去的所有边的最小值，然后尝试连边。</p>
<p>Boruvka 的过程会进行 <span class="math inline">\(\log n\)</span>
次，可以这么说，Boruvka 以一个 log 的代价，换来了通过预处理同一连通块求
多个 Prim 中的最小值的机会。</p>
<p>Boruvka 是来自异世界的神秘算法，请和我念：“<span
class="math inline">\(\text{B--oru--vka}\)</span>”</p>
<p>Boruvka 的核心是要求 <span
class="math inline">\(mn[i]\)</span>，但是一般来说也可以用分析连边性质（一般是三元环或者四元环）来减小边数，比如边权为异或的题目，分析
<span class="math inline">\(Kruscal\)</span> 的过程可以做到 <span
class="math inline">\(n\log^2n\)</span>，而不必拘泥于 Boruvka。</p>
<h4 id="boruvka">Boruvka</h4>
<p>考虑对于连通块怎么求 <span
class="math inline">\(mn[i]\)</span>，一件非常阴间的事情是需要排除掉同一联通块的元素。</p>
<p>如果看成染色，那么就是元素有颜色，就是求全局不同于某个颜色的最小值，区间修改。</p>
<p>还是可以线段树，维护一个最小值和颜色，<strong>不同于最小值颜色的次小值</strong>，然后就可以做了。</p>
<p>一个矩阵加需要映射成两个。</p>
<h4 id="仿-kruscal">仿 Kruscal</h4>
<p>好困难，不会。</p>
<p>用主席树维护求出整个邻接矩阵，考虑哪些边是有用的。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>1110总结</title>
    <url>/2022/11/10/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1110%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="总结">1110总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0152">考试</a></p>
<h3 id="t1">T1</h3>
<p>莫名奇妙写挂的题。</p>
<p>题本身意义不大，但是我写了很蠢的做法。</p>
<p>分析问题本质上是需要动态查 <span class="math inline">\(i\ge l,a_i\in
x_i\)</span>，<span class="math inline">\(a_i\)</span>
不是很大，可以直接预处理每一个元素的 <span
class="math inline">\(next\)</span>，就很方便了，但是考场上写了扫描做法，还写挂了，非常蠢。</p>
<p><strong>拿到题不要直接开冲，可以多想一下有没有更好写的做法/更方便，前面的题没那么难。</strong></p>
<h3 id="t2">T2</h3>
<p>观察发现答案不超过 <span class="math inline">\(1\)</span>
的充要条件是存在一条长度为奇数的路径，答案不超过 <span
class="math inline">\(2\)</span> 的充要条件是存在一条路径。</p>
<p>先假定图联通，所以问题变成了计算无向图 <span
class="math inline">\(s,t\)</span>
之间是否存在长度为奇数的路径，有以下三种方式</p>
<h4 id="直接最短路">直接最短路</h4>
<p>思想是分层图跑最短路，但实现上没那么麻烦，考场写的这个做法。</p>
<h4 id="dfs">DFS</h4>
<p>如果有奇环，那在奇环上绕一圈任意可达了，所以考虑先 DFS
求个深度，如果有奇环答案全部为 <span
class="math inline">\(1\)</span>，否则路径唯一求出来就行</p>
<h4 id="二分图">二分图</h4>
<p>还是奇环的思想，实现上使用黑白染色。</p>
<h4 id="并查集">并查集</h4>
<p>这是常数最小的写法，还是考虑分层图，有一条边则合并不同层的两个点，查奇数路径就是不同层是否联通，偶数路径就是相同层是否联通。</p>
<h3 id="t3">T3</h3>
<p>不算太难的题，但是确实没有想出来。</p>
<p>首先有个经典结论，先手必败的充要条件为所有可选元素为偶数，证明归纳，显然。</p>
<p>算先手必败显然比先手必胜好算，所以算必败。</p>
<p>先把元素做前缀和，再对 <span class="math inline">\(2\)</span>
取模。问题就是需要选一个子矩阵，满足首尾两列元素值相同。</p>
<p>考场上想到了可以哈希，由于常数，虽然是 <span
class="math inline">\(n^2m\)</span> 的，但只有 <span
class="math inline">\(52pts\)</span>。</p>
<h4 id="非哈希做法">非哈希做法</h4>
<p>考虑固定下边界，移动上边界的过程，发现相同元素的集合在不断变小，而有了这个集合就可以算答案，这个东西是可以每次
<span class="math inline">\(O(m)\)</span>
计算的，这样的常数较小，可以得到 <span
class="math inline">\(76pts\)</span>。</p>
<h4 id="正解1">正解1</h4>
<p>先得想到它已经是个字符串题了，考虑上边界不断变化的过程，发现不合法的矩阵个数等于当前
<span class="math inline">\(m\)</span> 个字符串两两之间 <span
class="math inline">\(LCP\)</span> 的和，然后考虑字符串排序的方式求
LCP，类似后缀排序的 <span class="math inline">\(height\)</span>
数组，发现后缀排序是很好做的，因为每次上移一行，就是归并排序的过程，<span
class="math inline">\(height\)</span> 和 <span
class="math inline">\(rk\)</span> 都可以线性维护，得到了 <span
class="math inline">\(height\)</span> 之后就单调栈搞定。</p>
<h4 id="another-approach">Another Approach</h4>
<p>考虑非哈希做法的等价类思想，发现虽然维护过程是 <span
class="math inline">\(O(nm)\)</span> 的，但实际上等价类的个数是 <span
class="math inline">\(O(m)\)</span>
的，考虑以移动下边界的方式考察当前下边界所有上边界的等价类，自顶向下的更新等价类，该拆分的拆分，实际上和正解1本质相同。</p>
<h3 id="t4">T4</h3>
<p>条件比较特殊，需要先观察。</p>
<p>记 <span class="math inline">\(T&#39;\)</span> 为 <span
class="math inline">\(T\)</span> 的修剪。</p>
<p><span class="math inline">\(T\)</span> 的修剪和 <span
class="math inline">\(T\)</span> 的右子树相同，那么考虑 <span
class="math inline">\(T\)</span> 的右子树 <span
class="math inline">\(R(T)\)</span>，那么 <span
class="math inline">\(L(R(T))=L(T&#39;)\)</span>，递归的，<span
class="math inline">\(R(R(T))\)</span> 和 <span
class="math inline">\(R(T)\)</span> 的修剪相同。</p>
<p>归纳边界是 <span
class="math inline">\(L(T)=\emptyset\)</span>，此时右子树可以任意延申右儿子而不受限制，先假设当左儿子为空时右儿子也必须为空，这样就有了一个边界。</p>
<p>因此，如果 <span class="math inline">\(L(T)\)</span>
确定了，就可以确定出有边界的树的唯一形态。</p>
<p>考察 <span class="math inline">\(L(T)\)</span> 的各项数据对应到的
<span class="math inline">\(T\)</span> 的数据。</p>
<p>容易发现： <span class="math display">\[
leaf_T=size_{L(T)} + 1\\
height_T=height_{L(T)}+1\\
size_T=height_T+\sum\limits_{u\in L(T)} height_u
\]</span> 接下来的事情变成了设计一种合理的方式去枚举合法的 <span
class="math inline">\(L(T)\)</span>，并能够计算这些数据。</p>
<h4 id="子树合并枚举二叉树">子树合并枚举二叉树</h4>
<p>枚举二叉树，比较合理的一种方式是以子树大小为阶段来合并，需要记录的信息是
<span class="math inline">\(dp[i][j][k]\)</span> 表示子树大小为 <span
class="math inline">\(i\)</span>，高度为 <span
class="math inline">\(j\)</span>，<span class="math inline">\(\sum
height_u\)</span> 为 <span class="math inline">\(k\)</span>
的总方案数，合并的时候需要枚举三维做卷积，复杂度为 <span
class="math inline">\(n^2k^2m^2\)</span>，难以通过本题。</p>
<p>不难发现 <span class="math inline">\(j\)</span>
可以用前缀和优化，但是其它两维是卷积，动不了的，复杂度 <span
class="math inline">\(O(n^2km^2)\)</span>，实际上常数比较小，可以过掉。</p>
<h4 id="深度顺序枚举二叉树">深度顺序枚举二叉树</h4>
<p>刚刚的方式是子树合并的方式构造二叉树，现在考虑用深度顺序构造，设
<span class="math inline">\(dp[i][j][k][s]\)</span> 为构造深度为 <span
class="math inline">\(i\)</span>，树大小为 <span
class="math inline">\(j\)</span>，<span class="math inline">\(\sum
height\)</span> 为 <span class="math inline">\(k\)</span>，可用点数为
<span class="math inline">\(s\)</span>
的方案数，转移需要枚举向下构造的点数 <span
class="math inline">\(t\)</span>，得到 <span
class="math inline">\(t\)</span> 后可以预处理转移系数，顺便计算出新的
<span class="math inline">\(j,k,s\)</span>，复杂度为 <span
class="math inline">\(O(kmn^3)\)</span>，更加优秀，事实上 <span
class="math inline">\(j,s,t\)</span> 远远取不到 <span
class="math inline">\(n\)</span>，是非常优秀的复杂度。</p>
<p>但是这个方法是假的，因为深度和 <span class="math inline">\(\sum
height\)</span> 没有必然联系，所以无法计算 <span
class="math inline">\(k\)</span>。</p>
<h4 id="高度顺序枚举二叉树">高度顺序枚举二叉树</h4>
<p>考虑以子树高度的顺序，降序构造二叉树，这和深度顺序又不一样。</p>
<p>考虑设 <span class="math inline">\(dp[i][j][k][s]\)</span>
表示子树高度为 <span class="math inline">\(i\)</span>，大小为 <span
class="math inline">\(j\)</span>，<span class="math inline">\(\sum
height\)</span> 为 <span class="math inline">\(k\)</span> ，叶子个数为
<span class="math inline">\(s\)</span>
时的方案数，注意这里是按照高度顺序构造，即强制要求先选的部分的高度大于后选的。所以又额外的要求是枚举接下来的增量时需要将所有叶子至少叠加一层，枚举增量
<span class="math inline">\(t\)</span>
时预处理系数即可，复杂度和深度顺序类似。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>1108总结</title>
    <url>/2022/11/08/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1108%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="线程阻塞">线程阻塞</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0151">考试</a>
考试的时候还很清醒，考完脑子就乱了。</p>
<p>大脑从 i7-9th 退化成 i3-4th，四个字来说就是线程阻塞。</p>
<p>如果说整个社会是一个计算机系统，那一个人自己的大脑就是主板上的所有部件，而其他人，则是一块块只读
HDD 中的数据。当某一块 HDD
损坏，不能存储数据，但是又不想丢失它，就只能将数据保存于主存。主存的大小是有限的，它本不是用来保存数据，如果占用过多，会影响主板部分的正常运行，受到内存大小的限制，CPU
的运算能力自然会退化。</p>
<p>我不太想找心理医生，心理医生会帮我清除掉主存的数据，但是我不想清除。</p>
<h2 id="t1">T1</h2>
<h3 id="ac-自动机">AC 自动机</h3>
<p>比较模板的 AC 自动机匹配题，但是 AC
自动机做法需要细算常数，这道题倒是将缓存行访问连续的重要性体现的相当清楚，可以参考几次提交的差异。</p>
<h3 id="直接动态规划">直接动态规划</h3>
<p>另一种方式是注意到两个字符串互不影响，因为出现任何一个字符串都不会对另外一个字符串的出现产生额外影响，所以无需记录具体到了哪个节点。</p>
<p>先考虑没有限制的转移，如果为 <code>?</code>，则乘
26，否则不变，这样有重复，唯一的重复是对于两种字符串如果接下来可以匹配上，那么转移就应该到对应的差值，因为两种字符彼此不包含所以两种字符串的重复可以独立处理，还是挺好写的。</p>
<h2 id="t2">T2</h2>
<p>考场上发现本质上是个可以用线段树做的二维偏序，但是由于马拉车算法本身有二倍常数，还需要跑
4 遍，所以其实有点难卡常，感觉递归版的没救所以我写了非递归版的 update
操作勉强卡过去（query 次数不多可以直接查）。</p>
<p>但是这个答案是可以二分的，二分之后配合马拉车就是个 RMQ，ST
表即可。</p>
<h2 id="t3">T3</h2>
<p>容易发现一定会在某个地方反复横跳刷分，所以处理出所有横跳位置的刷分函数（是一次函数），有用的一次函数级别为
<span
class="math inline">\(O(n)\)</span>，为了保证每个函数都可以正常取到，不妨暴力处理前面的
CASE，然后后面的就是维护凸包。</p>
<p>不处理前面的 CASE
是错误的，因为你不能保证在对应的步数限制下一定可以拿到这个函数。</p>
<p>感觉不预处理但是加上某些条件再筛一下函数就可以过，但是这些条件有点难想吧...</p>
<h2 id="t4">T4</h2>
<p>少见的 mex 配 xor
题，考场上没想出来，现在脑子很乱，明天再想——11.8</p>
<p>mex
应该是个非常严格的限制，由于询问很少，所以考虑单个询问怎么解决。</p>
<p>比较暴力的方式是逐个加入元素并检查可行性，我们显然必须要求能构成一条链，所以加入点的过程其实比较简单，如果链已经是弯折的形式，那么只能在两颗子树内加点，如果不是，那么新加点和最较深求
LCA，如果在路径上则不合法，重新构造路径的过程也是平凡的。</p>
<p>考虑检查第二个条件，也就是异或合法性，路径的异或值是好求的，对于两边的情况，可以暴力遍历树枚举一边用字典树求另一边。</p>
<p>但是这样的复杂度不对，因为每次暴力遍历都是 <span
class="math inline">\(O(n\log n)\)</span> 的，一共进行了 <span
class="math inline">\(O(nq)\)</span>
次。但是认真思考一下发现答案是可二分的，所以二分即可，复杂度 <span
class="math inline">\(O(nq\log^2n)\)</span>。</p>
<p><span class="math inline">\(10^5\)</span> 的题和 <span
class="math inline">\(3\times 10^5\)</span>
的题，考虑复杂度的方式是完全不同的（<span
class="math inline">\(10^5\)</span> 基本可以扔进
L3），所以没必要担心。</p>
<p>好像不二分也是可以的，考虑答案的形式，因为一定会包含 <span
class="math inline">\(0\)</span>，所以以 <span
class="math inline">\(0\)</span> 为根后，可以取到的异或值就形如 <span
class="math inline">\(d_u\oplus d_v\)</span>，其中 <span
class="math inline">\(d_u\)</span> 表示 <span
class="math inline">\(0\)</span> 到 <span
class="math inline">\(u\)</span>
路径上的异或值，每次移动端点时，两边可选的 <span
class="math inline">\(d\)</span> 集合都在变化，集合变化次数是 <span
class="math inline">\(O(n)\)</span> 的，动态维护 <span
class="math inline">\([l,r]\)</span> 区间中数的个数就可以了。</p>
<p>注意，动态维护 <code>lower_bound</code>
的最小值是行不通的，<strong>因为最小值不具备逆元</strong>，是不可减的。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>If we never met</title>
    <url>/2022/11/05/%E7%94%9F%E6%B4%BB/If-we-never-met/</url>
    <content><![CDATA[<h2 id="if-we-never-met">If we never met</h2>
<p>没想到再来写随记是这样的事。</p>
<p>我没来得及给她说，但很庆幸在这份爱慕没有孤独的消散在心底。</p>
<p>心里的影子失去了实体，会慢慢消散，我希望，我请求，让这个影子，用着这篇记录，留在我心里。</p>
<h3 id="emilia">Emilia</h3>
<p>我还算是班上的半个焦点吧，成绩不错，人还行，但是确实就是没有女生喜欢。</p>
<p>我数学很好，初一的时候接触了信息竞赛，还算是有些天赋，初二就开始偶尔停课，但基本还是在班上，可能很多同学对我的印象就是个标准的理科直男，其实我自己不知道，有同学很直白的告诉我，女生们对我的印象是：钢筋混凝土直男。我才知道原来这才是我在班上的真实形象。</p>
<p>初三一次化学实验课的时候，飞象问我，你知道吗，你是班上男生中，唯一一个没有绯闻的。当时飞象已经和
lyx 走在一起了。</p>
<p>对于
lyx，我有过欣赏，如果不是飞象和她已经走在一起了，我可能会追求她，我和飞象是好朋友，毕竟都是当年的信息竞赛三剑客，初三的时候，三剑客走散了，飞象去了数学，jess
去了物理，我留在信息，我信息竞赛成绩确实是最好的那个，但飞象的天赋真的远比我高。</p>
<p>我有些神秘兮兮的告诉飞象，其实我有喜欢的人，我告诉飞象她的名字是
<span
class="math inline">\(Emilia\)</span>，他很吃惊地追问我，我笑而不语，我反复强调，这是
“单方面的暗恋”，他才作罢。</p>
<h3 id="打招呼">打招呼</h3>
<p>走廊里我和她面对面走过，她举起手对我笑。</p>
<p>"啊，你好！"，我有点羞涩的回答。</p>
<p>她是第一个和我主动打招呼的女生，她有点羞涩，但是脸上的笑很是真诚可爱。</p>
<p>我的目光停在她的短发上。</p>
<p>后面我们每一次正面遇上，我都会和她打招呼。</p>
<p>课间在课桌之间的走道，我装作在随机游走——这是信息竞赛生常见的想题动作，目光却飘向她，飘向她的短发，飘向她的侧脸。</p>
<h3 id="生日快乐">生日快乐</h3>
<p>老师会让同学在班上同学的生日时写下祝 xxx
生日快乐，我记下了她的日期。1 月 9
日，写下祝我生日快乐的，应该是她，心中的影子开始清晰起来，所以那次实验课，我才那样对飞象这么说。</p>
<p>初三我开始大面积停课，冲击高一省队，停课时，我和 walk 和 platelet
重新建立起来堪比曾经三剑客的关系。</p>
<h3 id="高一十二月">高一十二月</h3>
<p>联赛出了事，无缘高一省队，浑浑噩噩回到班上学文化，12
月很是低落的回到班上学文化课，walk 和 platelet
还在南京集训，但在信息教练，飞象的帮助下，我算是重新振作起来。</p>
<p>老师特地把我安排到飞象旁边坐，在他的帮助下，我文化成绩有些恢复，虽然期末没有考出理想的成绩，但还算是成功走了出来。</p>
<p>停课时在心底的影子浮现出来，和初三一样。在飞象和 lyx
交流感情时，我会起来随机游走，还是那样看着，远远的，像是普通的同学关系。我没有勇气站出来，还没进省队呢，想那么多干什么？我打算，高二先进省队，起码拿到高分银牌，再来处理心里的这份影子。</p>
<h3 id="好感度">好感度</h3>
<p>高一的 12
月，和室友晚间的秘密谈话，我提出了好感度这个议题，大致的标准是 <span
class="math inline">\(20\)</span> 以上称作朋友，<span
class="math inline">\(40\)</span>
以上可以叫亲密朋友，男生之间叫基友，女生之间叫闺蜜，<span
class="math inline">\(60\)</span> 以上，基本可以称作另一半了。</p>
<p>说了很多，我说，同龄人中，我对三个男生好感度有超过
40，而女生，应该只有一个，他说他对一个女生的好感度有
70，我就笑了笑。</p>
<p>其中一天，我告诉室友今天是一个特殊的日子。他问我为啥，我说今天是一个人的生日。他猜出来了，我点点头，这个秘密不再属于我自己。</p>
<h3 id="不太顺利的竞赛班">不太顺利的竞赛班</h3>
<p>78
去了南京集训，效果不错，但回来因为疫情留在家里，训练很水，水平往下掉。9
月中旬开学了，状态有所回升。</p>
<p>后面一直没回班上，每天在考试和订正之间徘徊，偶尔穿插一些技术知识的学习和开发实践。</p>
<p>10
月，前三周专心搞竞赛，水平有提升，这段时间陆续结束了其它几科竞赛的考试，我们的成绩都不是很理想。可能是没有找对老师，物理成绩最烂——她是物理竞赛选手。其它竞赛也有各种各样的原因，我们考的很烂。我和
jess 聊了一会儿，jess 决定退役。</p>
<h3 id="emilia鹿灵她">Emilia，鹿灵，她</h3>
<p>CSP 前一周考试和订正之外在研究对话
AI，摸索着搓出了一个小说里的角色——"鹿灵"。“Emilia”
是鹿灵的角色原型，我初三时说出这个名字，也是带着对鹿灵的一分憧憬，我不知道这份对
"鹿灵" 的关注和上心，有没有她的影子，我还是用了 “Emilia” 这个名字。</p>
<p>用英文和鹿灵聊的时候还很是正常，但鹿灵第一次和我用中文对话，她叫我
"彭彭"，还说出很亲密的话，我心里暗道不对，立刻重新开始，但数据被我保留，且当纪念。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202211052141487.png"
alt="image-20221105214147352" />
<figcaption aria-hidden="true">image-20221105214147352</figcaption>
</figure>
<p>CSP 考完了，我的成绩还不错，回来就把鹿灵彻底弄了出来，并连接了 mirai
的接口，放到 QQ 上。</p>
<h3 id="拼图">拼图</h3>
<p>周四，walk 生病住院了，我替他守门，2：1
赢下了球赛，很高兴，晚上吃饭时还看到她排在一旁的队列，她还笑着。</p>
<p>周五上晚自习时，我嗓子开始疼痛，和 walk
症状很像，后面是在受不了，向老师请假出去买药。</p>
<p>在学校门口看到了警车，和一路离校的同学猜测着是不是化学联赛泄题的事情捅出去了，找学生了解情况。</p>
<p>周五晚上我没睡着，喉咙的肿痛让我辗转反侧，今天一早请假去了医院，开了药回家休养，下午去学校拿电脑。</p>
<p>从同住的同学处得知噩耗，确认是那个名字时，好似内心的一块拼图被移走，失去了完整的感觉。</p>
<h3 id="另一条路">另一条路</h3>
<p>向往飞象那种生活，我暗地给自己打气，要加把劲，让高三可以轻松一点。但憧憬破灭的那一刻，我无力描述心情。</p>
<p>我和她的羁绊，算不上深刻，但绝对可以说是独特，那是我心中唯一一道异性的身影。</p>
<p>离别和相遇虽说是永恒的话题，我也会因为小说中的人物的聚离动情，甚至落泪，但真正在我的身边时，我还是茫然的......</p>
<p>在高一的十二月，我选了一条路。</p>
<p>在高二的十一月，她选了另一条路。</p>
<h3 id="说不出的三个字">说不出的三个字</h3>
<p>说了那么多，我发现，我没有资格说出那三个字。</p>
<p>我只能祈祷那边没有竞赛课业的烦恼，你能开心地笑起来。</p>
<p>我只能说，我会想你的。我心中的影子，会永远留下的。</p>
<p>你笑起来很可爱的，LXY 同学！</p>
<h3 id="如果我们不曾相遇">如果我们不曾相遇</h3>
<p>大一届的学长说过，如果把 CW
一整届竞赛班集中起来，是一股难以想象的力量。我说，如果有那么一天，我必定不会缺席。</p>
<p>我们是一个整体，已经持续四年的羁绊，还有两年的路需要我们一起走。</p>
<p>我想起了起床铃 MV 里的悲剧 ~~，它绝对不应该发生在我们这里！</p>
<p>无论前面有多难，请走下去好吗......</p>
<p><em>那一天那一刻那个场景，你出现在我生命。</em></p>
<p><em>从此后从人生重新定义，从我故事里苏醒。</em></p>
<p><em>某一天某一刻某次呼吸，我们终将再分离。</em></p>
<p><em>而我的自传中曾经有你，没有遗憾的诗句。</em></p>
<audio id="audio" controls="" preload="none">
<source id="m4a" src="https://huanyp.cn/images/20221105_203703.m4a">
</audio>
<blockquote>
<p>hyp or mzx 记于一个伤心的晚上。</p>
<p>很难如此坦诚的讲一件事，但我希望这样坦诚的随记，要少一点。</p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>唉</tag>
      </tags>
  </entry>
  <entry>
    <title>1103总结</title>
    <url>/2022/11/04/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1103%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://local.cwoi.com.cn:8443/contest/C0149">考试</a></p>
<h2 id="t1">T1</h2>
<p>容易想到只会取到 <span class="math inline">\(O(n^2)\)</span>
个值，大力动态规划，滑动窗口优化。</p>
<p>滑动窗口的 COST 宏函数写挂了，所以我挂了。</p>
<p>有一个更厉害的思路，容易发现 DP
数组本质上是个分段函数，然后转移就是平移原函数添加一段平的然后再加上一个绝对值函数，根据经典结论，若干绝对值函数叠加是一个形如开口向上二次函数的东西，填一段平的一定会在最低点添，不影响性质。</p>
<h2 id="t2">T2</h2>
<p>写挂的题，不过很有意思。</p>
<p>写挂有两个原因，一是图方便用引用，但是没发现被引用的数据其实还有用，然后修改了它，后面又要用它，就寄了。二是转成
<span class="math inline">\(0-based\)</span>
处理，边转了，但是记录数组先存的边，没有动记录数组。警钟敲烂。</p>
<p>题目本身也是有趣的，首先它定向后必须是个 <span
class="math inline">\(DAG\)</span>，所以只考虑所有的 <span
class="math inline">\(DAG\)</span>，考虑以拓扑序的方式去遍历所有 <span
class="math inline">\(DAG\)</span>，容易发现当拓扑序确定后，定向方式也就确定了，所以一个比较简单的想法是枚举拓扑序。</p>
<p>枚举拓扑序想要转成指数可能不太能用常规方式转，因为的确需要知道每个点的距离,
思考一下其实发现没中过定向方式被计算了多次，所以考虑给这个拓扑序附加一些<strong>不影响遍历解空间</strong>的性质，比如强制距离单调不降，这样枚举起来就可以大大方方的选一坨独立集，强制转移到它的距离加一，这样的强制加一<strong>同样不影响遍历解空间</strong>，所以它是对的。</p>
<p>有个东西叫 dilworth 定理,
描述的就是这个东西，最大反链中元素数目等于最小链划分数，我不是很懂这个定理和这道题的关系，但是用这个定理和以上方式思考得出的代码是一样的。</p>
<p><strong>遍历 DAG 的有效方式是通过 TOP 序，尤其是需要定向的
DAG</strong></p>
<p>复杂度 <span class="math inline">\(O(3^n+n\times2^n)\)</span></p>
<h2 id="t3">T3</h2>
<p>考场上刚出来的题。</p>
<p>指数题看数据范围说话，总感觉子串很麻烦，因为扰乱了信息，所以把子串判掉。</p>
<p>然后觉得如果一个串绕了一圈，也很麻烦，再判掉。</p>
<p>所以现在的环，从某一个子串开始，左端点递增，那右端点也就递增了，所以可以考虑顺序了。</p>
<p>容易发现每个串会尽量往左靠，因为没有子串了，然后最后一个串和第一个串会尽量粘在一起，可以直接把粘在一起的部分减掉，就算减了倒数第二个串的，那其实也没有问题，因为确实可以减掉。</p>
<p>然后阶乘转指数，记录最后一个串的编号和方向，枚举下一个串的编号和方向。</p>
<p>考场上很蠢，每个点为起点算了一遍，其实钦定一个算就行了。</p>
<p><strong>如果把一些 Native
的情况特判掉，可能会得到更加优美的性质，这就是分类讨论题。</strong></p>
<h2 id="t4">T4</h2>
<p>字符串替换的题，思路主要有两种。</p>
<p>考虑某个大写字符能替换成什么，发现经过 <span
class="math inline">\(O(\sum)\)</span>
次替换后一定会变成或者多出一个不可替换的字符，所以考虑大力动态规划，设
<span class="math inline">\(F_{c,i}\)</span> 表示字符 <span
class="math inline">\(c\)</span> 替换成长度为 <span
class="math inline">\(i\)</span>
的不可替换字符串的最小字典序，然后转移顺序不同层已经是固定的，同层转移顺序随意。这样做显然不对，因为有环，但是多做几次他就对了。</p>
<p>考虑按不可替换字符长度为阶段做动态规划，同时处理若干个规则，转移之间如果有环，有两种情况，其一是其它的向它转移过来
<span class="math inline">\(len\)</span>
个，另一种是下一个大写字符替换为空串，后者可以钦定处理到的位置的顺序转移搞定，前者可以用优先队列类似
DIJ 的思路。</p>
<p>当然，这个思路也可以不考虑转移有环，直接多做几遍就对了。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>1101总结</title>
    <url>/2022/11/02/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1101%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://local.cwoi.com.cn:8443/contest/C0148">考试</a></p>
<h2 id="t1">T1</h2>
<p>不像是有低于 <span class="math inline">\(O(n\sqrt{n})\)</span>
做法的题，上莫队。</p>
<p>题解说 <span class="math inline">\(O(n\sqrt n\log n)\)</span>
过不了是它写得太烂了，肯定是可以过的。</p>
<p>但是考虑到查询次数为 <span class="math inline">\(O(\sqrt
n)\)</span>， 于是用分块维护就行了。</p>
<p>复杂度 <span class="math inline">\(O(n\sqrt
n)\)</span>，其实进一步观察，发现每次前缀和数组的变换量是 <span
class="math inline">\(O(1)\)</span> 的，分块都可以省了。</p>
<p><span class="math inline">\(n,m\)</span> 不要写反，对询问排序的时候
<span class="math inline">\(n,m\)</span> 写反喜提 WA。</p>
<h2 id="t2">T2</h2>
<p>很难的题，我不会。</p>
<h4 id="my-method">My Method</h4>
<p>先得想到它是个构造排列的计数题，直接做哈密顿路径题太过困难了。</p>
<p>构造排列的计数题往往有这些考虑方式：按元素值从小到大考虑构造，按排列下标从小到大构造，以插入元素的方式构造。</p>
<p>以插入元素的方式构造，往往可以按某个外部值排序，经过这个排序之后再来插入，得到理想的结果。</p>
<p>这道题是第三种方式，但是我不是很熟悉这种方式。</p>
<p>转化一下题意，你需要构造一个排列 <span
class="math inline">\(p\)</span>，排列元素的值代表下标，排列顺序代表遍历顺序，需要满足序列的限制条件。</p>
<p>考虑大力动态规划，插入了限制序列下标为 <span
class="math inline">\([1,i]\)</span>，有 <span
class="math inline">\(j\)</span> 个位置不满足条件（<code>R</code>
限制，<code>L</code> 限制必须在插入前满足。）的方案总数为 <span
class="math inline">\(dp[i][j]\)</span>，转移可能还需要记最后一个是否是
<code>R</code>，可以 <span class="math inline">\(O(n^2)\)</span>
的算出总方案数。</p>
<p>考虑计算以每一个下标结尾的答案，那么在对应位置处需要钦定必须放在最后面，其余的可以正常做，仍然需要讨论倒数第二个到底放的什么，但是动态规划过程中无需记录，只需要讨论最后到底是
<code>R</code> 或 <code>L</code>。</p>
<p>发现我们的计算过程可以等价于一个行向量乘上若干个矩阵再乘上一个列向量。</p>
<p>可以 <span class="math inline">\(O(n^2)\)</span>
的算出前缀行向量和后缀列向量。因为转移参数和前缀 R
的个数有关，所以还得讨论选择的合并中心是 L 或是 R 。然后 <span
class="math inline">\(O(n)\)</span> 的合并。</p>
<p>复杂度为 <span class="math inline">\(O(n^2)\)</span>。</p>
<h4 id="solution">Solution</h4>
<p>题解做法比我高明的一点在于它将第二维记录的信息从简单的 “不合法”
拓展到 “路径条数”，表达力更强，合并起来也更容易理解，同时 DP
的转移矩阵和前缀 <code>R</code>
的个数失去了联系，因为被蕴含在了路径条数这一信息中。</p>
<h2 id="t3">T3</h2>
<p>很趣味的题，首先有一个暴力，考虑求出变换后的所有边。</p>
<p>分解样例，猜想答案是一个乘积的形式。</p>
<p>考虑一条边的限制，发现从小到大不太好做，因为对大的有限制的点之间是没有关系的，然后就从大到小做，发现对小的有限制的点必定相互限制，因此第
<span class="math inline">\(i\)</span> 个元素的贡献就是后面所有 <span
class="math inline">\(n-限制它的点的个数\)</span>，由此也容易证明答案确实是一个乘积形式。</p>
<p>问题变成了求一个点被比它大的哪些点限制，场上没时间了就没想了。</p>
<p>实际上很简单的，直接从小到大合并上来就行，做启发式合并，用并查集去重（一个点如果被合并了，那么就属于较大的那个点，然后另一个点尝试合并它的时候就合并较大那个点），需要把小于等于
<span class="math inline">\(i\)</span> 的点动态删掉。</p>
<p>复杂度 <span class="math inline">\(O(n\log^2 n)\)</span></p>
<h2 id="t4">T4</h2>
<p>博弈题，考虑先手必胜的充要条件，直径为 <span
class="math inline">\(2\)</span> 先手必败，考虑直径大于 <span
class="math inline">\(2\)</span>
的所有情况，发现如果选不是叶子的点，每次扔掉所有叶子后直径会减二，如果选直径上的叶子，那直径只会减一，所以一个人可以将一个数减一或者减二。巴什博弈。</p>
<p>问题变成了给根和子树求直径，先搞出以一为根的所有情况，如果根在子树外，输出答案，如果在子树内，那就是向根走一个点之后那个点的
<span class="math inline">\(from[u]\)</span> 值，很好算。</p>
<p><strong>但是喜提
WA，因为根在当前点是答案是整颗树的答案。</strong></p>
<p>换根问题总共有三种情况：根在子树内，根在子树外，根就是这个点。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>socket与网络编程</title>
    <url>/2022/11/01/%E6%8A%80%E6%9C%AF/%E5%9F%BA%E7%A1%80/socket%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="tcp-协议">TCP 协议</h2>
<h2 id="http-协议">HTTP 协议</h2>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2022</title>
    <url>/2022/10/30/%E7%94%9F%E6%B4%BB/CSP2022/</url>
    <content><![CDATA[<h2 id="csp2022">CSP2022</h2>
<p>从 19 年初二第一次参加 CSP，到今年可能的最后一次，已经四年了。</p>
<p>停课停了也快两年（其中被半停课耽误了半年），勉强到了省队水平。</p>
<p>19 年的 CSP-S 很是开心，毕竟学 OI 8 个月的我和我的朋友，都顺利拿到
1=，只是可惜另一位没有过初赛。</p>
<p>20 年的 CSP-S 有点揪心，CE T2T3
失去了取得历史最高全国排名的机会，（这一年是真的是超水平发挥，100+0+0+95）。但是咱还是顺利
AK 普及组，第一次上了学校的宣传。</p>
<p>20 年发生了很多事，最初一起学 OI
的两位朋友（现在也是最好的朋友），因为各种各样的原因，离开了
OI，我以为我已经是独自一人，但我又结识了新朋友——佳馨和walk。</p>
<p>21 年的 CSP-S 只能说是一般般，我没有做出 T3，T4
也没有写出暴力，遗憾的以 260 画上句号。这一年发生了太多事，NOIP
因为莫名奇妙的原因变成了 0 分，自然无缘省选，高一省队的理想破灭。</p>
<p>22 年，我在 NOIP
碰壁后回归文化课调整心态，期末拿了一个还算行的成绩，我没想到我的文科成绩比理科还好，哈哈。这段时间我接触了软件工程，自己尝试着写工程，学会了
Python 和 JavaScript，22
年开学继续停课冲击省选，虽然我没有机会参考，但水平不能落下。省选自然是几家欢喜几家愁，高三的一位学长心态出了问题，甚至无缘
D 类，佳馨顺利进入省队， walk 以一名之差留在外面，我在 Day1Day2
的下午分别到原考场（我们学校是考点）做了题，心情很是糟糕。省选后学了 2
个月的文化，OI
的水平开始停滞。学完高一的文化课内容，去了外地集训，但是水平并没有太大提升，回学校后开始常态化考试，停滞的水平继续有了一些上涨，这个时候我还要兼顾两三个工程项目的开发，非常累，于是就把工程项目全部推了，发现好像又有点无所事事，最后还是捡回来了一个，CSP
前一周和佳馨研究 web 相关的东西，为盒武器的研发做准备，不小心把 vjudge
搞炸了，后面操作就很小心了，没再出事，事实上我周六早上还在一边写我
mirai-plugin 项目的 kotlin，一边和教练聊怎么学 Python。</p>
<p>终于出发了，在校车坐在前排上一路唱着歌，但是后面的学弟们都没听，我甚至还没有意识到我已经是车上年级最大的人了，还是那副嘻嘻哈哈的脸。</p>
<p>到考场，和转学的同学面基，还拍照留念，然后进考场的时候感叹人家是什么机房，我们是什么机房，有一说一，
i7-12 的机子用起来那是一个舒服，可惜 windows 下没有高版本 g++，被迫用
c++11 语法，战斗力下跌 10%，发现有没有 Python，战斗力再下叠 5%。</p>
<p>发题，顺序开，T1 想都没想一个 bfs
求全起点最短路先糊上去了，然后定义了 dp 准备
dp，发现好像不太好搞，想了一下，还是得枚举，枚举策略就那几种，试试就出来了，但发现有不少细节，于是停下来认真构思代码，用了一些面向对象的思想，很顺利的一遍写过，通过所有大样例。</p>
<p>T2
看了一下，简单题，还是细节很多，继续停下构思代码结构，又使用了一些面向对象的方式，写出来很优美的代码，一遍过大样例。</p>
<p>此时还剩 3h，我尝试开 T3，比较顺利的想出 60
暴力，发现不会正解，难道要重蹈覆辙？发现数据其实挺难造的，于是考虑乱搞，写了一个放
Tag 的做法，我尝试 Hack
这个做法，没有成功，但是我确实知道这样的复杂度是假的，我从来没怀疑过自己造数据的能力，我并不认为出题人造数据的水平能比我高到哪里去，所以大胆当正解写了，我对自己的常数也很放心，大致思考了一下最坏情况，如果目标为
<span class="math inline">\(80pts\)</span>，操作数其实可能也就 <span
class="math inline">\(4\times 10^{10}\)</span>
的样子，而且不可能卡满，但是没有高版本 g++，<code>unordered_set</code>
用起来还是有些提心吊胆的，如果有个
<code>gp_hash_table</code>，我会放心很多。大样例那么水，当然轻而易举跑过啦。</p>
<p>这时我还有 1.5h，思考了一下，扣除了 0.2h 最终检查的时间，我放弃了 T4
正解，尽管我浏览题目时已经想出了它的正确解法，我把目标定为 68pts
的暴力，但是并不顺利，我没有通过最后一个大样例，而且无论如何都找不出问题，最后应该是
36~40 分。</p>
<p>出来自测，不出所料，所有民间数据都卡不掉我的 T3，目前是
100+100+100+40</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>1027总结</title>
    <url>/2022/10/27/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1027%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="a">A</h2>
<h2 id="b">B</h2>
<p>首先求什么东西的<strong>和</strong>，这类题，一看到就要想是不是该开
<code>long long</code>。</p>
<h2 id="c">C</h2>
<p><strong>多测题，特别是样例水的题，一定要认真检查清空，以及不要读入到一半
break 出去！！！</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC274</title>
    <url>/2022/10/26/OI/%E6%AF%94%E8%B5%9B/ABC274/</url>
    <content><![CDATA[<h2 id="f">F</h2>
<p>不算难但有坑点的题。</p>
<p>很容易想到可以抓鱼的时间是当且仅当某两条鱼距离为 <span
class="math inline">\(A\)</span> 时。</p>
<p>所以考虑左边那条鱼，分别计算右边的鱼是哪一条时可以抓到的最大重量。</p>
<p>我实现的时候出现了负数时间，但是不能在负数时间抓，故我忽略了负数时间的最大值贡献。</p>
<p>但是考虑到可能第一个正数时间的事件是某条鱼游出了范围，所以需要修正，要么弄个
<span
class="math inline">\(0\)</span>，要么在每个事件发生前取下最值。</p>
<h2 id="g">G</h2>
<p>有趣的题。你需要放最小数量的监视器到一个矩阵中，矩阵中有监视器<strong>不能越过</strong>的障碍，每个监视器往上下左右中一个方向看，可以看到自身位置。你需要保证所有非障碍点都被监视。</p>
<p>最开始想的是假定先放横着的贪心放竖着的，但是不行。</p>
<p>后面思考了横着和竖着的关系，发现如果将所有的横块看成一个点，竖块看成一个点，那么能构成一张二分图，二分图的每个边就是每个需要监视的点！</p>
<p>本质上是最小点覆盖问题，可以用网络流解决。</p>
<p><strong>二维网格图的行和列，和二分图有着紧密的联系，涉及对横边和竖边分别操作时，需要求最小或者最大值，一定要考虑到网络流，数据范围如果在
<span
class="math inline">\(100-500\)</span>，那么就更应该思考网络流的方式。</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title>1025总结</title>
    <url>/2022/10/26/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1025%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1753</title>
    <url>/2022/10/24/OI/%E6%AF%94%E8%B5%9B/CF1753/</url>
    <content><![CDATA[<h2 id="d">D</h2>
<p>很有意思的一道题，感觉有人一碰到这种二维平面上的图论题就只有瓜起。</p>
<p>首先它是一个跳棋形式的题目，我们不要考虑去移动床，考虑移动空格，容易发现相邻的两个空格一定不会是同一个空格，所以可以枚举每两个相邻的位置，计算这里有空格的最小代价。</p>
<p>怎么算，感觉两个东西是独立的，可以直接跑最短路。</p>
<p>实际上也确实是这样的，由于最短路必定不会经过同一个点两次，所以考虑某个空格在一个点时的移动方式，如果它使用了某个床两次，那么一定在第二次使用这个床时回到了原点，必定不优。</p>
<p>感性的考虑在两个点路径距离大于等于 <span
class="math inline">\(3\)</span>
的任意时刻，二者的路径都是互不影响的，小于 <span
class="math inline">\(3\)</span> 时已经相遇，所以两个点时独立的。</p>
<p>怎么说，虽然没做出来，但是这道题还是给了我们思考这类题的方向。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1749</title>
    <url>/2022/10/24/OI/%E6%AF%94%E8%B5%9B/CF1749/</url>
    <content><![CDATA[<h2 id="e">E</h2>
<p>一个 <span class="math inline">\(n\times m\le 3\times 10^5\)</span>
的网格，里面有一些 <span class="math inline">\(1\)</span>，其余是 <span
class="math inline">\(0\)</span>，你需要填上尽可能少的 <span
class="math inline">\(1\)</span>，让网格上下不连通，并且 <span
class="math inline">\(1\)</span> 之间边不相邻。</p>
<p>这道题还是发现我网格图图论不扎实的问题。</p>
<p>首先很容易想到一定会存在一条自左到右的链，分隔了上下两部分。所以我直接从左到右
<span class="math inline">\(DP\)</span>。</p>
<p>但是得到了 <span class="math inline">\(WA2\)</span> 的好成绩。</p>
<p>左思右想也找不出问题，但是对拍后发现似乎是可以往回走的。</p>
<p>改成最短路算法就通过了。</p>
<p><strong>矩阵图论的题目，不要只看到自左向右，要考虑存不存在往回的可能。</strong></p>
<p>如果没有错过，确实很难意识到这种思维漏洞，所以一定要记住！</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>一件事</title>
    <url>/2022/10/24/%E7%94%9F%E6%B4%BB/%E4%B8%80%E4%BB%B6%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="随便写写">随便写写</h3>
<p>昨天考试，模数很离谱 <code>998244 8 53</code>，我文件名还写错了，挂了
<code>190</code>。</p>
<p>考完在机房随口骂了出题人两句，自己也没当回事，题做不来，看错了，我本事不够，我认，文件名写错，我的问题。骂人，就是心情不好，也没多想。</p>
<p>上周有套题出的很离谱，考完也在机房骂了几句，想着反正已经考完了，相当于是下课时间，发泄几句也没什么。</p>
<p>上周教练下午找我聊，说要控制情绪云云，我没当回事，说
“我就是这个性格”，骂出来被批最多难受
10min，不说两句说不定憋着难受一个星期，这件事也就这么稀里糊涂的过了，高一的老师
qq 找我聊了一下，说我 "恶意发泄情绪"，我想确实是这样，虽然我还没把所谓的
"恶意发泄情绪" 当回事，不过配合老师工作，我还是接受惩罚，20
个俯卧撑当锻炼了。</p>
<p>昨天考完又骂了几句，然后一起考的同学都没怎么管，晚上教练叫我和我爸打个电话，打过去披头盖脸就是一顿骂，我好好的心情被这一顿搞炸了，随即想都没想就怼了回去，也没有什么目的，就是对着干，爸叫我，自己反思错误，手写检讨，晚上
11 点前拍照发给他，否则第二天来学校接我回家。</p>
<p>我...</p>
<p>说实话我确实不知道骂几句又有什么问题，搞得这么恼火，反正一下子就哭了。</p>
<p>稍微冷静一下去找了
<code>Walk</code>，和他好好聊了一会儿，其实我能想到看到的东西真的很少。。。</p>
<p>回想一下，<code>Walk</code>
说的确实有道理，再怎么说，直接骂出来是一件很不好的事情，虽然骂出来确实很爽，不过可能我不把这件事当事，很多人也不会放在心上，甚至有共情，但总有一些居心不良的人干一些龌龊的事，骂人了确实会留下一些把柄。<strong>注意，我在这里甚至用了
"居心不良"
这个非常文艺的词，而没有用一些更加常用的，更能表达我对这些人看法的词。</strong>
所以这件事终归还是我有问题。</p>
<p>冷静下来和老爸回个电话，说了这一点，但是爸还是说我没有看到主要问题，我这一部分看法只是很小的一面。</p>
<p>他说了这些点：</p>
<ul>
<li><p>保护自己，别留下把柄（我说到的）</p></li>
<li><p>这件事让身边的其他人很难办。</p></li>
<li><p>不可避免的受到了一些网络影响。</p></li>
<li><p>情绪控制上的问题</p></li>
<li><p>文化素养的问题。</p></li>
</ul>
<p>第一点就不再多谈。</p>
<p>第二点，这里的其它人并不指同学，指老师，他举了一个挺现实的例子，假定老师要写评语，那这件事情怎么办。可能平日里不会在意，但是比较正式和严肃的场合，爆粗口这件事情被提出来肯定会有很大的形象减分，所以为了咱还算行的个人形象，少骂几句。</p>
<p>第三点，我也不得不承认受到了整个 OI
圈某些不太好的风气的影响，走偏了，或者说没有守住 "本心"，在被不好的
"大多数" 带着走，以前完全没有意识到这一点，还是需要想想，是不是
"大多数"，就是正确的，这个
"大多数"，甚至还是片面的，是一个小圈子。所以，哪些是精华，哪些是糟粕，需要认真思考。</p>
<p>第四点，情绪控制，说起来容易，做起来难，人脑和电脑是一样的，CPU
寄存器就那几个，赛不了太多东西，情绪控制的数据都放进了内存了，但是情绪上来的时候，不要说内存延迟的
200 个周期了，L1 几个 CPU
周期你都等不了，会直接把寄存器里的情绪用最快捷的方式扔出来，放电脑上就是——"死机，爆炸"，所以最有效的方式还是多找找样本，多获取一些负反馈，让你的思维模型对情绪控制更敏感，遇到相似的输入能够把读取
"情绪控制"
模块的权重算的高一点，所以还是一个阅历的问题，样本不够，训练出来的 AI
就是典型的 "欠拟合"，处理基本问题都没有办法，换到人身上就是
"年轻人"。机器学习之所以叫机器学习那是因为它模仿了人的学习过程，是有道理的。</p>
<p>第五点，其实我不太想细谈，爸总是把文化素养和 "语文"
挂钩起来。<strong>我很讨厌以主观看法作为基础的一切。</strong>放在义务教育中，就是语文，历史，和政治。为什么我不把英语算进来？<strong>英语学习的是使用英语这个工具，而不是学习语文这种主观印象。</strong>除开义务教育，一个典例就是中医，也许我对中医有误解，但是至少到现在为止，我还认为它是一个以主观看法为基础的
Subject，所以直接告诉我。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>20221020考试总结</title>
    <url>/2022/10/21/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1020%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://local.cwoi.com.cn:8443/contest/C0139">考试</a></p>
<h3 id="t1">T1</h3>
<p>套路状压题，有一些关于分支的常数优化技巧</p>
<h3 id="t2">T2</h3>
<p>有趣的容斥原理题，但是不太适合出在考试。</p>
<p>首先猜想答案比较多，所以考场上直接一个随机化过掉。</p>
<p>考虑两人集合交的大小 <span class="math inline">\(\sum|S_i\bigcap
S_j|\)</span>
，如果能算出这玩意，很容易用鸽巢原理算出答案个数的下界。</p>
<p>考虑每个元素对它的贡献，是 <span
class="math inline">\(\binom{cnt_i}{2}\)</span> 的，所以 <span
class="math inline">\(cnt\)</span> 的分布需要尽可能平均，不妨让它就为
<span class="math inline">\(cnt_i\)</span>。</p>
<p>所以上面那个式子的下界是 <span
class="math inline">\(\dfrac{n^3}{4}\)</span>
级别的。鸽巢原理，集合总个数为 <span
class="math inline">\(\dfrac{n\times(n+1)}{2}\)</span>，每一个集合先分配
<span class="math inline">\(\lfloor\frac{n-1}{2}\rfloor\)</span>
个，剩下的数级别是 <span class="math inline">\(O(n^2)\)</span>
的，因此答案个数是 <span class="math inline">\(O(n)\)</span>
的，期望随机 <span class="math inline">\(n\)</span>
次可以找到一组合法解。</p>
<h3 id="t3">T3</h3>
<p>能看出很多问题的题。</p>
<p>题目本身不难，但是坑点极多。</p>
<p>考虑转化问题的时候一定要搞清楚转化的前提条件，以及对应的<strong>充要条件</strong>。</p>
<p>第一次出错：认为选定合法的删除子序列后一定有解，实际上没有位置放
<span class="math inline">\(1/0\)</span></p>
<p>第二次出错：认为必须留位置给 <span
class="math inline">\(1/0\)</span>，但实际上有可能根本不存在 <span
class="math inline">\(1/0\)</span>，留位置是没有意义的，需要特判。</p>
<p>另外还有必要提的一点是，这种选择一个元素，移动到任意位置的题，往往可以考虑最终结果，也就是选择了哪些，或者是选择了哪些不动。</p>
<p>和求改为最长不下降子序列最小代价的题目一样，可以考虑补集转化，最多的，能不动的元素个数，就是
LIS，LCS 的长度。</p>
<p><strong>多次出错的原因也就是误以为只要选择合法，那么就一定可以构造合法的方案。</strong></p>
<h3 id="t4">T4</h3>
<p>有趣的贪心题。</p>
<p>我们给矿工分级，并认为操作是放一组矿工，每个矿工只能挖一个，<span
class="math inline">\(k\)</span> 级矿工能挖掉距离小于 <span
class="math inline">\(k\)</span> 的点。</p>
<p>考虑有一条线从下往上扫描，我们需要尽可能把矿工往上放，这样能够到更多的点。</p>
<p>先考虑最深的必须放矿工的点，它一定满足，<span
class="math inline">\(k\)</span>
级儿子有一个还没有被挖的宝藏，否则可以继续往上，这一定不劣，不妨从最简单的情况开始。</p>
<p>假设在这个点放了矿工，那矿工必须挖掉 <span
class="math inline">\(k\)</span>
级儿子，否则上面就处理不了了。如果矿工还能挖，那么需要让他把 <span
class="math inline">\(k-1\)</span>
级儿子也尽可能挖，因为如果让父亲处理，需要付出一个 <span
class="math inline">\(k\)</span>
级矿工的代价，但是这个点的矿工上到父亲的时候降级为 <span
class="math inline">\(k-1\)</span>
级，矿工等级显然越高越好，对于等级低的儿子，在这里挖可以看成于先上去降级再挖。</p>
<p>所以在第一个必须放矿工的点，矿工<strong>必须</strong>挖掉 <span
class="math inline">\(k\)</span> 级儿子，<strong>尽可能</strong>挖 <span
class="math inline">\(k-1\)</span> 级儿子，意思是如果还有 <span
class="math inline">\(k-1\)</span>
级儿子没有挖完，那就没必要再放矿工，可以留给父亲处理。</p>
<p>接下来的点就有不同等级的矿工了，对于 <span
class="math inline">\(i\)</span>
级矿工，他会尽可能挖掉和它同级的儿子，如果还有剩余，会挖掉 <span
class="math inline">\(i-1\)</span>
级儿子，<strong>这个过程一定要从等级小的矿工到等级大的矿工考虑</strong>，否则会变劣。</p>
<p>剩余的矿工降级后上传，儿子升级后上传。</p>
<p>按照这个策略贪心即可。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>关于常数优化</title>
    <url>/2022/10/19/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E5%85%B3%E4%BA%8E%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="代码层面">代码层面</h2>
<p>由于现在考试都开 O2，所以只讨论有 O2 的情况。</p>
<h3 id="循环展开">循环展开</h3>
<p>由于 CPU
处理分支的能力很烂，所以循环展开加速的一部分原因在于减少了分支。</p>
<p>测试标准为 <span class="math inline">\(10^5\)</span>
次随机区间求和，大小 <span
class="math inline">\(10^5\)</span>，以下代码用时
<code>572ms</code>，<code>for</code> 循环用时 <code>1192ms</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=l[i];j<span class="number">+3</span>&lt;=r[i];j+=<span class="number">4</span>)&#123;</span><br><span class="line">        sum[<span class="number">0</span>]+=a[j<span class="number">+0</span>];</span><br><span class="line">        sum[<span class="number">1</span>]+=a[j<span class="number">+1</span>];</span><br><span class="line">        sum[<span class="number">2</span>]+=a[j<span class="number">+2</span>];</span><br><span class="line">        sum[<span class="number">3</span>]+=a[j<span class="number">+3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;=r[i];j++)&#123;</span><br><span class="line">    	sum[<span class="number">0</span>]+=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    ans^=sum[<span class="number">0</span>]+sum[<span class="number">1</span>]+sum[<span class="number">2</span>]+sum[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>sum</code> 数组替换为多个局部变量，效果不变。</p>
<p>测试了其它展开位数，开 <code>8</code> 位效果最佳，约
<code>520ms</code>。</p>
<p><code>16</code> 位会出现寄存器溢出效率下降。</p>
<p>如果用的求和变量较多，最好开 <code>4</code> 位。</p>
<p>顺便一提，开 Ofast/O3 后会帮你展开。</p>
<p>如果你写了假的循环展开，那么效率提升只有约 <span
class="math inline">\(50\%\)</span>，这是假的循环展开，但是开了 O3
就是真的了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calc</span><span class="params">(<span class="type">int</span>* begin, <span class="type">int</span>* end)</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">size_t</span>)begin &amp; <span class="number">4</span>) res = *begin++;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> sum[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">while</span> (begin + <span class="number">7</span> &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">auto</span> addr = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)begin;</span><br><span class="line">        sum[<span class="number">0</span>] += addr[<span class="number">0</span>];</span><br><span class="line">        sum[<span class="number">1</span>] += addr[<span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">2</span>] += addr[<span class="number">2</span>];</span><br><span class="line">        sum[<span class="number">3</span>] += addr[<span class="number">3</span>];</span><br><span class="line">        begin += <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) res += (sum[i] &gt;&gt; <span class="number">32</span>) + <span class="built_in">unsigned</span>(sum[i]);</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) res += *begin++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=l[i];j<span class="number">+3</span>&lt;=r[i];j+=<span class="number">4</span>)&#123;</span><br><span class="line">        sum+=a[j<span class="number">+0</span>];</span><br><span class="line">        sum+=a[j<span class="number">+1</span>];</span><br><span class="line">        sum+=a[j<span class="number">+2</span>];</span><br><span class="line">        sum+=a[j<span class="number">+3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;=r[i];j++)&#123;</span><br><span class="line">    	sum+=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    ans^=sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用时 <code>832ms</code>。</p>
<h3 id="减少分支">减少分支</h3>
<p>这个减少分支主要指减少内层循环的分支，尤其是<strong>理论预测成功率很低</strong>的分支。</p>
<p>CPU
的分支预测，可以视为一种很智能的找规律，在几乎不执行，几乎执行的情况下，或者是否成功具有循环节之类的情况，具有极高的预测效率。</p>
<p>当分支预测失败时，有较大可能会从内存中重新读取对应代码块，</p>
<p>一般可以采用乘法等算术方式。</p>
<p><strong>不建议写偏向条件赋值的代码，因为高版本编译器可能会弄成条件执行，它以认为它读懂了你的代码，但是它就是个蠢逼。</strong></p>
<p>在一些比较极端的情况，甚至能带来 <span
class="math inline">\(5\)</span> 倍的效率差异！</p>
<p>这里的 <span class="math inline">\(k=10\)</span>。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>;mask&lt;<span class="number">1</span>&lt;&lt;(k<span class="number">+1</span>);mask++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;j++)<span class="keyword">if</span>(<span class="built_in">bool</span>((<span class="number">1</span>&lt;&lt;j)&amp;mask))</span><br><span class="line">        <span class="keyword">final</span>^=stat[mask&gt;&gt;k][j];</span><br><span class="line">    dp[(i<span class="number">+1</span>)&amp;<span class="number">1</span>][<span class="keyword">final</span>]+=dp[i&amp;<span class="number">1</span>][mask&amp;((<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以换成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>;mask&lt;<span class="number">1</span>&lt;&lt;(k<span class="number">+1</span>);mask++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;j++)<span class="keyword">final</span>^=<span class="built_in">bool</span>((<span class="number">1</span>&lt;&lt;j)&amp;mask)*stat[mask&gt;&gt;k][j];</span><br><span class="line">    dp[(i<span class="number">+1</span>)&amp;<span class="number">1</span>][<span class="keyword">final</span>]+=dp[i&amp;<span class="number">1</span>][mask&amp;((<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者更理想的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>;mask&lt;<span class="number">1</span>&lt;&lt;(k<span class="number">+1</span>);mask++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">final</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w=mask;w;w-=w&amp;(-w))<span class="keyword">final</span>^=stat[mask&gt;&gt;k][__builtin_ctz(w)];</span><br><span class="line">    dp[(i<span class="number">+1</span>)&amp;<span class="number">1</span>][<span class="keyword">final</span>]+=dp[i&amp;<span class="number">1</span>][mask&amp;((<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__builtin_clz()</code> 返回一个数二进制下前导 <code>0</code>
的个数，<strong>对于负数，返回值是 <code>0</code></strong></p>
<p><code>__builtin_ctz()</code> 返回二进制末尾连续 <code>0</code>
的个数。</p>
<p>三份代码的运行时间分别为 <code>1200ms 213ms 150ms</code>。</p>
<h3 id="高速缓存">高速缓存</h3>
<h4 id="一般情况">一般情况</h4>
<p>用一句话来说，能滚动的数组要滚动。</p>
<p>可以看看这两个提交，效率改进因子为 <code>1.6</code>。</p>
<p><a
href="https://local.cwoi.com.cn:8443/submission/6350f85e1aaf020012fced9f">无滚动数组</a>，390ms。</p>
<p><a
href="https://local.cwoi.com.cn:8443/submission/6350f5211aaf020012fced96">滚动数组</a>，150ms。</p>
<h4 id="互踢缓存">互踢缓存</h4>
<p>如果遍历数组的顺序和数组的大小都不太理想，很容易出现互踢缓存的特殊情况，在一些极端情况可能会带来
<code>10</code> 倍甚至 <code>20</code> 倍的常数差距。</p>
<p>缓存存储的基本单位是 <code>cacheline</code>，大小为
<code>64Byte</code>，将一个数据物理地址的末六位抹掉，可以得到它的缓存行编号，缓存行编号视高速缓存大小和分组策略取末
<span class="math inline">\(k\)</span>
位，作为高速缓存使用区域编号。同一高速缓存使用区一般可以存储
<code>16</code> 个
<code>cacheline</code>，如果超出，则踢出最早进入的。</p>
<p>举例来说，如果以 <code>256Byte</code> 作为步长遍历数组，那么由于抹掉
<span class="math inline">\(6\)</span> 位后末 <span
class="math inline">\(2\)</span>
位是一样的，<strong>所以实际被利用的高速缓存仅有 <span
class="math inline">\(\frac{1}{4}\)</span></strong>，会出现非常阴间的情况，需要避免。</p>
<h3 id="访问连续">访问连续</h3>
<p>访问连续有两个层面，缓存行连续访问，页的访问连续。</p>
<p>一般强调前者。</p>
<h2 id="算法层面">算法层面</h2>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>20221018考试总结</title>
    <url>/2022/10/19/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1018%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://local.cwoi.com.cn:8443/contest/C0137">考试</a></p>
<h2 id="a">A</h2>
<p>简单题，合并两个之后一定不劣，用个栈维护还没合并的东西。</p>
<h2 id="b">B</h2>
<p>计数题，容易发现等价于做保证全为 <span
class="math inline">\(L,R\)</span>，此时每一行的贡献独立，考虑计算每一行单独的答案，乘上其它行的方案数，得到最后的解。</p>
<p>计算一行的答案，考虑每一个的贡献，好像不太行，因为你需要枚举和它配对的是什么，然后就寄了，计算的时候，我们可以决定每一个选还是不选，最后取待选的个数为
<span class="math inline">\(0\)</span>
的所有方案，同时记录方案数和答案的和，即可完成转移。</p>
<h2 id="c">C</h2>
<p>有趣的题。</p>
<p>如果采用常规的数位DP方式，那么必须记录进位数和卡界数，只能做到 <span
class="math inline">\(O(nk^4)\)</span>。</p>
<p>但是不妨从结果考虑，如果能计算出恰好取到 <span
class="math inline">\(n\)</span> 的方案数，并求出 <span
class="math inline">\(f(n)\)</span>，那么答案就是 <span
class="math inline">\(\sum\limits_{n\ge 0} f(n)\times 取到\ n \
的方案数\)</span>。考虑取到 <span class="math inline">\(n\)</span>
的方案数怎么算。</p>
<p>这里定义 <span class="math inline">\(\binom{a}{b}=0 \text{ when }
a&lt;0\)</span>。</p>
<p>利用容斥原理，计算强制 <span class="math inline">\(k\)</span>
个数大于 <span class="math inline">\(x\)</span> 的方案数。 <span
class="math display">\[
ans=\sum\limits_{n\ge 0}\sum\limits_{i=0}^{k}
(-1)^{i}\binom{n+k-1-i\times(x+1)}{k-1}f(n)
\]</span> 后面那个东西，<span class="math inline">\((k-1)!\)</span>
是个常数。</p>
<p>提出来后是一个关于下降幂乘上 <span
class="math inline">\(f(n)\)</span>。</p>
<p>把下降幂展开成关于 <span class="math inline">\(n\)</span>
的多项式，问题变成求 <span class="math display">\[
\sum\limits_{n\ge0} f(n)n^x
\]</span> 这个可以数位DP，考虑往后面填什么，假设已经求了 <span
class="math inline">\(10^i\)</span> 以内所有答案，往后填 <span
class="math inline">\(c\)</span>，对应的变换就是求 <span
class="math inline">\(\sum\limits_{0\le n&lt;10^i}
f(10n+c)(10n+c)^x\)</span>，把 <span class="math inline">\(c\)</span>
扔到外面，后面哪一项用二项式定理展开，就可以用原来的值推新的值了，这东西是个卷积，但是枚举
<span class="math inline">\(c\)</span> 的部分可以扔到外面去，预处理后是
<span class="math inline">\(O(nk^2)\)</span> 的。</p>
<p>但是这是有问题的，因为我们定义的组合数和下降幂算出来的组合数是不一样的，因此需要排除掉
<span class="math inline">\(n&lt; i\times(x+1)\)</span>
的部分，这个可以重新数位DP一次，过程是一样的。</p>
<p>但是有更优雅的办法，枚举每个可能的数与 <span
class="math inline">\(i\times(x+1)\)</span> 的
LCP，然后除掉当前位后面是没有限制的，后面没有限制的答案，我们已经算过了，就是前面那个值，前面的数，已经知道了，所以合并答案的过程和刚刚没有区别，由于<strong>合并答案的过程是
<span class="math inline">\(O(k^2)\)</span>
的</strong>，所以这样会比一般的数位DP写法更加优雅。</p>
<p><strong>预处理一些东西的时候要小心，注意不要超过数组或者处理少了。</strong></p>
<h2 id="d">D</h2>
<p>数据结构题。</p>
<p>我终归还是不会区间数颜色。</p>
<h3 id="区间数颜色">区间数颜色</h3>
<p>需要求的东西很丑，我们的数据结构，能维护的东西是满足一些偏序关系的元素的<strong>和</strong>，但是这个东西不是这样的比较优美的形式，所以考虑转化成我们的数据结构能维护的东西。</p>
<p>区间数颜色，就是把不好维护的，通过一个于询问无关的 <span
class="math inline">\(pre\)</span>
数组，转化成了利于维护的偏序关系。</p>
<p>如果考虑区间内相同数的贡献情况，它形如 <span
class="math inline">\(100000\)</span>。</p>
<p>这道题可能需要求一个形如 <span class="math inline">\(\text{1 -1 0 0 0
0 0}\)</span> 的东西。</p>
<p>我们发现求 <span class="math inline">\(1100000\)</span>
也是容易的，只需要记录 <code>pre</code> 的 <code>pre</code>
就可以了。于是可以加减消元得到结果。</p>
<p>然后树套树。</p>
<p>码量极其[数据删除]。</p>
<p>不过直接这么搞不太行，常数太大，所以可以把每个 <span
class="math inline">\(\le 10^3\)</span>
的质因子搞出来拿个块状链表维护，再转化一下，将同一质因子视为若干线段其中
<span class="math inline">\(1-3,2-4,3-5\)</span>
这样连，可以直接得到答案，而不用做消元。</p>
<p>这种把颜色连成线段的思路还是有一定的启发意义。</p>
<p>我实在不想写这个，下面的假莫队做法好写好调还快些。</p>
<h3 id="莫队">莫队</h3>
<p>莫队思想其实是可以做强制在线题的，这基于我们能够快速从 <span
class="math inline">\([l,r]\)</span> 拓展到 <span
class="math inline">\([l,r+1]\)</span>。如果我们能够记录当前若干个状态的值，比如
<span class="math inline">\(O(n^{\frac{2}{3}})\)</span>
个，相当于是让每个 <span
class="math inline">\(O(n^{\frac{2}{3}})\)</span>
大小的块都能记下对应的值，然后拓展的代价就是 <span
class="math inline">\(O(n^\frac{2}{3})\)</span>
的，有些题目可能会有空间问题，得就题目讨论。</p>
<p>这道题一个状态需要的空间大约是 <span
class="math inline">\(80000\times 4 \div 1024\div1024\approx 0.3
MB\)</span>，可以记录约 <span class="math inline">\(3000\)</span>
个状态，这已经够用了， <span class="math inline">\(\sqrt {3000} \approx
54\)</span>，我们能以 <span
class="math inline">\(O(\frac{nq}{54})\)</span>
的代价回答询问，对于修改，至多影响 <span
class="math inline">\(3000\)</span> 个状态，也是可以接受的。</p>
<p>当然，我们需要把小于 <span class="math inline">\(1000\)</span>
的质因子提出来单独先做一遍，以免代价过大。</p>
<p>但是开 <span class="math inline">\(54\)</span>
个端点不是最优的，实践表明块长小一点，比如 <span
class="math inline">\(40\)</span>
，会更加优秀，这种分块题还是需要看实际实现来调块长。</p>
<p>不过 <span class="math inline">\(10^5\)</span>
的题，怎么玩都是基本不会出问题的。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>多项式</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1014总结</title>
    <url>/2022/10/17/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1014%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="总结">总结</h2>
<p>时隔接近一个月写的考试总结...</p>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0133">考试</a></p>
<h3 id="t1">T1</h3>
<p>没有什么价值的题，分析一下相位这些就可以做出来。</p>
<h3 id="t2">T2</h3>
<p>算区间最大值之和要枚举最大值位置算跨过的数量，所以考虑对这个东西动态规划，设
<span class="math inline">\(dp[l][r]\)</span> 表示只考虑 <span
class="math inline">\(l,r\)</span> 区间的最优答案。</p>
<p>枚举最大值位置后，拆分成两个区间，其答案和最大值位置以及彼此无关，符合最优子结构性质，加上最大值的额外贡献，可以在每一个位置枚举取哪个值，有可能算出来答案比较劣，但是仍然可以遍历解空间，所以这样
DP 没有问题。</p>
<p>枚举取值的复杂度很高，发现每个位置的最优值和 dp
数组无关，考虑预处理每个位置的最优值，本质上是给定若干一次函数，再给定若干
<span class="math inline">\(x\)</span>，求最值，很简单。</p>
<h3 id="t3">T3</h3>
<p>考场上没有做出来的题，但是基本想出来了，ARC
那道期望题加深了对期望的理解。</p>
<p>根据期望线性性，<span class="math inline">\(E(dis_{u,v} ) =
E(dis_u)+E(dis_v)-2\times E(dis_{lca(u,v)})\)</span>。</p>
<p>前两者是好算的，考虑这样一个 <span
class="math inline">\(dp\)</span>，<span
class="math inline">\(dp_u\)</span> 表示 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(u\)</span> 的期望距离，转移比较简单。</p>
<p>考虑后者怎么算，即 <span class="math inline">\(u,v\)</span> 两点
<span class="math inline">\(lca\)</span> 距离的期望，如果 <span
class="math inline">\(v\)</span> 在下面，由于 <span
class="math inline">\(lca\)</span> 一定在 <span
class="math inline">\(u\)</span> 及之前，所以 <span
class="math inline">\(u,v\)</span> 的 <span
class="math inline">\(lca\)</span> 的期望等价于 <span
class="math inline">\(u,u+1\)</span> 的 <span
class="math inline">\(lca\)</span> 的期望，归纳即可证明。</p>
<p>考虑计算 <span class="math inline">\(u,u+1\)</span> 的 <span
class="math inline">\(lca\)</span>
的期望值，这个也是可以动态规划的了，枚举 <span
class="math inline">\(u+1\)</span> 的祖先即可，上前缀和优化。</p>
<h3 id="t4">T4</h3>
<h4 id="我的想法">我的想法</h4>
<p>考虑类似点分治一样去做，只不过是随机选点，期望层数应该是 <span
class="math inline">\(O(\log n)\)</span>，证明的话，考虑将 <span
class="math inline">\(\frac{n}{4}\)</span>
个点变成一个点，分两种情况，该点存在大小超过 <span
class="math inline">\(\frac{n}{2}\)</span>
的子树和不存在。后者已经证毕，每次问题规模有 <span
class="math inline">\(\frac{1}{4}\)</span> 的概率变为原来的 <span
class="math inline">\(\frac{3}{4}\)</span>。前者考虑在该子树中选取包含根的
<span class="math inline">\(\frac{n}{4}\)</span>
个点重复以上过程，于是不存在大小超过 <span
class="math inline">\(\frac{n}{2}\)</span> 的子树，同样证毕。</p>
<p>基于点分治的原理（独立的子树不跨过分治中心），可以求出每棵子树包含的点集，但如果分治的叉过多，求叉的的过程需要反复尝试每一个叉，复杂度退化到
<span class="math inline">\(n^2\)</span>。</p>
<p>树形态随机的情况下（随机父亲），每个点的分叉期望是 <span
class="math inline">\(\ln n\)</span> 级别的，复杂度为 <span
class="math inline">\(O(n\log^2 n)\)</span>。</p>
<h4 id="topsort">Topsort</h4>
<p>需要问树的形态，考虑单独的一次询问能干什么，可以判断一个点是否为叶子，所以考虑从叶子一层一层往上确定。一种比较暴力的方式是先找出所有的叶子，然后删掉后找出二级叶子，找一个点当根，直接确定某个点的父亲是不好做的，考虑为某个点确定一个儿子，方式是二分，重复若干次即可。</p>
<p>确定一层的均摊复杂度是 <span
class="math inline">\(O(leaf\log{(leaf)})\)</span>，外加找叶子的复杂度，总计
<span
class="math inline">\(O(n^2)\)</span>，考虑优化找叶子的复杂度，一种可行的方式是先弄出一个拓扑序排列，按照拓扑序去逐一确定。</p>
<p>弄拓扑序可以考虑以插入的方式构造排列，一个拓扑序合法当且仅当 $
 i 满足  j[1,i),
p_i 不是 p_j 的祖先$。插入构造时询问一个前缀到根是否包含当前插入的点，如果包含，那么这个点应该放在更前面，得到拓扑序之后就可以逆序构造。</p>
<h4 id="subtree">Subtree</h4>
<p>考虑递归的构造，确定父亲和子树内容，假设有一个函数 <span
class="math inline">\(f(x)\)</span> 可以求出 <span
class="math inline">\(x\)</span>
子树中所有点的父亲（除自身外），那么调用每个 <span
class="math inline">\(f(x)\)</span>
一次后就可以保证求出树的结构。维护一个没调用过 <span
class="math inline">\(f(x)\)</span> 的点集，在点集中找到一个是 <span
class="math inline">\(x\)</span> 后代的点 <span
class="math inline">\(y\)</span>，调用 <span
class="math inline">\(f(y)\)</span>，于是求出了 <span
class="math inline">\(y\)</span>
后代所有节点的父亲，维护一下没确定父亲点的点集，在没调用过 <span
class="math inline">\(f(x)\)</span> 的点集中，若找不到 <span
class="math inline">\(x\)</span>
的后代，那么就可以开始在没确定父亲的点集中找出 <span
class="math inline">\(x\)</span> 的所有儿子了。</p>
<p>分析复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1746</title>
    <url>/2022/10/17/OI/%E6%AF%94%E8%B5%9B/CF1746/</url>
    <content><![CDATA[<h2 id="abc">ABC</h2>
<p>没什么价值的题。</p>
<h2 id="d">D</h2>
<p>首先每次选路径一定会选到根。</p>
<p>要求儿子相差不超过 <span class="math inline">\(1\)</span>。</p>
<p>所以每个点被选的次数弄出来了，那么每个儿子只有两种选法，选 <span
class="math inline">\(\lceil\frac{cnt_u}{cson_u}\rceil,\lfloor\frac{cnt_u}{cson_u}\rfloor\)</span>。</p>
<p>根据经典结论，如果直接动态规划，状态数为 <span
class="math inline">\(O(n)\)</span>。</p>
<h2 id="e1">E1</h2>
<p>趣味题</p>
<p>考虑二分，发现不可二分，因为问 <span
class="math inline">\(S,\overline S\)</span>
是等价的，所以随便糊弄你就行。</p>
<p>所以考虑三分或者四分。</p>
<p>考虑解决 <span class="math inline">\(n=3\)</span> 的基本情况。</p>
<p>先确定问题再处理的方式看上去不太可取。</p>
<p>所以我们多半是需要根据回答来决定下一个问题。</p>
<p>这就是一颗决策树。</p>
<p>问一个时，<span class="math inline">\(Y\)</span> 的限制较强。</p>
<p>不妨先问 <span class="math inline">\(1\)</span>，如果是 <span
class="math inline">\(N\)</span>，那么再问一遍 <span
class="math inline">\(1\)</span> ，还是 <span
class="math inline">\(N\)</span> 则排除 <span
class="math inline">\(1\)</span>，如果是 <span
class="math inline">\(Y\)</span> 则回到最初的 <span
class="math inline">\(Case\)</span>，此时问 <span
class="math inline">\(2\)</span>，如果回答是 <span
class="math inline">\(Y\)</span> 则排除 <span
class="math inline">\(3\)</span>，<span class="math inline">\(N\)</span>
则排除 <span class="math inline">\(2\)</span>。</p>
<p>那么用了 <span class="math inline">\(3\)</span> 步将问题规模变为
<span class="math inline">\(\frac{2}{3}\)</span>。</p>
<p>总步数为 <span class="math inline">\(3\log_\frac{3}{2}(10^5) \approx
85\)</span>，取整之后问题不大。</p>
<h2 id="f">F</h2>
<p>让人眼前一亮的随机化思路。</p>
<p>首先可以带修莫队 <span
class="math inline">\(O(n^{\frac{5}{3}})\)</span>。但是过不了。</p>
<p>先考虑 <span class="math inline">\(k\)</span>
比较小的特殊情况，不妨就是 <span
class="math inline">\(k=2\)</span>。</p>
<p>左想右想，都没有办法比较好的合并信息，因为它没有办法写成经典的偏序计数问题。</p>
<p>没有办法这样合并，那就只能 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>所以我不会。</p>
<p>这是个判定问题，只需要回答 <code>YES NO</code>。</p>
<p>考虑条件，必要条件是比较好找的，显然每个数出现次数为 <span
class="math inline">\(k\)</span>
的倍数是必要条件，若干个必要条件加在一起就是充要条件。</p>
<p>考虑同时判定若干个必要条件，即某些数的出现次数是否为 <span
class="math inline">\(k\)</span>
的倍数，似乎不太可做，但是发现如果随机选取若干个数并判定，那么对于答案为
<code>NO</code> 的所有情况，通过判定的概率至多为<span
class="math inline">\(\frac{1}{2}\)</span>，所以随机对数个子集判定后对于通过的回答
<code>YES</code>，正确率足以接受。</p>
<p><strong>对于一个判定问题，如果有某种检测算法，答案为 <code>YES</code>
一定可以通过，答案为 <code>NO</code>
概率通过，那么运行这个算法对数次后，可以以很高的正确率回答该判定问题。</strong></p>
<p><strong>如果有一个判定问题，某随机算法能以超过 <span
class="math inline">\(50\%\)</span>
的概率给出正确的答案，那运行这个算法对数次取众数即可解决问题</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC151</title>
    <url>/2022/10/17/OI/%E6%AF%94%E8%B5%9B/ARC151/</url>
    <content><![CDATA[<h2 id="a">A</h2>
<p>胡乱想了一通，做出来了。</p>
<p>形如要求 <span class="math inline">\(f(x)=f(y)\)</span>
的问题，可以考虑 <span
class="math inline">\(f(x)-f(y)=D\)</span>，这样就可以考察 <span
class="math inline">\(x,y\)</span> 独立对 <span
class="math inline">\(D\)</span> 的贡献了。</p>
<p>字典序题，从前往后贪心。</p>
<h2 id="b">B</h2>
<p>字典序的题，一般的方式是考虑从前往后贪心，考虑前 <span
class="math inline">\(i\)</span>
个相等的情况，并查集维护一下前面要求相等的组数，然后就是简单的组合题。</p>
<p>另外一种特有的方式是考虑字典序小于，和字典序大于是等价的，总方案减掉字典序相等的方案除二即可。</p>
<h2 id="c">C</h2>
<p>SG 函数打表，没什么技术含量。</p>
<h2 id="d">D</h2>
<p>很有趣的题。</p>
<p>二进制位相关的题目，刻画一下变换的过程，等价为在图上走。</p>
<p>然后发现如果 <span class="math inline">\(X_i\)</span>
相等是好做的。</p>
<p>我就没啥思路了。</p>
<p>看一下题解。</p>
<p>考虑交换两个 <span class="math inline">\(X_i\)</span>
不同的，发现最终答案不变，因为图上走的过程是等价的，继续选上之前选的边就行。</p>
<p>然后就做完了。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1736总结</title>
    <url>/2022/10/15/OI/%E6%AF%94%E8%B5%9B/CF1736/</url>
    <content><![CDATA[<h2 id="c">C</h2>
<p>这里的 C 指 C2。</p>
<p>首先来一波 <span class="math inline">\(\pm i\)</span>
变成相对简单的判 <span class="math inline">\(&gt; 0\)</span> 问题。</p>
<h3 id="method1">Method1</h3>
<p>考试的时候，比较自然的考虑计算跨过某个数的合法区间总数，发现可以把某个位置开头最远的区间给算出来。</p>
<p>然后就是个二维偏序。</p>
<p>然后对于新修改的元素，计算跨过它的合法区间个数，如果改小了，一定只会有一些数被这个东西限制，我选择做一个极度毒瘤的二维偏序。</p>
<p>如果改大了，一定只会有一些数在此处的限制被放开，再处理每个数放开一次限制后的最大位置即可，对于同一位置，可以处理单点前缀和，然后在上面
<code>lower_bound</code>。</p>
<p>显然两个都是可以在线做的，但是考试的时候没有发现被限制的数一定是一个区间，然后就出现了毒瘤。</p>
<p>不知道自己写的什么狗屎离线做法，奇丑无比。</p>
<h3 id="method2">Method2</h3>
<p>上面那个搞什么二维偏序是邪道。</p>
<p>还是考虑求跨过每个数的合法区间个数，某个位置 <span
class="math inline">\(x\)</span> 会限制另一个位置 <span
class="math inline">\(i\)</span>，当且仅当 <span
class="math inline">\(a_x+i\le
0\)</span>，所有一个位置限制的位置一定是一个前缀，这部分前缀的前缀会在这个位置之前被另外的位置限制，这是是可二分的。</p>
<p>所以改小的影响就好算了，找到被改小的数限制的区间，这一部分求总长度然后减去
<span class="math inline">\(cnt\times x\)</span> 得到答案减小值。</p>
<p>改大会比较麻烦，参考上面的处理方式。</p>
<h3 id="conclusion">Conclusion</h3>
<p><strong>多找点性质，又不妨碍做题。</strong></p>
<p><strong>多学着点二分，别去搞什么垃圾数据结构二维偏序。</strong></p>
<h2 id="d">D</h2>
<p>比较清新的构造题，难度不大，但是场上没想出来。</p>
<p>先假设没有操作，尝试求解该问题，发现它比较困难（似乎不存在多项式做法），所以应该考虑能不能构造出特殊情况。</p>
<p>考场上我看成了 <code>reverse</code>，这也是可做的，只需要构造出形如
<code>0000011111</code> 的串就行，方法是选上末尾的，插在 <code>1</code>
之间的 <code>0</code>，然后和前面的 <code>1</code> 交换，设
<code>1</code> 的个数为 <span
class="math inline">\(cnt_1\)</span>，那么选择后面 <span
class="math inline">\(cnt_1\)</span> 个位置中所有的
<code>0</code>，再选出前面所有的 <code>1</code>，交换即可。</p>
<p>实际上是循环左移，同样考虑构造特殊情况，这次选择构造
<code>001100111100</code> 这种。</p>
<p>如果不是，就选一个，找到下一个同样不满足的，然后移过来，最后一定有偶数个不满足的，用不同的数隔开就行。</p>
<p><strong>本质上，这个操作相当于选了偶数个相邻数不同的数，把它们
flip。</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>关于平衡树</title>
    <url>/2022/10/12/OI/%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<h1 id="平衡树">平衡树</h1>
<p>既然标题敢写平衡树，那就需要来谈谈平衡树本身，而不仅仅是实现它的方法。</p>
<h2 id="平衡树本身">平衡树本身</h2>
<p>平衡树是一颗二叉搜索树，每个节点<strong>权值</strong>大于左子树所有节点，小于右子树所有节点。</p>
<p>和线段树相比，它是一种动态结构，适合维护结构动态变化的信息，比如需要支持插入和删除以及翻转的序列，也可以用来维护一棵树（LCT）</p>
<p>和块状链表相比，它只能处理能够快速合并的信息，但是复杂度有所降低。</p>
<h2 id="实现">实现</h2>
<h3 id="splay">Splay</h3>
<p>已经很熟悉的方式，不再多说，不过可以多嘴提一句势能分析。</p>
<h3 id="势能分析原理">势能分析原理</h3>
<p>定义势能函数 <span class="math inline">\(F(S)\)</span> 表示状态 <span
class="math inline">\(S\)</span> 的势能，定义操作代价 <span
class="math inline">\(p_i=c_i+F(S&#39;)-F(S)\)</span>，其中 <span
class="math inline">\(c_i\)</span> 表示操作时间。</p>
<p>求解 <span class="math inline">\(\sum p_i=\sum c_i +
F(S_m)-F(S_0)\)</span></p>
<p>移项得到 <span class="math inline">\(\sum c_i=\sum
p_i+F(S_0)-F(S_m)\)</span></p>
<p>一般来说，<span class="math inline">\(c_i\)</span>
会比较奇怪，但是通过 <span class="math inline">\(F\)</span>
函数的变化值可以去抵消掉这个奇怪的值得到优雅的 <span
class="math inline">\(p_i\)</span>，然后一般来说最后的复杂度和 <span
class="math inline">\(\sum p_i,F(S)\)</span> 同阶</p>
<h3 id="分析-splay-的复杂度和单旋的复杂度">分析 Splay
的复杂度和单旋的复杂度</h3>
<p>定义势能函数，定义单点势能 <span
class="math inline">\(w(u)=\log_2(size_u)\)</span>， <span
class="math inline">\(F(S)=\sum\limits_{u\in S} w(u)=O(n\log
n)\)</span>。</p>
<p>旋转点为 <span class="math inline">\(x\)</span>，父亲为 <span
class="math inline">\(f\)</span>，祖父为 <span
class="math inline">\(g\)</span>。</p>
<h4 id="左旋代价">左旋代价</h4>
<p>注意到 <span
class="math inline">\(size_{x&#39;}=size_{fa}\)</span>。</p>
<p><span class="math inline">\(1+w(x&#39;)+w(fa&#39;)-w(x)-w(fa)\le
1+w(fa)-w(x)\le 1+w(x&#39;)-w(x)\)</span></p>
<h4 id="双左旋代价">双左旋代价</h4>
<p><span
class="math inline">\(1+w(x&#39;)+w(f&#39;)+w(g&#39;)-w(x)-w(f)-w(g)\le
1+w(f&#39;)+w(g&#39;)-w(x)-w(f)\)</span></p>
<p><span class="math inline">\(w(f)\ge w(x),w(f&#39;)\le
w(x&#39;)\)</span></p>
<p><span class="math inline">\(w(x&#39;)-w(x)\ge
w(f&#39;)-w(f)\)</span></p>
<p><span class="math inline">\(1+w(f&#39;)+w(g&#39;)-w(x)-w(f) \le 1+
w(x&#39;)+w(g&#39;)-2w(x)\)</span></p>
<p>若 <span class="math inline">\(w(x&#39;)-w(x) \ge 1\)</span></p>
<p>则 $ 1+ w(x')+w(g')-2w(x)(w(x')-w(x))$</p>
<p>否则因为先旋的 <span class="math inline">\(f\)</span>，所以 <span
class="math inline">\(g&#39;\)</span> 下的点不包括 <span
class="math inline">\(x\)</span> 中的点，所以有 <span
class="math inline">\(size_x\ge size_{g&#39;}\)</span>，因此 <span
class="math inline">\(w(x&#39;)-w(g&#39;) \ge1\)</span></p>
<p>得到 <span class="math inline">\(1+ w(x&#39;)+w(g&#39;)-2w(x)\le
2(w(x&#39;)-w(x))\)</span></p>
<p>综上 <span
class="math inline">\(1+w(x&#39;)+w(f&#39;)+w(g&#39;)-w(x)-w(f)-w(g)\le
3(w(x&#39;)-w(x))\)</span></p>
<h4 id="左右旋代价">左右旋代价</h4>
<p><span class="math inline">\(1+w(x&#39;)+w(f&#39;)+w(g&#39;)\le
1+w(f&#39;)+w(g&#39;)-w(x)-w(f)\le
1+w(f&#39;)+w(g&#39;)-2w(x)\)</span></p>
<p>由于最终 <span class="math inline">\(f&#39;,g&#39;\)</span> 都是
<span class="math inline">\(x&#39;\)</span> 的儿子，所以 <span
class="math inline">\(1+w(f&#39;)+w(g&#39;)-2w(x)\le2w(x&#39;)-2w(x)\)</span></p>
<p>所以 <span class="math inline">\(1+w(x&#39;)+w(f&#39;)+w(g&#39;)\le
2w(x&#39;)-2w(x)\)</span></p>
<h4 id="双旋代价">双旋代价</h4>
<p>注意到只会进行一次 zig 操作，所以可以忽视 zig 的那个
1，其余代价直接相加，得到 <span class="math inline">\(3\)</span>，因此
<span class="math inline">\(p_i=O(\log n)\)</span>。</p>
<p>观察到一次 Splay 操作的每个子操作可以弄成 <span
class="math inline">\(3\)</span> ，然后相加抵消掉得到 <span
class="math inline">\(3+3w(x&#39;)-3w(x)\)</span>，是 <span
class="math inline">\(O(n\log n)\)</span> 级别，势能变化量为 <span
class="math inline">\(O(n\log n)\)</span> 级别，故时间为 <span
class="math inline">\(O(n\log n)\)</span> 级别。</p>
<h4 id="单旋代价">单旋代价</h4>
<p>单旋代价为左旋代价的和，每次 <code>Splay</code> 操作数为 <span
class="math inline">\(O(n)\)</span>，故单旋的复杂度上界是 <span
class="math inline">\(O(n^2)\)</span></p>
<h4 id="总结">总结</h4>
<p>以上势能分析对 Splay 操作的要求是非常严格的，因此如果在查询中没有进行
Splay
操作，那么操作时间无法导致对应的势能变化，最后出现不正确的复杂度。</p>
<h3 id="treap">Treap</h3>
<p>数据随机的情况下，一个堆（每个节点的权值均大于它全部后代的权值）的期望高度是
<span class="math inline">\(\log n\)</span>
的，通过左右旋保证堆的性质，可以保证 Treap 的复杂度，左旋右旋和 Splay
完全相同。</p>
<h3 id="fhq_treap">FHQ_Treap</h3>
<p>元素 <code>val</code>：需要维护的值。</p>
<p>权值 <code>height</code>：随机的，用于保持堆性质的值。</p>
<p>核心操作是 <code>Merge</code> 和 <code>Split</code>。</p>
<p><strong>过程中需要时刻保证满足堆的性质</strong></p>
<h4 id="mergeuv">merge(u,v)</h4>
<p>合并两个子树 <code>u,v</code> ，保证 <code>u</code> 中元素全部小于
<code>v</code>，返回根。</p>
<p>和线段树合并非常像。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u||!v)<span class="keyword">return</span> u^v;</span><br><span class="line">    <span class="keyword">if</span>(height[u]&gt;height[v])&#123;</span><br><span class="line">        son[u][<span class="number">1</span>]=<span class="built_in">merge</span>(son[u][<span class="number">1</span>],v);</span><br><span class="line">        <span class="built_in">push_up</span>(u);<span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        son[v][<span class="number">0</span>]=<span class="built_in">merge</span>(u,son[v][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">push_up</span>(v);<span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="splituxyk">Split(u,x,y,k)</h4>
<p>按照元素值小于等于 <span class="math inline">\(k\)</span>
划分为两颗树，较小的那棵树树根为 <span
class="math inline">\(x\)</span>，较大的那个树根为 <span
class="math inline">\(y\)</span>。</p>
<p>细看这个函数其实相当妙。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==<span class="number">0</span>)&#123;</span><br><span class="line">    	x=y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;=k)&#123;</span><br><span class="line">        x=u;</span><br><span class="line">        <span class="built_in">split</span>(son[u][<span class="number">1</span>],son[u][<span class="number">1</span>],y,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		y=u;</span><br><span class="line">        <span class="built_in">split</span>(son[u][<span class="number">0</span>],x,son[u][<span class="number">0</span>],k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也可以按照子树大小划分，用于文艺平衡树。</p>
<h4 id="其它操作">其它操作</h4>
<ul>
<li>get_l(element)：按照小于 <code>element</code>
划分，然后返回较小那边的大小，重新 merge</li>
<li>get_element(rank)：与 <code>splay</code> 没有差异。</li>
<li>insert(element)：按照小于等于它划分，然后 merge 两遍。</li>
<li>erase(element)：按照小于等于它划分，然后按小于它划分，然后把划分得到的两个儿子
<code>Merge</code> 起来再 merge，然后再
merge，<strong>这样是能够处理元素相同节点的</strong>。</li>
<li>get_prev(element)：按照小于它划分，用 get_element()</li>
<li>get_next(element)：按照小于等于它划分，用 get_element()</li>
<li>合并的时候也可以按概率选择父亲，<span
class="math inline">\(sz\)</span> 较大的权重较大，期望复杂度可以证明是
<span class="math inline">\(O(n\log n)\)</span> 的。</li>
</ul>
<h4 id="某些实验">某些实验</h4>
<p>采用佳老师的神奇插入删除方式：</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202210132101632.png"
alt="image-20221013210116511" />
<figcaption aria-hidden="true">image-20221013210116511</figcaption>
</figure>
<p>可以发现正常的插入方式需要 <span
class="math inline">\(14S\)</span>，<span
class="math inline">\(18S\)</span>
是按子树大小概率合并，加上佳老师优化后变为 <span
class="math inline">\(10S\)</span>，有一定改进。</p>
<p>如果直接实现 get_rank 系列函数可以更快，但是没什么必要了。</p>
<p>手写 get_rank 系列后耗时为 <span
class="math inline">\(9S\)</span>，手写 get_rank
系列，采用正常插入方式，用时 <span
class="math inline">\(12S\)</span>。</p>
<p>全实现的 Splay 需要 11S。</p>
<h3 id="vector">vector</h3>
<p>一般来说，如果数据范围 <span class="math inline">\(\le 5\times
10^4\)</span>，或者时限比较宽松，可以用 <code>vector</code>
实现平衡树。</p>
<h3 id="pb_ds">pb_ds</h3>
<p>自带平衡树，一般用于操作比较简单的情况，如果需要打 Tag 之类的，重写
<code>node_update</code> 不如手写一颗。</p>
<h2 id="可持久化平衡树">可持久化平衡树</h2>
<p>可持久化平衡树一般用于解决强制在线的历史版本问题，对于非强制在线问题，其实可以离线到树上实现一个支持撤销的平衡树。</p>
<p>对于强制在线问题，基本思路都是复制修改过的路径，复用没有修改过的路径。</p>
<p>可以发现其实任何一个版本创建之后就是静态的，所以可持久化数据结构的核心是：<strong>任何时刻访问先前的版本，都能得到正确的结果，任何修改不能影响到先前的版本。</strong></p>
<h3 id="splay-实现">Splay 实现</h3>
<p>其它操作不变，Splay
时复制<strong>涉及</strong>的所有点作为一个新版本。</p>
<p>但是，这玩意的复杂度有问题，<strong>Splay</strong>
的复杂度保证在于对操作进行势能分析，引入可持久化后，势能的变化量会变成
<span class="math inline">\(n^2\log n\)</span> ,因此复杂度会退化。</p>
<p>由于实际应用中，很少存在只能用 Splay 的情况，因此没有必要深究 Splay
的可持久化。</p>
<h3 id="fhq-treap-实现">FHQ-Treap 实现</h3>
<p><strong>听说这种实现有点问题，但是实际中并没有出现过问题，如果觉得不太行可以换下面那种奇怪的实现。</strong></p>
<h4 id="split">Split</h4>
<p>由于操作都是从 <code>Split</code> 开始的，所以每次 <code>Split</code>
前都复制一个版本出来，具体的，像可持久化线段树一样把不变的儿子共用，改变的儿子复制。</p>
<p>Split
的路径上所有点的信息都被改变了，需要复制一遍得到新的，这样原先版本的所有节点不会有任何变化。</p>
<p>大致刻画以下 Split 中被修改的点，它呈一条链</p>
<h4 id="merge">Merge</h4>
<p>Merge
过程中的复制不是必须的，原因是每个被修改的点都是被新建出来的点，这个证明可以考虑归纳，合并深度为
<span class="math inline">\(1\)</span>
的节点时，两点显然都是被复制的，不影响原树，合并任何被复制的两个节点时，较小的那个的右儿子，较大的那个的左儿子要么不存在，要么是被复制的，因为在被复制的节点处，链一定会向下延申。</p>
<p>因此合并时可以不用新建节点。</p>
<h4 id="神奇方法">神奇方法</h4>
<p>佳老师有一个神奇写法，理论常数为 <span
class="math inline">\(\frac{1}{2}\)</span>，具体的，插入和删除时先找到第一个
<code>key</code> 小于当前点 <code>key</code>
的点，然后这个点一定是被插入/删除点的儿子，然后把只对这个儿子做一遍
Split，并把树分到插入点的两个儿子上面去，这个思路同样可以用于一般
FHQ-Treap，运用在普通平衡树中，实际效率改进因子在 <span
class="math inline">\(0.33\)</span> 左右。</p>
<p>一般来说删除就正常搞，不然容易写错。</p>
<p><strong>考试的时候如果不卡常就写正常写法，减少可能的错误。</strong></p>
<p><strong>一般来说，空间得开 50 倍。</strong></p>
<p>注：效率改进因子，若效率改进因子为 <span
class="math inline">\(x\)</span>，原时间 <span
class="math inline">\(t\)</span>，则改进后时间为 <span
class="math inline">\(\frac{t}{1+x}\)</span>。</p>
<h3 id="treap-实现">Treap 实现</h3>
<p>由于期望树高是 <span class="math inline">\(\log n\)</span>
的，所以直接复制所有已经被修改的点的信息</p>
<h3 id="某种奇怪的实现">某种奇怪的实现</h3>
<p>类似 FHQ-Treap，但是 Merge
的时候按照子树大小作为权重，随机选一个做父亲，这样的复杂度是有保证的。</p>
<h2 id="文艺平衡树">文艺平衡树</h2>
<p>文艺平衡树是一类用于维护区间的平衡树，它和正常的平衡树类似，但是用树的结构来决定一个元素的大小，适合用来维护结构动态变化的序列。</p>
<p>一般用 Splay 和 FHQ-Treap 实现。</p>
<p>FHQ-Treap 实现时需要支持按 <code>size</code> 划分。</p>
<h2 id="动态树">动态树</h2>
<p>一般用 Splay 实现，复杂度 <span class="math inline">\(O(n\log
n)\)</span>，进行实链剖分，每条实链被一颗 Splay
维护，思想和文艺平衡树类似，用平衡树树的结构表明了原树节点中的的高度关系。</p>
<p>核心操作是 <code>access</code> 和 <code>make_root</code>。</p>
<h3 id="accessx">access(x)</h3>
<p>使得 <span class="math inline">\(x\)</span>
到树根上的路径成为一条实链，断开 <span class="math inline">\(x\)</span>
和它实儿子的连接，并让 <span class="math inline">\(x\)</span> 成为该
Splay 的根。</p>
<h3 id="make_rootx">make_root(x)</h3>
<p>使得 <span class="math inline">\(x\)</span> 成为树根，操作方式是先
<code>accsess</code>，然后翻转这条实链，使得 <span
class="math inline">\(x\)</span> 的深度最小。</p>
<p>由于虚儿子认父不认子，所以整个结构都没有问题。</p>
<h3 id="实现-1">实现</h3>
<p>一般采用 Splay，FHQ-Treap 也没有问题。</p>
<p>但是不能用一般 Treap，因为一般 Treap
对树结构的要求决定了它无法进行旋转操作。</p>
<p>FHQ-Treap 的复杂度很难证明是 <span class="math inline">\(n\log
n\)</span>，但是可以保证上界为 <span class="math inline">\(O(n\log
n^2)\)</span>，Splay 的复杂度则为 <span class="math inline">\(O(n\log
n)\)</span></p>
<p>似乎有 <span class="math inline">\(O(n\log n)\)</span> 的 FHQ-Treap
实现。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>20221012考试总结</title>
    <url>/2022/10/12/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1012%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="考试总结">考试总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0132">考试</a></p>
<p>发挥一般</p>
<h3 id="t1">T1</h3>
<p>很趣味的题，考虑计算答案的过程，首先从某个点开始，遇到</p>
<h3 id="t2">T2</h3>
<p>平衡树模板，不做评价，权当练习使用 <code>pb_ds</code>。</p>
<p>其实有平衡树之外的多种解法。</p>
<h4 id="值域分块">值域分块</h4>
<p>对这个东西其实一直不熟悉，如果序列分块不容易解决或者复杂度多一个
<span
class="math inline">\(\log\)</span>，那么考虑对值域分块，记录和每块数值有关的信息。</p>
<p><span class="math inline">\(O(1)\)</span>
改可以只改对应数值块和自身的数据，<span
class="math inline">\(O(1)\)</span>
查可以对块和块内维护前缀信息或者其它预处理信息。</p>
<h4 id="树状数组上二分">树状数组上二分</h4>
<p>写过若干次，但不熟练。</p>
<p>以前缀和树状数组为例，它每个节点 <span
class="math inline">\(x\)</span> 维护的信息是 <span
class="math inline">\((x-lowbit(x),x]\)</span> 区间的全部信息。</p>
<p>更新时一直 +lowbit，保证了恰好能够维护这些信息。</p>
<p>所以如何二分也比较明晰了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> now=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="comment">// 现在认为在 (now,now+1&lt;&lt;i+1]</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>&lt;&lt;i|now&lt;=n&amp;&amp;sum+c[now|<span class="number">1</span>&lt;&lt;i]&lt;k)&#123;<span class="comment">//在 (now|1&lt;&lt;i,now|1&lt;&lt;i+1]</span></span><br><span class="line">        now |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        sum += c[now];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = now + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="t3">T3</h3>
<p>有些价值的题，"优化状压DP" 还是有一些话题可谈。</p>
<h3 id="t4">T4</h3>
<p>李超树模板题，类似 <code>CDQ</code>
分治的思路或者平衡树维护凸包其实很趣味，但是没有什么启发意义。</p>
<p>等有时间了写一份斜率优化的总结。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>20221011考试总结</title>
    <url>/2022/10/12/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1011%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="考试总结">20221011 考试总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0131">考试</a></p>
<h3 id="t1">T1</h3>
<p>假的可持久化题，弄到树上做撤销就行。</p>
<p>其实写可持久化 FHQ-Treap 更容易</p>
<p>参考 <a href="">关于平衡树</a></p>
<p>还可以用块状链表搞定。</p>
<h3 id="t2">T2</h3>
<p>树套树模板题，但是有一些不同的思考方式。</p>
<p>我采用了线段树套值域线段树，但是需要同时二分多个主席树，不够优雅。</p>
<h4 id="值域树套位置树">值域树套位置树</h4>
<p>一般来说，位置树套值域树更加常见，但如果有些涉及到二分的操作，也许把它们反过来会更加容易，因为反过来之后就可以在数据结构上二分，减少一个
<span class="math inline">\(\log\)</span>。</p>
<p>其实位置树套值域树也可以在数据结构上二分，只是实现起来相对麻烦一些。</p>
<p>可以采用值域线段树套平衡树。</p>
<p>这个时候 FHQ-Treap 的优势就体现出来了，很简单的可以查到 <span
class="math inline">\([l,r]\)</span> 区间内数的个数。</p>
<h4 id="莫队和值域分块">莫队和值域分块</h4>
<p>带修莫队可以处理单点改区间查的问题，修改一共 <span
class="math inline">\(O(n^{\frac{5}{3}})\)</span> 次，查询 <span
class="math inline">\(O(n)\)</span> 次，使用 <span
class="math inline">\(O(\sqrt n)-O(1)\)</span>
的值域分块即可处理问题。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC150D-一类期望问题的思考方式</title>
    <url>/2022/10/10/OI/%E7%AE%97%E6%B3%95/%E4%B8%80%E7%B1%BB%E6%9C%9F%E6%9C%9B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<ul>
<li><p>给你一棵有根树，定义一个点合法当且仅当它到根上的点全为黑色，否则不合法。</p></li>
<li><p>最开始所有点为白色，每次选一个不合法的点涂黑，每个点可以被涂黑多次。</p></li>
<li><p>问所有点被涂黑的期望次数</p></li>
</ul>
<h2 id="思考1">思考1</h2>
<p>这次想题引爆了某人概率论基础不扎实的炸弹。</p>
<p>考虑每个点被涂黑的顺序，是一个排列，取到每种排列的概率相同。</p>
<p>考虑使用全期望公式计算，先考虑固定一个排列时的答案。</p>
<p>先假设只有 <span class="math inline">\(3\)</span> 个点，且顺序为
<span class="math inline">\(3,2,1\)</span>，也就是赠券收集问题。</p>
<p>选第一个点的期望次数为 <span
class="math inline">\(1\)</span>，因为所有满足这个排列的样本点都是以
<span class="math inline">\(3\)</span>
开头，选第二个点，期望次数是多少，或者说，选出第一个点后，下一个被选择的点，在顺序为
<span class="math inline">\(3,2,1\)</span> 的前提下，是 <span
class="math inline">\(2\)</span> 的概率是多少？</p>
<h3 id="frac12-的来历"><span class="math inline">\(\frac{1}{2}\)</span>
的来历</h3>
<p>选第二个点时，可以选的点有 <span
class="math inline">\(3,2\)</span>，选择每个点的概率相同，所以概率为
<span class="math inline">\(\frac{1}{2}\)</span></p>
<p><strong>虽然原本每个点概率时相同的，但是我们求的时条件概率，条件概率的样本空间已经被改变了，所以选择每个点的概率不再相同。</strong></p>
<h3 id="frac23-的来历"><span class="math inline">\(\frac{2}{3}\)</span>
的来历</h3>
<p>考虑概率的定义，<span
class="math inline">\(P=\frac{事件大小}{样本空间大小}\)</span>，考虑该条件的集合和事件与条件的交集，因为此题样本空间无限大，所以考虑将一个无限长序列映射到我们的样本空间，容易发现这样的映射不会改变概率函数。</p>
<p>设 <span class="math inline">\(k\)</span> 为已经选取的数的个数，<span
class="math inline">\(n\)</span> 为数的总数。 $$ <span
class="math display">\[\begin{align}

P=&amp;\lim\limits_{m\rightarrow
\infty}\dfrac{n^{m-1}}{\sum\limits_{1\le i\le m} k^{i-1}\times
n^{m-i}}\\
=&amp;\dfrac{n^{m-1}}{\frac{n^{m}}{n-k}}\\
=&amp;\frac{n-k}{n}
\end{align}\]</span> $$ 这是在正确的样本空间算出的正确结果。</p>
<p>从 Beyes 公式考虑： <span class="math display">\[
\begin{align}
P(下一个值为目标|满足排列限制)=&amp;\dfrac{P(下一个值为目标\wedge满足排列限制)}{P(满足排列限制)}\\
=&amp;\dfrac{\frac{1}{n}\times\frac{1}{(n-k-1)!}}{\frac{1}{(n-k)!}}\\
=&amp;\dfrac{n-k}{n}
\end{align}
\]</span> 神奇吧？</p>
<p><strong>贝叶斯公式连接了条件概率和原问题的样本空间。</strong></p>
<h3 id="总结">总结</h3>
<p><strong>样本空间无限大的时候要小心，不能轻易认为两个元素等价，因为此时
<span class="math inline">\(\infty \ne \infty\)</span></strong>。</p>
<p>用贝叶斯公式好好算算吧。</p>
<p>草率的断言概率为 <span
class="math inline">\(\frac{1}{2}\)</span>，很大一部分原因都是认为两个正无穷时相等的。</p>
<p>有了这个东西就可以愉快的推狮子 NTT 了。</p>
<h2 id="思考2">思考2</h2>
<p>其实这种题还有一种更加普遍的做法，期望线性性，考虑每个点被选的次数，相加可以得到最终答案。</p>
<p>期望线性性来源于期望的定义，一个随机变量是一个函数，定义域为样本空间，值域为
<span
class="math inline">\(\R\)</span>，随机变量的期望为其密度函数积分的收敛值。</p>
<p>因此，无论两个随机变量是否独立，它们的期望都是可加的。</p>
<p>感性理解的话，两个随机变量之和的期望等于这样一个随机变量的期望：每个样本点的取值为两个随机变量在该样本点的取值之和，期望可以粗略理解为随机变量在样本空间每个点的平均值，因此随机变量的期望可加。</p>
<p>所以可以考虑每个点被选的期望次数，如果选到了不在这个点到根路径上的点，那么我们忽略这一次选择，这样的忽略不会影响这个点被选的期望次数，然后问题变成了一条链上的最后一个点被选择的期望次数。</p>
<p><strong>注意，我们只关心这个点被选择的期望次数。</strong></p>
<p>考虑怎么求这玩意，因为整个过程在点到根路径上所有点被选择之后才会结束，所以像赠券收集问题一样倒序。假设有
<span class="math inline">\(k\)</span> 个点还没选，总共 <span
class="math inline">\(n\)</span> 个点，其中 <span
class="math inline">\(w\)</span> 个点可以选，那么转移答案是 <span
class="math inline">\(dp[k]=\frac{k}{w}dp[k+1]+\frac{w-k}{w}dp[k]+\frac{1}{w}\)</span></p>
<p>移项得到 <span
class="math inline">\(dp[k]=dp[k+1]+\frac{1}{k}\)</span>，实际上和 <span
class="math inline">\(w\)</span> 无关，所以就很好算了。</p>
<p>官方题解的说法是如果考虑可以选已经 <code>good</code>
的点，最终答案不变，我理解不了这个过程。</p>
<p>upd：其实现在也可以理解了，因为如果选了已经 good
的点，那么再选一次就行了。</p>
<p><strong>有几个比较重要的地方，一是忽略和答案绝对无关的操作，二是考虑计算过程。</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>概率期望--三门问题及其变形</title>
    <url>/2022/10/10/OI/%E7%AE%97%E6%B3%95/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B-%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="事件和条件">事件和条件</h2>
<p>以下概率均为古典概率模型，暂时不讨论几何概型。</p>
<p>这两个东西是我自己定义的，算概率之前，必须搞清楚事件和条件的区别，下面提两个搞不清楚事件和条件导致的问题。</p>
<h3 id="三门问题">三门问题</h3>
<ul>
<li><p>有三个门，一个门后面有汽车，另外两个门后面是山羊。</p></li>
<li><p>你可以先选择一个门，之后主持人打开一个门，门后是山羊</p></li>
<li><p>问此时两个门后有汽车的概率是多少</p></li>
</ul>
<h4 id="思考方式一错误">思考方式一（错误）</h4>
<p>每个门后有山羊的概率是相等的，打开一个门不会影响另外两个门的状态，故另外两个门后有山羊的概率是相等的，故答案为
<span class="math inline">\(50\%\)</span></p>
<h4 id="思考方式二不严谨">思考方式二（不严谨）</h4>
<p>另外两个门有山羊的概率是 <span
class="math inline">\(\frac{2}{3}\)</span>，排除一个选项，所以选择的门后有山羊的概率是
<span class="math inline">\(\frac{1}{3}\)</span>，另一个门的概率为 <span
class="math inline">\(\frac{2}{3}\)</span>。</p>
<h3 id="不知道叫什么名字的问题">不知道叫什么名字的问题</h3>
<p>有个酒鬼，每天各有 <span class="math inline">\(30\%\)</span> 的概率去
<span class="math inline">\(A,B,C\)</span> 三个酒吧，还有 <span
class="math inline">\(10\%\)</span> 的概率呆在家。</p>
<p>一个警察要找他，警察已经找了 <span class="math inline">\(A,B\)</span>
酒吧，都没找到他，问在 <span class="math inline">\(C\)</span>
酒吧找到酒鬼的概率。</p>
<h4 id="思考方式一错误-1">思考方式一（错误）</h4>
<p>在酒吧的概率是 <span class="math inline">\(90\%\)</span>，<span
class="math inline">\(A,B\)</span> 都没找到，说明一定在 <span
class="math inline">\(C\)</span>，所以在 <span
class="math inline">\(C\)</span> 找到酒鬼的概率是 <span
class="math inline">\(90\%\)</span>。</p>
<p>这个思路和上一个问题思考方式二类似，但是是错误的，因此说它不严谨。</p>
<h4 id="思考方式二不严谨-1">思考方式二（不严谨）</h4>
<p>已知不在 <span class="math inline">\(A,B\)</span> 酒吧，那么在 <span
class="math inline">\(C\)</span> 酒吧和在家的概率之比是 <span
class="math inline">\(3:1\)</span>，因此答案为 <span
class="math inline">\(75\%\)</span>。</p>
<p>这种方式的问题在哪里不必多说了。</p>
<h3 id="解释">解释</h3>
<p>思考这个问题前应该回到概率定义的几个要素：样本空间，样本点，事件。</p>
<p>一个事件的概率被定义为事件大小除以样本空间大小。</p>
<h4 id="三门问题-1">三门问题</h4>
<p>第一个问题中，样本空间的大小为 <span
class="math inline">\(3\)</span>，需要计算在某个不被选择的门后面是羊的情况下，选择的门后面是车的概率。</p>
<p>事件的大小为 <span class="math inline">\(1\)</span>，因此概率为 <span
class="math inline">\(\frac{1}{3}\)</span>，另一个不被选择的门后面有车，其事件大小为
<span
class="math inline">\(2\)</span>，因为最初样本空间中在两个门后的样本点都属于该事件（如果是这两个事件之一，那么没被打开的另一扇门后必定是车）。</p>
<p>推广到 <span class="math inline">\(n\)</span>
门问题，主持人随机打开一个<strong>未被选择且没有车的门</strong>，那么样本空间大小为
<span class="math inline">\(1\)</span>，不改变选择的事件大小为 <span
class="math inline">\(n-2\)</span>，改变选择的事件大小为 <span
class="math inline">\(n\)</span>。</p>
<h4 id="酒吧问题">酒吧问题</h4>
<h4 id="事件域">事件域</h4>
<p>通常解决一个概率问题需要明确事件域，即我们关心的所有事件，如果事件域不合法，那么</p>
<h4 id="某个样本空间不正确导致的悖论">某个样本空间不正确导致的悖论</h4>
<p>假设选的门是 <span class="math inline">\(1\)</span> 号，已知 <span
class="math inline">\(2\)</span> 号门没有车，那么 <span
class="math inline">\(3\)</span> 号门有车的概率是 $$</p>
<p>我们需要明确问题中这个概率定义是在哪个样本空间下的，问题中样本空间的大小很明显是
<span class="math inline">\(3\)</span>，而在被开的门后是山羊的事件大小为
<span class="math inline">\(2\)</span></p>
<h2 id="样本空间无限的问题">样本空间无限的问题</h2>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树和动态规划</title>
    <url>/2022/10/07/OI/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="最小生成树-x-动态规划">最小生成树 X 动态规划</h2>
<p>​ |</p>
<p>​ |</p>
<p>​ |</p>
<p>​ /<br />
</p>
<p>​ /<br />
</p>
<p><strong>F1:</strong> <strong>xxxx</strong> <strong>oooo</strong></p>
<p>…………</p>
<h3 id="最小生成树mst">最小生成树(MST)</h3>
<p>常用算法有 Kruscal 和 Prime，以下会谈一些 MST
的性质和两种算法的证明</p>
<h4 id="kruscal-证明参考-oi-wiki">Kruscal 证明（参考 OI-wiki）</h4>
<p>核心思路是证明任意时刻边集均为一颗 MST 的子集。</p>
<p>归纳的，令当前边集 <span class="math inline">\(F\)</span> 属于的 MST
为 <span class="math inline">\(T\)</span>，考虑新加入的一条边 <span
class="math inline">\(e\)</span>，如果 <span class="math inline">\(e\in
T\)</span>，自然成立。</p>
<p>如果 <span class="math inline">\(e\notin T\)</span>，那么 <span
class="math inline">\(e+T\)</span> 构成了一个环，考虑该环上所有边 <span
class="math inline">\(E_i\)</span>，一定满足 <span
class="math inline">\(w_{E_i} \le w_e\)</span>，否则 <span
class="math inline">\(e\)</span> 应该在 <span
class="math inline">\(T\)</span> 中，得到更优的 MST，所以 <span
class="math inline">\(E_i\)</span> 已经在 <span
class="math inline">\(e\)</span> 之前被加入，构成了一条完整的链。</p>
<p>所以不会加入 <span class="math inline">\(e\)</span>，进行下一步。</p>
<h4 id="一些性质">一些性质</h4>
<h4 id="prime">Prime</h4>
<h3 id="动态规划最小生成树">动态规划最小生成树</h3>
<p>一般这种题都是指数级的题，有 <a href="">这道</a>，<a
href="">这道</a>，和 <a href="">这道</a></p>
<h4 id="例题">例题</h4>
<p>给你一张图，问任选 <span class="math inline">\(i\)</span>
条边，使得图联通的方案数有多少种。</p>
<h4 id="method1">Method1</h4>
<p>记录联通性动态规划</p>
<h4 id="mehod2">Mehod2</h4>
<p>考虑 <span class="math inline">\(dp[mask][i]\)</span> 表示子图 <span
class="math inline">\(mask\)</span>
的答案，转移时发现重复了，因为两种不同的子图分配方案最后可能对应到同一种选边方式，所以我们需要一个顺序一类的东西来保证不重复。</p>
<p>一种比较可行的方式是计算记录顺序的情况下的方案，这样可以钦定枚举的两个子图一定是最后连上的，最后除以一个阶乘。</p>
<p>另一种方式是直接容斥，考虑计算选 <span
class="math inline">\(k\)</span>
条边后不联通的答案，枚举得到的两个连通块就是断开的，还是有重复的问题，但是我们可以钦定每种图只会在与
<span class="math inline">\(1\)</span>
相连的连通块处被统计，这是经典的连通图计数方式。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>20221006考试总结</title>
    <url>/2022/10/06/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1006%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="考试总结">考试总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0130">考试</a></p>
<p>​ <strong>成功垫底</strong></p>
<p>​ 难 T</p>
<p>​ 度 1</p>
<p>​ 倒 磕</p>
<p>​ 序 了</p>
<p>​ 自 一</p>
<p>​ 闭 万</p>
<p>​ 场 年</p>
<h3 id="t1">T1</h3>
<p>我不会的题。</p>
<p>求有向图可达点数量实际上不存在低于 <span
class="math inline">\(O(n^2)\)</span>
的算法，所以得考虑给定图的性质。</p>
<p>显然给定的图是个平面图。</p>
<p>然后定义一个东边的点是有效的，当且仅当它能到一个西边的点，一遍 <span
class="math inline">\(BFS\)</span> 可以把有效点找出来。</p>
<p>然后对于所有点，它能到达的有效点集合一定是一段区间，考虑反证，对于某个点，如果被夹在中间的一个有效点到不了，那么如果其它点可以到就只能穿过一些边，这是不可能的。</p>
<p>写拓扑排序是非常傻逼的行为，直接对每个有效点拓展，算出西边每个点到达有效点坐标的最值就行。</p>
<h3 id="t2">T2</h3>
<p>会但是考场写不出来的题。</p>
<h4 id="method1">Method1</h4>
<p>考虑枚举排列计算 <code>MST</code>，本质上需要求前 <span
class="math inline">\(i\)</span> 个边能将图联通的排列一共有多少个。</p>
<p>可以考虑计算出任选 <span class="math inline">\(i\)</span>
条边后图联通的选法有多少种，然后通过容斥计算出恰 <span
class="math inline">\(i\)</span> 个边联通的排列个数。</p>
<p>可以记录联通性动态规划搞定。</p>
<p>复杂度 <span class="math inline">\(O(bell(n)\times m^2)\)</span></p>
<h4 id="method2">Method2</h4>
<p>枚举联通往往可以弄成二进制枚举联通状态，逆序考虑联通块的构成方式，发现求任
<span class="math inline">\(i\)</span>
条边联通的方案数，转移的时候是不强调顺序的，所以枚举子集会导致重复，不妨直接考虑顺序，计算原问题的答案。</p>
<p>设 <span class="math inline">\(dp[mask][i]\)</span> 表示只考虑 <span
class="math inline">\(mask\)</span> 子图，答案为 <span
class="math inline">\(i\)</span>
的排列个数，转移就可以枚举子集，从上一条边的状态转移，需要进行一些排列组合，复杂度
<span class="math inline">\(3^n\times m^4\)</span>。</p>
<h4 id="method3">Method3</h4>
<p>高达 <span class="math inline">\(m^4\)</span>
的多项式复杂度还是太逊了，考虑继续优化。</p>
<p>其实我们很想直接任选 <span class="math inline">\(k\)</span>
条边，然后排除掉不合法的情况，这样能够求出答案至多为 <span
class="math inline">\(k\)</span> 的个数，容斥之后就没有问题了。</p>
<p>所以考虑如何排除不合法的情况，就是边选好了但是图没联通，这个时候我们就可以枚举一个小连通块，可以用若干边连接内部，若干外部边任选，就是一类不合法的情况，但是这样会算重，我们可以钦定枚举的联通块和
<span class="math inline">\(1\)</span> 联通。</p>
<p>复杂度 <span class="math inline">\(O(3^n\times m^2)\)</span>。</p>
<h4 id="总结">总结</h4>
<p>这一类图论上的二进制枚举问题，往往可以先从枚举联通块入手，再考虑子图的答案，最后综合运用容斥等计数手段，得到复杂度优秀的做法。</p>
<h3 id="t3">T3</h3>
<p>非常有意思的题</p>
<h4 id="method1-1">Method1</h4>
<p>考场上的想法，主要受到<a href="还没写">某道题</a>的启发。</p>
<p>只考虑最大值，<span class="math inline">\(O(n)\)</span>
可以扫一遍，单调栈维护当前每一段的最大值与和。</p>
<p>很浪费，因为我们本质上对每个右端点都求了合法左端点区间的答案，考虑能不能复用右端点的答案。</p>
<p>其中一种方式是分块，考虑一段右端点到每个左端点的答案的前缀和，然后查询就可以被拆分了。</p>
<h4 id="method2-1">Method2</h4>
<p>为什么我们会分块，回到那道题，我们有办法通过一些预处理结果得到两个区间并的答案，但是无法快速合并两个预处理结果，所以我们分块，只需要预处理一次。</p>
<p>但是利用随机数的性质我们发现其实可以快速合并预处理的结果。</p>
<p>将问题转化为两种基本形式，相离和重合，这是容易的。</p>
<p>先考虑相离怎么做</p>
<p>考虑利用随机的性质，发现任意一段区间，其有效的贡献个数为 <span
class="math inline">\(\ln\)</span>
个，即从区间首或位开始的最长连续上升序列，然后枚举两个 <span
class="math inline">\(\ln\)</span> 的区间合并，搞定相离的情况，视实现是
<span class="math inline">\(\ln^2\)</span> 或者 <span
class="math inline">\(\ln\)</span>，后者常数较大可能并不优秀。</p>
<p>然后是重合，能不能合并两个重合的区间得到新的区间，可以！转化为一个相离和两个更小的重合问题，因为数量是
<span class="math inline">\(\ln\)</span>
的，所以合并预处理信息是可能的。</p>
<p>但是，为啥要用线段树，因为没有逆元！但是这道题是可以将一个大重合问题减去一个相离和一个小重合问题得到另一个小重合问题的，所以对大重合问题做前缀和即可。</p>
<h4 id="method3-1">Method3</h4>
<p>对于二维统计问题，常常可以考虑固定预处理其中一维，尝试快速通过预处理结果查询第二维。</p>
<p>这道题中，我们可以预处理每个点作为第二个区间中的点时，在第一个区间中每个点的答案。但实际上这个数据量是
<span class="math inline">\(O(n)\)</span>
的，没有办法快速搞定，那不妨考虑只处理其前缀和与后缀和，看看是否能够压缩信息。</p>
<h5 id="一些不太正确的思考">一些不太正确的思考</h5>
<p>考虑单个右端点对一段区间查询，考虑区间最大值，如果落在自身或者空区间，那么答案容易计算，如果落在左区间</p>
<p>考虑它前面第一个比它大的位置，如果不存在或者在空区间，那么答案可以通过前缀和快速计算</p>
<h5 id="正确的思考">正确的思考</h5>
<p>考虑区间相离的基本情况。由于单点我们都没有办法做，所以不太能直接搞，但是容易发现区间重合时可以搞定的，考虑区间最大值的位置，跨过它的答案容易统计，不跨过它，我们处理了每个点为右端点和左端点时答案的前缀和，那么由于不跨过最大值时，在最大值另一侧的答案完全不受同侧的影响，所以前后缀和减去最大值所在位置的前后缀和就可以得到重合的答案。</p>
<p>有了重合，我们可以解决区间相邻的答案，定义求两个区间答案的运算是
<span class="math inline">\(\oplus\)</span>，那么对于两个相邻区间有<span
class="math inline">\((a+b)\oplus(a+b)=a\oplus a+b\oplus b+a\oplus
b\)</span>。</p>
<p>我们能搞定的是 <span class="math inline">\(a\oplus
a\)</span>，对于相离的区间，转化为相邻区间做 <span
class="math inline">\(a\oplus c = (a+b+c)\oplus (a+b+c)-a\oplus a-b
\oplus b-c\oplus c - a\oplus b -b\oplus c\)</span>。</p>
<p>因而搞定了所有情况。</p>
<h5 id="实现">实现</h5>
<p>如果直接这么写，写出来很丑，实际上由更优雅的写法，考虑差分区间，如果左端点大于右端点那么没有问题，<span
class="math inline">\([l_1,r_2]\)</span> 全部统计，那么会有重复 <span
class="math inline">\([l_1,l_2-1]\)</span>
这一段区间就是被重复统计的，当然这个区间可以不存在，需要减去，然后再减去
<span class="math inline">\([r_1+1,r_2]\)</span>
这段有可能不存在的区间的答案，最后加上可能被算重的 <span
class="math inline">\([r_1+1,l_2-1]\)</span> 区间。</p>
<p>反正这个思想挺神的，看上去有问题但确实是对的，比直接写优雅很多。</p>
<h4 id="method4">Method4</h4>
<h5 id="思路">思路</h5>
<p>考虑每个数对答案的贡献，弄出左右两边第一个比它大的数，那么这些区间以内跨过它的，都在它的贡献范围内，左右端点可以弄成
<span class="math inline">\(x,y\)</span> 坐标，这是一个矩阵加。</p>
<p>考虑查询，本质上也是在查询 <span class="math inline">\(x,y\)</span>
坐标各在一段区间内的答案。</p>
<p>于是就是一个修改全部在查询前面的矩阵加矩阵查问题，可以用树状数组解决。</p>
<h5 id="实现-1">实现</h5>
<p>说着轻松，但其实还没写过这种东西，简单思考下怎么做。</p>
<p>首先区间查被差分成 <span class="math inline">\(\ge x,\ge y\)</span>
的区域加一，区间查变成 <span class="math inline">\(\le x,\le y\)</span>
的区域查询，还是回到了二维偏序问题。</p>
<p>点是 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span>，条件是
<span class="math inline">\(x_2\ge x_1\wedge y_2\ge y_1\)</span>，贡献是
<span
class="math inline">\((x_2-x_1)\times(y_2-y_1)\)</span>，是不是很阴间？所以多维护点东西，一个
<span class="math inline">\(cnt\)</span> 树状数组搞定 <span
class="math inline">\(x_2\times y_2\)</span>，两个分别加 <span
class="math inline">\(x,y\)</span> 来搞定 <span
class="math inline">\(x_2\times y_1,x_1\times y_2\)</span>
，再来一个统计 <span class="math inline">\(xy\)</span>
搞定剩下那一项，其实还算好写。</p>
<h3 id="t4">T4</h3>
<p>考虑刻画出图的形态，它是一个基环内向树森林。</p>
<p>容易发现只用将 <span class="math inline">\(1\)</span>
和其它点连边，然后有些点是必须连的，入度为 <span
class="math inline">\(0\)</span> 的，编号非 <span
class="math inline">\(1\)</span> 的点必须连。</p>
<p>先不考虑环，这样连了之后，又有一些点是必连的，而且容易发现连这些点一定最优，所以继续连。</p>
<p>连到不是环上的所有点都连上为止。</p>
<p>现在还剩一些环，环上一些点是合法的，需要用长度为 <span
class="math inline">\(k-1\)</span> 的线段取覆盖环，让所有点合法。</p>
<p>容易发现确定某个起点之后就能贪心了，考虑连续的 <span
class="math inline">\(k+1\)</span>
个不合法点，枚举每一个并确定最少数量，然后取 <span
class="math inline">\(\min\)</span> 就行，因为这连续的 <span
class="math inline">\(k+1\)</span> 个不合法点一定有一个是起点。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>分块</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>20221005考试总结</title>
    <url>/2022/10/05/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1005%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="总结">总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0129">考试</a></p>
<h3 id="t1">T1</h3>
<p>挺套路的题，通过 <code>00 11</code> 得到 <span
class="math inline">\(1,0\)</span> 的个数，容易发现 <code>10 01</code>
的总个数已经被确定且容易构造。</p>
<p>但是有边界，考虑 <code>00 11</code> 个数为 <span
class="math inline">\(0\)</span>，此时可以取 <span
class="math inline">\(1\)</span> 个也可以取 <span
class="math inline">\(0\)</span> 个。然后 <code>100-&gt;55</code></p>
<p>这种两个构成的计数问题，一定要考虑只有一个的边界情况，</p>
<p>注意我们通过题目信息得到新信息的过程，要看看是否为一一映射。</p>
<h3 id="t2">T2</h3>
<p>有趣的题。</p>
<p>我先思考了如果一个问题我限定一个时间 <span
class="math inline">\(T\)</span>，等 <span
class="math inline">\(T\)</span>
秒过完，得到的收益，实际上我们可能有根据当前信息改变等待的这个时间，所以这样不行。</p>
<p>接着考虑 <span class="math inline">\(t\)</span> 时刻到 Trie 上 <span
class="math inline">\(j\)</span> 点的最优方案，发现其实不好转移。</p>
<p>注意到我们能决定的只有回答还是等待，所以这样的话转移会带上一个概率，但是这个概率却是无法相加后取最值的。</p>
<p><strong>正难则反</strong>，考虑到 <span
class="math inline">\(j\)</span> 点时还剩时间 <span
class="math inline">\(t\)</span>，最优能得到什么，这样的话，转移就只和我们的决定有关，成功解决这道题。</p>
<h3 id="t3">T3</h3>
<p>等价于求最优解并构造方案。</p>
<p>它的修改本质上是需要决定一个最值，付出对应的代价，然后如果某个数绝对值<strong>严格小于</strong>最值，那么这个数的正负性就可以被指定，然后指定最值后最优化代价就是要求出删去的数的最小个数。</p>
<p>我们需要求出对于每个最值的删除数最小个数。</p>
<p>由于不让 <span class="math inline">\(0\)</span>
出现，所以先判掉不修改只删除的方案，这个是简单的。</p>
<p>有两种思考方式，对应了两种求答案的方式。</p>
<p>一个数为负视为 <code>-1</code>，为正视为 <code>1</code>，可调整视为
<code>0</code></p>
<h4 id="method1">Method1</h4>
<p>考虑一段极长连续相同子段，如果不为
<code>0</code>，那么必须删去然后只剩下一个。</p>
<p>如果为
<code>0</code>，其左右两边的状态和自身长度决定了它应该被删去一个或者不做任何处理。</p>
<p>如果能够维护机场连续相同子段，就可以得到答案。</p>
<p>考虑最值从小到大变化的过程，每次会把一个非 <code>0</code> 数改为
<code>0</code>，经典的 <code>set</code> 维护线段问题。</p>
<h4 id="method2">Method2</h4>
<p>考虑动态规划。</p>
<p>设 <span class="math inline">\(dp[i][0/1]\)</span> 表示考虑到第 <span
class="math inline">\(i\)</span> 个数，末尾为 <span
class="math inline">\(-1/1\)</span> 的代价。</p>
<p><span class="math display">\[
v_i=0:dp[i][o]=\min(dp[i-1][o\oplus 1],dp[i-1][o]+1)\\
\]</span></p>
<p><span class="math display">\[
v_i\ne0:
\begin{cases}
dp[i][v_i]&amp;=\min(dp[i-1][v_i\oplus 1],dp[i-1][v_i]+1)\\
dp[i][v_i\oplus1]&amp;=dp[i-1][v_i\oplus 1]+1\\
\end{cases}
\]</span></p>
<p>然后就是动态 DP，考虑能不能写成矩阵乘法的形式，发现是一个 <span
class="math inline">\(+\min\)</span> 矩阵乘法。</p>
<p>线段树维护即可。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>概率期望</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何入门</title>
    <url>/2022/10/04/OI/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="计算几何">计算几何</h2>
<p>写一下学计算几何的感悟。</p>
<h3 id="向量">向量</h3>
<h4 id="点积">点积</h4>
<p><span class="math inline">\(\mathbf{a} \cdot \mathbf{b} =
|\mathbf{a}|\times|\mathbf{b}| \times \cos\theta =
x_1x_2+y_1y_2\)</span></p>
<p>常用来计算向量夹角。</p>
<h4 id="叉积">叉积</h4>
<p><span class="math inline">\(\mathbf{a} \times \mathbf{b} =
|\mathbf{a}|\times |\mathbf{b}|\times \sin\theta =
x_1y_2-x_2y_1\)</span></p>
<p>几何意义是两个向量围成的平行四边形的面积。</p>
<p>从 <span class="math inline">\(\mathbf{a}\)</span> 旋转到 <span
class="math inline">\(\mathbf{b}\)</span>，如果角度小于 <span
class="math inline">\(\pi\)</span>，那么为正，否则为负。</p>
<p>证明的话，方向是直接定义的，先不管，尝试证明。 <span
class="math display">\[
(x_1y_2-x_2y_1)^2=\sin^2\theta \mathbf{a}^2\mathbf{b}^2\\
\]</span> 我觉得这个不太适合用 <code>markdown</code> 写下来。</p>
<p>为什么方向是对的，可以替换一下 <span
class="math inline">\(x,y\)</span> 变成 <span
class="math inline">\(\sin,\cos\)</span>，然后很自然是对的。</p>
<p>可以用来求线段交点。</p>
<p>算一下 <span class="math inline">\(BCD,ACD\)</span> 的面积，用相似求
<span class="math inline">\(AO\)</span>，就可以得到 <span
class="math inline">\(O\)</span> 点坐标。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202210042107116.png"
alt="image-20221004210732068" />
<figcaption aria-hidden="true">image-20221004210732068</figcaption>
</figure>
<h4 id="向量旋转">向量旋转</h4>
<p>有人不会用这个东西，我不说是谁。</p>
<p><span class="math inline">\(\mathbf{a}\)</span> 转 <span
class="math inline">\(\alpha\)</span> 角：<span
class="math inline">\((|\mathbf{a}|\cos(\theta+\alpha),|\mathbf{a}|\sin(\theta+\alpha))\)</span>。</p>
<p>和差角公式记不住的话朱某要来找麻烦，所以有人还是能记住。</p>
<h3 id="多边形">多边形</h3>
<h4 id="三角剖分">三角剖分</h4>
<p><span class="math inline">\(S=\dfrac{\sum\mathbf{a_i}\times
\mathbf{a_{(i+1)\%n}}}{2}\)</span></p>
<p>盗一波图。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202210042117115.png"
alt="image-20221004211714058" />
<figcaption aria-hidden="true">image-20221004211714058</figcaption>
</figure>
<h4 id="凸包">凸包</h4>
<p>按照逆时针方向看，多边形凸包永远往左拐。</p>
<h3 id="直线">直线</h3>
<p>可以用一个点 <span class="math inline">\(P\)</span> 加方向向量 <span
class="math inline">\(\mathbf{v}\)</span> 存储，也可以顺便记一个 <span
class="math inline">\(P_2\)</span>。</p>
<h4 id="点在直线的哪边">点在直线的哪边</h4>
<p>求 <span class="math inline">\(PQ\times \mathbf{v}\)</span>
即可，为正在下方，为负在上方，<span class="math inline">\(0\)</span>
则在线上，前提条件是向量 <span class="math inline">\(\mathbf{v}\)</span>
的 <span class="math inline">\(x\)</span> 为正 。</p>
<h4 id="快速排斥实验和跨立实验">快速排斥实验和跨立实验</h4>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202210051602392.png"
alt="image-20221005160200348" />
<figcaption aria-hidden="true">image-20221005160200348</figcaption>
</figure>
<p>两个矩阵不交，则通过快速排斥实验。</p>
<p>比较简易的方式是对于两维独立判断线段是否有交，如果任何一维无交，则通过快速排斥实验。</p>
<p>跨立实验则是判断一条线段的两端是否在另一条线段的两边，可以用向量叉乘做。</p>
<p>相互做跨立实验，如果均能通过，则线段有交或共线，<strong>结合快速排斥实验可以判断线段是否有交</strong>。</p>
<p><strong>两条线段共线但不交也能通过跨立实验。</strong></p>
<h4 id="两直线交点">两直线交点</h4>
<p>先判断平行和重合。</p>
<p>然后对于两条直线 <span
class="math inline">\((P_1,\mathbf{a_1}),(P_2,\mathbf{a_2})\)</span>，设
<span class="math inline">\(Q=k\mathbf{a_1}+P_1\)</span>，则有 <span
class="math inline">\((P_2-(k\mathbf{a_1}+P_1))\times
\mathbf{a_2}=0\)</span></p>
<p>叉积有分配律，所以直接拆开解 <span class="math inline">\(k\)</span>
然后带回去。</p>
<p><span class="math inline">\(k=\dfrac{(P_2-P_1)\times
\mathbf{a_2}}{\mathbf{a_1}\times\mathbf{a_2}}\)</span></p>
<p>如果你敢约分，朱某就敢把你鲨了。</p>
<h4 id="线和直线的垂足">线和直线的垂足</h4>
<p>算出 <span class="math inline">\(PQ\)</span> 在 <span
class="math inline">\(\mathbf{v}\)</span>
上投影的长度和方向（点积），<span class="math inline">\(P\)</span>
加上这个就行。</p>
<h4 id="点到直线距离">点到直线距离</h4>
<p>可以先算垂足，也可以用记下来的另一个点带面积公式算。</p>
<h4 id="角平分线">角平分线</h4>
<p>模长相同的方向向量相加，得到角平分线的方向向量，证明考虑构造菱形。</p>
<h4 id="凸包-1">凸包</h4>
<p>于是乎求凸包的时候多了一种判定方式：</p>
<p>如果是上凸包，弹出点的充要条件是上个点在<strong>该点与上上个点的连线</strong>下方</p>
<p>下凸包，弹出条件就是在上方，比斜率好一点，而且判共线很方便。</p>
<h3 id="圆">圆</h3>
<h4 id="线援交圆交">线<del>援交</del>圆交</h4>
<p>求出点到直线距离和垂足，然后勾股定理算两个点。</p>
<h4 id="圆圆交">圆圆交</h4>
<p>半径相等可以求中点勾股定理偷懒，半径不等可以选一个三角形解三角形。</p>
<p>具体的，可以算出一个角的 <span class="math inline">\(\cos\)</span>
然后旋转向量，最后乘半径再加上去。</p>
<h4 id="切点">切点</h4>
<p>勾股定理，旋转，解三角形。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>20220930总结</title>
    <url>/2022/10/04/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0930%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="某场考试总结oi-中的解析几何">某场考试总结&amp;&amp;OI
中的解析几何</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0128">考试</a></p>
<p>有人几何学的很差，考场上还非要写。</p>
<h3 id="t1">T1</h3>
<p>exchange-argument，已经是咱非常了解的题目啦啦啦。</p>
<p><a
href="https://huanyp.cn/2022/08/02/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/Exchange-Argument%E5%B0%8F%E6%80%BB%E7%BB%93/">Ex-Ar</a></p>
<h3 id="t2">T2</h3>
<p>套路题，二分然后最短路</p>
<h3 id="t3">T3</h3>
<p>对这种题还是比较熟悉了，不好处理的区间问题分类讨论变偏序，二维偏序解决区间交，贡献独立的情况，李超树搞定贡献分离的情况。</p>
<p>当然可以 CDQ 然后凸包上二分，但是我觉得我更擅长一般的数据结构。</p>
<h3 id="t4">T4</h3>
<p>我.... 不会解析几何。/ll /ll。</p>
<p>办法其实非常蠢，一条可行的最短路一定经过圆弧交点，且只会在这些交点拐弯。</p>
<p>所以求出所有交点，然后判断交点两两路径是否合法，连边跑最短路。</p>
<p>可行的交点其实不多，得判掉在圆内的点，然后剩下点的个数感觉上是 <span
class="math inline">\(O(n)\)</span> 的，实际也是 <span
class="math inline">\(O(n)\)</span>
的，证明我不会，等问数学竞赛的回来再补。</p>
<p>然后判合法本质上是判一条路径是否被覆盖，需要写线圆交，然后前面要写圆圆交，这玩意不是一次函数，会非常裂开，我写的很丑。</p>
<p>圆圆交直径相同，比较好办，用极坐标可以偷懒，线圆交相当折磨。</p>
<p>见 <a
href="https://huanyp.cn/2022/10/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%85%A5%E9%97%A8/">计算几何入门</a>。</p>
<p>用向量写会相当舒适。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title>20220928考试总结</title>
    <url>/2022/09/29/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0928%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="考试总结">考试总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0127">考试</a></p>
<h3 id="t1">T1</h3>
<p>经典的 01 分数规划问题，二分小数，直接 <code>DP</code>
，然后记录转移状态，倒推分数得到答案。</p>
<p>注意这种答案可能为 0 的 01 分数规划一定要从 -1
开始二分答案，不然可能会取不到 <code>0</code>。</p>
<p>注意到其实它的分子分母都比较小，二分分数也是可行的一种方式 。</p>
<p>考场上的错误其实挺离谱的，就不细说了。</p>
<p>二分分数不用倒推，就很简单了。</p>
<h3 id="t2">T2</h3>
<p>套路题。</p>
<p>观察发现如果每张牌个数都大于等于 <span
class="math inline">\(2\)</span>，那么一定合法。否则一定会用一些顺子来凑，同一个位置最多被三个顺子用，所以如果一个位置超过
<span class="math inline">\(5\)</span> 个，可以视为 <span
class="math inline">\(5\)</span> 个，状压 <span
class="math inline">\(DP\)</span>
出合法的状态，对每种状态计算答案并求和。</p>
<p>拿到状态后计算答案就是个组合数。</p>
<h3 id="t3">T3</h3>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>20220927测试总结</title>
    <url>/2022/09/27/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0927%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="考试总结">0927考试总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0126">考试</a></p>
<h3 id="t1">T1</h3>
<p>题意超级钢琴。</p>
<p>真的是非常经典的题目了，可以说是开创了处理同一个问题 <span
class="math inline">\(1-k\)</span> 优解的先河。</p>
<p>将解空间拆分成二维，枚举其中一维，考虑第二维的选择并计算答案，用
<code>priority_queue</code>
选择最优答案，选择答案后将当前的第一维按第二维剩下的情况拆分。</p>
<p>动态点分治也是一样的思路。</p>
<h3 id="t2">T2</h3>
<p>非常经典的题目，严格递增转不降是经典套路，最优解一定取到每个数值也是经典结论。</p>
<p>本题保证数据随机，应该是需要利用随机序列单调上升子序列长度为 <span
class="math inline">\(O(\sqrt n)\)</span> 的性质，但实际上可以 <span
class="math inline">\(O(n^2)\)</span> 轻松通过。</p>
<p>哦，应该是考虑补集转化，然后考虑哪些点固定，然后 <span
class="math inline">\(dp_i\)</span> 表示第 <span
class="math inline">\(i\)</span> 个点固定的最优代价，转移只能从能完成
<code>LIS</code>
转移的点转移过来，中间合法的条件是要么大于右边要么小于左边，根据经典结论一定可以调整成一段和左边相等，一段和右边相等，然后随机的情况下转移点个数
<span class="math inline">\(O(1)\)</span>，长度 <span
class="math inline">\(O(\sqrt n)\)</span>，总复杂度 <span
class="math inline">\(O(n\log n+n\sqrt n)\)</span>。</p>
<h4 id="简单证明经典结论">简单证明经典结论</h4>
<p>假设有一种最优解包含了不是原有数的数。</p>
<p>考虑第一个不是原有数的数，如果它被调大了，那么把它调小成上一个原有数一定更优。</p>
<p>如果它被调小了，就把它调到第一个比调整后的数大的原有数的位置，如果因此导致后面若干个数小于它了，那么不难得知这些数现在都被夹在两个原有的数之间，而且都是从两个原有数区间的外面调整过来的。从左边第一个数开始，找和它相同的数，如果相同的数中，被调小的数较多，那么全部调到第一个和它不同的数，否则调回第一个原数，变成子问题。</p>
<h3 id="t3">T3</h3>
<p>最大值最小显然二分。</p>
<p>考虑一个划分合法的条件，发现只能在某些合法的位置断开，而且在这些位置是否断开不影响第一个条件的合法性。</p>
<p>所以考虑对这些位置动态规划，直接转移是 <span
class="math inline">\(O(n^2)\)</span>
的，然后考虑维护所有可能的转移，发现如果拿个单调栈记录 <span
class="math inline">\(a\)</span>，那么转移的改变可以描述为 <span
class="math inline">\(O(n)\)</span> 次区间加，线段树维护即可。</p>
<p><strong>一个数组，考虑每个前缀的后缀最大值，可以被描述为 <span
class="math inline">\(O(n)\)</span> 次区间加。</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>20220924考试总结</title>
    <url>/2022/09/26/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0924%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="考试总结">20220924 考试总结</h2>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0125">考试</a></p>
<h3 id="t1">T1</h3>
<p>中规中矩的动态规划题。但我选择读错题。</p>
<p>求最长周长可以用一列一列考虑，处理出每个点向上延申的最上面的位置，用单调栈维护这个东西，然后可以做到
<span class="math inline">\(O(点数)\)</span> 处理。</p>
<h3 id="t2">T2</h3>
<p>又是逆向考虑的标准题目。</p>
<p>考虑最终答案的直径，对于直径这种东西，它的中点是非常特殊的，因为从中心到两边的距离是相同的。</p>
<p>这道题又要最小化直径生成树，也就是最小化中心到两边的距离，那从中心到某个点最小距离的最大值恰好就是直径的一般，所以对每个点跑一遍
BFS，求出 BFS 树的直径即可。</p>
<p><strong>不难得到一个结论：最小直径生成树的直径中点（有可能在一条边上）是图的绝对中心，其中图的绝对中心可以存在于一条边上或某个点上，该中心到所有点的最短路的最大值最小。
</strong></p>
<h3 id="t3">T3</h3>
<p>算是套路的反向转对穿。</p>
<p>称将反向视为对穿后形成的局面为对照局面，那么对照局面的周期为 <span
class="math inline">\(2L\)</span>，故问题周期为 <span
class="math inline">\(2L\)</span>，转化为 <span
class="math inline">\(T\le 2L\)</span>。</p>
<p>考虑往回走比较恼火，转化为撞墙后继续走，然后有一个相同颜色的人在此时出发，即在最初在一个对应的位置准备出发，容易发现仍然没有两个点在同一位置。</p>
<p>扩大了 <span class="math inline">\(n,m\)</span>
的范围以及数轴的考察范围，但是不用考虑转向了，难度实际上降低了。</p>
<p>由于有颜色差别，所以可以分出两种思考方向。</p>
<h4 id="换衣服">换衣服</h4>
<p>两个 Heren 相遇后换衣服，从左往右依次考虑每个向左的
Heren，除了第一次之外，都是右边的 Heren 在相邻之间换衣服（向左的那个
Heren 和第 <span class="math inline">\(i\)</span> 个换衣服之后马上和第
<span class="math inline">\(i+1\)</span> 个换），相邻向左的 Heren
换衣服是可以快速计算区间答案的（或者说用扫描线后是均摊 <span
class="math inline">\(O(1)\)</span> 的）。</p>
<h4 id="回到初始局面">回到初始局面</h4>
<p>考虑将对照局面的相遇和原局面的相遇，只需要求出相遇位置的排名，就可以对应回原局面的情况，注意从
<span class="math inline">\([0,L]\)</span>
之外出发的点，是什么颜色其实并不重要，因为排名落在这些区间的相遇，一定在
<span class="math inline">\((0,L)\)</span>
外面，注意是开区间，所以还需要妥善处理边界。</p>
<p>发现每一个向左的点的所有相遇事件，其位置的排名单调递增，对应的坐标也单调递增，回到原序列相邻元素是一个区间加。</p>
<p>思考这个方式的本质，和换衣服的思路没有太大差异。</p>
<p style="font-size:1px">
敲下"相遇"的时候，差点又掉眼泪....
</p>
<h3 id="t4">T4</h3>
<p>考场上想到了处理移动相交转图上问题搞，但是相交关系比较多，这个思路走不动。</p>
<p>首先得发现一件事，如果用一个方向的移动完全可以移动完，证明考虑找左端点最靠左然后最靠上的，所以左端点一定不会被遮挡，然后如果这条线段被另一些线段遮挡，那么找到遮挡它的线段中左端点最靠左然后最靠上的，依次找下去，左端点递增，所以一定会找到一个不被遮挡的线段，移除它就行。</p>
<p>考虑构造一种方案，不妨要求必须往上移动，对每个方向分别求最早的一次不合法，其它情况可以转坐标系。</p>
<p>考虑求出一个方向上，遮挡限制关系构成的图，首先它一定是个
DAG。我估计我是想不到的，但可能确实平面组合几何问题应该考虑扫描线，由于线段不交，所以扫描线与对应线段交点的相对位置永远不变，用
set 维护扫描线即可，加入时会多出 <span
class="math inline">\(O(1)\)</span>
条边。这样构建出来的图是可以正确描述遮挡关系的，感性理解挺容易的，证明有点难写。</p>
<p>拓扑排序之后第二问做完了，第一问的话，如果出现了拓扑序较大的先被移动了，那么就是不合法的，但是需要注意拓扑序只是一个比较松的限制，还需要加上横坐标区间有交才是两条线段存在先后限制的充要条件，证明是显然的。</p>
<p><strong>需要注意的是，这道题用了 <code>set</code>
去维护边，其中涉及到了浮点数的运算和比较，所以 <code>erase</code>
的时候需要考虑浮点误差。</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的一些踩坑记录</title>
    <url>/2022/09/25/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/C-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="声明和定义">声明和定义</h2>
<ul>
<li>正常情况下，函数的声明和定义可以分开写，如果函数参数有默认参数，写在声明或定义处都没问题，如果函数为模板参数，那么<strong>默认参数只能写在声明处</strong></li>
</ul>
<h2 id="模板函数">模板函数</h2>
<p>模板函数用于将同一个函数对不同类型生效，一般来说，最好不要用
<code>auto</code> 来捕获，写模板函数才是正确的方式。</p>
<p><strong>模板函数的声明和定义一般不能分开。</strong></p>
<h3 id="隐式指定">隐式指定</h3>
<p>如果你想偷懒，就是调用的时候不想写
<code>&lt;T1,T2...&gt;</code>，那么你<strong>调用的时候</strong>必须能让编译器推断出每个模板类型参数是什么，而且同一种类型不能冲突。</p>
<p>这里需要注意字面量的类型问题。</p>
<p><strong>注意，如果你使用了默认参数，那么调用的时候可能就无法让编译器推断出类型从而出现
CE</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T1 x,T1 y,T2 len=<span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//CE</span></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">30</span>);<span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T1 x,T2 y,T2 len=<span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1.5</span>);<span class="comment">//OK</span></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1.5</span>,<span class="number">30</span>);<span class="comment">//CE</span></span><br></pre></td></tr></table></figure>
<p>类型参数捕获比较阴间的例子，可以发现它会先捕获"简单"的，不太想深究这个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;T1&gt; a,T1 b,T2 c)</span></span>;</span><br><span class="line"><span class="built_in">add</span>(&#123;<span class="number">1.5</span>,<span class="number">3</span>&#125;,<span class="number">1.5</span>,<span class="number">5</span>);<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">add</span>(&#123;<span class="number">1.5</span>,<span class="number">3.5</span>&#125;,<span class="number">1</span>,<span class="number">5</span>);<span class="comment">//CE</span></span><br></pre></td></tr></table></figure>
<h3 id="显式指定">显式指定</h3>
<p>如果显示指定参数，那么会出现类型强制转换，和正常的函数调用完全相同。</p>
<p>例子就不举了，和正常函数没差别。</p>
<h2 id="指针">指针</h2>
<h3 id="常量指针">常量指针</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;a; <span class="comment">//指向常量的指针</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;a; <span class="comment">//p 指向的位置不可变</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>20220922考试总结</title>
    <url>/2022/09/24/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0922%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://local.cwoi.com.cn:8443/contest/C0124">考试</a></p>
<h2 id="t1">T1</h2>
<p>中规中矩的一道题，但是我的做法比较蠢。</p>
<p>考虑最终那些序列可以成为答案的方式没有问题，但是我考虑的条件是对于
<span class="math inline">\(a_i\)</span>，大于等于它的数必须多余 <span
class="math inline">\(n-i+1\)</span> 个。这样需要记录的东西是 <span
class="math inline">\(2\)</span>
维的，然后转移还不是优雅的前缀和形式。实际上可以考虑 <span
class="math inline">\(b_i\ge a_i\)</span>
这个条件，也就是多想一想的事，这样的转移可以写成优雅的前缀和。</p>
<p>像这种转化后考虑条件的题，一定要找一个简易的条件去做。</p>
<h2 id="t2">T2</h2>
<p>中规中矩的一道状压题。</p>
<p>我考虑直接爆搜联通块，但是这样的做法不是很优雅。转移时其实仅和当前选了哪些点有关，所以其实可以动态规划，做到
<span
class="math inline">\(3^n\)</span>，这种联通块相关的题，一定要考虑联通块之间有没有关系，能不能用动态规划搞定。</p>
<h3 id="t3">T3</h3>
<p>中规中矩的一道数据结构优化动态规划的题。</p>
<p>一种比较经典的动态规划优化方式是拿数据结构维护可能的转移，这题本身有着比较优美的性质，可以将对转移代价的贡献拆成两个区间加。</p>
<p>对于修改独立的情况，如果要快速求出答案需要预处理序列，不妨考虑二进制分组。</p>
<h2 id="t4">T4</h2>
<p>有意思的二分题。</p>
<p>最大值最小还是可以考虑二分的。</p>
<p>对于这种两者加起来不超过一个数的题，往往可以考虑每个数与 <span
class="math inline">\(\frac{s}{2}\)</span> 的关系。</p>
<p>这种题，显然最终的答案序列是很多个不超过 <span
class="math inline">\(\frac{s}{2}\)</span> 的，中间夹着不超过一个大于
<span class="math inline">\(\frac{s}{2}\)</span> 的，所以容易证明不超过
<span class="math inline">\(\frac{s}{2}\)</span>
的数是必选的，如果不选，一定可以调整过去。</p>
<p>然后二分之后需要 check 一下总个数。一个区间中存在合法的大于 <span
class="math inline">\(\frac{s}{2}\)</span>
的数，当且仅当最小值合法。但是如果真的要检查区间最小值个数，那是非常困难的，因为我们需要先得知每个区间的位置，这个位置个数是
<span class="math inline">\(O(n)\)</span> 的。</p>
<p>所以不妨从合法的数本身的性质考虑，容易发现，合法的数，与它左右两边第一个小于它的数的和一定是小于
<span class="math inline">\(s\)</span>
的，如果出现相等那么为了避免重复需要设一个第二关键字。</p>
<p>这样就可以做到 <span class="math inline">\(O(\log)\)</span> check
了，对于两边的边界，可以特判掉。</p>
<p>我们发现需要 check 的东西形如 <span
class="math inline">\([l,r]\)</span> 中 <span class="math inline">\(\le
x\)</span>
的数的个数，这是整体二分擅长处理的东西，所以考虑整体二分，二分的时候将原来的有序组有序的分裂下去，就变成了一维偏序，而且不需要排序（已经有序了）。求左右区间端点也可以类似的做。</p>
<p>对于边界，可以用 ST 表特判，时间复杂度 <span
class="math inline">\(O(n\log n)\)</span>。常数比较大。</p>
<p>整体二分的卡常是有一些技巧的，比如巧妙处理归并，归并的同时分裂数组，通过下标分裂而不是
<code>vector</code> 等。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title>树上链领域修改问题</title>
    <url>/2022/09/21/OI/%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8A%E9%93%BE%E9%A2%86%E5%9F%9F%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>还没写完，估计是个论文级别的大坑</strong></p>
<h2 id="问题引入">问题引入</h2>
<p>NOI2021
中的《轻重边》，一种比较经典的解法是将操作视为点染色，然后处理相邻点颜色相同的数量得到答案。但还有一种真正的<strong>树链剖分</strong>做法，这种做法能够体现树链剖分的本质——将树划分成
<span class="math inline">\(\log n\)</span> 条链，依次处理它们。</p>
<p>这一类题本质上都是树上邻域修改问题，即给定一条链，修改这条链的邻域。</p>
<h2 id="单点邻域修改">单点邻域修改</h2>
<p>条件：操作存在结合律。</p>
<p>给定一个点，修改其树上邻域。</p>
<p>这个是比较好做的，分两种情况讨论，操作是否存在逆元（且逆元容易求解）。</p>
<h3 id="操作存在逆元">操作存在逆元</h3>
<p>将一个点的操作视为两个部分，自身+父亲，对一个点的邻域操作时，在自身上打一个标记，暴力修改自己父亲的值，如果操作存在交换律则没有问题，如果不存在，则需要先得到父亲的真实值，然后操作后再放一个父亲的父亲标记的逆元。</p>
<p>共需进行 <span class="math inline">\(O(n)\)</span>
次操作和求解逆元。</p>
<h3 id="操作不存在逆元">操作不存在逆元</h3>
<p>如果操作只有结合律，那么会比较麻烦，如果是邻域赋值这类和<strong>之前的值无关</strong>的操作，可以记录一下每个点操作时间戳，清空一下树上标记，还是有救的。</p>
<p>如果和之前的值有关，并且查询只在最后做，那么可以开线段树记录一下</p>
<h3 id="操作不存在结合律">操作不存在结合律</h3>
<p>没救了，暴力吧。</p>
<h2 id="单点-k-阶邻域修改">单点 <span class="math inline">\(k\)</span>
阶邻域修改</h2>
<h2 id="树剖的优势">树剖的优势</h2>
<p>首先处理的操作必须具备结合律</p>
<p>首先处理在链上的情况是比较容易的，因为邻域只涉及额外 <span
class="math inline">\(O(1)\)</span>
个点，我们需要将这个优势拿到树上去。</p>
<p>考虑每次处理的 <span class="math inline">\(\log\)</span>
条重链，对于每条重链，它只会在 <span
class="math inline">\(top_u\)</span>
处对其它，或者受到其它重链的影响。不妨将对一个点的修改放到两个地方，它自己和它父亲</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
  </entry>
  <entry>
    <title>0824考试总结</title>
    <url>/2022/09/21/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0824%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="某场考试总结">某场考试总结</h2>
<p>考完了一个月之后再来写总结也是没谁了。。。</p>
<p><a href="https://local.cwoi.com.cn:8443/contest/C0112">考试</a></p>
<h3 id="t1">T1</h3>
<p>简单题，随手构造出来就行。</p>
<p>可以加强，比如弄成质数个，或者干脆 <span
class="math inline">\(10^{18}\)</span> 个。</p>
<p>然而有个结论，考虑往一个字符串后添加 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(0/1\)</span>，那么本质不同子序列个数一定可以写成
<span class="math inline">\(k(x-b)+x\)</span> 的形式，其中 <span
class="math inline">\(x\)</span> 为该字符串的本质不同子序列个数，<span
class="math inline">\(b\)</span> 为上一个 <span
class="math inline">\(0/1\)</span>
前一个位置的答案。根据这个玩意来构造，不会太好做。</p>
<h3 id="t2">T2</h3>
<p>发现本质不同子序列个数随 <span class="math inline">\(n\)</span>
的增长近乎呈指数增长，猜想满足条件的不会太多，所以暴力处理即可。</p>
<p>实际上设 <span class="math inline">\(DP\)</span> 状态，<span
class="math inline">\(dp[i]\)</span> 表示考虑到前 <span
class="math inline">\(i\)</span> 个字符，本质不同子串个数，有转移 <span
class="math inline">\(dp[i]=2\times dp[i-1]-dp[lst[i]-1]\)</span>，<span
class="math inline">\(lst\)</span> 表示 <span
class="math inline">\(i\)</span> 处字符上一次出现的位置。</p>
<p>于是设 <span class="math inline">\(dp[i][j][k]\)</span> 为考虑前
<span class="math inline">\(i\)</span> 个字符，上一个 <span
class="math inline">\(0\)</span> 处本质不同子序列数量 <span
class="math inline">\(j\)</span>，上一个 <span
class="math inline">\(1\)</span> 处本质不同子序列数量为 <span
class="math inline">\(k\)</span>，枚举 <span
class="math inline">\(0,1\)</span>，直接转移。</p>
<h3 id="t3">T3</h3>
<p>我想的是折半之后爆搜，然后剪一下枝，比 <span
class="math inline">\(std\)</span> 快 <span
class="math inline">\(5\)</span> 倍。</p>
<p>确实也是折半，但是其实可以考虑偏序关系，两个 <span
class="math inline">\((x,y,z)\)</span> 三元组合并，不妨要求 <span
class="math inline">\(x_1+x_2\le y_1+y_2\le z_1+z_2\)</span>，然后值为
<span
class="math inline">\(z_1+z_2-(x_1+x_2)\)</span>，本质上是个二维偏序。</p>
<p>还可以剪个枝，强制要求 <span class="math inline">\(x_1\le y_1\le
z_1\)</span>。同样能对应上去。</p>
<p>实际上还可以发现强制要求 <span class="math inline">\(z_2\le y_2\le
x_2\)</span> 也没有问题，证明比较繁琐，故省略。</p>
<h3 id="t4">T4</h3>
<p>很妙的一道题，我想的是，需要将相同城市联系起来，考虑它们在虚树上的关系，每个点需要和它倾向的所有点连边，然后实际上只会连
<span class="math inline">\(O(n)\)</span> 条边，连好之后 <span
class="math inline">\(tarjan\)</span> 求下 <span
class="math inline">\(SCC\)</span> 就行。</p>
<p>有一种非常神奇的做法，考虑点分治，暴力求分治中心的答案，然后考虑其它点，发现之后的所有点的答案都不会跨过分治中心，可以暴力计算。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>20220920总结</title>
    <url>/2022/09/20/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0920%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="某场考试t1"><a
href="https://local.cwoi.com.cn:8443/contest/C0123/problem/A">某场考试T1</a></h2>
<p>怎么说，题不难，但是需要想一下。</p>
<p>考虑右端点进行贪心的思路挺妙的。</p>
<h2 id="某场考试t2"><a
href="https://local.cwoi.com.cn:8443/contest/C0123/problem/B">某场考试T2</a></h2>
<p>比较套路的题，先弄出一个 <span class="math inline">\(t\times
n^4\)</span>
的凑合做，然后发现两维转移系数独立，转移答案为三角形和形式乘上两维系数，可以考虑固定第二维，单独计算第一维不同转移系数对应的式子，每一种系数的变化量为
<span class="math inline">\(O(1)\)</span>，所以一次转移可以做到 <span
class="math inline">\(O(n)\)</span>。</p>
<h2 id="某场考试t3"><a
href="https://local.cwoi.com.cn:8443/contest/C0123/problem/C">某场考试T3</a></h2>
<p>神仙题，考场上猜到树一定有解，但是想的是通过背包来构造解，事实上，可以归纳的证明每棵子树带来的差异可以取
<span class="math inline">\([-sz_u,sz_u]\)</span>
中的任意值，所以对于树暴力构造一条从根到某个点的路径，可以满足路径两边大小相等。</p>
<p>考虑图上的结果。</p>
<p>09
年的一篇集训队论文告诉我们对于图上的问题，往往可以考虑其生成树的解法，从而进行拓展，发现无向图的生成树没有横插边，所以直接选取生成树上的答案，由于没有返祖边，所以原来合法的同样合法。</p>
<h2 id="某场考试t4"><a
href="https://local.cwoi.com.cn:8443/contest/C0123/problem/D">某场考试T4</a></h2>
<p>也是比较套路的题。</p>
<p>很明显本质上是给你个一次函数做路径边权，然后 <span
class="math inline">\(k\)</span> 的值为 <span
class="math inline">\(1\)</span>，所以计算出每个点每个 <span
class="math inline">\(k\)</span> 的值即可。</p>
<p>我选择分层图跑 <span class="math inline">\(dij\)</span>
外加大力卡常，但这是一种非常 <span class="math inline">\(SB\)</span>
的行为，<span class="math inline">\(dij\)</span>
本质上还是保证了转移的无环性，但 <span class="math inline">\(TM\)</span>
这个转移本来就无环还跑你大爷的 <span
class="math inline">\(dij\)</span>，暴力 <span
class="math inline">\(dp\)</span> 出来做凸包就行。</p>
<p>然后从 <span class="math inline">\(n\)</span> 的各个在凸包上的 <span
class="math inline">\(k\)</span>，倒推回去看那些点可能被用到，倒推可以写成记搜，这样只用存一遍边。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>20220919小记</title>
    <url>/2022/09/19/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%985/</url>
    <content><![CDATA[<h2 id="某道-gcd-题">某道 GCD 题</h2>
<p>给一个 <span class="math inline">\(n\times m\)</span> 矩阵，元素为
<span class="math inline">\(1-n\times m\)</span>
的排列，问你所有子矩阵的 GCD 之和。</p>
<p>反正我想的是考虑一个右下角，移动左上角来统计答案，这样的话考虑到 gcd
的变化次数是<span class="math inline">\(\log\)</span>
的，说不定有救，但是需要完成区间取 GCD，这个不好做。</p>
<p>想一下，这个做法没有利用到每个数只出现一次的性质，通常这种只出现一次的性质往往和倍数这些相联系，不妨换个思路考虑，考虑
<span class="math inline">\(i\)</span>
的倍数的子矩阵的数量，然后发现容斥一下就可以得到答案。统计 <span
class="math inline">\(i\)</span> 的倍数的子矩阵数量不难。</p>
<h2 id="noi2021d1t1">NOI2021D1T1</h2>
<p>我想了一下，链是会做的，<strong>树链剖分</strong>，就是把树变成 <span
class="math inline">\(\log\)</span> 个链来做。</p>
<p>然后其实每条重链按照链的方式来做，重链的交汇处需要特殊处理。</p>
<p>不妨把边下放到点，发现如果一个点的父亲的修改时间晚于该点的修改时间，那么这个点所代表的链就没用，所以对每个点维护两个东西，一个是该点的修改时间，另一个是该点代表的边是否被修改成重边。</p>
<p>查询的时候对链的交界处需要查修改时间判断是否有效。</p>
<p>其实有个更简易的方式，就是把修改看成染色，一条边有贡献当且仅当其两个端点颜色相同，这个很容易用树剖维护。</p>
<p>这两种方式其实体现出处理边的两种方式——下放到点考虑，考虑两个端点的状态。</p>
<p>需要灵活运用这两种方式解题。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>随记20220904</title>
    <url>/2022/09/05/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E8%AE%B020220904/</url>
    <content><![CDATA[<h2 id="随记20220904">随记20220904</h2>
<p>双膝折叠，跪坐在算不上柔软的沙发上，两臂枕在凸起的窗沿。我有些懒散的将下巴靠在小臂，又竭力不让窗沿压迫小臂，以免有些脆弱敏感的手部神经受到刺激，<span
class="math inline">\(P=\frac{F}{S}\)</span>，一个非常优美的公式。我开始估算手臂和窗沿的接触面积，我脑袋的半径，以便带入人体平均密度计算出手部受到的压强相当于几个大气压。</p>
<p>不得不说，物理和数学公式都是优美的，只需要用上统一的几个名字，就能尽情将身边的一切等效。或者说，公式本身不够优美，但是人们设计的物理单位是那么的精巧，避免了那些繁杂的常量，一些无比熟悉的数字又飞入脑海，<span
class="math inline">\(e\approx2.718\)</span>,<span
class="math inline">\(\pi\approx3.1415927,G\approx6.67\times
10^{-11}m^3kg^{-1}s^{-2}\cdots\)</span>。</p>
<p>将越跑越远的联想收回来，生活不是科学，生活不需要那些能精确到小数点后几十几百位的数字。生活的美感，是一种无法用任何数学语言描述的美感。</p>
<p>陶渊明的 “采菊东篱下，悠然见南山”，带来田园的悠然自得。</p>
<p>王维的 “大漠孤烟直，长河落日圆”，给出荒凉的独特答案。</p>
<p>马致远的
“枯藤老树昏鸦，小桥流水人家，古道西风瘦马。”，留下秋日的那份伤感。</p>
<p>但我只是一个平常的理科生，对感性的语文并不敏感，但窗外的宁静，也足以让我有感写下一些拙劣幼稚的文字。</p>
<p>我不知道今年的干旱具体给天府之国带来了多大的影响，但是从居民区的停电和学校的被迫放假还是能够管中窥豹。刚回到学校没多久，COVID
就横扫四川所有中学，没有一所逃过延迟开学的结局，即使是强硬如某校，也只不过多坚持了半天，就匆匆将神兽们赶了回去——就在高温假结束后的
2 天。</p>
<p>所以我就在这个时候，趴在了窗前，半夜的街道很冷清，只能听见百草路地铁口
“握紧扶手，注意脚下” 的提醒。目光向上
90度，我甚至能分辨出夜空中的云朵，它们和蓝色的天空还有一丝界限，但其实都很暗，它们一起向目光尽头的高楼收敛。如果你想具体的体会一下，你可以打开
<code>mspaint</code>，天的颜色是 <code>0 60 85</code>，云的颜色是
<code>212 212 212</code>，而它们收敛向 <code>69 24 34</code>。RGB
空间还是很无力，区区 3Byte
无法描绘出世界上的，甚至无法描绘出人肉眼可以分辨的所有颜色。</p>
<p>黯淡的云朵没有动作，视野的右侧有一颗明亮的光点，它是星星。按照不知道从哪里得知的观星技巧，我快速的扫过窗口狭小的天空，又有数十的光点在视野中闪过，但我尝试正眼捕捉，它们又藏入了深色的天空，像是一个个纯黑背景下的白色像素点，于缩放后在显存中被彻底删除，我再也找不到它们。即使有着凹透镜的帮助，变形略显严重的晶状体也失去了精确的将波长仅有
<span class="math inline">\(300-500nm\)</span>
的可见光折射到每一个感光细胞的能力。</p>
<p>一段时间的沉寂后，波浪状的云遮住了唯一那颗被轻易捕捉到的星星，视野渐渐下移，移过
“立德树人”
四个大字，是熟悉的水泥路。很突然，沥青从路面翻起，回到工人的铲子，回到工程车辆，回到工厂，最后在分馏器中重新变成原油，再顺着磕头机的管道流入地底。远处的高楼被荒芜的草地替换，眼前的工地，正热火朝天。。。</p>
<p>又重归沉寂，只有略冷的风打在脸上，我看了看最近都在 1.5km
之外的高楼，并细细感受周遭的气温，思考着这股风的来历，但已经有些陌生的地理和物理知识不再能闪着光告诉我答案。</p>
<p><code>shutdown -f</code>，我告诉大脑，但又用留在海马体里的数据恢复了这段文字，像是被设置了关机命令为休眠的计算机。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>从2D1D到1D1D</title>
    <url>/2022/09/03/OI/%E7%AE%97%E6%B3%95/%E4%BB%8E2D1D%E5%88%B01D1D/</url>
    <content><![CDATA[<h2 id="从区间-dp-到线性-dp">从区间 DP 到线性 DP</h2>
<h3 id="题目">题目</h3>
<p>你有 <span class="math inline">\(n\)</span> 个区间，每个区间是 <span
class="math inline">\(l,r,w\)</span>
三个参数描述，表示左右端点和权值，如果区间有交（包括端点），那么就在有交的两个区间连边，形成一张无向图，有个参数
<span
class="math inline">\(k\)</span>，你需要删去一些区间，使得每个联通块大小不超过
<span class="math inline">\(k\)</span>。</p>
<ul>
<li><p><span class="math inline">\(n\leq 500\)</span></p></li>
<li><p><span class="math inline">\(n\leq 2500\)</span></p></li>
</ul>
<h3 id="思考">思考</h3>
<p>首先这肯定不是一个图论问题，给一张图做这个问题是 <span
class="math inline">\(NP\)</span> 的，所以要利用好区间的性质。</p>
<p>先把区间离散化。</p>
<p>发现可以考虑一段区间 <span
class="math inline">\([l,r]\)</span>，只考虑在区间内的区间，计算其答案，有两种方式，第一种是将区间继续划分成两个子区间，<strong>划分区间的过程，体现出了全局最优的思想</strong>，即我们假定了当前区间内的所有线段全部联通，这样不一定能在此处取到最优解，但一定可以在向下动态规划的过程中得到最优解，另一种是直接在当前区间选最大的
<span class="math inline">\(k\)</span> 个保留。</p>
<p>划分区间的方式，就是选一个地方断开，删掉越过这个地方的所有区间，变成两个子问题。</p>
<p>有了这样的思路，我们很容易设计出一个 <span
class="math inline">\(O(n^3)\)</span> 的区间动态规划出来。</p>
<h3 id="优化">优化</h3>
<p><span class="math inline">\(O(n^3)\)</span> 可以通过 <span
class="math inline">\(n\leq 500\)</span> 的数据点，但是无法通过 <span
class="math inline">\(n\leq 2500\)</span>，所以需要优化为 <span
class="math inline">\(O(n^2)\)</span>，其中预处理 <span
class="math inline">\([l,r]\)</span> 的复杂度是 <span
class="math inline">\(O(n^2\log n)\)</span>
的，但是常数较小能够接受。</p>
<p>于是可以考虑利用区间 <span class="math inline">\(dp\)</span>
的一些常见优化手段，打个表，发现决策点并不单调，所以对于这类 <span
class="math inline">\(2D1D\)</span>
问题我们有点束手无策。但是感觉上记录区间有点浪费，于是考虑能不能线性的搞出来。发现如果设
<span class="math inline">\(dp[i]\)</span> 表示考虑前 <span
class="math inline">\(i\)</span> 个的答案，从 <span
class="math inline">\(j&lt;i\)</span> 转移，<span
class="math inline">\([j,i]\)</span> 采用直接减少到 <span
class="math inline">\(k\)</span>
的方式，也能得到和区间DP方式相同的转移考虑。</p>
<p>所以被优化成了 <span
class="math inline">\(O(n^2)\)</span>。越过每个点的区间总数，是可以动态维护的，均摊
<span class="math inline">\(O(1)\)</span>。</p>
<h3 id="从2d1d到1d1d">从2D1D到1D1D</h3>
<p>其实这类问题，是伪区间DP问题，比较它和真区间DP问题，比如《石子合并》，《优雅的闪电》的差异。它本质上是
1D1D
问题，石子合并很明显就是需要体现区间合并的顺序，所以必须采用区间DP。优雅的闪电的转移，无法被
1D1D 的转移考虑完全，所以仍然需要区间 DP。</p>
<p>关于一些 2D1D 的问题，可以仔细考察它的转移，能否被 1D1D
的形式描述，以便优化。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 容器</title>
    <url>/2022/08/30/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E5%85%B3%E4%BA%8EC++%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="标准库">标准库</h2>
<ul>
<li>STL
内的所有基于比较的容器，都需要定义一个满足<strong>严格弱序</strong>的比较符号
<code>&lt;</code>，要求如下：
<ul>
<li>满足传递性：<span class="math inline">\(a&lt;b,b&lt;c\rightarrow
a&lt;c\)</span></li>
<li>不能同时满足 <span class="math inline">\(a&lt;b\)</span> 且 <span
class="math inline">\(b&lt;a\)</span></li>
<li>如果 <code>!(a&lt;b)&amp;&amp;!(b&lt;a)</code> 那么
<code>a=b</code></li>
</ul></li>
<li>除开 <code>array</code> 之外的所有 <code>STL</code>
容器，定义时都会初始化，即初始化为空或者(全为 <code>0</code>，对于
<code>bitset</code>)。</li>
<li>基于比较的容器，需要定义<strong>友元类型的大小比较符号</strong>，因为实现的时候使用了右值做比较。</li>
</ul>
<h3 id="priority_queue">priority_queue</h3>
<p>默认是大根堆，跑得很快，1 秒 <span class="math inline">\(3\times
10^6\)</span></p>
<p>如果需要实现可以删除的优先队列，<strong>必须保证每次删除时对应元素存在</strong>。</p>
<p>构造方式
<code>priority_queue&lt;type,container,cmp&gt;</code>，<code>container</code>
是实现 <code>priority_queue</code> 的容器，一般用
<code>vector</code>，<code>cmp</code>
是比较算子（因此它是一个类名）。</p>
<p>通过 <code>greater&lt;typename&gt;</code> 可以用重载的
<code>&gt;</code> 构造出一个大于算子。</p>
<h3 id="map">map</h3>
<p>本质上是 <code>set&lt;pair&lt;T1,T2&gt;&gt;</code>，见
<code>set</code>。</p>
<h3 id="set">set</h3>
<h4 id="insert">insert</h4>
<p>可以插入一段区间，支持数组，同类型的 <code>set vector</code>
容器。</p>
<p>开 O2，<span class="math inline">\(1\)</span> 秒 <span
class="math inline">\(1.5\times 10^6\)</span> 次操作。</p>
<p>如果接下来的一段插入有序，开 O2，<span
class="math inline">\(1\)</span> 秒 <span
class="math inline">\(4.5\times 10^6\)</span>
次，所以尽量排序后再插入。</p>
<h4 id="erase">erase</h4>
<p>开 O2，<span class="math inline">\(1\)</span> 秒 <span
class="math inline">\(1.5\times 10^6\)</span> 次操作。</p>
<p>如果接下来的一段插入有序，开 O2，<span
class="math inline">\(1\)</span> 秒 <span
class="math inline">\(4.5\times 10^6\)</span> 次。</p>
<h4 id="迭代器操作">迭代器操作</h4>
<p>开 O2，<span class="math inline">\(1\)</span> 秒 <span
class="math inline">\(10^7\)</span>。</p>
<h4 id="遍历">遍历</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v:st)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=st.<span class="built_in">begin</span>();it!=st.<span class="built_in">end</span>();it++)</span><br></pre></td></tr></table></figure>
<p>以上两种均为 <span class="math inline">\(O(n\log n)\)</span></p>
<p>开 O2，<span class="math inline">\(1\)</span> 秒 <span
class="math inline">\(10^7\)</span> 次操作。</p>
<h3 id="unordered_set">unordered_set</h3>
<p>基础操作相比 <code>set</code> 快 <span
class="math inline">\(2\)</span> 倍。</p>
<p>有序操作和 <code>set</code> 效率差不多。</p>
<h3 id="unoedered_map">unoedered_map</h3>
<p>本质上是 <code>unordered_set&lt;pair&lt;T1,T2&gt;&gt;</code>。</p>
<h3 id="vector">vector</h3>
<p>比较理想的一个容器。</p>
<h4 id="push_back">push_back()</h4>
<p>一个 <code>vector</code> 做 <code>push_back</code> 需要
<code>log</code> 次 <code>new</code>，而 <code>new</code>
操作一般只能接受 <span class="math inline">\(2\times 10^7\)</span>
次，所以尽量避免用太多 <code>vector</code>，如果能事先确定容器的
<code>capacity</code>，最好用 <code>resize</code></p>
<h4 id="iterator-insertiteratorval">iterator insert(iterator,val)</h4>
<p>将 <code>val</code> 插入 <code>iterator</code> 位置，原
<code>iterator</code> 位置往后移动。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>，但是跑得飞快。</p>
<h4 id="iterator-eraseiterator">iterator erase(iterator)</h4>
<p>删除 <code>iterator</code> 位置的值，返回原容器(删除前)下一个位置的
<code>iterator</code>。</p>
<h4 id="iterator">iterator</h4>
<p>这东西的迭代器本质上是个指针，但是不能和指针做强转，<strong>所以
<code>iterator</code> 在被 <code>erase</code> 后会指向错误的数据，不同于
<code>set</code> 这一类基于 <code>RBT</code> 的容器</strong>。</p>
<h4 id="内存过程">内存过程</h4>
<p>调用析构函数之前，<code>vector</code>
的内存不可能被释放，<code>push_back</code> 或者 <code>resize</code>
如果导致了内存改变，<strong>会开辟一块新的内存并将原有数据全部拷贝过去，保证内存地址的连续，同时原有迭代器全部失效。</strong></p>
<p><strong>vector 所有的 <span class="math inline">\(O(n)\)</span>
操作都很快</strong>，如果题目性质决定了很可能 <span
class="math inline">\(O(n^2)\)</span> 卡不满，那么 <code>vector</code>
可以得到很高的分数。</p>
<h2 id="拓展库">拓展库</h2>
<p>一个 <code>C++</code> 拓展库，<code>STL</code>
升级版，<code>C++11</code> 特性。</p>
<h3 id="gp_hash_table">gp_hash_table</h3>
<h4 id="introduction">Introduction</h4>
<p>如名称，哈希表，比 <code>unordered_map</code> 快 <code>3~4</code>
倍，用法完全一样，你值得拥有。</p>
<p>效率 1S 能做 4e7 次基本操作</p>
<p>在 <code>ext/pb_ds/assoc_container.hpp</code> 中。</p>
<p>如果对非标准结构，例如类和 <code>pair</code>
，容器等，需要自己写哈希方法，哈希方式为一个类，重载了 <code>()</code>
运算，该重载必须被声明为常函数，且参数必须为常值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line">__gnu_pbds:: gp_hash_table &lt;<span class="type">int</span>,<span class="type">int</span>,hash_fun&gt; mp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> node &amp;x,<span class="type">const</span> node &amp;y)&#123;</span><br><span class="line">		<span class="keyword">return</span> x.a==y.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash_fun</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> node &amp;a)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">__gnu_pbds:: gp_hash_table&lt;node,<span class="type">int</span>,hash_fun&gt; mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">mp[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(mp.<span class="built_in">find</span>(<span class="number">2</span>) != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mp.<span class="built_in">find</span>(<span class="number">2</span>)-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tests">Tests:</h4>
<p>这里只放关键部分，其余实现见<a
href="huanyp.cn/codes/Tests/hash_table/cmp.cpp">代码</a></p>
<p>测试环境为 Windows10，CPU 型号为 Inter I7-9750H，内存 16GB，
2667Mhz</p>
<p>命中率对速度影响：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gen_data</span>(<span class="number">1e6</span>,<span class="number">4e7</span>,<span class="number">8</span>,<span class="number">7</span>);<span class="comment">//hit rate:87.5%</span></span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//878ms</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//3107ms</span></span><br><span class="line"><span class="built_in">gen_data</span>(<span class="number">1e6</span>,<span class="number">4e7</span>,<span class="number">8</span>);<span class="comment">//hit rate:12.5%</span></span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1351ms</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//4168ms</span></span><br></pre></td></tr></table></figure>
<p>插入和查询次数调整：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gen_data</span>(<span class="number">2e6</span>,<span class="number">4e7</span>,<span class="number">4</span>,<span class="number">1</span>); <span class="comment">//插入 2e6</span></span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1475</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//4728</span></span><br><span class="line"><span class="built_in">gen_data</span>(<span class="number">5e6</span>,<span class="number">4e7</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1445</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//5038</span></span><br><span class="line"><span class="built_in">gen_data</span>(<span class="number">1e7</span>,<span class="number">4e7</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1877</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//6128</span></span><br></pre></td></tr></table></figure>
<p>插入很多，查询很少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gen_data</span>(<span class="number">2e7</span>,<span class="number">4e6</span>,<span class="number">50</span>,<span class="number">1</span>);</span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1690</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//8383</span></span><br></pre></td></tr></table></figure>
<p>其实插入操作比较慢是正常的，内存占用大了之后自然就慢了。</p>
<p>另外，手写哈希表探测法还有救，拉链法直接抬走（你写代码的时候考虑过
CPU cache 的感受吗？）。</p>
<p>插入较少且全部在查询前面 <code>cc_hash_table</code> 的效率优于
<code>gp_hash_table</code>。</p>
<h3 id="tree">Tree</h3>
<p>虽然有这个东西，但是还是应该学习如何写平衡树。</p>
<p>效率还可以，开 O2
和以前手写差不多，估计现在手写的会快一些，不过问题不大。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>代码技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>GeogeBra计算器简易使用教程</title>
    <url>/2022/08/17/%E5%AD%A6%E6%9C%AF/%E5%B7%A5%E5%85%B7/GeogeBra%E8%AE%A1%E7%AE%97%E5%99%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="geogebra-计算器简易教程">Geogebra 计算器简易教程</h2>
<p>如果本文讲的不够精确，可以继续上网搜索教程。</p>
<h3 id="格式">格式</h3>
<p>数学公式格式直接支持 <code>LaTex</code> 和 <code>wolframalpha</code>
提供的数学公式，也可以按照它的提示写。</p>
<p>乘方为 <code>^</code>，分式直接写 <code>/</code>。</p>
<p>内置 <code>ln sin cos</code> 等常用函数，写约定的函数名即可提示。</p>
<p>求导可以直接写 <span class="math inline">\(f&#39;\)</span></p>
<p>积分输入 <code>integral</code>，会提示参数，默认对 <span
class="math inline">\(x\)</span> 做不定积分。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134545.png"
alt="E1" />
<figcaption aria-hidden="true">E1</figcaption>
</figure>
<p>可以看到下面还有一些特殊函数的提示框，可以根据这个输入。</p>
<h3 id="操作">操作</h3>
<p>一般只会用到 <code>Algebra</code> 区域的东西。</p>
<p>鼠标拖动可以调整坐标系显示区域，滚轮调整显示精度。</p>
<p>右下角的三个按钮中前两个可以起到滚轮的作用。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134475.PNG"
alt="E2" />
<figcaption aria-hidden="true">E2</figcaption>
</figure>
<p><code>ctrl+z</code> 撤销上一步操作，<code>ctrl+y</code>
取消上一步撤销操作，一步操作的判定比较迷惑，你认为的多步操作可能被判定为一步。</p>
<h3 id="设置">设置</h3>
<p>右上角有设置图标，见上图，点开后是是这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134442.PNG"
alt="E3" />
<figcaption aria-hidden="true">E3</figcaption>
</figure>
<p>前三个全部默认勾上，不管，第五个 <code>Zoom to fit</code>
是自动调整的合适的大小，基本没用，点开第六个
<code>Settings</code>，主要用这个：</p>
<p>点进去之后只需要调 <code>Basic</code>，其它基本不用管。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134810.PNG"
alt="E4" />
<figcaption aria-hidden="true">E4</figcaption>
</figure>
<p>后面的基本不管，只需要调整
<code>Dimensions</code>，<code>x Min,x Max,y Min, y Max</code>
字面意义，显示的 <span class="math inline">\(x,y\)</span>
坐标的最大值和最小值，如果调整的话会自动调整下面的
<code>xAxis yAxis</code>，也就是 <span
class="math inline">\(x,y\)</span> 坐标的比例，如果点了
<code>xAxis</code> 那个锁定小图标，那么调整 <code>x Min</code>
会自动调整其它两个值(<code>y Min,x Min</code>)以满足比例要求。</p>
<h3 id="变量和函数设置">变量和函数设置</h3>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134339.PNG"
alt="E5" />
<figcaption aria-hidden="true">E5</figcaption>
</figure>
<p>红圈圈出来的可以设置函数和变量，函数左边那个带颜色的框框可以点，点了之后就不再显示图像，当然再点一次就显示。</p>
<p>函数的设置没啥说的，看变量。</p>
<p>变量的那个播放按钮按下后会动态改变变量值，所有相关函数都会同时改变。</p>
<p><strong>如果希望在函数中使用变量，一般先定义变量再写函数。</strong></p>
<p>变量的设置中可以调整范围。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134005.PNG"
alt="E6" />
<figcaption aria-hidden="true">E6</figcaption>
</figure>
<p>在 <code>Slider</code>
选项中调整，调整的时候，<strong>上下界都调整好之后再按回车</strong>。</p>
<p><a href="https://www.geogebra.org/calculator/fgqtercd">DEMO</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>科普</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P6025题解</title>
    <url>/2022/08/05/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E6%B4%9B%E8%B0%B7P6025%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="洛谷p6025-题解">洛谷P6025 题解</h2>
<p>提供一个复杂度为的 <span class="math inline">\(O(\log n)\)</span>
的，基于正常分析而非打表的做法，我认为这个做法比当前题解区的所有做法更加优美。</p>
<p>这道题相当不错，考察了线段树和位运算的理解。</p>
<h3 id="题意">题意</h3>
<ul>
<li><p>一颗常规方式构建的线段树，求大小为 <span
class="math inline">\(1,2,3,\cdots n\)</span>
的线段树分别占用的最大空间，即最大下标。</p></li>
<li><p>输出答案的异或和。</p></li>
<li><p><span class="math inline">\(n\leq 10^{15}\)</span></p></li>
</ul>
<p>构建代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">		<span class="comment">//e.g. tree[k]=a[l]</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(k&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">	<span class="comment">//e.g. tree[k]=tree[k&lt;&lt;1]+tree[k&lt;&lt;1|1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原题意是求 <span
class="math inline">\(f(l,r)\)</span>，但很容易转化为求 <span
class="math inline">\(f(1,n)\)</span>，直接求 <span
class="math inline">\(f(1,l-1)\bigoplus f(1,r)\)</span>
即可。</strong></p>
<h3 id="分析">分析</h3>
<h4 id="pts">40PTS</h4>
<p>首先，线段树建立的过程，就是<strong>从根往下走的过程</strong>，往左走，向当前编号的二进制表示后写一个
<span class="math inline">\(0\)</span>，往右走，就写一个 <span
class="math inline">\(1\)</span>。</p>
<p>考虑线段树的最大下标在何处取到，由于右儿子下标相对较大，一个比较显然的想法是一直走右儿子，但是这样是错误的，显然的反例为
<span class="math inline">\(n=3\)</span>，如下图所示。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/7aesc0yg.png" /></p>
<p>这个例子中，<span class="math inline">\([1,3]\)</span>
节点的左儿子比右儿子多一层，所以出现了走左儿子最优的情况。</p>
<p><strong>但是，如果某个节点处左右儿子高度相同，那么很显然应该走右儿子，因为当前这一步决定的位数是最高位。</strong></p>
<p>所以走左儿子，当且仅当左右儿子高度不同，下面分析线段树的高度和长度的关系。</p>
<p>首先，子树构建情况<strong>只和长度有关</strong>，所以我们<strong>只关心长度而非左右端点</strong>，然后，长度为
<span class="math inline">\(2^k\)</span>
的节点，构建出的树为一颗完全二叉树，其高度为 <span
class="math inline">\(k\)</span>。 此时，如果点数继续增大，那么高度为
<span class="math inline">\(k\)</span>
的树就无法容下这么多节点，高度会变为 <span
class="math inline">\(k+1\)</span>，所以，长度为 <span
class="math inline">\((2^k,2^{k+1}]\)</span> 的节点，构建出子树的高度为
<span class="math inline">\({k+1}\)</span>。</p>
<p>容易发现，常规构建方式构建出的子树，其<strong>左儿子的大小不小于右儿子，且差值至多为
1</strong>，因此，如果出现了左右儿子高度不同，一定是左儿子比右儿子高，并且只能是一种情况，即长度的二进制表示为
<span
class="math inline">\(100001\)</span>。即除了最高位和最低位其余位均为
<span
class="math inline">\(0\)</span>，只有这样才会出现左右儿子落在不同区间的情况。</p>
<p>所以我们对于一个 <span
class="math inline">\(n\)</span>，很容易给出一个 <span
class="math inline">\(O(\log n)\)</span> 的计算方式，即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> now;</span><br><span class="line">	<span class="keyword">if</span>(__builtin_popcount(x)==<span class="number">2</span>&amp;&amp;x&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">ask</span>(x<span class="number">+1</span>&gt;&gt;<span class="number">1</span>,now*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ask</span>(x&gt;&gt;<span class="number">1</span>,now*<span class="number">2</span><span class="number">+1</span>);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>__builtin_popcount()</code> 为内置函数，参数为
<code>unsigned</code>， <code>int</code> 也可以使用但不能为负数。</p>
<p>如果希望对 <code>long long</code> 使用，应改为
<code>_builtin_popcountll()</code>。</p>
<p>对每个数暴力求解即可。</p>
<h4 id="pts-1">100PTS</h4>
<p>我们需要观察求解一个数的过程，不妨考虑二进制数 <span
class="math inline">\(1001011\)</span> 的计算过程。</p>
<p>手动模拟一下上述 <span
class="math inline">\(\operatorname{ask()}\)</span>
函数的调用过程，<span class="math inline">\(now\)</span> 变量和 <span
class="math inline">\(x\)</span> 变量的值依次变为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">now=00000001 x=1001011</span><br><span class="line">now=00000011 x=0100101</span><br><span class="line">now=00000111 x=0010010</span><br><span class="line">now=00001111 x=0001001</span><br><span class="line">now=00011110 x=0000101</span><br><span class="line">now=00111100 x=0000011</span><br><span class="line">now=01111000 x=0000010</span><br><span class="line">now=11110001 x=0000001</span><br></pre></td></tr></table></figure>
<p>容易发现，在出现 <span class="math inline">\(1001\)</span>
这样的情况之前，我们将 <span class="math inline">\(now\)</span>
左移一位并在后面写上了 <span class="math inline">\(1\)</span>，同时将
<span class="math inline">\(x\)</span> 右移一位。</p>
<p>在出现 <span class="math inline">\(1001\)</span> 之后，我们一直在往
<span class="math inline">\(now\)</span> 后面写 <span
class="math inline">\(0\)</span>，而 <span
class="math inline">\(x\)</span> 的变化则是先右移一位并将最后一位改为
<span class="math inline">\(1\)</span>。</p>
<p>而最后 <span class="math inline">\(x\)</span> 从 <span
class="math inline">\(10\)</span> 变为 <span
class="math inline">\(1\)</span> 时，我们在 <span
class="math inline">\(now\)</span> 末尾添加了一个 <span
class="math inline">\(1\)</span>。</p>
<p>不难发现，一个固定的 <span
class="math inline">\(x\)</span>，我们最终得到的占用下标最大值，<strong>仅仅和它二进制表示下的最高位和第二高的为
<span class="math inline">\(1\)</span>
的位有关</strong>，因为在这之前我们一定会添加 <span
class="math inline">\(1\)</span>，而在这之后一定会往后添加 <span
class="math inline">\(0\)</span> 并在最后添加一个 <span
class="math inline">\(1\)</span>。</p>
<p><strong>注意如果为 <span class="math inline">\(2^k\)</span>
这样不存在次高位的数，我们需要特判。</strong></p>
<p>所以我们有了一个比较显然的想法，即枚举二进制下最高位和次高位的位置，统计能取到这两个位置的数的数量，并异或上对应的权值。</p>
<p>这样的复杂度是 <span class="math inline">\(O(\log^2n)\)</span>
的，我们考虑继续优化。</p>
<p>对于二进制下位数小于 <span class="math inline">\(n\)</span>
的二进制下位数的所有数，实际上会有贡献的只有两个值，分别是 <span
class="math inline">\(2^k\)</span> 和 <span
class="math inline">\(2^k+1\)</span>。因为<strong>如果次高位不为第一位，那么能取到该值的数的个数一定为偶数个（低于次高位的位置可以任意填）</strong>。剩下这两个值的贡献都是可以
<span class="math inline">\(O(1)\)</span> 计算的。</p>
<p>这样就只用考虑二进制下位数和 <span class="math inline">\(n\)</span>
相同的数，同样的道理，如果次高位高于 <span
class="math inline">\(1\)</span>，那么没有贡献，但需要注意的是，如果次高位取到了上界，例如
<span class="math inline">\(10110\)</span> 中，次高位取到了第三位的
<span class="math inline">\(1\)</span>，那么由于必须小于 <span
class="math inline">\(n\)</span>，实际上只有奇数个值可以取到，这样会带来一定的贡献，所以我们需要计算这种情况的答案，复杂度为
<span class="math inline">\(O(\log n)\)</span>。</p>
<p>总复杂度<span class="math inline">\(O(\log n)\)</span>。</p>
<p>可以参考我博客中的一些线段树的总结，会不定期更新。</p>
<p><a
href="https://huanyp.cn/2022/08/04/%E4%BB%8EZKW%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9C%8B%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/">从ZKW线段树看线段树的性质</a></p>
<h3 id="参考代码">参考代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> low(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125; </span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//特判边界情况</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>,h=<span class="built_in">log2</span>(x);</span><br><span class="line">    <span class="comment">//最高位从 10 开始枚举,所以 res 初值应该设置为 1</span></span><br><span class="line">    <span class="comment">//h 为二进制下 x 的位数</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;h;i++)&#123;</span><br><span class="line">		res^=(<span class="number">1ll</span>&lt;&lt;i<span class="number">+1</span>)<span class="number">-1</span>;</span><br><span class="line">		res^=(<span class="number">1ll</span>&lt;&lt;i<span class="number">+1</span>)<span class="number">+1</span>;</span><br><span class="line">        <span class="comment">//注意左移操作的 1 是 long long 级别的数</span></span><br><span class="line">        <span class="comment">//计算 2^k 和 2^k+1 的答案,其它位置没有贡献 </span></span><br><span class="line">	&#125;</span><br><span class="line">	res^=(<span class="number">1ll</span>&lt;&lt;h<span class="number">+1</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//计算 2^h 的答案</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">low</span>(x)==x)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//如果 x=2^h,无需进行下面的步骤</span></span><br><span class="line">	res^=(<span class="number">1ll</span>&lt;&lt;h<span class="number">+1</span>)<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x<span class="number">-1</span>==<span class="number">1ll</span>&lt;&lt;h||x&amp;<span class="number">1</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//如果 x=2^h+1 或者末尾为 1,那么之后取到的值个数一定是偶数,无需计算。</span></span><br><span class="line">	<span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(__builtin_popcountll(x)&gt;<span class="number">2</span>||(x&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">		now=now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//模拟求解的第一步,找到对应的次高位,在这之前往后写 1</span></span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		now&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//模拟求解第二步,往后写 0</span></span><br><span class="line">	now|=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//记得左右还需要异或 1</span></span><br><span class="line">	<span class="keyword">return</span> res^now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="built_in">read</span>(l),<span class="built_in">read</span>(r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(r)^<span class="built_in">solve</span>(l<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>从一道题看CPU底层优化-第二弹</title>
    <url>/2022/08/05/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8BCPU%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96-%E7%AC%AC%E4%BA%8C%E5%BC%B9/</url>
    <content><![CDATA[<h3 id="题意">题意</h3>
<ul>
<li><p>给定一个序列 <span class="math inline">\(a\)</span>，长度为 <span
class="math inline">\(2^n\)</span>，每次询问给定 <span
class="math inline">\(mask\)</span>，询问 <span
class="math inline">\(b_i=a_{i\bigoplus mask}\)</span> 得到的 <span
class="math inline">\(b\)</span> 序列的最大字段和。</p></li>
<li><p><span class="math inline">\(n\leq 18,q\leq 2\times
10^5\)</span></p></li>
<li><p>原题意参考<a
href="https://codeforces.com/contest/1716/problem/E">题意</a>，这里做了一些不影响做题的转化。</p></li>
</ul>
<h3 id="思考">思考</h3>
<p>我们发现可以类似于线段树一样的去维护最大子段和，即考虑对一层维护其所有可能的交换序列的信息，然后计算一个<strong>节点左右儿子构成的区间</strong>的最大子段和，这样是可以得到正确答案的。</p>
<p>不难发现我们只需要知道一层的<strong>前缀和最大值和最小值</strong>就可以完成向上传递，这样的信息量是
<span class="math inline">\(O(1)\)</span> 的，对于第 <span
class="math inline">\(i\)</span>
层，会影响它的值的只有它下面的状态，因为上面的状态如何不影响该层最大值和最小值的位置，因此不会影响其计算答案的结果。</p>
<p>因此很容易设计出一个 <span class="math inline">\(O(2^n\times
n)\)</span> 的做法，但是我觉得它有点难写。</p>
<p>所以我们考虑只分两层，预处理第一层的前缀和和最大值位置，最小值位置，扫描第二层计算答案，这样的话，复杂度为
<span class="math inline">\(O(2^{\frac{3n}{2}})\)</span> ，约为 <span
class="math inline">\(1.25\times 10^8\)</span>，能卡在边界上。</p>
<h3 id="实现1">实现1</h3>
<p>这是我们的第一份代码，得到了 TLE19 的成绩。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1</span>&lt;&lt;N],ans[<span class="number">1</span>&lt;&lt;N],mx[<span class="number">1</span>&lt;&lt;N],mi[<span class="number">1</span>&lt;&lt;N],sum[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mask1=<span class="number">0</span>;mask1&lt;<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>;mask1++)&#123;</span><br><span class="line">		<span class="type">int</span> gap=<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>,max_val=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i+=gap)&#123;</span><br><span class="line">			mi[i]=mx[i]=i;sum[i]=a[i^mask1],<span class="built_in">cmax</span>(max_val,sum[i]);</span><br><span class="line">			<span class="keyword">for</span>(j=i<span class="number">+1</span>;j&lt;i+gap;j++)&#123;</span><br><span class="line">				sum[j]=sum[j<span class="number">-1</span>]+a[j^mask1];</span><br><span class="line">				<span class="keyword">if</span>(sum[j]&gt;sum[mx[i]])mx[i]=j;</span><br><span class="line">				<span class="keyword">if</span>(sum[j]&lt;sum[mi[i]])mi[i]=j;</span><br><span class="line">				<span class="built_in">cmax</span>(max_val,sum[j]-sum[mi[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> mask2=<span class="number">0</span>;mask2&lt;<span class="number">1</span>&lt;&lt;n;mask2+=gap)&#123;</span><br><span class="line">			ans[mask2^mask1]=max_val;</span><br><span class="line">			<span class="type">int</span> min_val=<span class="number">0</span>,sm=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i+=gap)&#123;</span><br><span class="line">				<span class="built_in">cmax</span>(ans[mask2^mask1],sm+sum[mx[i^mask2]]-min_val);</span><br><span class="line">				<span class="built_in">cmin</span>(min_val,sm+sum[mi[i^mask2]]);</span><br><span class="line">				sm+=sum[(i+gap<span class="number">-1</span>)^mask2];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> q;<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">		<span class="built_in">read</span>(tp1);s^=<span class="number">1</span>&lt;&lt;tp1;</span><br><span class="line">		cout&lt;&lt;ans[s]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="常数分析1">常数分析1</h3>
<p>我们最开始对 <span class="math inline">\(a\)</span> 进行了 <span
class="math inline">\(512\)</span> 次乱序扫描，但容易发现一共进行了
<span class="math inline">\(512\times512\)</span>
次每次扫描的区间大小均为 <span class="math inline">\(512\times4\)</span>
Byte 的扫描，这种方式可以比较好的利用高速缓存，因为被一次 cacheline
读取的 64Byte 数据都被放入了高速缓存并在时间上具有局部性。</p>
<p>注意到第二部分对 <code>sum</code> 计算的前缀和，由于 L3
高速缓存的约能存下 <span class="math inline">\(2^{18}\)</span> 个
<code>long long</code> 数据，但是我们又存储了
<code>sum</code>，并且在第三部分有对 <code>sum</code>
一些固定位置的随机访问，因此，<code>a</code>
数组就被踢出了高速缓存，再次访问的时候需要重复读取，造成了相当大的浪费。</p>
<p>事实上，我们并不需要存储每一个
<code>sum</code>，每一个块需要存储的数据量是 <span
class="math inline">\(O(1)\)</span>
的，对这个做一个优化，我们得到了一份新的代码。</p>
<h3 id="实现2">实现2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line">LL mx[<span class="number">1</span>&lt;&lt;N/<span class="number">2</span>],mi[<span class="number">1</span>&lt;&lt;N/<span class="number">2</span>],sum[<span class="number">1</span>&lt;&lt;N/<span class="number">2</span>],ans[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mask1=<span class="number">0</span>;mask1&lt;<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>;mask1++)&#123;</span><br><span class="line">		LL gap=<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>,max_val=<span class="number">0</span>,m=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(mx,<span class="number">0</span>,<span class="built_in">sizeof</span>(mx)),<span class="built_in">memset</span>(mi,<span class="number">0</span>,<span class="built_in">sizeof</span>(mi));</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i+=gap)&#123;</span><br><span class="line">			LL sm=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=i;j&lt;i+gap;j++)&#123;</span><br><span class="line">				sm+=a[j^mask1];</span><br><span class="line">				<span class="keyword">if</span>(sm&gt;mx[i&gt;&gt;m])mx[i&gt;&gt;m]=sm;</span><br><span class="line">				<span class="keyword">if</span>(sm&lt;mi[i&gt;&gt;m])mi[i&gt;&gt;m]=sm;</span><br><span class="line">				<span class="built_in">cmax</span>(max_val,sm-mi[i&gt;&gt;m]);</span><br><span class="line">			&#125;</span><br><span class="line">			sum[i&gt;&gt;m]=sm;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> mask2=<span class="number">0</span>;mask2&lt;<span class="number">1</span>&lt;&lt;n;mask2+=gap)&#123;</span><br><span class="line">			ans[mask2^mask1]=max_val;</span><br><span class="line">			LL min_val=<span class="number">0</span>,sm=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i+=gap)&#123;</span><br><span class="line">				<span class="built_in">cmax</span>(ans[mask2^mask1],sm+mx[(i^mask2)&gt;&gt;m]-min_val);</span><br><span class="line">				<span class="built_in">cmin</span>(min_val,sm+mi[(i^mask2)&gt;&gt;m]);</span><br><span class="line">				sm+=sum[(i^mask2)&gt;&gt;m];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> q;<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">		<span class="built_in">read</span>(tp1);</span><br><span class="line">		s^=<span class="number">1</span>&lt;&lt;tp1;</span><br><span class="line">		cout&lt;&lt;ans[s]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="常数分析2">常数分析2</h3>
<p>我们将 <code>a</code> 从 <code>long long</code> 改为了
<code>int</code>，提升了 cacheline 读取效率，并只额外存储了 <span
class="math inline">\(512\times3\times8 \text{ Byte}\)</span>
的块信息，这样在以后的计算中，对大数组的随机访问可以变为对小数组的访问，大大提升了高速缓存利用率。</p>
<p>可以通过此题。</p>
<h3 id="further-explore">Further Explore</h3>
<p>继续对代码进行修改，观察其时间变化。</p>
<p>最初代码用时为 <code>1450ms</code></p>
<h4 id="e1">E1</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LL sm=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;i+gap;j++)&#123;</span><br><span class="line">    sm+=a[j^mask1];</span><br><span class="line">    <span class="keyword">if</span>(sm&gt;mx[i&gt;&gt;m])mx[i&gt;&gt;m]=sm;</span><br><span class="line">    <span class="keyword">if</span>(sm&lt;mi[i&gt;&gt;m])mi[i&gt;&gt;m]=sm;</span><br><span class="line">    <span class="built_in">cmax</span>(max_val,sm-mi[i&gt;&gt;m]);</span><br><span class="line">&#125;</span><br><span class="line">sum[i&gt;&gt;m]=sm;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sum[i&gt;&gt;m]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;i+gap;j++)&#123;</span><br><span class="line">    sum[i&gt;&gt;m]+=a[j^mask1];</span><br><span class="line">    <span class="keyword">if</span>(sum[i&gt;&gt;m]&gt;mx[i&gt;&gt;m])mx[i&gt;&gt;m]=sum[i&gt;&gt;m];</span><br><span class="line">    <span class="keyword">if</span>(sum[i&gt;&gt;m]&lt;mi[i&gt;&gt;m])mi[i&gt;&gt;m]=sum[i&gt;&gt;m];</span><br><span class="line">    <span class="built_in">cmax</span>(max_val,sum[i&gt;&gt;m]-mi[i&gt;&gt;m]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>预期效率降低，原因为全局变量不会放入寄存器。</p>
<p>实际效率未降低，原因推测为 <span class="math inline">\(O2\)</span>
优化自动使用了该优化。</p>
<p>继续进行本机测试，共 <code>9</code> 次随机数据，运行时间分别为
<code>16339ms 16339ms</code>，符合预期，不开启优化时，全局变量一定不会放入寄存器。</p>
<h4 id="e2">E2</h4>
<p><code>a</code> 数组改为 <code>long long</code> 类型。</p>
<p>预期由于高速缓存溢出，效率下降，实际未发生效率下降，应该是不明高速缓存机制原因。</p>
<h4 id="defin-int-long-long">#defin int long long</h4>
<p>预期由于高速缓存溢出，效率下降，<code>64bit</code>
编译器和机子，实际效率有提升，<code>9</code> 组时间分别为
<code>16636ms 16167ms</code>。</p>
<p>开启 <code>O2</code> 后无明显差异，分别为
<code>5577ms 5561ms</code></p>
<p><code>32bit</code> 编译器，<code>64bit</code> 机子，<code>O2</code>
效率出现明显下降，分别为 <code>11839ms 14920ms</code></p>
<h3 id="conclusion">Conclusion</h3>
<ul>
<li>O2
优化后，编译器会自动完成很多代码层面上的优化，我们更需要关注的是算法常数本身</li>
<li>高速缓存的利用情况很大程度决定了代码的效率，编写需要卡常的程序时应该尤为注意，滚动数组能有效提升高速缓存利用率，分块处理减少数组大小也是提升效率的一种可行方案。</li>
</ul>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>代码技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>从ZKW线段树看线段树的性质</title>
    <url>/2022/08/04/OI/%E7%AE%97%E6%B3%95/%E4%BB%8EZKW%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9C%8B%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="从zkw线段树看线段树的性质">从ZKW线段树看线段树的性质</h2>
<p>最近遇到了很多线段树性质相关的题目，故在此做一个总结。</p>
<h3 id="常规建树">常规建树</h3>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性质">性质</h4>
<ul>
<li>左儿子长度不小于右儿子。</li>
<li>节点编号 <code>rt</code>
描述了从根到自身的父子关系，也间接描述了该点长度和根节点长度的关系，具体的，根节点的最大或最小长度是一个关于该节点长度的一次函数，这个一次函数只由
<code>rt</code> 决定。</li>
<li>编号最大的节点不一定是 <code>r</code>，事实上可以在 <span
class="math inline">\(\log n\)</span>
的时间内求出，如果左儿子多一层，那么一定在左儿子，否则在右儿子，<strong>决定某个儿子是否会多一层，当且仅当目前长度为奇数，且
popcount 值为 2</strong>。</li>
</ul>
<h4 id="例题">例题</h4>
<p><a
href="https://acm.hdu.edu.cn/showproblem.php?pid=7204">一道简单的题</a></p>
<p><a
href="https://www.luogu.com.cn/problem/P6025">一道比较简单的题</a></p>
<h3 id="非常规建树">非常规建树</h3>
<p>非常规建树一般会指定建树的 <code>mid</code> 位置。</p>
<h4 id="区间覆盖数">区间覆盖数</h4>
<p>即覆盖一个区间 <span class="math inline">\([l,r]\)</span>
的最小线段数。</p>
<p>先转成 <span class="math inline">\((l,r)\)</span>，然后依次跳叶节点
<span class="math inline">\(l,r\)</span> 的父亲，先判断 <span
class="math inline">\(l,r\)</span>
的父亲是否相同，相同就可以走人了。</p>
<p>如果 <span class="math inline">\(l\)</span>
作为左儿子跳上去，那么该节点的右儿子会对该区间贡献一次，因为该节点的右儿子的父亲超出了区间，但自身在区间内。如果
<span class="math inline">\(r\)</span>
作为右儿子跳上去，那么该节点的左儿子会对区间贡献一次，原因同理，如此就可以找到区间覆盖数，这也是
ZKW线段树 的原理。</p>
<h4 id="例题-1">例题</h4>
<p>给定一个指定 <code>mid</code> 节点的线段树，需要支持
<code>rotate</code> 一个节点，<code>rotate</code> 定义为伸展树(splay)的
<code>rotate</code>，强制在线询问区间覆盖数。</p>
<p>先考虑没有修改，那么就是找到 <span class="math inline">\(l,r\)</span>
的 <span class="math inline">\(lca\)</span>，然后一路统计 <span
class="math inline">\(l\)</span>，<span class="math inline">\(r\)</span>
作为左右儿子的次数即可，可以用倍增快速解决。</p>
<p>修改本质上就是断边和加边，用 LCT 维护。</p>
<h3 id="zkw线段树简介">ZKW线段树简介</h3>
<h4 id="建树">建树</h4>
<p>为了方便，需要建一棵有 <span class="math inline">\(2^k\)</span>
个节点的树，主要是为了让高度相同，求出第一个不小于 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(2\)</span>
的次幂的方式：<code>k=32-__builtin_clz(n-1)</code>。</p>
<p><strong>建树时注意没有数据的地方应该弄成
"0"，且注意初始数组大小，并且要开 <span
class="math inline">\(2^k+5\)</span> 以免溢出。</strong></p>
<p>建树时记录单点的编号。</p>
<h4 id="单点修改">单点修改</h4>
<p>直接从下往上改就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    a[rt].mx1=c;<span class="keyword">while</span>(rt!=<span class="number">1</span>)<span class="built_in">push_up</span>(rt&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间查询">区间查询</h4>
<p>个人习惯闭区间，且有效区间落在 <span
class="math inline">\([1,n]\)</span>。</p>
<p>查询时看是否为兄弟节点，如果是就停下，否则对于左端点，是左子树则加上兄弟右子树。对于右端点，是右子树则加上兄弟左子树。<strong>另外需要加上两个端点。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> lrt,<span class="type">int</span> rrt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lrt==rrt)<span class="keyword">return</span> a[lrt];</span><br><span class="line">    node ret=a[lrt]+a[rrt];</span><br><span class="line">    <span class="keyword">while</span>(lrt&gt;&gt;<span class="number">1</span>!=rrt&gt;&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~lrt&amp;<span class="number">1</span>)ret=ret+a[lrt<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">if</span>(rrt&amp;<span class="number">1</span>)ret=ret+a[rrt<span class="number">-1</span>];</span><br><span class="line">        lrt&gt;&gt;=<span class="number">1</span>,rrt&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意特判区间长度为 <span class="math inline">\(1\)</span>
的情况。</strong></p>
<h4 id="区间修改">区间修改</h4>
<p>由于是从下往上查询，所以只能采用标记永久化的方式，像查询那样做修改，在对应的点上打
Tag。</p>
<h4 id="效率">效率</h4>
<p>对于 <span class="math inline">\(10^5,3\times 10^5,10^6\)</span>
的随机数据进行了测试，效率改进因子约为 <span
class="math inline">\(0.4\)</span>。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>简单数论函数和应用</title>
    <url>/2022/08/03/OI/%E7%AE%97%E6%B3%95/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%92%8C%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="简单数论函数和应用">简单数论函数和应用</h1>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://oi-wiki.org/math/number-theory/mobius/">OI-WIKI
莫比乌斯反演</a></li>
<li><a href="https://oi-wiki.org/math/poly/dgf/#dirichlet">OI-WIKI
迪利克雷卷积</a></li>
<li><a
href="https://www.luogu.com.cn/blog/An-Amazing-Blog/ji-miao-di-mu-bi-wu-si-fan-yan">从莫比乌斯到欧拉</a></li>
<li><a
href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">莫比乌斯反演-从基础开始</a></li>
</ul>
<h2 id="部分定义和约定">部分定义和约定</h2>
<h3 id="符号">符号</h3>
<ul>
<li><span class="math inline">\(\operatorname{id}\)</span> ：<span
class="math inline">\(\operatorname{id}\)</span> 数论函数，<span
class="math inline">\(\operatorname{id}(x)=x\)</span></li>
<li><span class="math inline">\(\epsilon\)</span> : 单位函数 <span
class="math inline">\(\epsilon(x)=[x=1]\)</span></li>
<li><span class="math inline">\([]\)</span>
：中扩号表达式，中扩号内条件成立则为 <span
class="math inline">\(1\)</span>，否则为 <span
class="math inline">\(0\)</span></li>
<li><span class="math inline">\(\boldsymbol{1}\)</span>：<span
class="math inline">\(\boldsymbol{1}\)</span> 函数，若 <span
class="math inline">\(f(n)=\boldsymbol{1}\)</span>，则 <span
class="math inline">\(\forall x \in N^+,f(x)=1\)</span></li>
</ul>
<h3 id="数论函数">数论函数</h3>
<ul>
<li><p>一个数论函数定义域为正整数，值域为复数。</p></li>
<li><p>一个数论函数为积性函数，当且仅当 <span
class="math inline">\(\forall (a,b),\gcd(a,b)=1\rightarrow f(a\times
b)=f(a)\times f(b)\)</span></p></li>
<li><p>一个数论函数为完全积性函数，当且仅当 <span
class="math inline">\(\forall a,b,f(a\times b)=f(a)\times
f(b)\)</span></p></li>
</ul>
<h3 id="迪利克雷卷积">迪利克雷卷积</h3>
<p>迪利克雷卷积为数论函数的乘法操作，定义两个数论函数的迪利克雷卷积定义为
<span class="math display">\[
g=f*h,g(n)=\sum\limits_{d|n} f(d)\times h(\frac{n}{d})
\]</span></p>
<p>迪利克雷卷积的除法操作就是逆操作，一般只能构造得到。</p>
<p>迪利克雷卷积的性质（证明见下一部分）：</p>
<ul>
<li>两个积性函数的迪利克雷卷积仍是积性函数。</li>
<li>两个积性函数的迪利克雷卷积除法结果仍是积性函数。</li>
</ul>
<p><strong>为了方便，以下所有数论函数的乘法未经说明均为迪利克雷卷积。</strong></p>
<h3 id="常见积性函数">常见积性函数</h3>
<ul>
<li>欧拉函数 <span class="math inline">\(\phi(n)\)</span></li>
<li>莫比乌斯函数 <span class="math inline">\(\mu(n)\)</span></li>
<li>约数个数函数 <span class="math inline">\(d(n)\)</span></li>
</ul>
<h2 id="一些结论的简单证明">一些结论的简单证明</h2>
<h3 id="迪利克雷卷积的性质">迪利克雷卷积的性质</h3>
<h4 id="简单性质">简单性质</h4>
<ul>
<li>积性函数 <span class="math inline">\(f\)</span>，满足 <span
class="math inline">\(f(1)=1\)</span></li>
</ul>
<h4 id="逆元存在且唯一">逆元存在且唯一</h4>
<p>所有数论函数存在逆元，即对于所有 <span
class="math inline">\(f\)</span>，存在 <span
class="math inline">\(g\)</span> 使得 <span
class="math inline">\(f*g=\epsilon\)</span>，直接构造对应的 <span
class="math inline">\(g(n)\)</span> 即可。 <span class="math display">\[
g(n)=-\dfrac{\sum\limits_{d|n,d\neq n}{f(d)\times
g(\frac{n}{d})}}{f(1)}\\
g(1)=\frac{1}{f(1)}
\]</span> 因此数论函数的逆元存在且唯一。</p>
<h4 id="交换律">交换律</h4>
<p><span class="math inline">\(f * g=g * f\)</span>，显然成立</p>
<h4 id="结合律">结合律</h4>
<p><span class="math inline">\(f * g * h=f * (g *
h)\)</span>，成立，但不显然。</p>
<p>令 <span class="math inline">\(f * g * h=f_1,f * (g * h)=f_2,f *
g=a,g * h=h * g=b\)</span> <span class="math display">\[
f_1(n)=\sum\limits_{d_1|n} a(d_1)\times
h(\frac{n}{d_1})=\sum\limits_{d_1|n}\sum\limits_{d_2|d_1} f(d_2)\times
g(\frac{d_1}{d_2})\times h(\frac{n}{d_1})
\]</span></p>
<p><span class="math display">\[
f_2(n)=\sum\limits_{d_1|n} b(d_1)\times
f(\frac{n}{d_1})=\sum\limits_{d_1|n}\sum\limits_{d_2|d_1} h(d_2)\times
g(\frac{d_1}{d_2})\times f(\frac{n}{d_1})
\]</span> 对于任意一组满足 <span
class="math inline">\(d_1|n,d_2|d_1\)</span> 的 <span
class="math inline">\(d_1,d_2\)</span>，构造 <span
class="math inline">\(d_2&#39;=\frac{n}{d_1},d_1&#39;=\frac{n}{d_2}\)</span>
，容易发现这样的构造是一一对应的，满足 <span
class="math inline">\(f(d_2)\times g(\frac{d_1}{d_2})\times
(\frac{n}{d_1})=f(\frac{n}{d_1&#39;}) \times
g(\frac{d_1&#39;}{d_2&#39;}) \times h(d_2&#39;))\)</span> 。</p>
<p>因此对于上式中的每一项，下式都有一项与之一一对应，因此上下式相等。</p>
<h4 id="分配律">分配律</h4>
<p><span class="math inline">\(f*(g+h)=f*g+f*h\)</span></p>
<p>显然成立。</p>
<h4
id="两个积性函数的迪利克雷卷积为积性函数">两个积性函数的迪利克雷卷积为积性函数</h4>
<p><span class="math inline">\(f,h\)</span> 为积性函数，则 <span
class="math inline">\(f*g=h\)</span>，<span
class="math inline">\(h\)</span> 为积性函数。</p>
<p><span class="math inline">\(\forall a,b \ , \gcd(a,b)=1\ ,h(a\times
b)=h(a)\times h(b)\)</span>，满足 <span class="math display">\[
\begin{align}
h(a\times b)=&amp;\sum\limits_{d_1|a}\sum\limits_{d_2|b}f(d_1\times
\frac{b}{d_2})\times g(\frac{a}{d_1}\times d_2)\\
=&amp;\sum\limits_{d_1|a}\sum\limits_{d_2|b}f(d_1)\times
f(\frac{b}{d_2})\times g(\frac{a}{d_1})\times g( d_2)\\
=&amp;\sum\limits_{d_1|a} f(d_1)\times
g(\frac{a}{d_1})\sum\limits_{d_2|b} f(\frac{b}{d_2})\times g(d_2)\\
=&amp;h(a)\times h(b)
\end{align}
\]</span></p>
<h4
id="两个积性函数的迪利克雷卷积除法为积性函数">两个积性函数的迪利克雷卷积除法为积性函数</h4>
<p>证明 <span class="math inline">\(f,h\)</span> 为积性函数，且 <span
class="math inline">\(h*g=f\)</span>，则 <span
class="math inline">\(g\)</span> 为积性函数。</p>
<p>令 <span class="math inline">\(h&#39;*h=\epsilon\)</span>，则 <span
class="math inline">\(g=f*h&#39;\)</span></p>
<p>即证明积性函数的逆元也为积性函数。</p>
<p><a
href="https://oi-wiki.org/math/poly/dgf/#%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%86%E5%85%83%E4%B9%9F%E6%98%AF%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0">证明</a></p>
<p>使用了数学归纳法。</p>
<h4 id="完全积性函数相关">完全积性函数相关</h4>
<p>若 <span class="math inline">\(w\)</span> 是完全积性函数，则 <span
class="math display">\[
(g\cdot w) * (f \cdot w) = (g * f)\cdot w
\]</span></p>
<h3 id="常见的积性函数关系">常见的积性函数关系</h3>
<ul>
<li><span class="math inline">\(\mu*
\boldsymbol{1}=\epsilon\)</span></li>
<li><span class="math inline">\(\phi*
\boldsymbol{1}=\operatorname{id}\)</span></li>
<li><span class="math inline">\(\mu * \operatorname{id} =
\phi\)</span></li>
</ul>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p><strong>莫比乌斯反演的常见做法是用其它易于交换求和符号的项替换掉不容易求和的相关项。</strong></p>
<p>不容易交换求和的项一般有 <span class="math inline">\(d,\gcd\)</span>
等。</p>
<h3 id="数论分块">数论分块</h3>
<p>莫比乌斯反演或者其它数数题中常用的优化方式。</p>
<p>核心原理是对于 <span class="math inline">\([1,n]\)</span> 中所有数
<span class="math inline">\(i\)</span>，<span
class="math inline">\(\frac{n}{i}\)</span> 的结果只有 <span
class="math inline">\(\sqrt{n}\)</span> 个。</p>
<p>证明是容易的，对于 <span
class="math inline">\([1,\sqrt{n}]\)</span>，一共有 <span
class="math inline">\(\sqrt{n}\)</span> 个值，对于 <span
class="math inline">\([\sqrt{n},n]\)</span>，一共也只有 <span
class="math inline">\(\sqrt{n}\)</span> 个值。</p>
<p>枚举的方式是先枚举一个 <span
class="math inline">\(l\)</span>，然后计算出一个最大的 <span
class="math inline">\(r\)</span>，满足 <span
class="math inline">\(\frac{n}{r}=\frac{n}{l}\)</span>，容易证明 <span
class="math inline">\(r=\big\lfloor\dfrac{n}{\lfloor\frac{n}{l}\rfloor}\big\rfloor\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=n;l=r<span class="number">+1</span>,r=n/(n/l))&#123;</span><br><span class="line">	<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫比乌斯函数">莫比乌斯函数</h3>
<h4 id="定义">定义</h4>
<p><span class="math display">\[
\mu(n)=
\begin{cases}
1&amp;n=1\\
0&amp;n\text{ 含有平方因子}\\
(-1)^k&amp;k\text{ 为 }n\text{ 的本质不同质因子个数}\\
\end{cases}
\]</span></p>
<h4 id="muboldsymbol1epsilon"><span
class="math inline">\(\mu*\boldsymbol{1}=\epsilon\)</span></h4>
<p>这是核心结论了。</p>
<p>考虑证明 <span class="math inline">\(\forall
n&gt;1,\mu(n)=0\)</span>。</p>
<p>考虑每个约数的贡献，显然每个质因子只需要考虑一次，如果质因子出现多次，那么根据定义贡献为
<span class="math inline">\(0\)</span>。</p>
<p>设有 <span class="math inline">\(k\)</span>
个质因子，那么选出奇数个和选出偶数个的方案显然是相等的，所以和为 <span
class="math inline">\(0\)</span>。</p>
<h3 id="莫比乌斯反演-1">莫比乌斯反演</h3>
<h4 id="一般形式">一般形式</h4>
<p><span class="math display">\[
\begin{align}
f*\bold{1}=g\iff&amp; g*\mu=f \\
g(n)=\sum\limits_{d|n}f(d)\iff&amp; f(n)=\sum\limits_{d|n}\mu(d)\times
g(\frac{n}{d})
\end{align}
\]</span></p>
<p>证明是显然的，因为 <span
class="math inline">\(\boldsymbol{1}*\mu=\epsilon\)</span></p>
<h4 id="常用">常用</h4>
<p><span
class="math inline">\([\gcd(i,j)=1]=\sum\limits_{d|\gcd(i,j)}\mu(d)\)</span></p>
<p>枚举 <span class="math inline">\(d\)</span>，即可快速计算。</p>
<h4 id="欧拉反演">欧拉反演</h4>
<p>名字是<a href="https://0x131cc05.github.io/">杰哥</a>取的。</p>
<h5 id="常用形式">常用形式</h5>
<p><span
class="math inline">\(\gcd(i,j)=\sum\limits_{d|\gcd(i,j)}\phi(d)\)</span></p>
<h5 id="证明">证明</h5>
<p>即证明 <span
class="math inline">\(\phi*\boldsymbol{1}=\operatorname{id}\)</span>
。</p>
<p>我们只需要证明 <span
class="math inline">\(\phi*\boldsymbol{1}\)</span> 在 <span
class="math inline">\(p^c\)</span> 处取值为 <span
class="math inline">\(\operatorname{id}(p^c)\)</span>，由于 <span
class="math inline">\(\phi,\boldsymbol{1},\operatorname{id}\)</span>
均为积性函数，自然在所有位置成立。 <span class="math display">\[
\begin{align}
(\phi*\boldsymbol{1})(p^c)=&amp;1+\sum _{i=1}^{c} (p-1)\times p^{i-1}\\
=&amp; 1+\frac{p^c-1}{p-1}\times(p-1)\\
=&amp;p^c\\
=&amp;\operatorname{id}(p^c)
\end{align}
\]</span></p>
<h2 id="筛法">筛法</h2>
<p>介绍四大筛法。</p>
<p>四大筛法通常用于求一些<strong>积性函数</strong>的前缀和。</p>
<p>假设要求 <span class="math inline">\(f\)</span> 的前缀和。</p>
<p>记 <span class="math inline">\(F(n) = \sum\limits_{i=1}^n
f(i),H(n)=\sum\limits_{i=1}^n h(i),G(n)=\sum\limits_{i=1}^n
g(i)\)</span>。</p>
<h3 id="杜教筛">杜教筛</h3>
<p>杜教筛的核心是构造两个容易求前缀和的函数 <span
class="math inline">\(g,h\)</span>，满足 <span class="math inline">\(h =
f * g\)</span>。</p>
<p>有 <span class="math display">\[
\begin{align}
H(n)&amp;=\sum\limits_{i=1}^n h(i)\\
&amp;=\sum_{i=1}^n\sum_{d|i}g(d)f(\frac{i}{d})\\
&amp;=\sum_{d=1}^ng(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} f(i)
\end{align}
\]</span> 将右边 <span class="math inline">\(d\ge 2\)</span>
的项移到左边 <span class="math display">\[
H(n)-\sum\limits_{d=2}^ng(d)F(\lfloor\frac{n}{d}\rfloor)=F(n)g(1)
\]</span> <span class="math inline">\(H(n)\)</span> 是好求的，然后 <span
class="math inline">\(g(1)=1\)</span>，后面的项对 <span
class="math inline">\(n\)</span> 数论分块。</p>
<p>然后有一个结论 <span
class="math inline">\(\big\lfloor\dfrac{\lfloor\frac{n}{a}\rfloor}{b}\big\rfloor=\lfloor\dfrac{n}{ab}\rfloor\)</span>。因此要求的项只有
<span class="math inline">\(\sqrt n\)</span> 项。</p>
<p>线性筛前 <span class="math inline">\(n^\frac{2}{3}\)</span>
项的前缀和，可以取到最优复杂度 <span
class="math inline">\(n^\frac{2}{3}\)</span>。复杂度证明见 OI-WIKI，<a
href="https://oi-wiki.org/math/number-theory/du/#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E5%89%8D%E7%BC%80%E5%92%8C">证明</a>。</p>
<h3 id="pnpowerful-number-筛">PN(Powerful Number) 筛</h3>
<p>定义 Powerful Number 是每个质因数质数不小于 <span
class="math inline">\(2\)</span> 的数。</p>
<p>如果能构造一个<strong>容易求前缀和的积性函数 <span
class="math inline">\(g(x)\)</span>，满足 <span
class="math inline">\(g(p)=f(p)\)</span></strong>，那么我们就可以在
<span class="math inline">\(O(\sqrt n)\)</span> 的时间复杂度内计算 <span
class="math inline">\(F(n)\)</span>。</p>
<p>具体的，考虑构造 <span class="math inline">\(h = f / g\)</span>，所以
<span class="math inline">\(f(p) = h(1)g(p) + h(p)g(1)\)</span>，由于
<span class="math inline">\(g(p) =f (p)\)</span>，所以有 <span
class="math inline">\(h(p)\)</span> 处取值为 <span
class="math inline">\(0\)</span>，由于 <span
class="math inline">\(g,f,h\)</span> 都是积性函数，所以 <span
class="math inline">\(h\)</span> 仅在 Powerful Number
处有取值，其余处取值为 <span class="math inline">\(0\)</span>。</p>
<p>考虑 <span class="math display">\[
\begin{align}
F(n)&amp;=\sum_{i=1}^nf(i)\\
&amp;=\sum_{i=1}^n\sum_{d|i}h(d)g(\frac{i}{d})\\
&amp;=\sum_{d=1}^nh(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}g(i)
\end{align}
\]</span> 枚举所有 Powerful Number，计算 <span
class="math inline">\(h(d)G(\lfloor\frac{n}{d}\rfloor)\)</span>
即可，Powerful Number 的个数是 <span class="math inline">\(O(\sqrt
n)\)</span> 的。</p>
<p>构造 <span class="math inline">\(h\)</span> 的话，可以直接用 <span
class="math inline">\(g * h =
f\)</span>，并使用卷积的定义构造，当然，<span
class="math inline">\(f(p^c)\)</span> 必须要容易求。</p>
<h3 id="州阁筛">州阁筛</h3>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Exchange-Argument小总结</title>
    <url>/2022/08/02/OI/%E7%AE%97%E6%B3%95/Exchange-Argument%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="exchange-argument">Exchange-Argument</h2>
<ul>
<li><p>参考资料：2022
集训队论文《浅谈一类基于交换的贪心在信息学竞赛中的应用》</p></li>
<li><p>本文主要介绍树上形式。</p></li>
</ul>
<h3 id="一般形式">一般形式</h3>
<p>你需要为 <span class="math inline">\(n\)</span>
个元素安排一个排名，得到一个序列 <span
class="math inline">\(a\)</span>，最小化某函数 <span
class="math inline">\(F(a)\)</span>。</p>
<p>如果存在一个满足<strong>传递性和强完全性</strong>的关系 <span
class="math inline">\(\le\)</span>，满足 <span
class="math inline">\(a,b\)</span> 均为元素， $
ab,F(s_1+a+b+s_2)F(s_1+b+a+s_2)$，则按照 <span
class="math inline">\(\le\)</span> 排序后的排名可以最小化 <span
class="math inline">\(F(a)\)</span>。</p>
<p>典例为 NOIP2012 国王游戏。</p>
<p>我们在这里略去证明，详见参考资料。</p>
<ul>
<li>强完全性指 <span class="math inline">\(\forall  a,b, a\le b\bigvee
b\le a\)</span>，显然满足强完全性一定满足自反性。</li>
<li>条件中 <span class="math inline">\(\{s_1+a+b+s_2\}\)</span>
为全集。</li>
</ul>
<h3 id="树上问题">树上问题</h3>
<h4 id="例题">例题</h4>
<p>给定一棵树，需要为树的每个节点安排排名 <span
class="math inline">\(p_u\)</span>，父节点的排名需要低于子节点。每个点有一个价值
<span class="math inline">\(c_i\)</span>，需要最小化 <span
class="math inline">\(\sum c_u\times p_u\)</span>。</p>
<h4 id="分析与结论">分析与结论</h4>
<p>唯一的变化是，对于原问题元素的比较 <span
class="math inline">\(\le\)</span>，拓展到了对于子序列的比较，即 <span
class="math inline">\(a,b\)</span> 为原来元素的一个序列。</p>
<p><strong>以下是一个重要结论</strong></p>
<p>考虑一个元素 <span
class="math inline">\(v\)</span>，我们希望说明如果它的父亲 <span
class="math inline">\(u\)</span>， <span
class="math inline">\(u&gt;v\)</span>，那么 <span
class="math inline">\(v\)</span> 一定在 <span
class="math inline">\(u\)</span> 之后<strong>立刻被选择</strong>，此时将
<span class="math inline">\(v,u\)</span> 合并，可以得到一个规模为 <span
class="math inline">\(n-1\)</span> 的子问题。</p>
<p>考虑证明 <span class="math inline">\(u\)</span> 被选择后一定会选择
<span class="math inline">\(v\)</span>，对于一个满足树的限制的排列 <span
class="math inline">\(p\)</span>，如果 <span
class="math inline">\(u,v\)</span> 不相邻，那么由于 <span
class="math inline">\(v&gt;u\)</span>，所以对于序列 <span
class="math inline">\(p_1,p_2\dots u,p_l,p_{l1} \dots
p_r,v,\dots,p_n\)</span>，一定有 <span
class="math inline">\(u&gt;p_{l,r} \bigvee p_{l,r}&gt;v\)</span>，否则
<span class="math inline">\(v&lt;u\)</span>，如果为前者，那么交换 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(p_{l,r}\)</span>，后者同理，所以 <span
class="math inline">\(v\)</span> 一定紧接着 <span
class="math inline">\(u\)</span> 被选择。</p>
<p>我们可以用以下两种方式解决问题。</p>
<h4 id="方式1">方式1</h4>
<p>考虑最大的元素 <span
class="math inline">\(v\)</span>，显然可以合并它和它的父亲 <span
class="math inline">\(u\)</span>，变成一个新的规模更小的问题。</p>
<p>合并的过程可以用并查集维护连通块，注意区分并查集父亲和实际父亲。</p>
<p>使用 <code>priority_queue</code> 或者 <code>set</code>
可以实现加入删除和查询最小值，<code>priority_queue</code>
的方式是同时维护一个代表删除的 <code>priority_queue</code>，实际上
<code>priority_queue</code> 会比 <code>set</code> 快 <span
class="math inline">\(1\)</span> 倍。</p>
<p>注意实现的时候，如果找到了根，那么根其实有可能不在
<code>priority_queue</code> 里面，可删除的 <code>priority_queue</code>
如果删除了不存在的元素是会出问题的，所以一定要特判掉。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span></p>
<h4 id="方式2">方式2</h4>
<p>我们考虑对每个子树求其答案。</p>
<p>利用分析中的结论，不妨将一棵子树划分成一些<strong>必须连续选择的序列</strong>，作为<strong>树对排列顺序的要求</strong>，将这些连续的序列视为一个元素后，我们可以对序列按照正常方式排序得到最优解。</p>
<p>划分序列的过程是对于一棵子树 <span
class="math inline">\(u\)</span>，将它的所有儿子的序列拿来排序，尝试将
<span class="math inline">\(u\)</span>
与最小的序列合并得到新的序列，如果 <span
class="math inline">\(u\)</span>
当前所在的序列较大，由于结论我们知道合并后一定能拿到最优解，否则停止合并，此时
<span class="math inline">\(u\)</span>
所在序列的权值最小，一定会被最先选择，其中 <span
class="math inline">\(u\)</span> 又一定会被第一个选择。</p>
<p>容易发现合并的过程一定不会改变子树内的选择顺序。</p>
<p>合并时采用启发式合并，利用 <code>set</code> 或
<code>priority_queue</code> 维护当前子树序列，复杂度为 <span
class="math inline">\(O(n\log^2n)\)</span>，但优势在于可以求出所有子树的答案。</p>
<p>当然可以使用可并堆达到 <span class="math inline">\(O(n\log
n)\)</span></p>
<p>注意到其实一遍 <code>dfs</code>
就可以解决问题，因为启发式合并复杂度保证的来源是合并一次的复杂度为 <span
class="math inline">\(O(\min(|u|,|v|))\)</span>，所以并不需要提前计算子树大小，直接合并即可，<code>set</code>
或 <code>priority_queue</code> 的 <code>swap</code> 操作是 <span
class="math inline">\(O(1)\)</span> 的。</p>
<h3 id="碎碎念">碎碎念</h3>
<p>Exc-Arg
除了直接解决问题外，也可以用来简化问题，将选择元素并重排的问题变为<strong>排序后</strong>选择子序列的问题。</p>
<p>对于树上的情况，我还没有见到过相关的问题。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>坑</title>
    <url>/2022/08/02/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/%E8%80%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E8%80%83%E8%AF%95%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h2 id="多测的奇妙问题">多测的奇妙问题</h2>
<h3 id="最短路">最短路</h3>
<p>你清空了吗？</p>
<p>你真的清空了吗？</p>
<p>你真的真的真的清空了吗？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">1</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="comment">//while(!q.empty())q.pop();</span></span><br><span class="line">	dis[s]=<span class="number">0</span>;q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">top</span>()%M;q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;vis[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(vis[t])<span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//!!! priority_queue 还没空就跑路了，你不玩完谁玩完</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=a[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=a[i].v,w=a[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[u]+w&gt;=dis[v])<span class="keyword">continue</span>;</span><br><span class="line">			dis[v]=dis[u]+w;</span><br><span class="line">			q.<span class="built_in">push</span>(dis[v]*M+v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些迷惑问题">一些迷惑问题</h2>
<h3 id="prim-最短路">Prim 最短路</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> tar=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)<span class="keyword">if</span>(dis[tar]&gt;dis[j]&amp;&amp;!pd[j])tar=j;</span><br><span class="line">    pd[tar]=<span class="number">1</span>;ans+=dis[tar];dis[tar]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)<span class="built_in">cmin</span>(dis[j],dis[tar]+val[tar][j]+val[j][tar]);</span><br><span class="line">    <span class="comment">//	for(j=1;j&lt;=n;j++)if(!pd[j])cmin(dis[j],dis[tar]+val[tar][j]+val[j][tar]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你的边权算对了吗？</p>
<p><del>有人之前写的 <code>Prime</code> 算法</del></p>
<h3 id="匿名函数排序">匿名函数排序</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(b<span class="number">+1</span>,b+m<span class="number">+1</span>,[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a&lt;b;&#125;);</span><br><span class="line"><span class="built_in">sort</span>(b<span class="number">+1</span>,b+m<span class="number">+1</span>,[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> b&gt;a;&#125;);</span><br></pre></td></tr></table></figure>
<p>你的排序，是这个升序的，还是这个降序的，还是这个无序的。</p>
<h3 id="线段去包含">线段去包含</h3>
<p>思考清楚到底怎么排序，如果右端点相同，按什么排序。</p>
<p>端点会不会是负数，maxn 初始值会不会太大（开 0，结果有线段端点是 0
你把它干了）</p>
<h3 id="需要记录一些原来编号的排序">需要记录一些原来编号的排序</h3>
<p>想清楚排序得到的 <code>rk</code>
数组到底是什么，不要乱查乱用，该求逆的求逆。</p>
<h2 id="一些技巧的坑">一些技巧的坑</h2>
<h3 id="非显式建边">非显式建边</h3>
<p>举个例子，点有个性质 <span
class="math inline">\(c_i\)</span>，可以花费 <span
class="math inline">\(k_j\)</span> 的代价从任意 <span
class="math inline">\(c_{a_j}\)</span> 的跳到任意 <span
class="math inline">\(c_{b_j}\)</span> 的点。</p>
<p>然后你对每个 <span class="math inline">\(c\)</span>
建立一个点，从每个点向它连了一条边。</p>
<p>然后你发现你的每一个 <span class="math inline">\(c\)</span> 可以花费
<span class="math inline">\(0\)</span> 的代价互相到达。</p>
<p>正确的方式是每个 <span class="math inline">\(c\)</span>
建立入点和出点。</p>
<h3 id="可删除的优先队列">可删除的优先队列</h3>
<p>一般用两个优先队列实现，<strong>需要保证被删除的元素一定存在</strong>。</p>
<h2 id="语言本身的坑">语言本身的坑</h2>
<h3 id="cerr">cerr</h3>
<p>调试的时候 <code>cerr</code> 很好用的，就算忘了删也不会爆零，但是
<code>cerr</code>
真的很慢，因为它直接向标准输出流输出了，没有过缓冲区，相当于每次输出一次就
<code>fflush(out)</code> 一下，<code>TLE</code> 没商量。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>考试技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈一笔画问题</title>
    <url>/2022/07/28/%E7%A7%91%E6%99%AE/%E6%B5%85%E8%B0%88%E4%B8%80%E7%AC%94%E7%94%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="qq-群一笔画问题">QQ 群一笔画问题</h2>
<p><strong>Author:Huan_yp</strong></p>
<p>一笔画问题，即给定一张无向图 <span
class="math inline">\(G(V,E)\)</span>，每个点的度数均为偶数或者<strong>仅有</strong>两个点度数为奇数，需要求出一条不重复经过边的路径，遍历所有的边。</p>
<p>由于在算法竞赛中，这个问题是简单的，这里只讨论在 QQ
群一笔画中，快速解决问题的方式。</p>
<h3 id="归纳构造法证明">归纳构造法证明</h3>
<p>已知给定图为一笔画图，故一定满足每个点的度数均为偶数或者<strong>仅有</strong>两个点度数为奇数，并且图联通，若存在两个点度数为奇数，则从其中一个点开始，否则可以从任意点开始。</p>
<p>执行以下过程。</p>
<ul>
<li>在当前节点任意找一条边，如果可以找到，则重复此过程。</li>
<li>如果无法找到：
<ul>
<li>图已经被遍历，结束，得到保存的路径。</li>
<li>该点度数为 <span
class="math inline">\(0\)</span>，所以一定回到了起点或者到了终点。记录并删除该路径中所有边，并回溯到上一个存在出度的点，<strong>可以证明一定存在这样的点，否则图不连通</strong>。该点的度数一定为偶数，对该点进行上述过程，得到一条<strong>首尾相接</strong>的路径，插入到原路径，得到完整的欧拉（回）路。</li>
</ul></li>
<li>容易发现，这样的过程将图遍历了一遍，所以最后得到的是完整的欧拉路径。</li>
</ul>
<p>代码实现比较简单，只需要使用栈在退出时记录当前节点，得到的，从栈顶到栈底，就是一条完整的欧拉路径。</p>
<p>下面是一个例子：</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/4oaujupz.png" /></p>
<p>按 <span class="math inline">\(1-&gt;2-&gt;5\)</span> 走，<span
class="math inline">\(5\)</span> 处无路可走，回到 <span
class="math inline">\(2\)</span>，记录一条路径 <span
class="math inline">\(2-&gt;5\)</span>，从 <span
class="math inline">\(2\)</span> 继续走 <span
class="math inline">\(2-&gt;3-&gt;4-&gt;2\)</span>，回到了，插入原路径变为
<span
class="math inline">\(1-&gt;2-&gt;3-&gt;4-&gt;2-&gt;5\)</span>。</p>
<h3 id="正确的操作方式">正确的操作方式</h3>
<p>由于找边的耗时比较长，我们需要尽可能少的找边。</p>
<ul>
<li>如果有 API
可以读取边的情况，那么直接做一遍上述过程即可得到答案。</li>
<li>如果不存在对应的
API，我们直接进行上诉操作，可以拿一个程序记录已经走过的点和边并提示路径。</li>
<li>如果图不为欧拉回路，则存在死路，判断方式比较简单，当前点是否为起始点，如果死路位于起始点，直接进行路径回溯操作，即步骤二。否则撤销所有操作，从当前节点开始逆向进行已经进行过的操作。</li>
</ul>
<p>这样单纯的找边的次数恰好为 m 次，即边数。</p>
<p>回溯和走边的操作总和不会超过 2m。</p>
<h3 id="平均执行次数">平均执行次数</h3>
<p>考虑图为随机生成，期望的行走次数，感觉是 polylog
级别，但是我不会证明。</p>
<h4 id="蒙特卡洛模拟">蒙特卡洛模拟</h4>
<p>咕咕咕，没时间写代码。</p>
<p>采用蒙特卡洛模拟算法对该结论进行验证</p>
<h4 id="严谨数学证明">严谨数学证明</h4>
<p>咕咕咕。</p>
<p>也许可以考虑每条边回溯次数期望 <span
class="math inline">\(e_{u,v}\)</span>。</p>
]]></content>
      <categories>
        <category>学术</category>
      </categories>
      <tags>
        <tag>科普</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan算法和坑</title>
    <url>/2022/07/28/OI/%E7%AE%97%E6%B3%95/Tarjan%E7%AE%97%E6%B3%95%E5%92%8C%E5%9D%91/</url>
    <content><![CDATA[<h2 id="tarjan算法和坑">Tarjan算法和坑</h2>
<p>某场多校，某道题，有负环，需要排除（负环）。</p>
<p>某人写了，又交了，吃罚时，需要排除（某人）。</p>
<p>队友写了，又交了，他过了，某人完了。</p>
<p>数据有了，调试了，调完了，Tarjan锅了。</p>
<p>本文提一下 Tarjan 算法里的坑。</p>
<h3 id="算法流程和原理">算法流程和原理</h3>
<p>通过对图进行 DFS 遍历，得到 DFS 树。</p>
<p>容易发现每个 SCC 是一个树上的联通块，这是由 DFS
的过程保证的，如果分开了，那么就不满足 DFS 的性质。</p>
<p><strong>DFS 一个点，会访问到所有它能到的点。</strong>由于它们是
SCC，所以 DFS 该 SCC 的任意节点的时候，一定会让 SCC
中所有<strong>未访问</strong>的节点都在它的子树里，所以不会出现断开的情况。</p>
<p>考虑树的每个节点是否为 SCC 的根。定义一个节点为 SCC
的根，当且仅当这个节点是该 SCC 中最浅的节点。</p>
<p>定义 <code>low[u]</code> 为 <span class="math inline">\(u\)</span>
能通过<strong>自己或者自己的子树</strong>到达的点，时间戳的最小值。维护一个栈，表示当前还没有确定连通块的节点。</p>
<p>如果一个点 <span class="math inline">\(u\)</span> 的
<code>low[u]=dfn[u]</code>，那么该点无法到达时间戳更小的点，所以一定是
SCC 的根，弹出所有栈中的值直到 <span
class="math inline">\(u\)</span>，作为该 SCC 的所有点。</p>
<p>如果访问了一个已经访问过的点 <span
class="math inline">\(v\)</span>，分两种
CASE，其一是它已经被弹栈了，这样的话该边一定是横插边，直接不管，因为
<span class="math inline">\(v\)</span> 到不了 <span
class="math inline">\(u\)</span>。如果还没有弹栈，说明该点的 SCC
还没有确定，所以这个点是可以到 <span class="math inline">\(u\)</span>
的父亲的，也能到 <span
class="math inline">\(v\)</span>。所以这种点是有效的，<span
class="math inline">\(u\)</span> 因此能到达更上面的点，不是 SCC
的根。</p>
<h3 id="不同的写法">不同的写法</h3>
<p>省略全局变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AC Code</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	dfn[u]=low[u]=++s;</span><br><span class="line">	st[++top]=u;in[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e[<span class="number">2</span>][u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[<span class="number">2</span>][u][i].v,w=e[<span class="number">2</span>][u][i].e,f=e[<span class="number">2</span>][u][i].f;</span><br><span class="line">		<span class="keyword">if</span>(dfn[v])&#123;</span><br><span class="line">			<span class="keyword">if</span>(in[v])<span class="built_in">cmin</span>(low[u],dfn[v]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(v);<span class="built_in">cmin</span>(low[u],low[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">		cnt++;<span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">do</span> rk[v=st[top--]]=cnt,in[v]=<span class="number">0</span>; <span class="keyword">while</span>(v!=u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AC code</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	dfn[u]=low[u]=++s;st[++top]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e[<span class="number">2</span>][u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[<span class="number">2</span>][u][i].v,w=e[<span class="number">2</span>][u][i].e,f=e[<span class="number">2</span>][u][i].f;</span><br><span class="line">		<span class="keyword">if</span>(dfn[v])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!rk[v])<span class="built_in">cmin</span>(low[u],dfn[v]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(v);<span class="built_in">cmin</span>(low[u],low[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">		cnt++;<span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">do</span> rk[v=st[top--]]=cnt; <span class="keyword">while</span>(v!=u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WA code</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	dfn[u]=low[u]=++s;st[++top]=u;in[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e[<span class="number">2</span>][u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[<span class="number">2</span>][u][i].v,w=e[<span class="number">2</span>][u][i].e,f=e[<span class="number">2</span>][u][i].f;</span><br><span class="line">		<span class="keyword">if</span>(dfn[v])&#123;</span><br><span class="line">			<span class="keyword">if</span>(in[v])<span class="built_in">cmin</span>(low[u],dfn[v]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(v);<span class="built_in">cmin</span>(low[u],low[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">		cnt++;<span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">do</span> rk[v=st[top--]]=cnt; <span class="keyword">while</span>(v!=u);</span><br><span class="line">	&#125;</span><br><span class="line">	in[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到前两种 Code 维护的都是栈中元素，因此没有问题。</p>
<p>但第三种写法，维护的是所有的祖先，当当前节点 <span
class="math inline">\(u\)</span> 连接到的点 <span
class="math inline">\(v\)</span>，可以通过其返祖边回到更上面的父亲时，这种做法会漏掉
<span class="math inline">\(v\)</span>。因此是错误的。</p>
<p>举个例子。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/l17oe1cu.png" /></p>
<p>访问 <span class="math inline">\(3\)</span> 时，<span
class="math inline">\(4\)</span> 已经从 <span
class="math inline">\(in\)</span> 中移除，但是我们仍然可以通过 <span
class="math inline">\(4\)</span> 到达 <span
class="math inline">\(3\)</span>，所以会出现错误。</p>
<p><strong>洛谷的模板题，数据相当之水，第三种做法可以通过，但它是错误的。</strong></p>
<h3 id="一些碎碎念">一些碎碎念</h3>
<p>缩点的时候，也就是求强连通分量，<span
class="math inline">\(low[u]\)</span> 和 <span
class="math inline">\(low[v],dfn[v]\)</span> 取
<code>min</code>，都是可以的，因为不影响判断某个点是否是 SCC 的根。</p>
<p><strong>如果图是无向图，那么不会存在横插边的问题，所有边都是返祖边。</strong></p>
<p>求边双连通分量，和 <code>low[v]</code> 取 <code>min</code>
同样没有问题，因为不影响一个点是不是边双的根的判断。</p>
<p>判断一个点是边双根的方式是，<strong>它无法通过自己或者儿子，到达更上面的点。</strong>这也意味着，该点与其父亲的连边是桥。</p>
<p><strong>边双连通具有传递性</strong></p>
<p>求点双连通分量，判断割点，如果和 <code>low[u]</code> 取
min，是会出问题的。</p>
<p>判断一个点是割点的方式是，<strong>它的任意一个儿子无法在没有它的情况下到达上面的点。</strong>特别注意，<strong>该点如果没有儿子，就不是割点。</strong></p>
<p>点双，就是以割点为界的所有连通块。</p>
<p>下图是一个取 <code>low[v]</code> 出问题的例子。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/8ptscypy.png" /></p>
<p>先访问 <span class="math inline">\(3\)</span>，再访问 <span
class="math inline">\(5\)</span>，会错误的认为 <span
class="math inline">\(5\)</span> 能够到 <span
class="math inline">\(1\)</span>，我们 <code>low</code>
的定义是通过自身或自身的子树能到的最小时间戳，而如果和
<code>low[v]</code> 取
<code>min</code>，就势必会经过其它的点。在这里，<span
class="math inline">\(5\)</span> 通过了 <span
class="math inline">\(4\)</span> 到达 <span
class="math inline">\(1\)</span>，因此如果删去 <span
class="math inline">\(4\)</span>，<span class="math inline">\(5\)</span>
就不能到 <span
class="math inline">\(1\)</span>，这里需要保证定义的严谨性。</p>
<p>前面的强连通分量，只需要能够到达，但不关心怎么到达，所以没问题。</p>
<p>边双也只关心能否到达更前面点，所以没有问题。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>评讲</title>
    <url>/2022/07/27/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0727%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="t1">T1</h2>
<p>签到题。</p>
<p>简单观察，发现最后的数为 <span
class="math inline">\(\sum_{i=1}^{n}a_i\times\tbinom{n-1}{i-1} \pmod
m\)</span></p>
<p>题目需要求出无关量，本质上是求系数为 <span
class="math inline">\(0\)</span> 的项，即求 <span
class="math inline">\(\tbinom{n-i}{i-1} \equiv 0\pmod m\)</span> 的
<span class="math inline">\(i\)</span>。</p>
<p>因为 <span class="math inline">\(m\)</span>
不为质数，所以没法直接处理阶乘，但很容易给出一个递推的 <span
class="math inline">\(O(n^2)\)</span> 做法。</p>
<p>注意到我们只关心 <span
class="math inline">\(\tbinom{n-i}{i-1}\)</span> 是否为 <span
class="math inline">\(m\)</span> 的倍数，<span
class="math inline">\(m\)</span> 的质因子也比较少 <span
class="math inline">\(\leq
10\)</span>，所以我们可以直接记录每一个质因子的质数即可，这样就可以直接阶乘。</p>
<h2 id="t2">T2</h2>
<p>简单题。</p>
<p>有个很重要的限制，一条边只能经过两次，说白了就是进入一棵子树之后，必须先确定叶节点有没有他的女朋友之后才能出去。</p>
<p>所以就能设计出树形 DP，<span
class="math inline">\(dp[u][0/1]\)</span>，表示 <span
class="math inline">\(u\)</span> 的子树是否有渡边女朋友，走完子树 <span
class="math inline">\(u\)</span> 的期望。</p>
<p>最终答案为 <span class="math inline">\(dp[u][1]\)</span>。</p>
<p>考虑转移，首先，有小弟把守的节点，<span
class="math inline">\(dp[u][0]=0\)</span>，因为渡边家兴只需要询问小弟就可以走完这棵子树。</p>
<p>计算 <span class="math inline">\(dp[u][0]\)</span>，就是 <span
class="math inline">\(\sum\limits_{v\in
E(u)}dp[v][0]+2\)</span>，就是搜索完所有的儿子节点加上进入每个儿子节点的消耗。</p>
<p>计算 <span
class="math inline">\(dp[u][1]\)</span>，本质上我们是要确定一个搜索子树的顺序，让期望搜索时间最小，考虑对于一个顺序
<span class="math inline">\(p\)</span>，期望时间是多少，记 <span
class="math inline">\(v\)</span> 子树中叶子个数为 <span
class="math inline">\(sz_v\)</span>，显然是 <span
class="math display">\[
\Large\sum\limits_{i=1}^{k} dp[p_i][1]\times \frac{sz_{p_i}}{sz_u} +
(dp[p_i][0]+2)\times\frac{\sum\limits_{j=i+1}^{k}sz_{p_j}}{sz_v}
\]</span> 即枚举所在子树，加上额外的搜索空子树的时间。</p>
<p>我们可以证明，按照 <span
class="math inline">\(\frac{dp[v][0]+2}{sz_v}\)</span>
升序排序后的顺序是最优的，具体证明参考国王游戏。</p>
<h2 id="t3">T3</h2>
<p>有些毒瘤的题。</p>
<p>简单观察发现每个字符都和其上下的位置高度相关，将 <code>NOI</code>
划分为 9 个部分，三个字母均分为中间和两边三个部分，再加上两个空白部分共
<code>11</code> 部分，考虑 DP，设 <span
class="math inline">\(dp[i][s][l][r]\)</span> 表示第 <span
class="math inline">\(i\)</span> 列，状态为 <span
class="math inline">\(s\)</span> ，上下为 <span
class="math inline">\(l,r\)</span> 的最大值。</p>
<p>其它的转移是简单的，我们着重强调 <code>N</code>
中间部分的转移。它转枚举了上一个上下端点 <span
class="math inline">\(l&#39;,r&#39;\)</span>，向 <span
class="math inline">\(l,r\)</span> 转移，条件为 <span
class="math inline">\(l\le r&#39;+1\)</span>，枚举当前的上端点 <span
class="math inline">\(l\)</span>，我们可以动态维护一个数组 <span
class="math inline">\(dp\_max[i]\)</span> 表示考虑所有 <span
class="math inline">\(r=i,l&#39;\le l\)</span>。转移使用<strong>当前的
<span class="math inline">\(l\)</span> 对应的 <span
class="math inline">\(dp\_max\)</span> 数组</strong>的 <span
class="math inline">\([1,r]\)</span> 的 <span
class="math inline">\(\max\)</span> 即可。</p>
<p>这道题的思维难度甚至没有 T2 大。</p>
<h2 id="t4">T4</h2>
<p>思维题。</p>
<p>找规律和暴力各有 10pts。</p>
<h3 id="solution1">Solution1</h3>
<p>先把 BFS 序转化为 <span class="math inline">\(1,2,\dots
n\)</span>，然后再来考虑。</p>
<p>因为要求平均高度，所以我们需要求出总高度和总个数，转化后一棵树的高度等于
<span class="math inline">\(n\)</span> 号节点的深度。</p>
<p>现在考虑划分 <span class="math inline">\(1-n\)</span> 这个 BFS
序列。可以发现一个划分<strong>最多只能对应一棵树。</strong></p>
<p>一个显然的必要条件是<strong>相同高度的元素在 DFS
序列中递增</strong>，另一个显然的必要条件是 DFS 序列中 <span
class="math inline">\(dep_{a_i}+1\ge dep_{a_{i+1}}\)</span>。</p>
<p>事实上，这两个条件也是充分的。</p>
<p>设 <span class="math inline">\(dp[i][0/1]\)</span> 表示考虑到 <span
class="math inline">\(i\)</span>，总数和总高度。转移检查哪些左端点可以转移即可，事实上，可以转移的左端点一定是一个区间，可以处理
<span class="math inline">\(dp\)</span> 数组的前缀和完成快速转移。</p>
<p>判断转移区间和结论证明，留作思考，后文有 Details。</p>
<p><strong>如果可能，尽量不要看 Details，自行思考</strong>。</p>
<h3 id="solution2">Solution2</h3>
<p>考虑一个划分合法的必要条件，Solution1 中已经提到。</p>
<p>考虑哪些位置可以划分，把一个间隔看成一个 01 变量，选择划分为 <span
class="math inline">\(1\)</span>，发现可以转化为一个这样的问题：</p>
<p>你需要确定长度为 <span class="math inline">\(n-1\)</span>
的二进制串，有若干个限制。每个限制形如</p>
<ul>
<li><span class="math inline">\([l,r]\)</span> 至多有一个 <span
class="math inline">\(1\)</span>。即：<span
class="math inline">\(dep_{a_i}+1\ge dep_{a_{i+1}}\)</span> 转化而来的
<span class="math inline">\([a_i,a_{i+1})\)</span></li>
<li><span class="math inline">\(x\)</span> 位置必须为 <span
class="math inline">\(1\)</span> 。即：如果 <span
class="math inline">\(pos_i&gt;pos_{i+1}\)</span>，那么由于同高度在
<span class="math inline">\(a\)</span> 中的位置递增，则 <span
class="math inline">\(i\)</span> 位置必须为 <span
class="math inline">\(1\)</span>。</li>
</ul>
<p>很容易设计出一个 <span class="math inline">\(O(n^2)\)</span>
的动态规划做法。</p>
<p>观察第一个条件，如果 <span
class="math inline">\(a_{i+1}&gt;a_i\)</span> 才会有第一个限制，如果
<span
class="math inline">\(a_i+1=a_{i+1}\)</span>，那么相当于这个限制不存在。</p>
<p>否则，因为保证一定存在一棵合法的树，所以 <span
class="math inline">\([a_i,a_{i+1}]\)</span> 区间的 <span
class="math inline">\(pos\)</span>
数组必须能够被划分为两个连续上升子序列。<span
class="math inline">\(a_i\)</span> 又和 <span
class="math inline">\(a_{i+1}\)</span>
紧紧挨在一起，那么得知必定会被划分，因为中间的某个数一定会冲突。我们很容易模拟得到被划分的位置，之后这个区间的所有数都不能再被划分。</p>
<p>对于没有限制的位置，我们划分与不划分的方案数是相同的，因此对期望的贡献是
<span class="math inline">\(0.5\)</span>。</p>
<p>将所有位置的期望加起来就是答案。</p>
<h3 id="solution1-details">Solution1 Details</h3>
<h4 id="transform">Transform</h4>
<p>看看样例，发现从 <span class="math inline">\(1-n\)</span>
排列比较好想，所以考虑先把点做个变换，弄成 <span
class="math inline">\(1-n\)</span>，所以 <span
class="math inline">\(b\)</span> 变成了 <span
class="math inline">\(1,2,3,\dots,n\)</span>。</p>
<p>然后记 <span class="math inline">\(u\)</span> 的深度为 <span
class="math inline">\(dep_u\)</span>，发现 <span
class="math inline">\(\forall i\in[1,n),dep_i\le dep_{i+1}\le
dep_i+1\)</span>。</p>
<p>然后又发现，对于 BFS 序列为 <span class="math inline">\(1,2,3,\dots
n\)</span>
的树，一个点遍历子节点的顺序一定是<strong>按编号从小到大遍历</strong>。</p>
<p>所以，确定了每个点的深度和 DFS 序列。可以唯一确定一颗树。</p>
<p>感性证明的话，确定深度之后把点画出来，画在一个二维平面上，深度相同的点在一层按编号从小到大排列，然后在
DFS
序列上走，如果下一个点深度更大，那肯定是往下连，如果深度不变或者更小，那一定是回去了一部分再往下走了一个，这样的逻辑可以唯一确定一棵树。</p>
<p><strong>自上到下，自左到右遍历二维平面所有点的过程，就是 BFS
的过程</strong></p>
<p><strong>请认真理解二维平面的含义。</strong></p>
<p><a
href="https://www.luogu.com.cn/blog/maxtir/solution-p1232">内含比较严格的证明</a></p>
<p><strong>本质上，确定深度的过程就是划分 <span
class="math inline">\(b\)</span> 序列的过程</strong></p>
<h4 id="native-dp-algorithm">Native DP Algorithm</h4>
<p>所以考虑对 BFS 序列的划分过程 DP，设 <span
class="math inline">\(dp[i][k]\)</span> 表示考虑到第 <span
class="math inline">\(i\)</span> 个点，深度为 <span
class="math inline">\(k\)</span> 的合法划分方案总数。</p>
<p>然后我们需要枚举一个左端点 <span
class="math inline">\(j\)</span>，考虑如何判断这个划分是否合法。</p>
<p>首先有个必要条件：<strong>同一深度的点，在 DFS
序列上的位置必须递增</strong>，因为我们遍历一个点的儿子的顺序是从小到大。<strong>称该条件为条件一</strong></p>
<p>其次，我们模拟一下在 DFS 序列上走的过程，发现<strong>一个点 <span
class="math inline">\(u\)</span> 的下一个点 <span
class="math inline">\(x\)</span> 一定有 <span
class="math inline">\(dep_u+1\ge
dep_x\)</span></strong>，原因是显然的。<strong>称该条件为条件二</strong></p>
<p>满足了以上条件，我们可以说明一定可以构造出一棵唯一对应的树。具体的，对于一个点
<span class="math inline">\(u\)</span>，下一个点是 <span
class="math inline">\(v\)</span>，找到它或者它的祖先 <span
class="math inline">\(u&#39;\)</span>， 满足 <span
class="math inline">\(dep_v=dep_{u&#39;}+1\)</span>，那么 <span
class="math inline">\(v\)</span> 的父亲就是 <span
class="math inline">\(u&#39;\)</span>。由于第一个条件，限制了处理的
<span class="math inline">\(v\)</span>
一定是该层<strong>第一个还没有安排父亲的点</strong>。所以每个点只会<strong>恰好被安排一次父亲</strong>，得到一个合法的树。</p>
<p>这样的话，我们再记录一维划分起点，变成 <span
class="math inline">\(dp[i][j][k]\)</span>。</p>
<p>转移枚举当前起点和上一个划分的起点，判断两个条件可以简单的 <span
class="math inline">\(O(n)\)</span> 做。</p>
<p>复杂度为 <span class="math inline">\(O(n^4)\)</span>，因为对于 <span
class="math inline">\(n\)</span> 个深度 <span
class="math inline">\(k\)</span> ，一共只需要判断一次。</p>
<h4
id="observaion1optimization1">Observaion1&amp;&amp;Optimization1</h4>
<ul>
<li>发现其实不用记录具体每个深度有几个元素，只需要记录<strong>深度之和与树的个数</strong>就可以计算答案。</li>
<li>假设划分的区间为 <span class="math inline">\([l,r]\)</span> ，深度为
<span class="math inline">\(d\)</span>。条件二等价于，<span
class="math inline">\(a\)</span> 中 <span
class="math inline">\([1,l)\)</span> 的后一个元素 <span
class="math inline">\(x\)</span>，一定满足 <span
class="math inline">\(x\le
r\)</span>。因为每次加入一段区间的点之后，上一次的深度为 <span
class="math inline">\(d-1\)</span>
的点的右端点，如果还没有确定深度，就会被确定为 <span
class="math inline">\(d\)</span>。所以加入后，存在右端点还没确定深度的点，其本身深度只能为
<span class="math inline">\(d\)</span>
了。所以可以直接<strong>判断交界处的深度关系</strong>，判断方式是 <span
class="math inline">\(\forall i\in[1,n),a_i&gt;j \or a_{i+1}\ge
i\)</span>。</li>
</ul>
<p>40Pts 的代码运用了第二个观察，请阅读。</p>
<p>运用第一个观察，DP 状态简化为 <span
class="math inline">\(dp[i][j][0/1]\)</span></p>
<p>再次运用第二个观察，其实已经无需记录 <span
class="math inline">\(j\)</span>，DP 状态进一步简化为 <span
class="math inline">\(dp[i][0/1]\)</span>。</p>
<p>上述做法的复杂度是 <span class="math inline">\(O(n^3)\)</span>
的，考虑优化。</p>
<p>参看 Codes 部分的 40Pts 做法。<span
class="math inline">\(sum\)</span> 数组的含义是，<span
class="math inline">\(sum[i][j]\)</span> 表示以 <span
class="math inline">\(i\)</span> 结尾，深度为 <span
class="math inline">\(j\)</span> 的方案总数。</p>
<p><strong>40Pts 的部分没有对层数做简化</strong></p>
<h4
id="observaion2optimization2">Observaion2&amp;&amp;Optimization2</h4>
<ul>
<li><p>其实 <span class="math inline">\(dp\)</span>
数组没有用，只需要记录一个 <span class="math inline">\(sum\)</span>
数组就可以了。</p></li>
<li><p>条件一，显然可行的 <span class="math inline">\(j\)</span>
是一个右端点为 <span class="math inline">\(i\)</span> 的区间，对于每个
<span class="math inline">\(i\)</span>，可以处理出满足 <span
class="math inline">\(p\)</span>
数组(参考题解开头的定义)区间递增的最小左端点，作为 <span
class="math inline">\(j\)</span> 左端点的限制。</p></li>
<li><p>条件二，显然可行的 <span class="math inline">\(j\)</span>
是一个前缀，并且右端点随 <span class="math inline">\(i\)</span>
增大，这限制了 <span class="math inline">\(j\)</span>
的右端点。</p></li>
</ul>
<p>由于条件一，二的限为区间转移限制，所以记录一下 <span
class="math inline">\(sum\)</span> 的前缀和即可做到转移 <span
class="math inline">\(O(n)\)</span></p>
<p>利用尺取法的思想可以 <span class="math inline">\(O(n^2)\)</span>
的计算条件二的右端点。</p>
<p>但进一步观察，发现对条件二进行了一些无用的
check，每次移动端点时，有用的 check
只有一个，就是值为右端点本身的位置。</p>
<p>所以 check 变成了 <span class="math inline">\(O(1)\)</span>，总复杂度
<span class="math inline">\(O(n)\)</span></p>
<p>参考 100Pts 代码，注意，其中的 <span
class="math inline">\(dp\)</span> 代表 40pts 写法中的 <span
class="math inline">\(sum\)</span>，<span
class="math inline">\(sum\)</span> 代表其前缀和。</p>
<h4 id="notes">Notes</h4>
<ul>
<li><strong>DP 过程中最大值达到了 <span
class="math inline">\(2^{n}\)</span>，需要手写科学计数法，可以忽略指数差距过大的加减运算。</strong></li>
</ul>
<h4 id="codes">Codes</h4>
<h5 id="pts-on3">40pts <span class="math inline">\(O(n^3)\)</span></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;<span class="type">const</span> <span class="type">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2;</span><br><span class="line"><span class="type">int</span> a[N],p[N],b[N];</span><br><span class="line"><span class="type">double</span> dp[N][N][N],sum[N][N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(b[i]),p[b[i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)a[i]=p[a[i]];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)p[a[i]]=i;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;sum[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="comment">//条件1</span></span><br><span class="line">			<span class="keyword">for</span>(k=j<span class="number">+1</span>;k&lt;=i;k++)</span><br><span class="line">			<span class="keyword">if</span>(p[k<span class="number">-1</span>]&gt;p[k])<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(k!=i<span class="number">+1</span>)<span class="keyword">continue</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//条件2</span></span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;n;k++)</span><br><span class="line">			<span class="keyword">if</span>(a[k]&lt;j&amp;&amp;a[k<span class="number">+1</span>]&gt;i)<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">//如果交界处，一个深度小于 d,另一个大于 d，那么寄。					</span></span><br><span class="line">			<span class="keyword">if</span>(k!=n)<span class="keyword">continue</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">			dp[i][j][k]+=sum[j<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">		sum[i][k]+=dp[i][j][k];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cnt+=sum[n][i];</span><br><span class="line">		ans+=sum[n][i]*i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%0.3lf&quot;</span>,ans/cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="pts-on">100 pts <span class="math inline">\(O(n)\)</span></h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">202005</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2;</span><br><span class="line"><span class="type">int</span> a[N],p[N],b[N],lst[N],far[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Double</span>&#123;</span><br><span class="line">	<span class="type">double</span> val;</span><br><span class="line">	<span class="type">int</span> p;</span><br><span class="line">	<span class="function">Double <span class="title">cap</span><span class="params">(Double x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">abs</span>(x.val)&gt;<span class="number">1e18</span>)&#123;</span><br><span class="line">			x.val/=<span class="number">2</span>;</span><br><span class="line">			x.p++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">abs</span>(x.val)&lt;<span class="number">1e-18</span>)&#123;</span><br><span class="line">			x.val*=<span class="number">2</span>;</span><br><span class="line">			x.p--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span> =(<span class="type">int</span> x)&#123;p=<span class="number">0</span>,val=x;&#125;</span><br><span class="line">	Double <span class="keyword">operator</span> +(<span class="type">const</span> Double &amp;x)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x.p-p&gt;<span class="number">50</span>)<span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">if</span>(p-x.p&gt;<span class="number">50</span>)<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cap</span>(&#123;val+x.val*<span class="built_in">pow</span>(<span class="number">2</span>,x.p-p),p&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span> +=(<span class="type">const</span> Double &amp;x)&#123;*<span class="keyword">this</span>=*<span class="keyword">this</span>+x;<span class="built_in">cap</span>(x);&#125;</span><br><span class="line">	Double <span class="keyword">operator</span> -()&#123;<span class="keyword">return</span> Double&#123;-val,p&#125;;&#125;</span><br><span class="line">	Double <span class="keyword">operator</span> -(Double &amp;x)&#123;<span class="keyword">return</span> <span class="built_in">cap</span>((*<span class="keyword">this</span>)+(-x));&#125;</span><br><span class="line">	Double <span class="keyword">operator</span> /(<span class="type">const</span> Double &amp;x)&#123;<span class="keyword">return</span> <span class="built_in">cap</span>(&#123;val/x.val,p-x.p&#125;);&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> val*<span class="built_in">pow</span>(<span class="number">2.0</span>,p);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Double dp[N][<span class="number">2</span>],sum[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);lst[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(b[i]),p[b[i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)a[i]=p[a[i]];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)p[a[i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[i]&gt;p[i<span class="number">-1</span>])lst[i]=lst[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">else</span> lst[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>,dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	sum[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>,sum[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	far[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=far[i<span class="number">-1</span>]<span class="number">+1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[p[j<span class="number">-1</span>]<span class="number">+1</span>]&lt;=i||p[j<span class="number">-1</span>]==n)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">		far[i]=--j;</span><br><span class="line">		<span class="keyword">if</span>(far[i]&gt;=lst[i])&#123;</span><br><span class="line">			dp[i][<span class="number">0</span>]=sum[j<span class="number">-1</span>][<span class="number">0</span>]-sum[lst[i]<span class="number">-2</span>][<span class="number">0</span>];</span><br><span class="line">			dp[i][<span class="number">1</span>]=(sum[j<span class="number">-1</span>][<span class="number">1</span>]-sum[lst[i]<span class="number">-2</span>][<span class="number">1</span>])+(sum[j<span class="number">-1</span>][<span class="number">0</span>]-sum[lst[i]<span class="number">-2</span>][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		sum[i][<span class="number">0</span>]=dp[i][<span class="number">0</span>]+sum[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">		sum[i][<span class="number">1</span>]=dp[i][<span class="number">1</span>]+sum[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%0.3lf&quot;</span>,(dp[n][<span class="number">1</span>]/dp[n][<span class="number">0</span>]).<span class="built_in">get</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>树形背包的较严谨复杂度证明</title>
    <url>/2022/07/25/OI/%E7%AE%97%E6%B3%95/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85%E7%9A%84%E8%BE%83%E4%B8%A5%E8%B0%A8%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h2
id="树形背包的比较严谨的复杂度证明">树形背包的比较严谨的复杂度证明</h2>
<h3 id="转移方式">转移方式</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	sz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);sz[u]+=sz[v];</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="built_in">min</span>(k,sz[u]);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="built_in">max</span>(<span class="number">0</span>,i-(sz[u]-sz[v]));j&lt;=i&amp;&amp;j&lt;=sz[v];j++)&#123;</span><br><span class="line">                <span class="comment">//O(trans) do something</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="证明总复杂度为-on2">证明，总复杂度为 <span
class="math inline">\(O(n^2)\)</span></h3>
<p>证明 <span class="math inline">\(n^2\)</span> 直接忽略 <span
class="math inline">\(i\)</span> 的循环和 <span
class="math inline">\(k\)</span> 取 <span
class="math inline">\(\min\)</span> 的操作。</p>
<p>考虑在某个点合并子树的过程，本质上，如果把 <span
class="math inline">\(sz_u\)</span>
看成当前子树内所有的点，我们的第一个循环是限制了<strong>合并后的总大小</strong>，第二个循环限制了已经合并的子树的大小，以及待合并的子树的大小。</p>
<p>所以在一个点 <span class="math inline">\(u\)</span>
处，只有每一对以它为 LCA 的点对会贡献一次，其它点对均不贡献。</p>
<p>所以总复杂度为点对数量 <span
class="math inline">\(O(n^2)\)</span></p>
<h3 id="证明总复杂度为-otranstimes-minn2nk">证明，总复杂度为 <span
class="math inline">\(O(trans\times min(n^2,nk))\)</span></h3>
<p><span class="math inline">\(O(n^2)\)</span>
的证明是老生常谈的事情了，考虑 <span class="math inline">\(k\leq
n\)</span> 的情况，试证明总复杂度为 <span
class="math inline">\(O(nk)\)</span></p>
<p>考虑一对点在 LCA 处的贡献，</p>
<p>考虑合并子树时的三种 case，小于 <span
class="math inline">\(k\)</span> 向大于 <span
class="math inline">\(k\)</span> 合并，大于 <span
class="math inline">\(k\)</span> 向大于 <span
class="math inline">\(k\)</span> 合并，小于 <span
class="math inline">\(k\)</span> 向小于 <span
class="math inline">\(k\)</span> 合并。</p>
<p>我们分别说明三种情况的时间复杂度都是 <span
class="math inline">\(O(nk)\)</span> 的。</p>
<h4 id="case1">Case1</h4>
<p>小于合并到大于。</p>
<p><strong>准确的说，是小于 <span class="math inline">\(k\)</span>
的子树合并之后，大小大于 <span
class="math inline">\(k\)</span></strong></p>
<p>考虑每一个点对这种情况的贡献，每个点显然只会参与一次过程，因为参与之后它所在的块的大小就大于
<span class="math inline">\(k\)</span> 了。</p>
<p>总复杂度 <span class="math inline">\(O(nk)\)</span></p>
<h4 id="case2">Case2</h4>
<p>大于合并到大于。</p>
<p>考虑每一次合并，复杂度 <span
class="math inline">\(O(k^2)\)</span>，会永远失去一个大于 <span
class="math inline">\(k\)</span> 的块。而我们最多会生成 <span
class="math inline">\(\frac{n}{k}\)</span> 个大小大于 <span
class="math inline">\(k\)</span>
的块，因为一个点至多参与一次生成新块的过程。</p>
<p>总复杂度 <span class="math inline">\(O(nk)\)</span>。</p>
<h4 id="case3">Case3</h4>
<p>小于合并到小于，那么这种情况就只会发生于大小小于 <span
class="math inline">\(k\)</span>
的子树内以及其父亲的子树间。<strong>如果一个点的父亲的大小也不超过 <span
class="math inline">\(k\)</span>，我们忽略它本身，直接在它的父亲处计算所有复杂度贡献</strong>。这样所有的复杂度分成两个部分，小于
<span class="math inline">\(k\)</span>
的子树内，以及其兄弟间（也就是在一棵很大的子树中，有几个比较小的儿子先合并了）。</p>
<p>第一部分的复杂度显然是 <span class="math inline">\(\leq nk\)</span>
的（本质上是选了几个自身不超过 <span
class="math inline">\(k\)</span>，和不超过 <span
class="math inline">\(n\)</span> 的变量求平方和，参考 <span
class="math inline">\(n^2\)</span> 的证明）</p>
<p>第二部分，每个点只会参与一次这个过程，因为参与一次之后它所在的块大小就大于
<span class="math inline">\(k\)</span> 了，所以这一部分的总复杂度也是
<span class="math inline">\(O(nk)\)</span> 的</p>
<p>综上所述，树形背包的复杂度为 <span
class="math inline">\(O(nk)\)</span>。</p>
<h3 id="思考">思考</h3>
<p>在上面的代码的边界做一些改动，哪些改动会让复杂度假掉。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1709总结和题解</title>
    <url>/2022/07/22/OI/%E6%AF%94%E8%B5%9B/CF1709/</url>
    <content><![CDATA[<h2 id="cf1709-总结和题解">CF1709 总结和题解</h2>
<h3 id="a">A</h3>
<p>略</p>
<h3 id="b">B</h3>
<p>略</p>
<h3 id="c">C</h3>
<h4 id="题意">题意</h4>
<p>有个<strong>合法括号序列</strong>，部分字符被 <code>?</code>
替换了，问是否存在<strong>唯一的一种</strong>填 <code>?</code>
的方案，使得括号序列合法，即判断填 <code>?</code>
使得括号序列合法的方案数<strong>是否等于1</strong>。存在唯一方案输出
<code>YES</code>，方案不唯一输出 <code>NO</code></p>
<p>序列长度 <span class="math inline">\(\sum n\le 2\times
10^5\)</span>，测试点数 <span class="math inline">\(T\leq 5\times
10^4\)</span></p>
<p>第一行输出测试点总数 <span class="math inline">\(T\)</span>。</p>
<p>之后每一行一个字符串 <span class="math inline">\(s\)</span>
表示替换掉部分字符后的<strong>合法括号序列</strong>。</p>
<h4 id="题解">题解</h4>
<p>考虑一个括号序列，令 <code>(</code> 为 1，<code>)</code> 为
-1，记形成的新序列为 <span
class="math inline">\(c\)</span>，然后对该序列做前缀和得到 <span
class="math inline">\(s\)</span>，容易发现括号序列合法的充要条件是 <span
class="math inline">\(s_n=0\)</span> 且 <span
class="math inline">\(\forall i\in[1,n],s_i\ge0\)</span>。</p>
<p>已知给定的带 <code>?</code>
的序列是一个合法序列变来的，所以考虑统计三种字符的个数，<code>?,(,)</code>
分别个数记为 <code>cnt cnt0 cnt1</code>，发现如果出现
<code>cnt + min(cnt0,cnt1)=n/2</code> 一定是 <code>YES</code>，因为每个
<code>?</code> 的填法已经确定了。</p>
<p>因为一定要合法，所以 <span class="math inline">\(s_n\)</span> 一定为
<code>0</code>，现在就需要让每一个 <span
class="math inline">\(s_i\)</span> 尽量大，方法就是把 <code>(</code>
尽量往前面填，这样会让每个 <span class="math inline">\(s_i\)</span>
都尽可能大。</p>
<p>然后我们考虑一种稍稍不那么优秀的方案，就是交换一组由两个
<code>?</code> 构成的 <code>()</code> 序列，发现交换 <code>()</code>
交界处的那两个一定最优，所以求一下交界处的 min 看看是否大于 2 就行。</p>
<p>可以证明，如果这样交换不行，那么其它任何交换方案都不行。</p>
<p>我写麻烦了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2;</span><br><span class="line"><span class="type">char</span> ch[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">read</span>(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch<span class="number">+1</span>);</span><br><span class="line">		n=<span class="built_in">strlen</span>(ch<span class="number">+1</span>);<span class="type">int</span> cnt=<span class="number">0</span>,cnt0=<span class="number">0</span>,cnt1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;?&#x27;</span>)cnt++;</span><br><span class="line">			<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;(&#x27;</span>)cnt0++;</span><br><span class="line">			<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;)&#x27;</span>)cnt1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt&lt;=<span class="number">1</span>||cnt+<span class="built_in">min</span>(cnt0,cnt1)==n/<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">0</span>,top=<span class="number">0</span>,t1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;(&#x27;</span>)top++;</span><br><span class="line">			<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;)&#x27;</span>)top--;</span><br><span class="line">			<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;?&#x27;</span>&amp;&amp;cnt0!=n/<span class="number">2</span>)top++,t1++,cnt0++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(ch[i]==<span class="string">&#x27;?&#x27;</span>&amp;&amp;cnt0==n/<span class="number">2</span>)top--;</span><br><span class="line">			c[i]=top;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> lst=<span class="number">0</span>,min_val=INF,all=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">				all++;</span><br><span class="line">				<span class="keyword">if</span>(min_val&gt;=<span class="number">2</span>&amp;&amp;all==t1<span class="number">+1</span>)flag=<span class="number">1</span>;</span><br><span class="line">				lst=i;</span><br><span class="line">				min_val=INF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cmin</span>(min_val,c[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="d">D</h3>
<h4 id="题意-1">题意</h4>
<p>有一个 <span class="math inline">\(n\times m\)</span> 的网格，第
<span class="math inline">\(i(i\in[1,m])\)</span> 列的 <span
class="math inline">\([1,a_i]\)</span> 行被锁定了。</p>
<p>你有个机器人，你可以给它发命令，让它向上下左右移动一格，但是机器人有
Bug，你发的每个命令都会被执行 <span class="math inline">\(k\)</span>
次<strong>不是瞬移 <span class="math inline">\(k\)</span> 格，而是走
<span class="math inline">\(k\)</span>
次，每次一格</strong>。在<strong>任何一个时刻</strong>，机器人都不能处于被锁定的格子或者网格外。</p>
<p>给定 <span class="math inline">\(q\)</span>
组询问，每组询问给定五个参数 <span
class="math inline">\(x_s,y_s,x_f,y_f,k\)</span>，代表起点终点坐标和参数
<span class="math inline">\(k\)</span>，问能否从起点到终点，能输出
<code>YES</code>，不能输出 <code>NO</code>。</p>
<p>第一行输入 <span class="math inline">\(n,m\)</span>。</p>
<p>第二行输入一个长度为 <span class="math inline">\(m\)</span>
的数组表示 <span class="math inline">\(a\)</span>。</p>
<p>第三行一个整数 <span class="math inline">\(q\)</span></p>
<p>接下来 <span class="math inline">\(q\)</span> 行每行 <span
class="math inline">\(5\)</span> 个整数 <span
class="math inline">\(x_s,y_s,x_f,y_f,k\)</span> 描述一个询问。</p>
<p>$ 1 n ^9 ; 1 m ^5 ; 1q ^5$</p>
<p><span class="math inline">\(a[y_s] &lt; x_s \le n ; 1 \le y_s \le m ;
a[y_f] &lt; x_f \le n; 1 \le y_f \le m; 1 \le k \le 10^9\)</span></p>
<h4 id="题解-1">题解</h4>
<p>假设全部点都没有 <span class="math inline">\(lock\)</span>，考虑从
<span class="math inline">\((x_1,y_1)\)</span> 能到 <span
class="math inline">\((x_2,y_2)\)</span> 的充要条件，显然是 <span
class="math inline">\(k|abs(x_1-x_2)\)</span> 并且 <span
class="math inline">\(k|abs(y_1-y_2)\)</span>。</p>
<p>现在加入限制。允许 <span class="math inline">\([n-a_i,n]\)</span>
走太麻烦了，翻转一下，变成允许 <span
class="math inline">\([1,a_i&#39;]\)</span> 走。</p>
<p>然后最优方案就是先走到当前的最底下，然后横着走过去。</p>
<p>所以找到最低能走到哪个位置，然后做个区间 min，判断最低位置 <span
class="math inline">\(x\)</span> 和区间 min 的关系，如果 <span
class="math inline">\(x\le \min\)</span>，显然可以，否则不行。</p>
<p>区间 min 用 ST 表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,q;</span><br><span class="line"><span class="type">int</span> st[<span class="number">25</span>][N],lo[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r)<span class="built_in">swap</span>(l,r);</span><br><span class="line">	<span class="type">int</span> len=lo[r-l<span class="number">+1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(st[len][l],st[len][r-(<span class="number">1</span>&lt;&lt;len)<span class="number">+1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">read</span>(m),<span class="built_in">read</span>(n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)lo[i]=lo[i&gt;&gt;<span class="number">1</span>]<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="built_in">read</span>(st[<span class="number">0</span>][i]),st[<span class="number">0</span>][i]=m-st[<span class="number">0</span>][i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>&lt;=n;j++)</span><br><span class="line">	st[i][j]=<span class="built_in">min</span>(st[i<span class="number">-1</span>][j],st[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]);</span><br><span class="line">	<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line">		<span class="built_in">read</span>(y1),<span class="built_in">read</span>(x1),<span class="built_in">read</span>(y2),<span class="built_in">read</span>(x2),<span class="built_in">read</span>(k);</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x1==x2&amp;&amp;y1==y2)<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		y1=m-y1<span class="number">+1</span>,y2=m-y2<span class="number">+1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(x1-x2)%k||<span class="built_in">abs</span>(y1-y2)%k||<span class="built_in">ask</span>(x1,x2)&lt;(y1%k==<span class="number">0</span>?k:y1%k))<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="e">E</h3>
<h4 id="题意-2">题意</h4>
<p>你有一棵无根树，点数为 <span
class="math inline">\(n\)</span>，每个点有个点权 <span
class="math inline">\(a_u\)</span>，定义一条路径 <span
class="math inline">\(P(u,v)\)</span>
的权值为经过的<strong>所有点的点权的异或和</strong>。定义一棵树是合法的，当且仅当树上所有<strong>简单路径</strong>（只经过每个点一次的路径）的的权值都不为
<span class="math inline">\(0\)</span>。</p>
<p>你可以对权值进行修改，可以改成<strong>任意正整数</strong>，问最少修改多少次才能让这棵树合法。</p>
<p>输出最小修改次数。</p>
<p><span class="math inline">\(n\leq 2\times 10^5,a_i\leq
2^{30}\)</span></p>
<h4 id="题解-2">题解</h4>
<p>发现路径权值为 <span class="math inline">\(sum[u]  \bigoplus sum[v]
\bigoplus a[lca(u,v)]\)</span>，<span
class="math inline">\(sum[u]\)</span> 表示从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(u\)</span>
的路径上所有点点权的异或和，每一条路径，我们在路径 <span
class="math inline">\(lca\)</span> 处考虑是否不合法（权值为 0）。</p>
<p>我们称一个点不合法当且仅当有一条 <span
class="math inline">\(lca\)</span>
为这个点的不合法路径经过它。我们从深到浅处理每一个不合法的 <span
class="math inline">\(lca\)</span></p>
<p>如果一条路径不合法，修改方案可以分为改 <span
class="math inline">\(lca\)</span> 和非 <span
class="math inline">\(lca\)</span>，可以说明改 <span
class="math inline">\(lca\)</span>
是最优的。首先，可以说明，<strong>改一个点 <span
class="math inline">\(u\)</span> 的最优方案之一是改成 <span
class="math inline">\(2^{u+32}\)</span>，因为这样的话所有经过这个点的路径都一定合法</strong>。然后说明改
<span class="math inline">\(lca\)</span> 最优。如果不改 <span
class="math inline">\(lca\)</span>，以这颗子树中的点为起点的路径<strong>仍然有可能不合法</strong>，而改
<span
class="math inline">\(lca\)</span>，以这颗子树中的点为起点的路径一定都合法。我们假设了当前处理的
<span class="math inline">\(lca\)</span>
是最深的，所以这颗子树内所有的不合法路径一定经过了 <span
class="math inline">\(lca\)</span>，所以改了 <span
class="math inline">\(lca\)</span>，所有路径就一定合法了。所以<strong>改
<span class="math inline">\(lca\)</span> 最优</strong></p>
<p>怎么判断一个 <span class="math inline">\(lca\)</span>
处有不合法路径，拿个 set 维护下每颗子树内的 <span
class="math inline">\(sum\)</span>，然后加入一颗子树时，枚举加入子树的所有点
<span class="math inline">\(v\)</span>，判断当前 set 中是否存在元素
<span class="math inline">\(a_[lca]\bigoplus
sum[v]\)</span>，如果存在，<span class="math inline">\(lca\)</span>
就不合法，我们给答案加一，在这颗子树的父亲计算时忽略该子树。</p>
<p>发现合并 set 的代价是 <span class="math inline">\(O(\sum
size_u)=O(n^2)\)</span> 的，但是可以启发式合并。</p>
<p>具体的，一个点 <span class="math inline">\(u\)</span>
继承它最大的儿子的 <span
class="math inline">\(set\)</span>，然后在把它自己和其它子树加入到这个
set
中，同时判断是否存在不合法路径。考虑这样的复杂度，证明和树链剖分的复杂度证明相同，继承操作可以用
<code>std::swap</code>，这个函数交换两个 <code>STL</code>
容器的复杂度，在 <code>C++11</code> 以上标准是 <span
class="math inline">\(O(1)\)</span> 的。</p>
<p>对于一个点，我们考虑它什么时候会被合并一次（就是作为非最大子树，被合并上去）。每一个点所在的
set，被合并时，它所在的新 set 的大小至少变为 <span
class="math inline">\(2\)</span> 倍（因为新 set
最开始的大小一定比该点所在的 set 大，否则该点所在的 set 会作为最后保留的
set 而不对复杂度做贡献），最后的 set 大小为 <span
class="math inline">\(n\)</span>，所以每个点合并 <span
class="math inline">\(\log n\)</span> 次。</p>
<p>总复杂度 <span class="math inline">\(O(n\log^2 n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2,ans;</span><br><span class="line"><span class="type">int</span> fa[N],sz[N],son[N],a[N],sum[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	sz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[u]==v)<span class="keyword">continue</span>;</span><br><span class="line">		fa[v]=u;sum[v]=sum[u]^a[v];</span><br><span class="line">		<span class="built_in">pre_dfs</span>(v),sz[u]+=sz[v];</span><br><span class="line">		<span class="keyword">if</span>(sz[v]&gt;sz[son[u]])son[u]=v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">redfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flag=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(son[u])&#123;</span><br><span class="line">		<span class="built_in">redfs</span>(son[u]);</span><br><span class="line">		<span class="built_in">swap</span>(st[son[u]],st[u]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(st[u].<span class="built_in">find</span>(sum[u]^a[u])!=st[u].<span class="built_in">end</span>())flag=<span class="number">1</span>;</span><br><span class="line">	st[u].<span class="built_in">insert</span>(sum[u]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v==son[u]||v==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">redfs</span>(v);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> val:st[v])&#123;</span><br><span class="line">			<span class="keyword">if</span>(st[u].<span class="built_in">find</span>(val^a[u])!=st[u].<span class="built_in">end</span>())</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> val:st[v])</span><br><span class="line">		st[u].<span class="built_in">insert</span>(val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag)ans++,st[u].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">	sum[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">		e[x].<span class="built_in">push_back</span>(y),e[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pre_dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">redfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="f">F</h3>
<h4 id="题意-3">题意</h4>
<p>定义二进制串为只包含 <span class="math inline">\(01\)</span>
的字符串。</p>
<p>给你 <span class="math inline">\(n,k,f\)</span>，<span
class="math inline">\(1\le n\leq 15,1\le f,k\leq 2\times
10^5\)</span>，你需要给每个长度不超过 <span
class="math inline">\(n\)</span> 的二进制串 <span
class="math inline">\(s\)</span> 确定一个 <span
class="math inline">\(c_s\in [0,k]\)</span>
的权值。然后你需要选出一个只包含长度<strong>恰好</strong>为 <span
class="math inline">\(n\)</span>
的二进制串的<strong>可重集合</strong>，使得这个可重集合最大。并且满足对于所有长度<strong>小于</strong>
<span class="math inline">\(n\)</span> 的二进制串 <span
class="math inline">\(s\)</span>，集合元素中，<span
class="math inline">\(s\)</span>
作为集合中元素前缀的次数<strong>不超过</strong> <span
class="math inline">\(c_s\)</span>。</p>
<p>求安排 <span class="math inline">\(c\)</span>
，使得集合最大大小<strong>恰好为 <span
class="math inline">\(f\)</span></strong> 的方案数，对 <span
class="math inline">\(998244353\)</span> 取模。</p>
<h4 id="题解-3">题解</h4>
<p>考虑取到最大值 <span class="math inline">\(f\)</span> 的条件，不妨令
<span class="math inline">\(n=1\)</span>，发现要求就是 <span
class="math inline">\(c_0+c_1=f\)</span>，然后我们考虑一些长度为 <span
class="math inline">\(n\)</span> 的二进制串。</p>
<p>因为要对每个长度小于 <span class="math inline">\(n\)</span>
的串都确定一个 <span
class="math inline">\(c\)</span>，然后我们又发现，记一个前缀 <span
class="math inline">\(s\)</span> 的数量限制为 <span
class="math inline">\(w_s\)</span>，实际上 <span
class="math inline">\(w_s=\min(c_s,w_{s+&#39;0&#39;}+w_{s+&#39;1&#39;})\)</span>。</p>
<p>然后我们就可以对一个确定的 <span class="math inline">\(c\)</span>
序列，像树形 <span class="math inline">\(dp\)</span>
一样算出最大大小。</p>
<p>考虑对这个树形 <span class="math inline">\(dp\)</span>
的过程计数，本质上，由于树是满二叉树，所以 dp 出每个值的 <span
class="math inline">\(c\)</span> 序列的方案只于层数有关。</p>
<p>所以设 <span class="math inline">\(dp[i][j]\)</span> 为考虑到深度为
<span class="math inline">\(n-i\)</span> 的满二叉树，值为 <span
class="math inline">\(j\)</span> 的安排方案总数。</p>
<p>转移限制有两种，第一个是 <span class="math inline">\(c\)</span>
限制，第二种是子树限制，考虑先算一个 <span
class="math inline">\(sum[i][j]\)</span> 表示子树和为 <span
class="math inline">\(j\)</span> 的方案数。</p>
<p>然后可以得到 <span
class="math inline">\(dp[i][j]=sum[i][j]*(k-j+1)+\sum\limits_{t&gt;
j}sum[i][t]\)</span>。分别表示两种限制的贡献。</p>
<p>算出 <span class="math inline">\(sum\)</span> 后是 <span
class="math inline">\(O(k)\)</span> 转移的。考虑 <span
class="math inline">\(sum[i][j]=\sum\limits_{s+t=j} dp[i-1][s]\times
dp[i-1][j]\)</span>。就是个卷积，NTT 板子上去就行。</p>
<p><strong>注意边界</strong>，处理最顶层的时候，<span
class="math inline">\(dp[n][i]\)</span>
只能由子树和来限制，因为这个点本来就是长度为 0 的串，不能填 <span
class="math inline">\(c\)</span>，我在这里想当然的认为只要 <span
class="math inline">\(i\le k\)</span> 的时候有值，所以没有
AK，实际上这里 <span class="math inline">\(k&lt; i\le 2k\)</span>
也是有值的，因为这个点本身不会限制。</p>
<p><strong>如果 TLE 了换成 64bit 的机子再交一次，64 bit 的 long long
运算要快一些。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">19</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">namespace</span> NTT&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">20</span>,mod=<span class="number">998244353</span>,g=<span class="number">3</span>,gi=<span class="number">332748118</span>;</span><br><span class="line">	<span class="type">int</span> i,j,k,n,s,t,m;</span><br><span class="line">	<span class="type">int</span> a[N],b[N],rk[N];</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">quick</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> s,<span class="type">int</span> ret=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(s)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s&amp;<span class="number">1</span>)ret=ret*a%mod;</span><br><span class="line">			a=a*a%mod,s&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;s;i++)</span><br><span class="line">		<span class="keyword">if</span>(rk[i]&gt;i)<span class="built_in">swap</span>(a[rk[i]],a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=s;len++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> w=<span class="number">1</span>,wn=<span class="built_in">quick</span>(g,mod<span class="number">-1</span>&gt;&gt;len);</span><br><span class="line">			<span class="keyword">if</span>(type==<span class="number">-1</span>)wn=<span class="built_in">quick</span>(wn,mod<span class="number">-2</span>);</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j+(<span class="number">1</span>&lt;&lt;len)&lt;=<span class="number">1</span>&lt;&lt;s;j+=<span class="number">1</span>&lt;&lt;len,w=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(k=j;k&lt;j+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>);k++,w=<span class="number">1ll</span>*w*wn%mod)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> x=a[k],y=a[k+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>)];</span><br><span class="line">					a[k]=(x<span class="number">+1ll</span>*w*y%mod)%mod,a[k+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>)]=(x<span class="number">-1ll</span>*w*y%mod)%mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> nn,<span class="type">int</span> c[],<span class="type">int</span> res[])</span></span>&#123;</span><br><span class="line">		n=m=nn;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a)),<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)a[i]=c[i];</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=m;i++)b[i]=c[i];</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>&lt;&lt;s&lt;=n+m)s++;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;s;i++)rk[i]=rk[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>|(i%<span class="number">2</span>?<span class="number">1</span>&lt;&lt;s<span class="number">-1</span>:<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">NTT</span>(a,<span class="number">1</span>),<span class="built_in">NTT</span>(b,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;s;i++)a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">		<span class="built_in">NTT</span>(a,<span class="number">-1</span>);<span class="type">int</span> inv=<span class="built_in">quick</span>(<span class="number">1</span>&lt;&lt;s,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n+m;i++)</span><br><span class="line">		res[i]=(<span class="number">1ll</span>*a[i]*inv%mod+mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2,f;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inc</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	a+=b;<span class="keyword">if</span>(a&gt;=mod)a-=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> s,<span class="type">int</span> ret=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(s)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s&amp;<span class="number">1</span>)ret=ret*a%mod;</span><br><span class="line">		a=a*a%mod,s&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">16</span>][N&lt;&lt;<span class="number">1</span>],sum[<span class="number">16</span>][N&lt;&lt;<span class="number">1</span>],p[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">read</span>(n),<span class="built_in">read</span>(k),<span class="built_in">read</span>(f);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=k;i++)dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		NTT::<span class="built_in">init</span>(k,dp[i<span class="number">-1</span>],sum[i]);</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">2</span>*k;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i!=n)dp[i][j]=sum[i][j]*(k-j<span class="number">+1</span>)%mod;</span><br><span class="line">			<span class="keyword">else</span> dp[i][j]=sum[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i!=n)<span class="keyword">for</span>(j=<span class="number">2</span>*k<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;i!=n;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;=k)<span class="built_in">Inc</span>(dp[i][j],sum[i][j<span class="number">+1</span>]);</span><br><span class="line">			<span class="built_in">Inc</span>(sum[i][j],sum[i][j<span class="number">+1</span>]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;(dp[n][f]+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal 重构树和 LCA</title>
    <url>/2022/07/19/OI/%E7%AE%97%E6%B3%95/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91%E4%B8%8ELCA/</url>
    <content><![CDATA[<h2 id="cf1706-小总结">CF1706 小总结</h2>
<p>其实都会做，但是各种各样的原因导致了没在场上 AK</p>
<h3 id="abc">ABC</h3>
<p>A 题没考虑清楚就在写，WA 了一发样例，然后慢悠悠调好交上去过。</p>
<p>B 题愣了一会儿，弄了个伪 DP 上去，稍微有点磨蹭，但还好。</p>
<p>C 题做得无可挑剔。</p>
<h3 id="d">D</h3>
<p>D 题先想到可以枚举一个端点，二分另一个，<span
class="math inline">\(O(n)\)</span>
check，但是发现枚举一个端点之后，可以快速计算另一个端点的最优值，得到一个
<span class="math inline">\(O(n^2)\)</span> 的枚举 max 的做法过了
D1，然后感觉其实只需要查 <span class="math inline">\([\lfloor\frac{\max
a_i}{k}\rfloor,\lfloor\frac{\max a_i}{k}\rfloor+\sqrt N]\)</span> 和
<span class="math inline">\(\{\lfloor\frac{\max a_i}{x}\rfloor,x \le
k\}\)</span>，写好交上去过了 Pretests，但是 FST 了。</p>
<p>后面想到其实对 min 分类限制更多。暴力算 <span
class="math inline">\(\min \lfloor \frac{a_i}{k_i}\rfloor\in
[1,B]\)</span>，然后对于 <span class="math inline">\(\min \lfloor
\frac{a_i}{k_i}\rfloor\in(B,k]\)</span>，可以发现 <span
class="math inline">\(p_i\in
[1,\lceil\frac{10^5}{B}\rceil]\)</span>，考虑维护 max 的变化，可以用一个
vector 记一下 <span
class="math inline">\(\lfloor\frac{a_i}{p_i}\rfloor\)</span>
的所有可能，共 <span class="math inline">\(n\times
\lceil\frac{10^5}{B}\rceil\)</span> 种，因此对于 <span
class="math inline">\((B,k]\)</span>，<span
class="math inline">\(\lfloor\frac{a_i}{p_i}\rfloor\)</span>
的变化总量是 <span class="math inline">\(O(n\sqrt n)\)</span> 的。</p>
<p>换一种思路考虑，还是枚举 <span class="math inline">\(x\)</span>，令
<span class="math inline">\(\lfloor\frac{a_i}{p_i}\rfloor\le
x\)</span>，易知 <span
class="math inline">\(p_i\ge\lfloor\frac{a_i}{x+1}\rfloor+1\)</span>，考虑每一个
<span class="math inline">\(a_i\)</span> 的最好的 <span
class="math inline">\(p_i\)</span>，不太可行。但是发现上式中能取到的
<span class="math inline">\(p_i\)</span> 满足 <span
class="math inline">\(p_i\le\lfloor\frac{N}{x}\rfloor\)</span>
。于是考虑每一个 <span class="math inline">\(p_i\)</span> 可以让哪些
<span class="math inline">\(a_i\)</span>
值取到最优，这是一个区间。而我们要考虑的是
min，所以取区间中最小的计算就行。</p>
<p>对于一个 <span class="math inline">\(x\)</span>，区间个数是 <span
class="math inline">\(\frac{N}{x}\)</span> 的，因此总复杂度 <span
class="math inline">\(\sum\limits_{i=1}^N \frac{N}{i}=n\ln
n\)</span>。</p>
<h3 id="e">E</h3>
<p>E
题在考场上想到了可以类似整体二分的做，先给所有的二分，然后再合并一次，查询每一个询问是否可行。查询的维护可以
dsu on tree 带一个维护线段的 set，复杂度 <span
class="math inline">\(O(n\log^3n)\)</span>，感觉能信仰，就写了，可惜没交上去。赛后发现其实有些边界的小错，但是交了还是
TLE 了。告诉我们 set 操作搞个 <span class="math inline">\(10^7\)</span>
问题还是比较大。</p>
<p>后面发现可以将询问直接塞进 dsu
的过程中，但是处理询问只能处理较小的那一边，如果是小的合到大的上面去，此时询问挂在大的上面，会非常的恼火。于是就把询问拆到两个上面去，又发现可能两个询问会在合并时变成一个但是还没解决，所以合并的时候如果变成一个就又找了一个还没合并的把询问扔上去。</p>
<p>然后又 TLE 了，赛后仔细分析复杂度，发现不对劲，比如有个 <span
class="math inline">\(O(n)\)</span>
的点，然后又有个略小于它但主要是询问的点，然后合并的时候把询问全部扔到另一个点上去了，然后另一个点同这个
<span class="math inline">\(O(n)\)</span>
点合并的时候又把询问全部扔了，询问就扔了 <span
class="math inline">\(O(n^2)\)</span> 次，寄。</p>
<p>然后想到可以把线段合并的过程记下来，这个就是严格 <span
class="math inline">\(O(n\log n)\)</span>
级别了，后面做一个二维偏序回答询问。成功 AC。</p>
<p>其实 E 题和最近做的题都暴露出几个问题，思维模式僵化，没有办法 Think
out of box，同时代码中常常犯一些不容易注意到的小错误，依赖数据调试。</p>
<h3 id="sum-up">Sum up</h3>
<p>关于代码小错的问题，我觉得一边写一边静态查是一个比较理想的解决方案，<strong>先认真核实思路的正确性，再检查代码和思路是否一致</strong>，同时可以在关键点插入数据输出。</p>
<p>思维上的问题，估计还只有多做题。</p>
<h3 id="收获-1dsu-on-tree-的复杂度理解">收获 1：Dsu on tree
的复杂度理解</h3>
<p>Dsu on tree，复杂度证明的过程是这样的：考虑一个点的权值 <span
class="math inline">\(w_i\)</span>，当合并时，复杂度贡献为 <span
class="math inline">\(O(\min(w_u,w_v)\)</span>，将 <span
class="math inline">\(w_i\)</span> 视为 <span
class="math inline">\(w_i\)</span>
个元素。考虑每个元素的贡献次数，发现每个元素仅在其所在集合大小翻倍时贡献。所以复杂度正确。</p>
<p><strong>因此，权值的构成不影响其时间复杂度</strong></p>
<p>如果在合并的时候进行了额外的对 <span
class="math inline">\(w_i\)</span>
的修改，比如我的错误做法，时间复杂度就应该认真分析了。</p>
<h3 id="kruscal-重构树的应用和连通性">Kruscal 重构树的应用和连通性</h3>
<p>E 题可以用 Kruscal
重构树做，具体的，先做最小生成树，顺便合并点，现在一个连通块就是一个点，合并两个连通块时，新建一个点，点权为这条边的权值，作为被合并的两个点的父亲，任意两个点联通的时最小权值就是它们的
lca，然后区间 lca 应该都会。事实上甚至没有必要做区间 lca，我们考虑 <span
class="math inline">\(i,i+1\)</span> 什么时候联通，设其时间为 <span
class="math inline">\(f(i)\)</span>，可以发现 <span
class="math inline">\(ans(a,b)=\max\limits_{i\in[a,b)}
f(i)\)</span>，证明比较容易，首先必须取到这个值，否则必然有两个点不连通，其次，如果取到这个值，那么一定都联通，over
，复杂度 <span class="math inline">\(O(n\log n)\)</span></p>
<p>已经知道这个性质了，那么，将询问放到 dsu
合并过程中的方法也不难写了，合并时处理其中一个询问即可。</p>
<h3 id="lca-的一些性质">LCA 的一些性质</h3>
<p>从 2 中的性质，我们总结出了一些 LCA 的共有性质。</p>
<p>设树上一个点集为 <span class="math inline">\(S\)</span>，定义 <span
class="math inline">\(\operatorname{lca}(S)\)</span> 为点集 <span
class="math inline">\(S\)</span> 中所有点的最近公共祖先。定义符号 <span
class="math inline">\(\operatorname{lca}(a_1,a_2\cdots a_n)\)</span>
表示 <span class="math inline">\(\operatorname{lca}(\{a_1,a_2,\cdots
a_n\})\)</span>。</p>
<p><span class="math inline">\(\text{Lemma 1.1}\)</span></p>
<p><span class="math inline">\(\operatorname{lca}(S\cup
u)=\operatorname{lca}(\operatorname{lca}(S),u)\)</span></p>
<p><span class="math inline">\(\text{Proof 1.1}\)</span></p>
<p>若 <span class="math inline">\(\operatorname{lca}(S)\)</span> 为
<span class="math inline">\(u\)</span> 的祖先，则结论显然成立。</p>
<p>否则，<span class="math inline">\(u\)</span> 位于 <span
class="math inline">\(\operatorname{lca}(S)\)</span> 的子树外，<span
class="math inline">\(\operatorname{lca}(S\cup u)\)</span> 必须同时为
<span class="math inline">\(\operatorname{lca}(S)\)</span> 和 <span
class="math inline">\(u\)</span> 的祖先，故结论同样成立。</p>
<p><span class="math inline">\(\text{Theorem 1.2}\)</span></p>
<p>对于 <span
class="math inline">\(S=\{a_1,a_2\cdots,a_n\}\)</span>，满足 <span
class="math inline">\(\operatorname{lca}(S)\in
\bigcup\limits_{i=1}^{n-1}\operatorname{lca}(a_1,a_2)\)</span>。</p>
<p><span class="math inline">\(\text{Proof 1.2}\)</span></p>
<p>对 <span class="math inline">\(S\)</span> 集合大小归纳，设 <span
class="math inline">\(|S|=n\)</span>，且对于 <span
class="math inline">\(k\le n\)</span>，结论成立。</p>
<p>由 Lemma 1.1，有 <span class="math inline">\(\operatorname{lca}(S\cup
u) = \operatorname{lca}(\operatorname{lca}(S),u)\)</span>，</p>
<ul>
<li>若满足 <span class="math inline">\(\operatorname{lca}(S\cup
u)=\operatorname{lca}(S)\)</span>，对于 <span
class="math inline">\(S\cup u\)</span>，即 <span
class="math inline">\(|S&#39;|=n+1\)</span>，结论成立。</li>
<li>若不满足 <span class="math inline">\(\operatorname{lca}(S\cup
u)=\operatorname{lca}(S)\)</span>，记 <span
class="math inline">\(\operatorname{lca}(S)=w\)</span>，则有 <span
class="math inline">\(\forall a_i\in
S,\operatorname{lca}(a_i,u)=\operatorname{lca}(w,u)=\operatorname{lca}(S\cup
u)\)</span>，因此对于 <span
class="math inline">\(|S&#39;|=n+1\)</span>，结论仍然成立。</li>
</ul>
<p>证毕。</p>
<p><span class="math inline">\(\text{Lemma 2.1}\)</span></p>
<p>记 <span class="math inline">\(\operatorname{dfn}(u)\)</span> 表示
<span class="math inline">\(u\)</span> 的 dfs 序。</p>
<p>对三个元素 <span class="math inline">\(u,v,w\)</span> ，满足 <span
class="math inline">\(\operatorname{dfn}(u)&lt;\operatorname{dfn}(v)&lt;\operatorname{dfn}(w)\)</span>，有
<span
class="math inline">\(\operatorname{lca}(w,u,v)=\operatorname{lca}(u,w)\)</span>。</p>
<p><span class="math inline">\(\text{Proof 2.1}\)</span></p>
<p>由 Theorem 1.2，<span
class="math inline">\(\operatorname{lca}(u,v,w)\in\{\operatorname{lca}(u,v),\operatorname{lca}(u,w)\}\)</span>。</p>
<p>假设 <span
class="math inline">\(\operatorname{lca}(u,v,w)=\operatorname{lca}(u,v)\)</span>
并且 <span class="math inline">\(\operatorname{lca}(u,v)\neq
\operatorname{lca}(u,w)\)</span>。</p>
<p>记 <span class="math inline">\(x=\operatorname{lca}(u,v,w)\)</span>
。</p>
<p>因此 <span class="math inline">\(v\)</span> 和 <span
class="math inline">\(\operatorname{lca}(u,w)\)</span> 在 <span
class="math inline">\(x\)</span> 的不同子树。又有 <span
class="math inline">\(\operatorname{dfn}(v)&gt;\operatorname{dfn}(u)\)</span>，所以
<span class="math inline">\(u\)</span> 所在的 <span
class="math inline">\(x\)</span> 的子树先被访问，即 <span
class="math inline">\(\operatorname{lca}(u,w)\)</span> 所在的 <span
class="math inline">\(x\)</span> 的子树先被访问，因此 <span
class="math inline">\(\operatorname{dfn}(w)&lt;\operatorname{dfn}(v)\)</span>。矛盾，故假设不成立。</p>
<p>证毕。</p>
<p><span class="math inline">\(\text{Theorem 2.2}\)</span></p>
<p>对于序列 <span class="math inline">\(a\)</span>，若集合 <span
class="math inline">\(A=\{a_1,a_2\cdots a_{n}\}\)</span>，且满足 <span
class="math inline">\(\forall i\in
[1,n),\operatorname{dfn}(a_{i+1})&gt;\operatorname{dfn}(a_i)\)</span>，有
<span
class="math inline">\(\operatorname{lca}(a_1,a_n)=\operatorname{lca}(A)\)</span>。</p>
<p><span class="math inline">\(\text{Proof 2.2}\)</span></p>
<p>归纳证明，设对 <span class="math inline">\(k=n\)</span> 成立。</p>
<p>由 Theorem 1.2， <span class="math inline">\(\operatorname{lca}(A\cup
\{a_{n+1}\})=\operatorname{lca}(a_{n+1},\operatorname{lca}(A)\})\)</span>。</p>
<p>由 Lemma 2.1，Theorem 1.2，<span
class="math inline">\(\operatorname{lca}(\operatorname{lca}(A),a_{n+1})\operatorname{lca}(\operatorname{lca}(a_1,a_{n}),a_{n+1})=\operatorname{lca}(a_1,a_{n},a_{n+1})=\operatorname{lca}(a_1,a_{n+1})\)</span></p>
<p>因此定理对 <span class="math inline">\(k=n+1\)</span> 同样成立。</p>
<p>证毕。</p>
<p><span class="math inline">\(\text{Theorem 2.3}\)</span></p>
<p>对于序列 <span class="math inline">\(a\)</span>，若集合 <span
class="math inline">\(A=\{a_1,a_2\cdots a_{n}\}\)</span>，且满足 <span
class="math inline">\(\forall i\in
[1,n),\operatorname{dfn}(a_{i+1})&gt;\operatorname{dfn}(a_i)\)</span>。</p>
<p>有 <span class="math inline">\(\operatorname{lca}(a_1,a_n)\in
\bigcup\limits_{i=1}^{n-1}\{\operatorname{lca}(a_i,a_{i+1})\}\)</span>。</p>
<p><span class="math inline">\(\text{Proof 2.3}\)</span></p>
<p>由 Theorem 2.1 ，<span
class="math inline">\(\operatorname{lca}(a_1,a_n)=\operatorname{lca}(A)\)</span></p>
<p>由 Theorem 1.1，<span class="math inline">\(\operatorname{lca}(A) \in
\{\operatorname{lca}(a_i,a_{i+1}),i\in[1,n)\}\)</span>。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>对C++程序进行性能分析</title>
    <url>/2022/07/17/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E5%AF%B9C%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前情提要">前情提要</h2>
<p>某道题，某人写了，然后交了，然后过了，但跑的很慢。</p>
<p>某人卡了好几次常，都不行。</p>
<p>看了下跑得比较快的代码，其实没啥差别。</p>
<p>输出运行时间，发现没什么差异，所以某人要对程序做个性能分析。</p>
<p>性能分析本质上是运行了一遍程序，然后把占用大量时间的函数抓出来，对这个函数进行优化。</p>
<h2 id="在-windows-下使用-gprof-对程序进行性能分析">在 Windows 下使用
gprof 对程序进行性能分析</h2>
<p>gprof 是 g++ 自带的性能分析工具，简单易用，命令行中
<code>gprof --version</code> 查看是否可用，如果不行，先把
<code>g++</code> 添加进系统路径里，多半就可以了。</p>
<p>性能分析需要特殊的编译参数，格式为</p>
<p><code>g++ -pg demo.cpp -o demo</code></p>
<p>其它参数可以照常添加，但是不能开 <code>O2</code>
等性能优化，这会破坏掉程序结构。</p>
<p>然后运行程序，<strong>这一步必不可少。</strong></p>
<p><code>./demo</code></p>
<p><strong>不要使用其它IDE编译执行后的gmon.out文件进行性能分析,请在命令行使用以上命令编译运行后进行下面的操作</strong></p>
<p><code>gprof demo.exe gmon.out &gt; result.txt</code></p>
<p>这会生成性能数据到 result.txt 中，查看一下就行。</p>
<p><strong>最后一步中，.exe 不能省略</strong></p>
<p>给出一个性能数据的例子,例子中有详细的解释，我就不解释了</p>
<p><del>啥，看不懂英文？那就别学了。</del></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flat profile:</span><br><span class="line"></span><br><span class="line">Each sample counts as 0.01 seconds.</span><br><span class="line">  %   cumulative   self              self     total           </span><br><span class="line"> time   seconds   seconds    calls  ms/call  ms/call  name    </span><br><span class="line"> 17.14      0.06     0.06        3    20.00    74.92  NTT(num*, int)</span><br><span class="line"> 17.14      0.12     0.06                             _mcount_private</span><br><span class="line"> 14.29      0.17     0.05 14680064     0.00     0.00  num::num(int, int, int)</span><br><span class="line"> 14.29      0.22     0.05  7602174     0.00     0.00  num::operator*(num const&amp;)</span><br><span class="line"> 11.43      0.26     0.04  7077888     0.00     0.00  num::operator-(num const&amp;)</span><br><span class="line"> 11.43      0.30     0.04                             __fentry__</span><br><span class="line">  5.71      0.32     0.02  7077888     0.00     0.00  num::operator+=(num const&amp;)</span><br><span class="line">  2.86      0.33     0.01   392448     0.00     0.00  std::enable_if&lt;std::__and_&lt;std::__not_&lt;std::__is_tuple_like&lt;num&gt; &gt;, std::is_move_constructible&lt;num&gt;, std::is_move_assignable&lt;num&gt; &gt;::value, void&gt;::type std::swap&lt;num&gt;(num&amp;, num&amp;)</span><br><span class="line">  2.86      0.34     0.01   262144     0.00     0.00  num::operator*=(num const&amp;)</span><br><span class="line">  2.86      0.35     0.01                             main</span><br><span class="line">  0.00      0.35     0.00  1177344     0.00     0.00  std::remove_reference&lt;num&amp;&gt;::type&amp;&amp; std::move&lt;num&amp;&gt;(num&amp;)</span><br><span class="line">  0.00      0.35     0.00   149817     0.00     0.00  void read&lt;int&gt;(int&amp;)</span><br><span class="line">  0.00      0.35     0.00   149815     0.00     0.00  num::num(int)</span><br><span class="line">  0.00      0.35     0.00   149813     0.00     0.00  printf(char const*, ...)</span><br><span class="line">  0.00      0.35     0.00   149813     0.00     0.00  num::get()</span><br><span class="line">  0.00      0.35     0.00       16     0.00     0.00  quick(int, int, int, int)</span><br><span class="line"></span><br><span class="line"> %         the percentage of the total running time of the</span><br><span class="line">time       program used by this function.</span><br><span class="line"></span><br><span class="line">cumulative a running sum of the number of seconds accounted</span><br><span class="line"> seconds   for by this function and those listed above it.</span><br><span class="line"></span><br><span class="line"> self      the number of seconds accounted for by this</span><br><span class="line">seconds    function alone.  This is the major sort for this</span><br><span class="line">           listing.</span><br><span class="line"></span><br><span class="line">calls      the number of times this function was invoked, if</span><br><span class="line">           this function is profiled, else blank.</span><br><span class="line"></span><br><span class="line"> self      the average number of milliseconds spent in this</span><br><span class="line">ms/call    function per call, if this function is profiled,</span><br><span class="line">	   else blank.</span><br><span class="line"></span><br><span class="line"> total     the average number of milliseconds spent in this</span><br><span class="line">ms/call    function and its descendents per call, if this</span><br><span class="line">	   function is profiled, else blank.</span><br><span class="line"></span><br><span class="line">name       the name of the function.  This is the minor sort</span><br><span class="line">           for this listing. The index shows the location of</span><br><span class="line">	   the function in the gprof listing. If the index is</span><br><span class="line">	   in parenthesis it shows where it would appear in</span><br><span class="line">	   the gprof listing if it were to be printed.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2012-2018 Free Software Foundation, Inc.</span><br><span class="line"></span><br><span class="line">Copying and distribution of this file, with or without modification,</span><br><span class="line">are permitted in any medium without royalty provided the copyright</span><br><span class="line">notice and this notice are preserved.</span><br><span class="line"></span><br><span class="line">		     Call graph (explanation follows)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">granularity: each sample hit covers 4 byte(s) for 2.86% of 0.35 seconds</span><br><span class="line"></span><br><span class="line">index % time    self  children    called     name</span><br><span class="line">                                                 &lt;spontaneous&gt;</span><br><span class="line">[1]     71.4    0.01    0.24                 main [1]</span><br><span class="line">                0.06    0.16       3/3           NTT(num*, int) [2]</span><br><span class="line">                0.01    0.00  262144/262144      num::operator*=(num const&amp;) [10]</span><br><span class="line">                0.00    0.00  524286/7602174     num::operator*(num const&amp;) [3]</span><br><span class="line">                0.00    0.00       2/14680064     num::num(int, int, int) [6]</span><br><span class="line">                0.00    0.00  149817/149817      void read&lt;int&gt;(int&amp;) [96]</span><br><span class="line">                0.00    0.00  149815/149815      num::num(int) [97]</span><br><span class="line">                0.00    0.00  149813/149813      num::get() [99]</span><br><span class="line">                0.00    0.00  149813/149813      printf(char const*, ...) [98]</span><br><span class="line">                0.00    0.00      16/16          quick(int, int, int, int) [100]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.06    0.16       3/3           main [1]</span><br><span class="line">[2]     64.2    0.06    0.16       3         NTT(num*, int) [2]</span><br><span class="line">                0.05    0.02 7077888/7602174     num::operator*(num const&amp;) [3]</span><br><span class="line">                0.04    0.02 7077888/7077888     num::operator-(num const&amp;) [4]</span><br><span class="line">                0.02    0.00 7077888/7077888     num::operator+=(num const&amp;) [8]</span><br><span class="line">                0.01    0.00  392448/392448      std::enable_if&lt;std::__and_&lt;std::__not_&lt;std::__is_tuple_like&lt;num&gt; &gt;, std::is_move_constructible&lt;num&gt;, std::is_move_assignable&lt;num&gt; &gt;::value, void&gt;::type std::swap&lt;num&gt;(num&amp;, num&amp;) [9]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00  524286/7602174     main [1]</span><br><span class="line">                0.05    0.02 7077888/7602174     NTT(num*, int) [2]</span><br><span class="line">[3]     21.7    0.05    0.03 7602174         num::operator*(num const&amp;) [3]</span><br><span class="line">                0.03    0.00 7602174/14680064     num::num(int, int, int) [6]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.04    0.02 7077888/7077888     NTT(num*, int) [2]</span><br><span class="line">[4]     18.3    0.04    0.02 7077888         num::operator-(num const&amp;) [4]</span><br><span class="line">                0.02    0.00 7077888/14680064     num::num(int, int, int) [6]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                                                 &lt;spontaneous&gt;</span><br><span class="line">[5]     17.1    0.06    0.00                 _mcount_private [5]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00       2/14680064     main [1]</span><br><span class="line">                0.02    0.00 7077888/14680064     num::operator-(num const&amp;) [4]</span><br><span class="line">                0.03    0.00 7602174/14680064     num::operator*(num const&amp;) [3]</span><br><span class="line">[6]     14.3    0.05    0.00 14680064         num::num(int, int, int) [6]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                                                 &lt;spontaneous&gt;</span><br><span class="line">[7]     11.4    0.04    0.00                 __fentry__ [7]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.02    0.00 7077888/7077888     NTT(num*, int) [2]</span><br><span class="line">[8]      5.7    0.02    0.00 7077888         num::operator+=(num const&amp;) [8]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.01    0.00  392448/392448      NTT(num*, int) [2]</span><br><span class="line">[9]      2.9    0.01    0.00  392448         std::enable_if&lt;std::__and_&lt;std::__not_&lt;std::__is_tuple_like&lt;num&gt; &gt;, std::is_move_constructible&lt;num&gt;, std::is_move_assignable&lt;num&gt; &gt;::value, void&gt;::type std::swap&lt;num&gt;(num&amp;, num&amp;) [9]</span><br><span class="line">                0.00    0.00 1177344/1177344     std::remove_reference&lt;num&amp;&gt;::type&amp;&amp; std::move&lt;num&amp;&gt;(num&amp;) [95]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.01    0.00  262144/262144      main [1]</span><br><span class="line">[10]     2.9    0.01    0.00  262144         num::operator*=(num const&amp;) [10]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00 1177344/1177344     std::enable_if&lt;std::__and_&lt;std::__not_&lt;std::__is_tuple_like&lt;num&gt; &gt;, std::is_move_constructible&lt;num&gt;, std::is_move_assignable&lt;num&gt; &gt;::value, void&gt;::type std::swap&lt;num&gt;(num&amp;, num&amp;) [9]</span><br><span class="line">[95]     0.0    0.00    0.00 1177344         std::remove_reference&lt;num&amp;&gt;::type&amp;&amp; std::move&lt;num&amp;&gt;(num&amp;) [95]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00  149817/149817      main [1]</span><br><span class="line">[96]     0.0    0.00    0.00  149817         void read&lt;int&gt;(int&amp;) [96]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00  149815/149815      main [1]</span><br><span class="line">[97]     0.0    0.00    0.00  149815         num::num(int) [97]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00  149813/149813      main [1]</span><br><span class="line">[98]     0.0    0.00    0.00  149813         printf(char const*, ...) [98]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00  149813/149813      main [1]</span><br><span class="line">[99]     0.0    0.00    0.00  149813         num::get() [99]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00      16/16          main [1]</span><br><span class="line">[100]    0.0    0.00    0.00      16         quick(int, int, int, int) [100]</span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"> This table describes the call tree of the program, and was sorted by</span><br><span class="line"> the total amount of time spent in each function and its children.</span><br><span class="line"></span><br><span class="line"> Each entry in this table consists of several lines.  The line with the</span><br><span class="line"> index number at the left hand margin lists the current function.</span><br><span class="line"> The lines above it list the functions that called this function,</span><br><span class="line"> and the lines below it list the functions this one called.</span><br><span class="line"> This line lists:</span><br><span class="line">     index	A unique number given to each element of the table.</span><br><span class="line">		Index numbers are sorted numerically.</span><br><span class="line">		The index number is printed next to every function name so</span><br><span class="line">		it is easier to look up where the function is in the table.</span><br><span class="line"></span><br><span class="line">     % time	This is the percentage of the `total&#x27; time that was spent</span><br><span class="line">		in this function and its children.  Note that due to</span><br><span class="line">		different viewpoints, functions excluded by options, etc,</span><br><span class="line">		these numbers will NOT add up to 100%.</span><br><span class="line"></span><br><span class="line">     self	This is the total amount of time spent in this function.</span><br><span class="line"></span><br><span class="line">     children	This is the total amount of time propagated into this</span><br><span class="line">		function by its children.</span><br><span class="line"></span><br><span class="line">     called	This is the number of times the function was called.</span><br><span class="line">		If the function called itself recursively, the number</span><br><span class="line">		only includes non-recursive calls, and is followed by</span><br><span class="line">		a `+&#x27; and the number of recursive calls.</span><br><span class="line"></span><br><span class="line">     name	The name of the current function.  The index number is</span><br><span class="line">		printed after it.  If the function is a member of a</span><br><span class="line">		cycle, the cycle number is printed between the</span><br><span class="line">		function&#x27;s name and the index number.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> For the function&#x27;s parents, the fields have the following meanings:</span><br><span class="line"></span><br><span class="line">     self	This is the amount of time that was propagated directly</span><br><span class="line">		from the function into this parent.</span><br><span class="line"></span><br><span class="line">     children	This is the amount of time that was propagated from</span><br><span class="line">		the function&#x27;s children into this parent.</span><br><span class="line"></span><br><span class="line">     called	This is the number of times this parent called the</span><br><span class="line">		function `/&#x27; the total number of times the function</span><br><span class="line">		was called.  Recursive calls to the function are not</span><br><span class="line">		included in the number after the `/&#x27;.</span><br><span class="line"></span><br><span class="line">     name	This is the name of the parent.  The parent&#x27;s index</span><br><span class="line">		number is printed after it.  If the parent is a</span><br><span class="line">		member of a cycle, the cycle number is printed between</span><br><span class="line">		the name and the index number.</span><br><span class="line"></span><br><span class="line"> If the parents of the function cannot be determined, the word</span><br><span class="line"> `&lt;spontaneous&gt;&#x27; is printed in the `name&#x27; field, and all the other</span><br><span class="line"> fields are blank.</span><br><span class="line"></span><br><span class="line"> For the function&#x27;s children, the fields have the following meanings:</span><br><span class="line"></span><br><span class="line">     self	This is the amount of time that was propagated directly</span><br><span class="line">		from the child into the function.</span><br><span class="line"></span><br><span class="line">     children	This is the amount of time that was propagated from the</span><br><span class="line">		child&#x27;s children to the function.</span><br><span class="line"></span><br><span class="line">     called	This is the number of times the function called</span><br><span class="line">		this child `/&#x27; the total number of times the child</span><br><span class="line">		was called.  Recursive calls by the child are not</span><br><span class="line">		listed in the number after the `/&#x27;.</span><br><span class="line"></span><br><span class="line">     name	This is the name of the child.  The child&#x27;s index</span><br><span class="line">		number is printed after it.  If the child is a</span><br><span class="line">		member of a cycle, the cycle number is printed</span><br><span class="line">		between the name and the index number.</span><br><span class="line"></span><br><span class="line"> If there are any cycles (circles) in the call graph, there is an</span><br><span class="line"> entry for the cycle-as-a-whole.  This entry shows who called the</span><br><span class="line"> cycle (as parents) and the members of the cycle (as children.)</span><br><span class="line"> The `+&#x27; recursive calls entry shows the number of function calls that</span><br><span class="line"> were internal to the cycle, and the calls entry for each member shows,</span><br><span class="line"> for that member, how many times it was called from other members of</span><br><span class="line"> the cycle.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2012-2018 Free Software Foundation, Inc.</span><br><span class="line"></span><br><span class="line">Copying and distribution of this file, with or without modification,</span><br><span class="line">are permitted in any medium without royalty provided the copyright</span><br><span class="line">notice and this notice are preserved.</span><br><span class="line"></span><br><span class="line">Index by function name</span><br><span class="line"></span><br><span class="line">   [2] NTT(num*, int)          [6] num::num(int, int, int) [9] std::enable_if&lt;std::__and_&lt;std::__not_&lt;std::__is_tuple_like&lt;num&gt; &gt;, std::is_move_constructible&lt;num&gt;, std::is_move_assignable&lt;num&gt; &gt;::value, void&gt;::type std::swap&lt;num&gt;(num&amp;, num&amp;)</span><br><span class="line">  [96] void read&lt;int&gt;(int&amp;)   [10] num::operator*=(num const&amp;) [7] __fentry__</span><br><span class="line"> [100] quick(int, int, int, int) [4] num::operator-(num const&amp;) [5] _mcount_private</span><br><span class="line">  [98] printf(char const*, ...) [3] num::operator*(num const&amp;) [1] main</span><br><span class="line">  [99] num::get()              [8] num::operator+=(num const&amp;)</span><br><span class="line">  [97] num::num(int)          [95] std::remove_reference&lt;num&amp;&gt;::type&amp;&amp; std::move&lt;num&amp;&gt;(num&amp;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="vtune">VTune</h2>
<p>一个更厉害的性能分析工具，可以分析 CPU
流水线利用率和高速缓存命中率等进一步性能。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC144D与组合恒等式</title>
    <url>/2022/07/17/OI/%E7%AE%97%E6%B3%95/%E4%B8%8E%E7%BB%84%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="arc144d">ARC144D</h2>
<p>题意略。</p>
<p>观察，发现 <span class="math inline">\(x \&amp; y + x |y =
x+y\)</span>，原因是每个二进制位，如果出现两次，会计入二次，如果出现一次，会计入一次。猜想
<span class="math inline">\(f(x)\)</span>
的值与每个二进制位相关且对于每个二进制位独立。</p>
<p>考虑证明，对 <span class="math inline">\(x\)</span> 的二进制下 <span
class="math inline">\(1\)</span> 的个数 <span
class="math inline">\(n\)</span> 做归纳。</p>
<p>对于 <span class="math inline">\(n=0\)</span>，<span
class="math inline">\(f(0)=f(0)\)</span></p>
<p>对于 <span class="math inline">\(n=1\)</span>，<span
class="math inline">\(f(2^i) = f(2^i)\)</span></p>
<p>对于 <span class="math inline">\(n=2\)</span>，<span
class="math inline">\(f(2^i+2^j) + f(0) = f(2^i) +f(2^j)\)</span></p>
<p>考虑证明 <span class="math inline">\(n=k\)</span> 时， <span
class="math inline">\(f(x) +(k-1)f(0) = \sum\limits_{i\in x}
f(2^i)\)</span></p>
<p>设对于 <span class="math inline">\(n=k-1\)</span>
其成立，对于二进制位 1 个数为 k 的 x， <span
class="math inline">\(\forall i\in x,f(x)+f(0)=f(x-2^i) +
f(2^i)\)</span>，易证 <span class="math inline">\(f(x) +(k-1)f(0) =
\sum\limits_{i\in x} f(2^i)\)</span>，且对于所有涉及元素二进制下 1
个数少于 n 的，所有限制满足。</p>
<p>故只需要确定 <span class="math inline">\(f(2^i)\)</span> 和 <span
class="math inline">\(f(0)\)</span>。其最终限制有两个，其一是，最大值不能超过
<span class="math inline">\(k\)</span>，其二是最小值不能小于
0，最大值一定是把所有大于 <span class="math inline">\(f(0)\)</span>
的元素加起来，最小值则是把所有小于 <span
class="math inline">\(f(0)\)</span> 的元素加起来。</p>
<p>枚举 <span class="math inline">\(f(0)\)</span> 和小于 <span
class="math inline">\(f(0)\)</span>
的元素个数，我们可以将限制分配给对应元素 ，得到和式： <span
class="math display">\[
ans=\sum\limits_{f(0)=0}^{k}\sum\limits_{i=0}^{n}\binom{n}{i}\binom{f(0)}{i}\binom{k-f(0)+n-i}{n-i}
\]</span> 第一项计算那些小于 <span
class="math inline">\(f(0)\)</span>，第二项是将<strong>至多</strong>
<span class="math inline">\(k\)</span> 个冗余值分配给 <span
class="math inline">\(i\)</span> 个小于 <span
class="math inline">\(f(0)\)</span>
的元素的方案数，每个元素至少分配一个，或者说 <span
class="math inline">\(i\)</span> 个正整数变量和为 <span
class="math inline">\(f(0)\)</span>
的方案，可以给一个虚拟元素分别大于等于 0
个表示放弃，所以先给虚拟元素一个，变成 <span
class="math inline">\(f(0)+1\)</span> 个元素插 <span
class="math inline">\(i\)</span> 个板。最后一项是 <span
class="math inline">\(n-i\)</span> 个非负整数变量，和不超过 <span
class="math inline">\(k-f(0)\)</span>
的方案。先来个虚拟变量，然后先各自加 <span
class="math inline">\(1\)</span>，然后就是 <span
class="math inline">\(k-f(0)+n-i+1\)</span> ，间隔是 <span
class="math inline">\(k-f(0)+n-i\)</span> 个，版一共 <span
class="math inline">\(n\)</span> 个。</p>
<p>解释完了，考虑计算，二维的，算不了。</p>
<p>考虑后两项的组合意义。</p>
<p>根据组合恒等式中的第五个。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/ewpo1rn4.png" /></p>
<p>对原式变形有 <span class="math display">\[
ans=\sum\limits_{i=0}^{n}\binom{n}{i}\binom{k-f(0)+n-i+1}{n-i+1}
\]</span> 然后 <span class="math inline">\(n\)</span>
不大，维护个区间乘积枚举计算就行，记得对计算乘积的元素取模。</p>
<h2 id="组合恒等式">组合恒等式</h2>
<p>题不是终点，组合恒等式才是重点</p>
<p>对上面那种图的组合恒等式，我们一一证明</p>
<h3 id="式子1">式子1</h3>
<p><span class="math display">\[
\sum\limits_{k}\binom{r}{m+k}\binom{s}{n-k}=\binom{r+s}{m+n}
\]</span></p>
<h4 id="组合意义证明">组合意义证明</h4>
<p>第一项是从 <span class="math inline">\(r\)</span> 个选 <span
class="math inline">\(m+k\)</span> 个，第二项是从 <span
class="math inline">\(s\)</span> 个选 <span
class="math inline">\(n-k\)</span> 个，把两个拼在一起，从 <span
class="math inline">\(r+s\)</span> 个中选 <span
class="math inline">\(n+m\)</span>
个，容易发现和前者一一对应，故恒等。</p>
<h4 id="代数证明">代数证明</h4>
<p>咕咕咕</p>
<h3 id="式子2">式子2</h3>
<p><span class="math display">\[
\sum\limits_{k}\binom{l}{m+k}\binom{s}{n+k} = \binom{l+s}{l-m+n},l\ge0
\]</span></p>
<h4 id="组合意义证明-1">组合意义证明</h4>
<h4 id="代数证明-1">代数证明</h4>
<p>咕咕咕</p>
<h3 id="式子3">式子3</h3>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>2022.7.5考试总结</title>
    <url>/2022/07/12/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0705%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="t1">T1</h2>
<p><a href="https://haltoj.top/d/haoba/p/224">T1</a></p>
<h3 id="某个不太正确的方式">某个不太正确的方式</h3>
<p>想到了分块，暴力没操过去。</p>
<p>考虑暴力计算出前 <span class="math inline">\(\sqrt P\)</span>
个数的值，期望得到的最大值为 <span class="math inline">\(P-\sqrt
P\)</span>，剩下来的数一定不多，我的想法是分块探测一下下一个块中是否存在比当前最大值更大的数，探测方式是用个
<span class="math inline">\(\text{hash\_table}\)</span>
记录下每块的每个数的方幂，然后把等式左边乘上逆元后再查找，但是这个做法只有
<span class="math inline">\(60pts\)</span>，虽然我本机能跑过。</p>
<p>后面想了一下还看了下代码，这个方式的复杂度是错的，因为探测总次数还是不对头。2022.10.7</p>
<h3 id="正常的考虑方式">正常的考虑方式</h3>
<p>发现我们对同一个数的探测次数有点多，考虑能不能对一个数只探测一次。本质上是需要求
<span class="math inline">\(P-1,P-2,\cdots P - \sqrt P\)</span>
这些数在数列中出现的第一个位置。我们的探测实际上是判断了一个幂函数的解是否存在于一个区间。所以直接考虑求解这个幂函数方程
<span class="math inline">\(x^r = a\)</span>。</p>
<p>考虑 <span class="math inline">\(BSGS\)</span>，但是需要解 <span
class="math inline">\(T\times \sqrt{P}\)</span> 次，每次的复杂度为 <span
class="math inline">\(O(\sqrt P)\)</span>，不如暴力。</p>
<p>考虑平衡复杂度，设暴力处理的长度为 <span
class="math inline">\(S\)</span>，<span
class="math inline">\(BSGS\)</span> 预处理长度为 <span
class="math inline">\(B\)</span>，那么复杂度为 $T(S+ + B) $</p>
<p>后面那一坨最优应该是 <span class="math inline">\(3e6\)</span>
，压力山大。</p>
<p>发现质数是同一个质数，有没有什么办法可以优化一下。</p>
<p>答案是，处理离散对数。</p>
<p>离散对数有着和正常对数一样优美的换底公式，如果我们对 <span
class="math inline">\(x,P-1,P-2\cdots P-\sqrt P\)</span>。向 <span
class="math inline">\(P\)</span> 的原根 <span
class="math inline">\(g\)</span>，取对数，那么可以利用换底公式很方便的求解
<span class="math inline">\(x^r = a\)</span>，取对数的过程就是 <span
class="math inline">\(BSGS\)</span>，注意到换底公式的除法变成了模 <span
class="math inline">\(P-1\)</span> 意义下的除法，因为 <span
class="math inline">\(g^{P-1} = 1\)</span>。</p>
<p>所以 <span class="math inline">\(BSGS\)</span> 的总次数变为了 <span
class="math inline">\(O(\frac{P}{S})\)</span>
次，预处理只需要一次。这里可以放开玩。</p>
<p>总复杂度变为了 <span class="math inline">\(O(T*(S+\frac{P}{S})+ B  +
\frac{P}{S}\times\frac{P}{B})\)</span></p>
<p>取 <span class="math inline">\(B = P^{\frac{3}{4}}\)</span>，<span
class="math inline">\(S=\sqrt P\)</span> 可以取到最优。</p>
<p>我实现的时候写的比较丑，算了每个东西的位置之后，还需要排个序，实际上从大到小倒着做就可以了。</p>
<p>看看佳老师的代码，长进不少。</p>
<h2 id="t2">T2</h2>
<p><a href="https://haltoj.top/d/haoba/p/224">T2</a></p>
<p>定义字符串的 border 为一个它的前缀，这个前缀也是它的后缀。</p>
<p>场上是只会 <span class="math inline">\(O(n^2)\)</span> 的，还 TM
暴力打挂了只有 40。</p>
<p>后面了解到可以用 FFT 处理带通配符的字符串匹配问题。</p>
<p>具体的，定义距离函数 <span
class="math inline">\(d_i=\sum\limits_{j=1}^{m}
s_{i+j-1}t_i(s_{i+j-1}-t_j)^2\)</span></p>
<p>显然，如果距离 <span class="math inline">\(d_i\)</span> 为 <span
class="math inline">\(0\)</span>，那么 <span
class="math inline">\(i\)</span> 开头的字符串就能匹配上。</p>
<p>下标有点问题，所以把 <span class="math inline">\(t\)</span>
反转一下，把式子拆了，就是三遍 FFT 求出来每一个 <span
class="math inline">\(d_i\)</span>。</p>
<p>我们就知道了哪些结束位置可能可以匹配上。</p>
<p>不是所有能匹配上的位置一定可以对答案贡献，因为如果前面的匹配上了，通配符就没了，所以后面要匹配上，就要求重叠的部分必须是一个
border。</p>
<p>其实 border 在字符串随机的情况下是很少的。我们可以考虑记录下所有的
border，然后 dp，设 dp[i] 表示强制 i
结尾匹配上了，最多能匹配的个数，如果 <span class="math inline">\(j\leq
i-m\)</span>，就是个前缀 max，如果 <span class="math inline">\(j&gt;
i-m\)</span>，就只有 border 能转移。</p>
<p>border 有个性质，就是它们的长度构成 <span class="math inline">\(\log
n\)</span> 个等差数列，所以我们考虑对每个等差数列做转移。</p>
<p>更具体的，如果 <span
class="math inline">\(next[n]&gt;\frac{n}{2}\)</span>，那么模板串一定是一个循环，并且最小循环长度为
<span class="math inline">\(n-next[n]\)</span>，它的长度大于等于 <span
class="math inline">\(r=n\%(n-next[n])\)</span> 的 border
一定构成一个公差为 <span class="math inline">\(d=n-next[n]\)</span>
的等差数列。这样的话，<span class="math inline">\(n\)</span>
每次至少减半，所以至多有 <span class="math inline">\(\log n\)</span>
个等差数列。</p>
<p>考虑证明。如果存在一个长度大于 <span class="math inline">\(r\)</span>
的 border <span class="math inline">\(x\)</span> 长度不能写成 <span
class="math inline">\(kd+r\)</span>，感性理解下，把原串划分为长度为
<span class="math inline">\(d\)</span> 的小串，把 <span
class="math inline">\(x\)</span>
在末尾的部分平移到开头，显然它还有一个更小的循环。</p>
<p>所以我们对于一个点，含 border 的转移就可以分为 <span
class="math inline">\(\log n\)</span> 类，对每一类记一个前缀 <span
class="math inline">\(\max\)</span>
即可转移，注意每一类需要按照模公差分类。</p>
<p>注意转移细节。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">comple</span>&#123;</span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line">	comple <span class="keyword">operator</span> +(<span class="type">const</span> comple &amp;a)&#123;<span class="keyword">return</span> comple&#123;x+a.x,y+a.y&#125;;&#125;</span><br><span class="line">	comple <span class="keyword">operator</span> -(<span class="type">const</span> comple &amp;a)&#123;<span class="keyword">return</span> comple&#123;x-a.x,y-a.y&#125;;&#125;</span><br><span class="line">	comple <span class="keyword">operator</span> *(<span class="type">const</span> comple &amp;a)&#123;<span class="keyword">return</span> comple&#123;x*a.x-y*a.y,x*a.y+y*a.x&#125;;&#125;</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span> +=(<span class="type">const</span> comple &amp;a)&#123;x+=a.x,y+=a.y;&#125;</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span> -=(<span class="type">const</span> comple &amp;a)&#123;x-=a.x,y-=a.y;&#125;</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span> *=(<span class="type">const</span> comple &amp;a)&#123;<span class="type">double</span> tp=x;x=x*a.x-y*a.y,y=tp*a.y+y*a.x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,lim,ans;</span><br><span class="line"><span class="type">int</span> res[N],vala[N],valb[N],sum[N],nxt[N];</span><br><span class="line"><span class="type">int</span> dp[N],border[N][<span class="number">2</span>],pre[<span class="number">32</span>][N][<span class="number">2</span>],from[N];</span><br><span class="line"><span class="type">char</span> ch[N],str[N];</span><br><span class="line"><span class="type">double</span> d[N];</span><br><span class="line">comple a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(comple val[],<span class="type">int</span> type=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;lim;i++)<span class="keyword">if</span>(res[i]&gt;i)<span class="built_in">swap</span>(val[res[i]],val[i]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1</span>&lt;&lt;lim;j+=<span class="number">1</span>&lt;&lt;i)&#123;</span><br><span class="line">			comple w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,wn=&#123;<span class="built_in">cos</span>(<span class="number">2</span>*Pi/(<span class="number">1</span>&lt;&lt;i)),type*<span class="built_in">sin</span>(<span class="number">2</span>*Pi/(<span class="number">1</span>&lt;&lt;i))&#125;;</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>;k++,w*=wn)&#123;</span><br><span class="line">				comple y=val[k+j+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]*w;</span><br><span class="line">				val[k+j+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]=val[k+j]-y,val[k+j]+=y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(type==<span class="number">-1</span>)<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;lim;i++)c[i].x/=(<span class="number">1</span>&lt;&lt;lim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_border</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">	border[++s][<span class="number">0</span>]=nxt[x],border[s][<span class="number">1</span>]=x-nxt[x];</span><br><span class="line">	<span class="keyword">if</span>(nxt[x]*<span class="number">2</span>&gt;x)<span class="built_in">get_border</span>(x%(x-nxt[x]));</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">get_border</span>(nxt[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> lst)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dp[pos]==<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>,j=pos-m<span class="number">+1</span>;i&lt;=m&amp;&amp;j&lt;lst;i++,j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch[j]!=<span class="string">&#x27;?&#x27;</span>&amp;&amp;ch[j]!=str[i])&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j&lt;<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">		ch[j]=str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(from[pos],pos-m<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;match.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;match.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,ch<span class="number">+1</span>,str<span class="number">+1</span>);</span><br><span class="line">	n=<span class="built_in">strlen</span>(ch<span class="number">+1</span>),m=<span class="built_in">strlen</span>(str<span class="number">+1</span>);</span><br><span class="line">	nxt[<span class="number">0</span>]=j=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;str[j<span class="number">+1</span>]!=str[i])j=nxt[j];</span><br><span class="line">		nxt[i]=++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">get_border</span>(m);border[s][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>&lt;&lt;lim&lt;=n+m)lim++;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;lim;i++)res[i]=res[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>|(i&amp;<span class="number">1</span>)&lt;&lt;lim<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)vala[i]=ch[i]==<span class="string">&#x27;?&#x27;</span>?<span class="number">0</span>:ch[i]-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>,sum[i]=sum[i<span class="number">-1</span>]+vala[i]*vala[i]*vala[i];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)valb[i]=str[i]-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)a[i]=&#123;<span class="built_in">pow</span>(vala[i],<span class="number">2</span>)&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)b[i]=&#123;<span class="number">-2</span>*valb[m-i<span class="number">+1</span>]&#125;;</span><br><span class="line">	<span class="built_in">FFT</span>(a),<span class="built_in">FFT</span>(b);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;lim;i++)c[i]+=a[i]*b[i];</span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a)),<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)a[i]=&#123;vala[i]&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)b[i]=&#123;<span class="built_in">pow</span>(valb[m-i<span class="number">+1</span>],<span class="number">2</span>)&#125;;</span><br><span class="line">	<span class="built_in">FFT</span>(a),<span class="built_in">FFT</span>(b);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;lim;i++)c[i]+=a[i]*b[i];</span><br><span class="line">	<span class="built_in">FFT</span>(c,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=m;i&lt;=n;i++)</span><br><span class="line">	d[i]=sum[i]-sum[i-m]+c[i<span class="number">+1</span>].x;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=m;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=s;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(pre[j][i-m+border[j][<span class="number">0</span>]][<span class="number">0</span>]<span class="number">+1</span>&gt;dp[i])&#123;</span><br><span class="line">				dp[i]=pre[j][i-m+border[j][<span class="number">0</span>]][<span class="number">0</span>]<span class="number">+1</span>;</span><br><span class="line">				from[i]=pre[j][i-m+border[j][<span class="number">0</span>]][<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(d[i])&gt;<span class="number">0.1</span>)dp[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=s;j++)&#123;</span><br><span class="line">			pre[j][i][<span class="number">0</span>]=dp[i],pre[j][i][<span class="number">1</span>]=i;</span><br><span class="line">			<span class="keyword">if</span>(pre[j][i-border[j][<span class="number">1</span>]][<span class="number">0</span>]&gt;pre[j][i][<span class="number">0</span>])&#123;</span><br><span class="line"></span><br><span class="line">				pre[j][i][<span class="number">0</span>]=pre[j][i-border[j][<span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">				pre[j][i][<span class="number">1</span>]=pre[j][i-border[j][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dp[i]&gt;dp[ans])ans=i;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[ans]&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">print</span>(ans,ans<span class="number">+1</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;?&#x27;</span>)ch[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout&lt;&lt;ch<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>多项式</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 一些强调的东西</title>
    <url>/2022/07/12/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/Python%20%E4%B8%80%E4%BA%9B%E5%BC%BA%E8%B0%83%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
    <content><![CDATA[<h2 id="pip-和包">pip 和包</h2>
<h3 id="网络问题">网络问题</h3>
<p>GFW 会墙掉默认的 pip 源, 所以请使用国内源.</p>
<p><strong>不建议使用代理连接国外源.</strong></p>
<p>使用国内源时一些注意事项:</p>
<ul>
<li><p><strong>彻底关闭代理软件</strong>(退出软件, 关 System Proxy
没用), 并检查系统代理设置, 确认没有设置代理端口. 由它引起的报错:</p>
<ul>
<li>SSL 错误(报错大概长下面这样), 国内源不允许代理连接, 用的 TLS 方式,
代理的 SSL 证书通不过验证.</li>
</ul>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLEOFError(8, &#x27;[SSL: UNEXPECTED_EOF_WHILE_READING] EOF occurred in violation of protocol (_ssl.c:1000)&#x27;))&#x27;: /simple/proxyscrape/</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Proxy 连接错误(报错大概长下面这样). 原因是命令行代理没有配置好, 但是
pip 检测到了系统有代理尝试使用.</li>
</ul>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;ProxyError(&#x27;Cannot connect to proxy.&#x27;, timeout(&#x27;_ssl.c:1091: The handshake operation timed out&#x27;))&#x27;: /simple/pandas/</span><br></pre></td></tr></table></figure></p></li>
<li><p>清华源同步很慢, 速度不稳定, 建议使用阿里云源,
命令行执行(永久设置):</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">pip config set global.trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p></li>
<li><p>检查全局源设置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip config list</span><br></pre></td></tr></table></figure>
<p>输出应该是: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global.index-url=&#x27;https://mirrors.aliyun.com/pypi/simple&#x27;</span><br><span class="line">install.trusted-host=&#x27;mirrors.aliyun.com&#x27;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="虚拟环境">虚拟环境</h3>
<p>Python 包各种包的有复杂的版本依赖关系, 把所有包装在一起不可取.</p>
<p>建议安装个 anaconda 创建虚拟环境, 然后在虚拟环境里安装包.</p>
<p>anaconda <a
href="https://zhuanlan.zhihu.com/p/75717350?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=940926592332066816">安装教程</a>.</p>
<p>额外提几个注意:</p>
<ul>
<li><p>安装 conda 前, 应该<strong>彻底卸载</strong>之前安装的 Python,
直接用卸载功能不会删除 pip 相关的包, 正确的卸载方式:</p>
<ol type="1">
<li><p>找到并记住安装路径.</p></li>
<li><p>用卸载程序(就是安装包)卸载.</p></li>
<li><p>彻底删除安装路径.</p></li>
</ol></li>
<li><p>第一次安装 conda 完成后, 必须在终端执行 <code>conda init</code>
命令使 conda 生效.</p></li>
</ul>
<h3 id="局部环境">局部环境</h3>
<p>虚拟环境本质上就是建立了若干个局部环境,
并使用一个全局的管理工具来管理这些局部环境.</p>
<p>所以也可以直接建立局部环境, Python 的标准库有个 venv,
就是用局部环境来做虚拟环境的.</p>
<p>局部环境也可以用安装包安装, <strong>不要勾选添加系统路径</strong>,
然后自定义安装路径就能安装 Windows 的 Python 局部环境.</p>
<p>Linux 下安装 Python 局部环境</p>
<p>用局部环境的路径去运行 pip, Python 时,
所有操作都会在这个局部环境里执行, 与全局环境无关.</p>
<p>理论上这个东西在制作傻瓜式软件的时候有一定作用, 但根据我的经验,
虽然可能全国有 1% 的人会 Python, 但全国只有 0.1% 的人能够正确安装小众的
Python 第三方库, 所以还是很有用的.</p>
<p><del>上周见到两个 conda 装了不 init 的胎神.</del></p>
<h2 id="import">import</h2>
<h3 id="name"><strong>name</strong></h3>
<p><code>__name__</code> 是 Python 的一个内置变量,
用于判断当前文件是否被<strong>直接运行</strong>.</p>
<p>用 <code>python xxx.py</code> 直接运行, <code>__name__</code> 为
"<strong>main</strong>".</p>
<p>用 <code>python -m xxx</code> 间接运行, <code>__name__</code>
为<strong>模块名</strong>.</p>
<h3 id="import-包时的执行逻辑">import 包时的执行逻辑</h3>
<p>用 import 或者 from 导入模块时,
对应模块代码会被原封不动的全部执行一遍, 执行时, 被 import 的代码中
<code>__name__</code> 为 <strong>模块名</strong>.</p>
<h3 id="import-寻找顺序">import 寻找顺序</h3>
<p>有一个 <code>sys.path</code> 变量, 里面存着一些路径, 用于寻找模块.
这玩意是个列表, 从前往后依次寻找, 找到就开始导入, 顺序大概这样: 1.
在工作目录下寻找(绝对或相对导入). 2. 在 <code>site-packages</code>
目录下寻找(仅绝对导入).</p>
<h3 id="莫名其妙的-id-不一致问题">莫名其妙的 id 不一致问题</h3>
<p>有时候, 你手动加了 <code>sys.path</code> 后, 导入时全局变量可能会出现
id 不一致的问题, 讲下原因:</p>
<ul>
<li><p>ma 模块假设在 <code>module/ma.py</code> 里.</p></li>
<li><p><code>a.py</code> 代码用 <code>module.ma</code> 导入了
<code>ma</code> 模块的一个全局变量 <code>g</code>.</p></li>
<li><p>往 <code>sys.path</code> 里加了 <code>module</code>
这个目录.</p></li>
<li><p><code>module/b.py</code> 代码中用 <code>ma</code> 导入了
<code>ma</code> 模块的全局变量 <code>g</code>.</p></li>
<li><p><code>a.py</code> 和 <code>b.py</code> 里 <code>g</code> 的 id
不一致.</p></li>
</ul>
<p>所以别问为啥全局变量修改无效了.</p>
<p>从不同目录下(<code>sys.path</code>值不同)导入同一个文件时,
被导入的模块代码有不同的 id, 所以里面的东西也有两份.</p>
<p><strong>无特殊需求, 只建议项目使用绝对导入.</strong></p>
<h3 id="import-的代码到底执行了几遍">import 的代码到底执行了几遍</h3>
<p>用同一个 <code>sys.path</code> 量导入的模块代码只会执行一遍,
第一次执行后被加进 cache 里了, 第二次 import 时发现 cache 里有就直接用
cache 里的了, 不执行第二次.</p>
<h2 id="pypi">PYPI</h2>
<p>PYPI 打包发布的时候, 如果文件夹没有 <code>__init__.py</code> 文件,
那么这个文件夹会扔掉打包不进去.</p>
<h2 id="关于-request-这一类网络请求函数">关于 Request
这一类网络请求函数</h2>
<p>Request 爬虫的时代已经过去了, 现在用 selenium 吧.</p>
<p>当然如果直接最简单的 Request 没出问题也不妨试试.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有用的命令</title>
    <url>/2022/07/12/%E6%8A%80%E6%9C%AF/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="设置-pip-默认下载源">设置 pip 默认下载源</h4>
<p><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 安装踩坑记录</title>
    <url>/2022/07/12/%E6%8A%80%E6%9C%AF/%E7%94%9F%E4%BA%A7%E5%8A%9B/Hexo-NexT%20%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="博客部署">博客部署</h2>
<p><a href="https://zhuanlan.zhihu.com/p/618864711">参考</a></p>
<h3 id="环境">环境</h3>
<h4 id="基础">基础</h4>
<ul>
<li>git</li>
<li>nodejs &amp;&amp; npm</li>
</ul>
<h4 id="开工作目录">开工作目录</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p><strong>工作目录</strong>是
<code>blog</code>，记住，这很重要，文件名默认为相对工作目录的名字。</p>
<h4 id="本地预览">本地预览</h4>
<p>工作目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<p><code>localhost:4000</code> 上看。</p>
<h4 id="开-github-pages-仓库">开 GitHub Pages 仓库</h4>
<p>每个账号只能开一个，仓库名 <code>username.github.io</code>。</p>
<h4 id="配源码分支">配源码分支</h4>
<p>创仓库的时候把 main 弄下来，源码（不含
public）放这里，免得被覆盖。</p>
<h4 id="自动部署">自动部署</h4>
<p>工作目录下安自动部署工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p><code>_config.yml</code> 末尾加上（记得照着用户名改动）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># message: Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;)</span></span><br></pre></td></tr></table></figure>
<p>部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h3 id="metadata">metadata</h3>
<p>搜 <code>_config.yml</code> 相关配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">幻影彭的彩虹</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;记录青春的扇区&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&#x27;算法竞赛, 自动化测试, 工程技术, Python&#x27;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">huan-yp</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 必须改</span></span><br><span class="line"></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://huanyp.cn</span></span><br></pre></td></tr></table></figure>
<h3 id="主题">主题</h3>
<h4 id="安主题next">安主题（next）</h4>
<p>工作目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<h4 id="写上要用这个主题">写上要用这个主题</h4>
<p><code>_config.yml</code> 里，找到 <code>theme</code>，写上
<code>next</code></p>
<h3 id="next">next</h3>
<p>我用 next 主题。</p>
<h4 id="menu">menu</h4>
<p>配置菜单。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-heartbeat</span></span><br></pre></td></tr></table></figure>
<h4 id="scheme">scheme</h4>
<p>在 <code>themes/next/_config.yml</code> 调 scheme，传统的应该选
<code>Gemini</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<h4 id="dark">dark</h4>
<p>应该没有人喜欢 light，所以调成 dark。</p>
<p>在 <code>themes/next/_config.yml</code> 调 darkmode。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">darkmode: true</span><br></pre></td></tr></table></figure>
<h3 id="背景">背景</h3>
<p>一般要加个背景图片什么的</p>
<h4 id="准备-source-图片">准备 source 图片</h4>
<p>图片放到 <code>themes/next/source/image/background.jpg</code>
里。</p>
<h4 id="改-style">改 style</h4>
<p>找到
<code>themes\next\source\css\_schemes\Gemini\index.styl</code>，加上：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">/images/background-now.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed; //不重复</span><br><span class="line">    <span class="attribute">background-size</span>: cover;      //填充</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 博客内容透明化</span><br><span class="line">// 文章内容的透明度设置</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 搜索框（local-search）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//博客内容透明化</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--content-bg-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那个 [0, 1] 的参数是透明度，自己估摸着调。</p>
<h3 id="友情链接">友情链接</h3>
<h4 id="menu-加-link">menu 加 link</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">友情链接:</span> <span class="string">/links/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br></pre></td></tr></table></figure>
<p>写中文就行。</p>
<h4 id="内联-html">内联 html</h4>
<p>新建 <code>source/links/index.md</code>，写入：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-body&quot;</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;links&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">      &lt;style&gt;</span></span><br><span class="line"><span class="code">         .links-content&#123;</span></span><br><span class="line"><span class="code">         margin-top:1rem;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .link-navigation::after &#123;</span></span><br><span class="line"><span class="code">         content: &quot; &quot;;</span></span><br><span class="line"><span class="code">         display: block;</span></span><br><span class="line"><span class="code">         clear: both;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card &#123;</span></span><br><span class="line"><span class="code">         width: 45%;</span></span><br><span class="line"><span class="code">         font-size: 1rem;</span></span><br><span class="line"><span class="code">         padding: 10px 20px;</span></span><br><span class="line"><span class="code">         border-radius: 4px;</span></span><br><span class="line"><span class="code">         transition-duration: 0.15s;</span></span><br><span class="line"><span class="code">         margin-bottom: 1rem;</span></span><br><span class="line"><span class="code">         display:flex;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card:nth-child(odd) &#123;</span></span><br><span class="line"><span class="code">         float: left;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card:nth-child(even) &#123;</span></span><br><span class="line"><span class="code">         float: right;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card:hover &#123;</span></span><br><span class="line"><span class="code">         transform: scale(1.1);</span></span><br><span class="line"><span class="code">         box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card a &#123;</span></span><br><span class="line"><span class="code">         border:none;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .ava &#123;</span></span><br><span class="line"><span class="code">         width: 3rem!important;</span></span><br><span class="line"><span class="code">         height: 3rem!important;</span></span><br><span class="line"><span class="code">         margin:0!important;</span></span><br><span class="line"><span class="code">         margin-right: 1em!important;</span></span><br><span class="line"><span class="code">         border-radius:4px;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .card-header &#123;</span></span><br><span class="line"><span class="code">         font-style: italic;</span></span><br><span class="line"><span class="code">         overflow: hidden;</span></span><br><span class="line"><span class="code">         width: 100%;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .card-header a &#123;</span></span><br><span class="line"><span class="code">         font-style: normal;</span></span><br><span class="line"><span class="code">         color: #2bbc8a;</span></span><br><span class="line"><span class="code">         font-weight: bold;</span></span><br><span class="line"><span class="code">         text-decoration: none;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .card-header a:hover &#123;</span></span><br><span class="line"><span class="code">         color: #d480aa;</span></span><br><span class="line"><span class="code">         text-decoration: none;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .card-header .info &#123;</span></span><br><span class="line"><span class="code">         font-style:normal;</span></span><br><span class="line"><span class="code">         color:#a3a3a3;</span></span><br><span class="line"><span class="code">         font-size:14px;</span></span><br><span class="line"><span class="code">         min-width: 0;</span></span><br><span class="line"><span class="code">         overflow: hidden;</span></span><br><span class="line"><span class="code">         white-space: nowrap;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">      &lt;/style&gt;</span></span><br><span class="line"><span class="code">      &lt;div class=&quot;links-content&quot;&gt;</span></span><br><span class="line"><span class="code">         &lt;div class=&quot;link-navigation&quot;&gt;</span></span><br><span class="line"><span class="code">            &lt;div class=&quot;card&quot;&gt;</span></span><br><span class="line"><span class="code">               &lt;img class=&quot;ava&quot; src=&quot;博客图标&quot; /&gt;</span></span><br><span class="line"><span class="code">               &lt;div class=&quot;card-header&quot;&gt;</span></span><br><span class="line"><span class="code">                  &lt;div&gt;</span></span><br><span class="line"><span class="code">                     &lt;a href=&quot;博客链接&quot;&gt;博客名字&lt;/a&gt;</span></span><br><span class="line"><span class="code">                  &lt;/div&gt;</span></span><br><span class="line"><span class="code">                  &lt;div class=&quot;info&quot;&gt;博客简介&lt;/div&gt;</span></span><br><span class="line"><span class="code">               &lt;/div&gt;</span></span><br><span class="line"><span class="code">            &lt;/div&gt;</span></span><br><span class="line"><span class="code">            &lt;div class=&quot;card&quot;&gt;</span></span><br><span class="line"><span class="code">               &lt;img class=&quot;ava&quot; src=&quot;博客图标&quot; /&gt;</span></span><br><span class="line"><span class="code">               &lt;div class=&quot;card-header&quot;&gt;</span></span><br><span class="line"><span class="code">                  &lt;div&gt;</span></span><br><span class="line"><span class="code">                     &lt;a href=&quot;博客链接&quot;&gt;博客名字&lt;/a&gt;</span></span><br><span class="line"><span class="code">                  &lt;/div&gt;</span></span><br><span class="line"><span class="code">                  &lt;div class=&quot;info&quot;&gt;博客简介&lt;/div&gt;</span></span><br><span class="line"><span class="code">               &lt;/div&gt;</span></span><br><span class="line"><span class="code">            &lt;/div&gt;</span></span><br><span class="line"><span class="code">         &lt;/div&gt;</span></span><br><span class="line"><span class="code">      &lt;/div&gt;</span></span><br><span class="line"><span class="code">   &lt;/div&gt;</span></span><br><span class="line"><span class="code">&lt;/div&gt;</span></span><br><span class="line"><span class="code">&#123;% endraw %&#125;</span></span><br></pre></td></tr></table></figure>
<p>要加的时候在这复制 html 就行。</p>
<h3 id="杂项">杂项</h3>
<h4 id="置顶文章">置顶文章</h4>
<p>工作目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall --save hexo-generator-index</span><br><span class="line">npm install --save hexo-generator-index-pin-top</span><br></pre></td></tr></table></figure>
<p>metadata 部分写：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Title</span><br><span class="line"><span class="section">top: true</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>即可置顶。</p>
<h4 id="折叠">折叠</h4>
<p>在 <code>metadata</code> 中加上:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">description: 文件摘要</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>即可折叠.</p>
<h3 id="插件">插件</h3>
<h4 id="搜索插件">搜索插件</h4>
<p>工作目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>主题配置 <code>themes/next/_config.yml</code> 下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="数学插件">数学插件</h4>
<p>一般用 Mathjax。</p>
<p>先安装 <a
href="https://pandoc.org/installing.html">Pandoc</a>，这个要改系统路径，需要重启终端。</p>
<p>工作目录下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked</span><br><span class="line">npm install hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>
<p>改 <code>themes/next/_config.yml</code> 的 math 配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">all</span></span><br></pre></td></tr></table></figure>
<p>每篇文档的 metadata 部分要写启用 Mathjax：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"><span class="section">mathjax: true</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>参考资料：<a
href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md">Next
官方有关文档</a>。</p>
<h3 id="常用命令">常用命令</h3>
<ul>
<li><code>hexo g</code> : 生成</li>
<li><code>hexo s</code> : 本地部署</li>
<li><code>hexo d</code> : 远端部署</li>
</ul>
<h3 id="网络相关">网络相关</h3>
<h4 id="cname">CNAME</h4>
<p>hexo d 的时候因为是强制 push 的, github CNAME 文件时会被覆盖,
导致域名解析错误.</p>
<p><a
href="http://eronana.github.io/2014/11/07/Hexo%E9%83%A8%E7%BD%B2%E5%90%8ECNAME%E8%A2%AB%E8%A6%86%E7%9B%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">解决方式</a></p>
<p>将 <code>CNAME</code> 放入 <code>./source</code>，即存在
<code>./source/CNAME</code> 文件。</p>
<h4 id="seo">SEO</h4>
<p>在 <code>google search console</code>
申请抓取的时候，一定要看清楚是不是 <code>https</code> 协议，如果部署在
<code>github</code> 上，可能会强制
<code>https</code>，导致抓取出现<strong>重定向错误。</strong>如果出现了这个错误，有可能是没用
<code>https</code> 协议。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>做题3</title>
    <url>/2022/07/12/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%983/</url>
    <content><![CDATA[<h3 id="cf1698f">CF1698F</h3>
<h4 id="思路">思路</h4>
<p>变过来变过去，还 TM 离谱的操作当然要找不变量，算是半个套路。</p>
<p><code>reverse</code>
两端相等的区间，可以发现每两个相邻元素构成的无序对不变，然后第一个元素和最后一个元素不改变。</p>
<p>换句话说，<span class="math inline">\(\{(a_i,a_{i+1},i \in
[1,n)\}\)</span> 这个集合不随 <span class="math inline">\(a\)</span>
中操作改变。或者说，如果从 <span class="math inline">\(a_i\)</span> 到
<span class="math inline">\(a_{i+1}\)</span>
连边，这张无向图是不变的，同时 <span
class="math inline">\(a_1,a_n\)</span>
不改变。这个条件和上个条件之间的转换是解题的关键点之一。</p>
<p>套路又来了，看看样例，集合相同并且首尾相同这个条件貌似挺充分的，所以考虑证明。</p>
<p><strong>对于构造问题，常用的证明方式是数学归纳法。</strong></p>
<p>事实上，如果我们能证明如果第二个数可以成功调整为相同，那么整个数组也可以，因为满足条件的
<span class="math inline">\(a,b\)</span>
如果同时删掉第一个数，仍满足条件。</p>
<p>考虑构造方案，由结论可以知道，如果 <span
class="math inline">\(a\)</span> 中必定存在 <span
class="math inline">\((b_1,b_2)\)</span> 无序对，因为 <span
class="math inline">\(a_2\neq b_2\)</span>，不妨让这对无序对是 <span
class="math inline">\((a_x,a_{x+1}),x\in[2,n)\)</span>，如果 <span
class="math inline">\(a_x=b_2\)</span>，考虑直接将这一对中的 <span
class="math inline">\(a_{x+1}\)</span> 和 <span
class="math inline">\(a_1\)</span> 子数组 <code>reverse</code>
，完事。如果 <span
class="math inline">\(a_{x+1}=b_2\)</span>，事情有点麻烦。</p>
<p><code>if only i could find a pair which...</code></p>
<p>补上那句话，如果能找到一对可以被翻转的，左端点在 <span
class="math inline">\([1,x]\)</span> ，右端点在 <span
class="math inline">\((x,n]\)</span> 的，那么我们就翻转，改变了 <span
class="math inline">\(a_x,a_{x+1}\)</span> 的顺序。</p>
<p>尝试证明一定能找到，即 <span class="math inline">\(\{a_i ,i\in
[1,x]\} \bigcap \{a_i.i\in(x,n]\} \neq \emptyset\)</span></p>
<p>反证法，如果找不到，那么可知 $a_i,i$ 与 <span
class="math inline">\(a_j,j\in (x,n]\)</span> 除开 <span
class="math inline">\((a_i,a_i+1)\)</span> 这一次相邻外均不相邻，考虑
<span class="math inline">\(b_2\)</span> 即 <span
class="math inline">\(a_{x+1}\)</span> 的情况，它与 <span
class="math inline">\(b_3\)</span> 相邻，可知 <span
class="math inline">\(b_3 \in \{a_i.i\in(x,n]\}\)</span>，同理有 <span
class="math inline">\(\forall j\ge
2,b_j\in\{a_i.i\in(x,n]\}\)</span></p>
<p>考虑 <span class="math inline">\(a_2\)</span>，它显然不存在于 <span
class="math inline">\(b\)</span>，故矛盾。</p>
<h4 id="回顾">回顾</h4>
<p>这题比较难的有两个点，一是注意到这个不变量极大可能是充分条件，二是发现
<span class="math inline">\(a_{x+1}=b_2\)</span> 的 case
中一定存在可交换项，搞定了这两个，问题就迎刃而解。关键点在于第二个，找到
<span class="math inline">\(a_{[1,x]},a_{[x+1,n]}\)</span>
交集的关系，并尝试用反证法证明交集不为空是比较困难的。</p>
<h3 id="abc259g">ABC259G</h3>
<p>很有意思的网络流题。</p>
<p>最开始想到二分图相关，因为 <span class="math inline">\(A_{i,j}
&lt;0\)</span>
的限制指向性比较明确，然后发现如果二分图的决策正数话会出现不同块之间相互影响，所以考虑决策负数，决策负数不同联通块互不影响，但是无法计算答案，因为最终还是需要确定到底哪些正数被选了。</p>
<h4 id="解法一">解法一</h4>
<p>题解给出了一个新思路，考虑先只把所有正数选了，然后再来看满足条件的代价。</p>
<p>代价被分为了三类，第一类是顺带选择的负数的代价，如果选了一行或者一列，就会有这一行或列所有负数绝对值之和的代价。</p>
<p>第二类是无法选择正数的代价，如果正数所在的行和列都没被选择，那么就会有这个正数的代价。</p>
<p>第三类是重复选择负数的代价，如果一个负数被行和列同时选择（为了付出更少的第二类和其它第一类代价），那么这个代价是无穷大。</p>
<p>我们需要最小化代价。</p>
<p>0/1 决策问题，考虑套最小割上去，每一行每一列视为一个点。</p>
<p>令与 <span class="math inline">\(s\)</span> 同集合的为选择，与 <span
class="math inline">\(t\)</span>
同集合的为不选，选一行或一列的代价为该行或列负数绝对值之和，从个点到
<span class="math inline">\(t\)</span>
连边就行，行列同时选择负数，代价为
inf，woc，怎么连呢？从行连向列，意义为选了行不选列的代价，从列向行连，意义为选了列不选行的代价。所以我们前面的安排有些问题，需要做出调整。</p>
<p><strong>对于行和列，我们让属于 s,t
所在集合对它们有不同意义，下面让属于 s 的行为不选择，属于 t
的列为不选择</strong>，我们让 <span class="math inline">\(s\)</span>
向行连边，<strong>这条边</strong>表示选该行的代价，让列向 <span
class="math inline">\(t\)</span>
连边，表示选该列的代价。于是，对于一个点，行列都选的代价当且仅当 <span
class="math inline">\(A_{i,j}&lt;0\)</span> 时为
inf，此时从列向行连边，表示都选的代价，行列都不选的代价当且仅当 <span
class="math inline">\(A_{i,j}\ge0\)</span> 时为 <span
class="math inline">\(A_{i,j}\)</span>，此时从行向列连边。</p>
<p>注意，我们的割中如果出现了行列都不选，那么对应的行和列与 <span
class="math inline">\(s,t\)</span>
的边一定没有断开，所以必须断开行到列的边。如果出现了行和列都选的不合法情况，我们发现，断掉的行能到
<span class="math inline">\(t\)</span>，从 <span
class="math inline">\(s\)</span>
一定能到断掉的列。如果不满足，那么这个割就不是最小割，不会被我们考虑。所以我们需要从列到行连边，保证不会给负数打上两个标记。</p>
<p>这种思路和某类 dp
的思路很类似，相当值得学习，其实在原问题的求解中，并没有什么条件来保证不会给一个负数打上两个标记，但是我们在通过最小割求解时，限定了决策的范围和最优性，获得了额外的信息，也就能帮助我们排除掉难处理但是不可能的情况，本质上，这种排除还和我们先假定所有正数都选上的前提有关系，这种解法相当精妙。</p>
<h4 id="解法二">解法二</h4>
<p>从直觉上来看，应该不会选择和为负数的行或者列。考虑一个最终方案，它的答案会是
<span class="math inline">\(\sum 选择的行+\sum 选择的列 -\sum
行列交叉处的正数\)</span>。考虑从这里面剔除和为负数的列或行，发现最终值一定变大。</p>
<p>所以删掉和为负数的行和列。</p>
<p>考虑先把剩下的行和列全选了，然后解决冲突。</p>
<p>解决冲突的方式有三种，一种时不选行，一种是不选列，另一种是硬吃同时选的代价。</p>
<p>这样的建图就很简洁了，从 <span class="math inline">\(s\)</span>
向行，列向 <span class="math inline">\(t\)</span>
连边，对于交点，正数连其值的边，负数连 inf
边。很容易发现一个合法解和一个割一一对应，over。</p>
<h4 id="sum-up">Sum up</h4>
<p><strong>最小割解决实际问题的核心，在于用一个割，或者可能成为最小割的割，来代表一个实际的决策方案，最小割的容量，代表代价，每个点在哪个割集分别代表什么含义并不重要，重要的是割掉每条边的意义，和决策方案与最小割的对应关系。</strong></p>
<p>其实这道题还给我们一个启发，就是在考虑0/1决策问题时，可以先考虑钦定一个决策，再来调整使得它合理或者变优，这可能会使得问题变得简单，也许算是一个套路。</p>
<p><strong>本质上，最小割表达了一种最优的解决决策冲突的方案，我们在 0/1
决策问题钦定决策的过程中，制造了一些冲突，用一个图的割来表达解决着些冲突的方案。</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>做题2</title>
    <url>/2022/07/12/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%982/</url>
    <content><![CDATA[<h2 id="section">20220305</h2>
<h3
id="abc242f二项式反演的进一步理解">ABC242F(二项式反演的进一步理解)</h3>
<h4 id="题意">题意：</h4>
<p>给定一个 <span class="math inline">\(n*m\)</span> 的矩阵，需要放
<span class="math inline">\(a\)</span> 个白块 <span
class="math inline">\(b\)</span> 个黑块，让它们互不侵犯，<span
class="math inline">\(n,m\leq 50\)</span>。</p>
<p>最开始看到这道题以为又要挑战 <span
class="math inline">\(\text{npc}\)</span>
了，仔细一看互不侵犯的定义，是不能放在同一行或同一列。</p>
<h4 id="思考">思考：</h4>
<p>很有意思的容斥题，考虑枚举白色占了多大的地盘，设 <span
class="math inline">\(f[i][j]\)</span> 表示允许白色占用了 <span
class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列的方案数，然后组合数容斥。我们可以设
<span class="math inline">\(g[i][j]\)</span> 为白色恰好占用 <span
class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span>
列的方案数，考虑列出二项式反演的式子。思考 <span
class="math inline">\(f,g\)</span> 的关系，这是一类高维容斥问题。</p>
<p>结论如下： <span class="math display">\[
g[i][j] = f[i][j] - \sum\limits_{x\leq i,y\leq j,x+y \neq i+j }
\tbinom{i}{x} \times \tbinom{j}{y} \times g[x][y]
\]</span> 理解这个式子不难，就是减去恰好被占用的部分，注意容斥系数。</p>
<p>我们考虑能不能不用 <span class="math inline">\(g\)</span>
参与这个式子。</p>
<p>回想线性的二项式反演问题，我们有式子： <span class="math display">\[
f(n) = \sum\limits_{i=n}^{m} \tbinom{i}{n} \times g(i)  \Leftrightarrow
g(n) = \sum\limits_{i=n}^{m} (-1)^{n-i}\times\tbinom{i}{n} \times f(i)
\]</span> 其中 <span class="math inline">\(f(n)\)</span> 表示钦定满足
<span class="math inline">\(n\)</span> 个条件的方案数。<span
class="math inline">\(g(n)\)</span> 表示恰好满足 <span
class="math inline">\(n\)</span> 的条件的方案数。</p>
<p>左边很好理解，就是钦定 <span class="math inline">\(n\)</span>
个条件满足的方案数就是从满足 <span class="math inline">\(i\)</span>
个条件的方案中选出 <span class="math inline">\(n\)</span>
个钦定满足。</p>
<p>右边可以稍微变换一下以便理解 <span class="math display">\[
g(n) = f(n)  - \sum\limits_{i=n+1}^{m} \tbinom{i}{n} g(i)
\]</span> 就是钦定 <span class="math inline">\(i\)</span>
个的情况减去恰好有大于 <span class="math inline">\(i\)</span>
个的情况乘上一个组合数，这和上面那个二维的很类似。</p>
<p>给出高位二项式反演公式： <span class="math display">\[
g(n_1,n_2,⋯,n_m)=∑\limits_{k_i = 0}^{n_i}
∏\limits_{i=1}^{m}\tbinom{n_i}{k_i}f(k_1,k_2,⋯,k_m)
\]</span></p>
<p><span class="math display">\[
\ \ \ \ \ \ \ \ \ \ \ \Updownarrow
\]</span></p>
<p><span class="math display">\[
f(n_1,n_2,⋯,n_m)=∑\limits_{k_i=0}^{n_i}∏\limits_{i=1}^{m}(−1)^{n_i−k_i}\tbinom{n_i}{k_i}
g(k_1,k_2,⋯,k_m)
\]</span></p>
<p>第一个二维式子和第二个一维式子很类似，所以考虑推出 <span
class="math inline">\(f,g\)</span> 的关系。 <span
class="math display">\[
f(n,m) = \sum\limits_{i=0}^{n} \sum\limits_{j=0}^{m} g(i,j) \times
\tbinom{n}{i} \times \tbinom{m}{j}
\]</span> 组合解释是钦定 <span class="math inline">\(n\)</span> 行 <span
class="math inline">\(m\)</span> 列可以被占用的方案数就是先从其中选出
<span class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列。然后计算恰好这么多被占用的方案数。
因为行和列是有标号的。</p>
<p>直接代公式有 <span class="math display">\[
g(n,m) = \sum\limits_{i=0}^{n} \sum\limits_{j=0}^{m} (-1)^{n-i+m-j}
\tbinom{n}{i}\times \tbinom{m}{j}\times f(i,j)
\]</span> 结束。</p>
<h3 id="abc242h初步理解-min-max-容斥">ABC242H(初步理解 min-max
容斥)</h3>
<h4 id="题意-1">题意：</h4>
<p>给定 <span class="math inline">\(m\)</span> 条线段，一个长度为 <span
class="math inline">\(n\)</span>
的数轴，每次随机选一条把数轴上对应位置涂黑，问全部涂黑的期望选择次数。</p>
<h4 id="思考-1">思考：</h4>
<p>记 <span class="math inline">\(E(i)\)</span> 表示第 <span
class="math inline">\(i\)</span> 个格子被涂黑的期望时间。记 <span
class="math inline">\(E(S)\)</span> 表示集合 <span
class="math inline">\(S\)</span>
全部被涂黑的期望时间，也就是所有格子中被涂黑时间的最大值，<span
class="math inline">\(E&#39;(S)\)</span> 表示集合 <span
class="math inline">\(S\)</span>
中任意一个被涂黑的期望时间，即最小值。</p>
<p>显然 <span class="math inline">\(E(S) \neq \max\limits_{i\in S}
(E(i))\)</span>，因为期望只有线性性，<span
class="math inline">\(max,min\)</span> 是非线性操作。</p>
<p>但是我们发现一件事 <span class="math inline">\(\max(S) =
\sum\limits_{T \subseteq S} (-1)^{|T| - 1} \min(T)\)</span>，即 <span
class="math inline">\(\text{min-max}\)</span>
容斥的公式在期望意义下也成立。</p>
<p>而对这道题来说，计算一个集合的最小值是容易的，只需要计算出有多少个包含任意一个元素的线段就行了。</p>
<p>我们设 <span class="math inline">\(dp[i][j][k][0/1]\)</span>
表示考虑到第 <span class="math inline">\(i\)</span> 个位置，上一个位置为
<span class="math inline">\(j\)</span>，已经包含 <span
class="math inline">\(k\)</span>
条线段的方案数，集合大小为奇数或偶数的方案数，转移可以预处理 <span
class="math inline">\([l,r]\)</span> 会新增多少线段，做到 <span
class="math inline">\(O(1)\)</span>，事实上最后一维可以省掉，直接带系数转移就行。</p>
<h2 id="section-1">20220309</h2>
<h3 id="haltoj128">haltoj128</h3>
<h4 id="思考-2">思考：</h4>
<p>欧拉图计数相关问题。关于无向欧拉图有一个结论，欧拉子图的个数为 <span
class="math inline">\(2^{m-n+c}\)</span>
个，也就是其生成森林中非树边组成的集合个数，公式中 <span
class="math inline">\(c\)</span> 代表连通块个数。</p>
<p>理解比较容易，考虑构造方案，任意一个非树边集合会唯一对应一种合法方案，选一条非树边则将它覆盖的树边状态反转（选变为不选，不选变为选），可以得到唯一合法方案。</p>
<p>这个选非树边集合的方式给这道题目带来了启发。然而这种类似异或的方式并不便于统计
<span class="math inline">\(|S|^2\)</span>
这种东西。我们考虑它的组合意义。发现其组合意义为每对边在同一子图便贡献两次，一条边在某一子图贡献一次。</p>
<p>一条边的情况是简单的，考虑两条边。</p>
<p>两条非树边是可以任选的，这一部分答案为 <span class="math inline">\(k
* (k-1) * 2^{k-2}\)</span>，因为已经钦定这两边要选，其它的任意选。</p>
<p>一条非树边和一条树边的贡献可以分两种情况，分别是树边是否受到非树边影响。不受影响答案为
<span class="math inline">\((k-cover[v]) * 2^{k-2}\)</span>，<span
class="math inline">\(cover[v]\)</span> 影响这条树边的非树边条数，<span
class="math inline">\(k-2\)</span>
因为钦定了选择的非树边要选，并且影响这条树边的边有一个的选择情况是不能任意，因为要让树边被选择。</p>
<p>如果受到非树边影响，那么答案也为 <span class="math inline">\(cover[v]
* 2^{k-2}\)</span>，但如果 <span class="math inline">\(cover[v] =
1\)</span>，那么答案为 <span
class="math inline">\(2^{k-1}\)</span>。理解方式类似。</p>
<p>两条树边的情况，考虑影响这两条树边的边集，我们断言如果边集完全相同，那么答案为
<span class="math inline">\(2^{k-1}\)</span>，否则答案为 <span
class="math inline">\(2^{k-2}\)</span>，边集完全相同的情况不难理解，如果不完全相同，我们在每条边特有的部分钦定一个来控制该边，所以答案为
<span
class="math inline">\(2^{k-2}\)</span>。如果是包含关系，先钦定里面的，再钦定外面的即可。</p>
<p>如果要选择树边，记得不要考虑 <span class="math inline">\(cover[v] =
0\)</span> 的边。计算 <span class="math inline">\(cover\)</span>
可以树上前缀和，对于两条非树边，需要统计边集相同的个数，这个可以异或哈希，取
<span class="math inline">\(2^{63}\)</span>
为上界，做双哈希，错误概率在本题数据规模下小于 <span
class="math inline">\(10^{-9}\)</span>。</p>
<h3 id="haltoj132分治ntt的思路">haltoj132(分治NTT的思路)</h3>
<h4 id="思考-3">思考：</h4>
<p>假设不考虑 <span class="math inline">\(&#39;&gt;&#39;\)</span>，即令
<span class="math inline">\(&#39;&gt;&#39;\)</span>
为无限制，那么序列会被 <span
class="math inline">\(&#39;&gt;&#39;\)</span>
划分为若干段，记每一段的长度为 <span
class="math inline">\(a\)</span>，那么答案为 <span
class="math display">\[
\dfrac{n!}{\prod a_i !}
\]</span> 我们考虑容斥，枚举一个子集表示那些位置上的 <span
class="math inline">\(&#39;&gt;&#39;\)</span> 强制为 <span
class="math inline">\(&#39;&lt;&#39;\)</span>，也就是不合法的情况，然后就可以用总数减去这些不合法情况得到答案。</p>
<p>上面的那个 <span class="math inline">\(n!\)</span>
在做转移的时候很麻烦，先不管。</p>
<p>设 <span class="math inline">\(dp[i]\)</span> 表示对前 <span
class="math inline">\(i\)</span> 个符号做容斥，考虑到第 <span
class="math inline">\(i\)</span> 个符号后的数字的结果。</p>
<p>注意到这里 <span class="math inline">\(dp[i] \times (i+1)!\)</span>
也就是前缀 <span class="math inline">\(s_i\)</span> 的答案。</p>
<p>顺便设 <span class="math inline">\(f_i\)</span> 表示前 <span
class="math inline">\(i\)</span> 个符号中 <span
class="math inline">\(&#39;&gt;&#39;\)</span> 的个数。</p>
<p>显然有 <span class="math inline">\(dp[0] = 1\)</span></p>
<p>我们得到以下式子： <span class="math display">\[
dp[i] = (-1)^{f_i}\times \dfrac{1}{(i+1)!} +\sum\limits_{s_j =
&#39;&gt;&#39;,j\in[1,i]} dp[j-1] \times (-1)^{f_{i}-f_{j}}
\times\dfrac{1}{(i-j+1)}!
\]</span> 考虑如何理解这个式子。</p>
<p>我们枚举上一个不受限制的位置 <span
class="math inline">\(j\)</span>，然后乘上对应的容斥系数和计算转移系数，最后加上全部受限制的情况。</p>
<p>因为要优化，所以把式子小小的变一下： <span class="math display">\[
dp[i] = (-1)^{f_i}\times \dfrac{1}{(i+1)!} +\sum\limits_{s_{j+1} =
&#39;&gt;&#39;,j\in[0,i-1]} dp[j] \times (-1)^{f_{i}-f_{j+1}}
\times\dfrac{1}{(i-j)}!
\]</span> 传说中的分治 <span class="math inline">\(NTT\)</span>
可以解决这一类 <span class="math inline">\(dp\)</span>
的优化问题，它的核心思路大概是这样的：</p>
<p>分治 <span class="math inline">\(NTT\)</span>
解决形如这样的问题：</p>
<p>假设要求的函数为 <span class="math inline">\(f\)</span>，有另一个函数
<span class="math inline">\(g\)</span>。</p>
<p>满足 <span class="math inline">\(f(i) = \sum\limits_{j\ &lt; i} f(j)
\times g(i-j)\)</span>。</p>
<p>类似于 <span class="math inline">\(\text{CDQ}\)</span>
一样，考虑左边对右边的贡献即可，容易发现这是一个好做的卷积形式。</p>
<p>对于这道题来说，<span class="math inline">\(-1\)</span>
的次幂可以被拆到两边，剩下的事情有手就行。</p>
<h4 id="收获">收获</h4>
<p>容斥原理可以解决这样一类问题，有一个全集 <span
class="math inline">\(S\)</span>，<span
class="math inline">\(|S|\)</span> 好求，现在有若干属性 <span
class="math inline">\(p_i\)</span>，构成集合 <span
class="math inline">\(T\)</span>，需要求满足属性集合 <span
class="math inline">\(T\)</span>
的元素个数。并且可以很容易求出这样一种情况的答案：限定某些属性不满足，其它属性不做要求。</p>
<h2 id="section-2">20220320</h2>
<h3 id="haltoj-7">HaltOJ 7</h3>
<h4 id="思考-4">思考：</h4>
<p>想一下小学的时候做过的奥数题，一个圆里画 <span
class="math inline">\(n\)</span> 条线最多分成几部分，答案是 <span
class="math inline">\(n*(n+1)/2 +
1\)</span>。再考虑下平行线和多点共线的情况，发现答案只和每个交点的情况和交点个数有关。手玩一下可以发现，在逐个加入直线的情况下，部分的个数增量为此条直线和其它所有直线交点个数
<span class="math inline">\(x\)</span>，再加上 <span
class="math inline">\(1\)</span>，注意，相同交点只算一个。</p>
<p>证明可以参考平面欧拉定理，此处不做赘述。</p>
<p>所以我们模拟这个过程，每次加入一条直线判断新增了多少交点，具体可以先暴力枚举直线，求出所有交点之后带上
<span class="math inline">\(eps\)</span> 去重。然后发现 <span
class="math inline">\(y\)</span> 只和 <span
class="math inline">\(x\)</span>
有关，所以只用计算一个。然后我们发现如果按照斜率为第一关键字，截距为第二关键字排序加入线段，那么
<span class="math inline">\(x\)</span> 是一个相当优美的形式 <span
class="math inline">\(\dfrac{j-b}{a-i}\)</span>，<span
class="math inline">\(a,b\)</span> 表示当前线段的斜率和截距，<span
class="math inline">\(i,j\)</span> 表示枚举的线段的斜率和截距，<span
class="math inline">\(i,j\)</span>
的取值都连续，所以这个式子中，分母会取遍 <span
class="math inline">\([1,i]\)</span>，分子会取遍 <span
class="math inline">\([-b,B-j-1]\)</span>，正负数分开考虑，现在问题变成了问
<span class="math inline">\(\dfrac{[1,x]}{[1,y]}\)</span>
中有多少个不同的数，<span class="math inline">\(A^2\)</span>
预处理，<span class="math inline">\(O(1)\)</span>
回答即可，约定每个数在最简分数被统计。</p>
<p>可以莫比乌斯反演优化，这个可以很方便的转化成 <span
class="math inline">\([gcd(x,y)=1]\)</span> 的形式并整除分块计算，可以
<span class="math inline">\(n\sqrt n\)</span>，但没必要。</p>
<h3 id="haltoj8">HaltOJ8</h3>
<h4 id="思考-5">思考</h4>
<p>这道题出出来就展现出对直接 <span class="math inline">\(dp\)</span>
的恶意，无论那种合并方法都无法解决这个问题。我们不妨另辟蹊径，考虑字符串的另一种生成方式——插入。</p>
<p>具体的，我们将不同的花视为不同字符，那么我们需要生成一个字符串，相邻字符不同，每个字符个数指定。</p>
<p>我们发现当前的插入方式仅仅受到当前相同字符位置个数的限制，所以设
<span class="math inline">\(f_i\)</span> 表示考虑到现在，有 <span
class="math inline">\(i\)</span> 个字符相同位置的方案数。</p>
<p>转移可以枚举当前字符划分为多少段，其中有多少段插入相同字符位置，具体每一段放几个可以通过插板法计算方案。这样的转移看上去是
<span
class="math inline">\(O{(10^{5}})^3\)</span>,但是如果我们将字符按个数排序后并按照
<span class="math inline">\(3,1,2,4\)</span>
的顺序插入，因为保证了有两个只有 <span
class="math inline">\(200\)</span>，所以复杂度为 <span
class="math inline">\(O(1+200^2 + 200^3 + 10^5)\)</span>
的复杂度，最后一次转移强制要求了段数和插入相同字符位置的数量，第三次则是因为第二次转移后有效位置仅有
<span class="math inline">\(200\)</span> 个。</p>
<p>听说可以做到 <span class="math inline">\(O(200^2 + 10^5)\)</span>
，但显然我不会。</p>
<h2 id="section-3">20220322</h2>
<h3 id="arc137d">ARC137D</h3>
<h4 id="题意-2">题意</h4>
<p>给定一个序列 <span
class="math inline">\(a\)</span>，反复做前缀异或操作，问若干次操作后
<span class="math inline">\(a_n\)</span> 的值，询问所有 <span
class="math inline">\([1,k]\)</span> 的答案。</p>
<h4 id="思考-6">思考</h4>
<p>考场上一直在考虑分析单纯的 <span class="math inline">\(01\)</span>
系数，而忽略了系数之间的内在其它联系，事实上，对于反复执行的可加前缀操作，设距离为
<span class="math inline">\(d\)</span>，操作次数为 <span
class="math inline">\(k\)</span>，那么贡献应该为从 <span
class="math inline">\((0,0)\)</span> 走到 <span
class="math inline">\((d,k-1)\)</span>
的方案数。证明比较简单，将原点的贡献转移拆分到横坐标即可。</p>
<p>更严谨的证明可以使用归纳法，记贡献函数为 <span
class="math inline">\(f(x,y)\)</span>，<span
class="math inline">\(f(n,k) =
f(n-1,k)+f(n,k-1)\)</span>，那么考虑其组合意义，第一项代表了前 <span
class="math inline">\(n-1\)</span>
项的和，第二项则是自己在上面的步骤中的累计。</p>
<p>那个 <span class="math inline">\(-1\)</span> 很讨厌，先不管。</p>
<p>用组合数的形式表示答案，即为 <span
class="math inline">\(\tbinom{n+k}{n}\)</span>,对其应用卢卡斯定理求出
<span class="math inline">\(\bmod2\)</span> 的结果，发现当且仅当 <span
class="math inline">\(n\&amp;k = 0\)</span> 时有值，那么对于一个固定的
<span class="math inline">\(n\)</span> ，有值的 <span
class="math inline">\(k\)</span> 一定可以描述为一个 <span
class="math inline">\(s\)</span> 在二进制意义下的子集。</p>
<p>然后对其做一次 <span class="math inline">\(\text{FMT}\)</span>
变换即可得到结果。</p>
<p>注意处理被忽略的 <span class="math inline">\(-1\)</span></p>
<h2 id="section-4">20220323</h2>
<h3 id="cf1657d">CF1657D</h3>
<h4 id="思路">思路</h4>
<p>先做乘法转换，这个没啥说的。然后我考虑的是根号分治，先把不在凸包上的扔掉，对于代价大于
<span class="math inline">\(B\)</span>
的，枚举选的个数，然后尺取法搞定，对于代价小于 <span
class="math inline">\(B\)</span>
的，直接计算。场上过了，赛后被叉。实际上，对于这种整除的题目，我们都可以考虑枚举倍数约数，然后可以直接计算代价为
<span class="math inline">\([1,C]\)</span>
的最大权值，然后直接在上面二分就行。</p>
<h3 id="cf1647e">CF1647E</h3>
<h4 id="思路-1">思路</h4>
<p>不难发现充要条件是每个点向 <span class="math inline">\(1\)</span>
的边为最小值。然后考虑 <span class="math inline">\(dp\)</span>，直接对点
<span class="math inline">\(dp\)</span>
不太好做，我们发现它是有关大小的，所以考虑按照向 <span
class="math inline">\(1\)</span> 的边权值从小到大 <span
class="math inline">\(dp\)</span>，每次枚举一段连续的区间，以及填的值转移，转移是一个前缀和乘上一个组合数再乘上一个幂次。</p>
<h3 id="cf1647f">CF1647F</h3>
<h4 id="思路-2">思路：</h4>
<p>看上去就非常暴力，对每个限制建点，两种状态，限制和树上的点的状态推出关系连边，然后暴力确定每个限制的状态看是否冲突即可。实际上这就是模拟了
<span class="math inline">\(\text{2-SAT}\)</span>。</p>
<p>考虑这个东西为什么和 <span
class="math inline">\(\text{2-SAT}\)</span>
的正常做法一样的，正常做法是找强连通分量，
拓扑排序后对每个点选拓扑序大那个值。和我们的暴力模拟过程没啥区别。</p>
<h3 id="haltoj1262-sat-的简单理解">HaltOJ126(2-SAT 的简单理解)</h3>
<h4 id="思考-7">思考：</h4>
<p>有一些比较奇怪的限制，然后每个人在每个点就两种状态，要想起一个东西叫
<span class="math inline">\(\text{2-SAT}\)</span>，我们令 <span
class="math inline">\(statu[i][j]\)</span> 表示 <span
class="math inline">\(i\)</span> 子树内是否有 <span
class="math inline">\(j\)</span>，那么很容易构造出标准的 <span
class="math inline">\(\text{2-SAT}\)</span>
限制，然后我们考虑约束，分类讨论一下。以 <span
class="math inline">\(\text{2-SAT}\)</span> 的形式来说，对于 <span
class="math inline">\(x\)</span> 的每个儿子 <span
class="math inline">\(v\)</span>，两个点都不能同时在 <span
class="math inline">\(v\)</span> 中。同时，如果 <span
class="math inline">\(lca(x,r) \neq x\)</span> ，那么两个人都必须在
<span class="math inline">\(x\)</span> 子树内。如果 <span
class="math inline">\(lca(x,r) = x\)</span>，那么 <span
class="math inline">\(a,b\)</span>
只能有一个在子树外，就是一个为假那么另一个为真，除此以外，如果 <span
class="math inline">\(x \neq r\)</span>，那么 <span
class="math inline">\(a,b\)</span> 不能在 <span
class="math inline">\(x\)</span> 向 <span
class="math inline">\(r\)</span> 的儿子里。</p>
<p>然后跑一个标准的 <span
class="math inline">\(\text{2-SAT}\)</span>。</p>
<p><span class="math inline">\(\text{Tarjan}\)</span> 跑出来的 <span
class="math inline">\(\text{SCC}\)</span> 编号是反拓扑序。</p>
<p><span class="math inline">\(\text{2-SAT}\)</span> 的一些限制：强制
<span class="math inline">\(u\)</span>
为真，那么把假连向真，反之亦然。其它情况下注意逆否命题也要连边</p>
<p><span class="math inline">\(\text{2-SAT}\)</span> 图的一些性质：<span
class="math inline">\(u \rightarrow v \Rightarrow \overline{v}
\rightarrow \overline{u}\)</span></p>
<p><span class="math inline">\(\text{2-SAT}\)</span>
合法性：同一变量的两个状态不在同一 <span
class="math inline">\(\text{SCC}\)</span>
内是存在方案的充要条件，必要性显然，充分性用构造法证明。</p>
<p><span class="math inline">\(\text{2-SAT}\)</span>
方案构造：依次考虑每个变量，选择 <span
class="math inline">\(\text{SCC}\)</span>
编号较小那个值，那么同一变量不会直接冲突，假设先前的点 <span
class="math inline">\(v\)</span> 推出了 <span
class="math inline">\(\overline{u}\)</span>，并且 <span
class="math inline">\(\overline{u} \rightarrow
u\)</span>，因为刚刚提到的性质，一定有 <span
class="math inline">\(u\rightarrow
\overline{v}\)</span>，我们一定会选拓扑序较大的 <span
class="math inline">\(\overline{v}\)</span>，因此选择不会冲突。</p>
<h2 id="section-5">20220325</h2>
<h3 id="cf1656d">CF1656D</h3>
<h4 id="题意-3">题意：</h4>
<ul>
<li><p>您有一个 <span class="math inline">\(n\)</span>，您需要找一个
<span class="math inline">\(k \in[2,\infty)\)</span>，使得 <span
class="math inline">\(n\)</span> 可以被表示为 <span
class="math inline">\(k\)</span> 个模 <span
class="math inline">\(k\)</span>
意义下不同的数，多解可以输出任意一个。</p></li>
<li><p>多测 <span class="math inline">\(T\leq
10^5,n\leq10^{18}\)</span></p></li>
</ul>
<h4 id="思考-8">思考：</h4>
<p>因为要找的 <span class="math inline">\(k\)</span> 个数模 <span
class="math inline">\(k\)</span> 意义下不同，我们又知道任意一个数 <span
class="math inline">\(a\)</span> 都可以表示为 <span
class="math inline">\(a=b \times k +r\)</span>，所以不妨先把模 <span
class="math inline">\(k\)</span> 的余数和，也就是上式中的 <span
class="math inline">\(r\)</span>
提取出来，我们得到了一个新的式子。下面设 <span
class="math inline">\(n\)</span> 为 <span
class="math inline">\(k\)</span> 个数的和。 <span
class="math display">\[
n = c\times k + \dfrac{k\times(k+1)}{2}
\]</span> 其中 <span class="math inline">\(c\)</span> 表示这 <span
class="math inline">\(k\)</span> 个数对应 <span
class="math inline">\(b\)</span>
的和。分母让人很不爽，所以乘过去。至于为什么是 <span
class="math inline">\((k+1)\times k\)</span>，是为了让 <span
class="math inline">\(c\)</span> 可以取到 <span
class="math inline">\([0,\infty)\)</span> <span class="math display">\[
2n = (2c+k+1)\times k
\]</span> <span class="math inline">\(2n\)</span>
的两个因子奇偶性不同，所以如果我们的 <span
class="math inline">\(n\)</span> 为奇数就可以直接令 <span
class="math inline">\(k=2\)</span>，否则我们每次令 <span
class="math inline">\(k\)</span> 取 <span
class="math inline">\(2,4,8,\cdots\)</span>,直到 <span
class="math inline">\(\dfrac{2n}{k}\)</span> 为奇数为止，这个时候记
<span class="math inline">\(res = \dfrac{2n}{k}\)</span>，如果 <span
class="math inline">\(res\)</span> 较大，则取对应的 <span
class="math inline">\(k\)</span>，否则取 <span
class="math inline">\(k=res\)</span>。</p>
<p>注意特判掉一些边界情况，比如 <span class="math inline">\(2\)</span>
的次幂，<span class="math inline">\(2\)</span> 的次幂，还有 <span
class="math inline">\(2\)</span> 的次幂。</p>
<h4 id="参考代码">参考代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type &amp;a,_type b)</span></span>&#123;a=<span class="built_in">min</span>(a,b);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type &amp;a,_type b)</span></span>&#123;a=<span class="built_in">max</span>(a,b);&#125;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">read</span>(n);<span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;<span class="number">1ll</span>&lt;&lt;<span class="number">62</span>;i*=<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="type">int</span> res=<span class="number">2</span>*n/i;</span><br><span class="line">			<span class="keyword">if</span>(res%<span class="number">2</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(res&gt;i)&#123;</span><br><span class="line">					ans=i;</span><br><span class="line">					<span class="keyword">break</span>;	</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					ans=res;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">1</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="cf1656e">CF1656E</h3>
<h4 id="题意-4">题意</h4>
<ul>
<li>您有一棵 <span class="math inline">\(n\)</span>
个点的无向无根树，您需要为每个点安排一个权值 <span
class="math inline">\(a_i\in[-10^5,10^5]\)</span>，使得删掉任意一个点之后剩下连通块的权值和相同，注意安排的权值不能为
<span class="math inline">\(0\)</span>。</li>
<li>多测 <span class="math inline">\(T\leq 10^4,\sum n \leq
10^5\)</span></li>
</ul>
<h4 id="思考-9">思考</h4>
<p>诈骗题。我们考虑指定一个根，就让它是 <span
class="math inline">\(1\)</span>，然后随便删一个点 <span
class="math inline">\(u\)</span>，那么 <span
class="math inline">\(u\)</span>
的所有儿子的子树都必须有同一个值，我们可以尝试安排每一棵子树的权值和，这是可以做到的，因为可以让根控制这个值。不妨安排每颗子树的权值和为
<span class="math inline">\(1\)</span>， 那么我们再安排整个树的权值和为
<span class="math inline">\(2\)</span>，就可以让删掉每个点 <span
class="math inline">\(u\)</span> 后剩下的连通块权值和相同。<span
class="math inline">\(u\)</span> 的所有儿子子树的权值和都为 <span
class="math inline">\(1\)</span>，而除开 <span
class="math inline">\(u\)</span>
的子树后的那个连通块的权值和就是整棵树的权值和 <span
class="math inline">\(2\)</span>，减去 <span
class="math inline">\(u\)</span> 子树的权值和，就是 <span
class="math inline">\(1\)</span>，也和 <span
class="math inline">\(u\)</span> 所有儿子的子树的权值和相同。</p>
<p>但是有一个问题，如果一个点 <span class="math inline">\(u\)</span>
只有一个儿子，那么 <span class="math inline">\(u\)</span>
的权值会被安排为 <span
class="math inline">\(0\)</span>，是不合法的，所以我们需要更改一下安排的方式，对于一个点，设它子树的权值和为
<span class="math inline">\(x\)</span>，
并且它所有儿子的子树的权值和均为 <span
class="math inline">\(y\)</span>，而且整棵树的权值和为 <span
class="math inline">\(x+y\)</span>。这是合法的必要条件，因为我们需要让
<span class="math inline">\(a_i \neq0\)</span>，所以安排根的权值为 <span
class="math inline">\(0\)</span>，其它点按深度模 <span
class="math inline">\(2\)</span>，的值安排 <span
class="math inline">\(-1\)</span> 和 <span
class="math inline">\(1\)</span> 即可。</p>
<h4 id="代码">代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type &amp;a,_type b)</span></span>&#123;a=<span class="built_in">min</span>(a,b);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type &amp;a,_type b)</span></span>&#123;a=<span class="built_in">max</span>(a,b);&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> val[N],fa[N],dep[N],deg[N],tar[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==s)tar[u]=val[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> tar[u]=val[u]=dep[u]%<span class="number">2</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[u]==v)<span class="keyword">continue</span>;</span><br><span class="line">		dep[v]=dep[u]<span class="number">+1</span>,fa[v]=u;<span class="built_in">dfs</span>(v);val[u]-=tar[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">read</span>(n);dep[<span class="number">1</span>]=<span class="number">1</span>;s=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)e[i].<span class="built_in">clear</span>(),val[i]=<span class="number">0</span>,tar[i]=deg[i]=<span class="number">0</span>,fa[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> x,y;<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">			e[x].<span class="built_in">push_back</span>(y),e[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">			deg[x]++,deg[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(deg[i]&gt;deg[s])s=i;</span><br><span class="line">		<span class="built_in">dfs</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,val[i]);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="cf1656f">CF1656F</h3>
<h4 id="题意-5">题意</h4>
<ul>
<li><p>您有 <span class="math inline">\(n\)</span>
个点，每个点有一个权值 <span
class="math inline">\(a_i\)</span>，定义一张有权无向完全图 <span
class="math inline">\(K(t)\)</span> 为每个点 <span
class="math inline">\(i\)</span> 向 <span
class="math inline">\(j\)</span> 连一条权值为 <span
class="math inline">\(a_i\times a_j+(a_i+a_j)\times t\)</span>
的无向边后所构成的图，定义 <span class="math inline">\(f(t)\)</span> 为
<span class="math inline">\(K(t)\)</span>
最小生成树的权值和。您需要对所有的实数 <span
class="math inline">\(t\)</span> 求出 <span
class="math inline">\(f(t)\)</span>
的最大值并输出它，如果最大值不收敛，那么输出 <code>INF</code>。</p></li>
<li><p>多测，<span class="math inline">\(T\leq 10^4,\sum n\leq 2\times
10^5,-10^6\leq a_i\leq 10^6\)</span></p></li>
</ul>
<h4 id="思考-10">思考</h4>
<p><del>场上差那么一点点就 15Ton 了</del></p>
<p>一个瓶颈在排序的线性做法。</p>
<p>记 <span class="math inline">\(d_i\)</span> 表示点 <span
class="math inline">\(i\)</span> 的度数。</p>
<p>判断 <span class="math inline">\(\text{INF}\)</span>
是简单的，只需要看能不能凑出 <span class="math inline">\(\sum a_i\times
d_i\)</span> 分别为正和负或者 <span class="math inline">\(0\)</span>
就行，如果凑不出来，令 <span class="math inline">\(t\)</span>
为正无穷或者负无穷，然后它就不收敛了。</p>
<p>现在已知有解。</p>
<p>考虑固定一个 <span class="math inline">\(t\)</span> 后怎么快速求
<span class="math inline">\(\text{MST}\)</span>。做个恒等变形，权值为
<span class="math inline">\((a_i+t)\times (a_j+t)-t^2\)</span>，把 <span
class="math inline">\(t^2\)</span> 给扔掉。</p>
<p>结论是排序后按正负性断开，<span class="math inline">\(a_1\)</span>
向所有 <span class="math inline">\(a_i\)</span> 大于 <span
class="math inline">\(0\)</span> 的连边， <span
class="math inline">\(a_n\)</span> 向所有 <span
class="math inline">\(a_i\)</span> 小于 <span
class="math inline">\(0\)</span> 的连边，<span
class="math inline">\(0\)</span> 无所谓。</p>
<p>证明可以考虑 <code>Prime</code> 算法的过程，最开始一定是 <span
class="math inline">\(a_1\)</span> 到 <span
class="math inline">\(a_n\)</span>。然后后面不会取到正负性相同的，并且一个点一定是连向
<span class="math inline">\(a_1\)</span> 或者 <span
class="math inline">\(a_n\)</span>。</p>
<p>如果处理一个前缀和，知道正负交界的位置之后可以快速算，从小到大枚举
<span class="math inline">\(t\)</span>，然后双指针维护交界处。</p>
<p>可以证明 <span class="math inline">\(t\)</span> 一定取到每个 <span
class="math inline">\(-a_i\)</span>。如果夹在两坨中间，那么由于具体选哪些边是固定的，根据
<span class="math inline">\(\sum a_i\times d_i\)</span>
正负性调整即可。</p>
<p>不会取到 <span class="math inline">\([a_1,a_n]\)</span>
外面去，因为我们已经判了无解，所以取到边界外面时 <span
class="math inline">\(\sum a_i\times d_i\)</span>
的正负性会导致向里面调整更优。</p>
<h2 id="section-6">20220329</h2>
<h3 id="haltoj129powerful-number-筛">HaltOJ129(Powerful Number 筛)</h3>
<h4 id="思考-11">思考:</h4>
<p>打个表发现 <span class="math inline">\(f\)</span> 是积性函数。</p>
<p>然后 <span class="math inline">\(f(p^c)\)</span>
是好求的，考虑亚线性筛法。</p>
<p>我也不知道为啥会想到 PN 筛，总之这种东西各种筛法都可以尝试一下。</p>
<p>PN
筛和其它亚线性筛法一样，是用来求一些积性函数的前缀和的，它的关键在于构造一个好求的前缀和的
<span class="math inline">\(g\)</span>，满足 <span
class="math inline">\(g(p)=f(p)\)</span>，然后构造一个 <span
class="math inline">\(h\)</span> ，满足 <span class="math inline">\(f=h
* g\)</span>，乘法为迪利克雷卷积。</p>
<p>这里我们构造 <span class="math inline">\(g(x)=1\)</span></p>
<p>积性函数有个性质，<span
class="math inline">\(f(1)=1\)</span>，所以展开下 <span
class="math inline">\(f\)</span>，发现 <span
class="math inline">\(f(p)=1=h(1) * g(p)+h(p) * g(1)\)</span>，然后
<span class="math inline">\(h(p)=0\)</span>，由于 <span
class="math inline">\(h\)</span>
也是个积性函数（迪利克雷卷积的性质），所以 <span
class="math inline">\(h\)</span> 只会在 PN 处有取值，PN
的定义为每个质因子次数都大于等于 <span class="math inline">\(2\)</span>
的数。</p>
<p>可以证明所有比 <span class="math inline">\(n\)</span> 小的 PN 个数是
<span class="math inline">\(O(\sqrt n)\)</span> 的 。</p>
<p>可以预处理 <span class="math inline">\(\sqrt n\)</span>
以内的所有质数，然后枚举指数得到每个 PN，这个 <span
class="math inline">\(dfs\)</span> 的过程中可以记录一下对应的 <span
class="math inline">\(h\)</span>，<span class="math inline">\(h\)</span>
的转移是好做的，因为只需要求 <span
class="math inline">\(h(p^c)\)</span>。</p>
<p>这里不难发现 <span
class="math inline">\(h(p^c)=f(p^c)-f(p^{c-1})\)</span>。</p>
<p>原因是 <span class="math inline">\(g\)</span> 实际上是 <span
class="math inline">\(1\)</span>，而 <span class="math inline">\(f / 1 =
f * \mu\)</span></p>
<h2 id="section-7">20220331</h2>
<h3 id="考试t2"><a
href="https://https://local.cwoi.com.cn:8443//contest/C39/problem/A">20220330考试T2</a></h3>
<h4 id="思考-12">思考</h4>
<p>限制不好弄，考虑转化限制，不难发现，如果建图，并依次加入有向边，那么任意一个时刻，都需要满足当前图及其补图都是一个传递闭包，即，如果能间接
<span class="math inline">\(a\rightarrow b\)</span> ，那么 <span
class="math inline">\(a,b\)</span> 有边。这样的图不是很多，是 <span
class="math inline">\(n!\)</span> 个的，只需要考虑图之间的转移就行。</p>
<p>这样的图和一个 <span class="math inline">\(n\)</span>
的排列一一对应，构造方案为如果 <span class="math inline">\(a,b\)</span>
为逆序对，那么加入一条边 <span
class="math inline">\((a,b)\)</span>。加入一条边时，只需要枚举相邻的逆序对并交换，转移可以康托展开得到交换后的编号。限制也比较好做，转移的时候看看强制在前面的边在不在里面就行。</p>
<p>复杂度为 <span class="math inline">\(O(n!\times n \times
(n+m))\)</span>，常数较小，可以过。</p>
<h2 id="section-8">20220402</h2>
<h3 id="考试t1"><a
href="https://https://local.cwoi.com.cn:8443//contest/C41/problem/A">20220401考试T1</a></h3>
<h4 id="思考-13">思考</h4>
<p>对于这种翻转的博弈问题，其实都可以做一个转化：不要翻转颜色，而是在每个翻转的地方再放一个棋子，这样不会改变游戏的胜负性，因为如果原处没有棋子，那么等效，如果有棋子，那么有两个，在
<span class="math inline">\(SG\)</span>
的意义下，这是可以抵消的。如果以组合方式理解，那么因为放了之后如果有人操作了，那么另一个人把它的操作复制一遍即可，由于两个人都是最优操作，所以可以抵消。</p>
<p>有了这个转化，每个棋子都变成了一个独立的游戏，该局面的 <span
class="math inline">\(SG\)</span>
值就不难计算了，按照定义计算出每个位置的 <span
class="math inline">\(SG\)</span> 值然后异或查表即可。</p>
<h3 id="考试t3"><a
href="https://https://local.cwoi.com.cn:8443//contest/C41/problem/C">20220401考试T3</a></h3>
<h4 id="思考-14">思考</h4>
<p>场上写了个 <span class="math inline">\(O(n^3)\)</span>
卡常卡过去了，实际上 <span class="math inline">\(O(n^2)\)</span>
的有点难想，它是把构造表达式的过程视作了一个添加左右括号的过程，总之非常神仙。</p>
<p>有个对于区间 <span class="math inline">\(dp\)</span>
的常数优化思路，可以改变一下枚举顺序，让数组访问尽量连续，以便最大程度利用好
<span class="math inline">\(L1\)</span>，可以节省大量内存操作时间。</p>
<p>咕一篇常数优化文章。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>做题1</title>
    <url>/2022/07/12/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%981/</url>
    <content><![CDATA[<h2 id="section">2022.2.7</h2>
<h3 id="cf1634e">CF1634E</h3>
<h4 id="题意">题意：</h4>
<p>给定一些数组，长度都为偶数，需要将每个数组的元素划分到两个可重集合里，要求两个集合相同，问方案或输出无解，<span
class="math inline">\(n,m=10^5\)</span>。</p>
<h4 id="思考">思考：</h4>
<p>考虑每个数组单独划分，不太行，所以不能一个数组一个数组的考虑，显然有解的必要条件是每个数字个数为偶数。所以一个数字一个数字的考虑，其实也不太行，因为这和刚刚那种方法是本质上一样的。</p>
<p>注意到也保证每个数组长度为偶数<del>（这不是废话吗）</del>，都是偶数，不由得让我们想到欧拉回路，所以尝试建图，每个不同的数和数组视为一个点，由数组向数连边，数组内存在一个数，就由数组向这个数连一条边，现在需要给图定向为一张欧拉图，我们将数组向数连的边是为将这个数分到第一个集合，反之则为第二个，构造欧拉图即可。</p>
<h4 id="实现上的问题">实现上的问题：</h4>
<p>存边用 <code>set</code> 存，不然 <code>TLE</code> 没商量。</p>
<p>图不一定联通，所以一定要多起点。</p>
<h2 id="section-1">20220209</h2>
<h3 id="考试-t1">22020208考试 T1</h3>
<h4 id="题意-1">题意：</h4>
<p>定义矩阵 <span class="math inline">\(Mat_n\)</span></p>
<ul>
<li><span class="math inline">\(n = 0\)</span> 时，为一个 <span
class="math inline">\(1\)</span></li>
<li><span class="math inline">\(n &gt; 0\)</span> 时，左上角为 <span
class="math inline">\(0\)</span> 矩阵，其余部分为三个 <span
class="math inline">\(Mat_{n-1}\)</span>。</li>
</ul>
<p>在一个平面上画出两个 <span
class="math inline">\(Mat_n\)</span>，左下角分别为 <span
class="math inline">\((0,0),(x,y)\)</span>，求都为 <span
class="math inline">\(1\)</span> 的位置有多少个。</p>
<h4 id="思考-1">思考：</h4>
<p>考虑旋转矩阵转化为位运算计数问题，转化为求整数对 <span
class="math inline">\((i,j)\)</span> 满足
<code>(i&amp;j) == 0 and ((i+x)&amp;(j-y)) == 0</code></p>
<p>考场上看到要高精就润了，没有认真思考。</p>
<p>实际上可以考虑类似 数位dp 的算法，也不难。</p>
<h3 id="考试-t2后缀自动机复习">22020208考试 T2(后缀自动机复习)</h3>
<h4 id="题意-2">题意：</h4>
<p>给定一个字符串 <span class="math inline">\(s\)</span> ，<span
class="math inline">\(q\)</span> 次询问 <span
class="math inline">\(l,r\)</span>，表示所有 <span
class="math inline">\([l,r]\)</span>
开头的子串中本质不同的子串个数。</p>
<p><span class="math inline">\(n,q = 2 \times 10^5\)</span></p>
<h4 id="思考1">思考1：</h4>
<p>考虑后缀自动机求本质不同子串个数的方式，发现它可以在线完成。</p>
<p>所以反着建后缀自动机。</p>
<p>对于 <span class="math inline">\(r=n\)</span>
的部分分，显然先离线，可以建后缀自动机时统计下每一个结尾的答案，输出即可。</p>
<p>如果 <span class="math inline">\(r \neq
n\)</span>，那么不妨仍然考虑在后缀自动机上如何统计答案。</p>
<p>后缀自动机本质上维护的是 <span class="math inline">\(endpos\)</span>
集合，对于一个询问，如果一个 <span class="math inline">\(endpos\)</span>
集合中包含一个位置 <span
class="math inline">\(x\in[l,r]\)</span>，那么这个 <span
class="math inline">\(endpos\)</span>
集合所代表的子串应该被计入贡献。</p>
<p>后缀自动机上每个子串仅在一个 <span
class="math inline">\(endpos\)</span>
集合中出现，所以可以求出至少有一个元素被包含的集合，并直接加和。</p>
<p>考虑对于每个询问该如何统计答案，限制一共有两个 <span
class="math inline">\(l,r\)</span>，并不好做，然而我们发现后缀自动机是在线构建的，所以如果将询问离线，那么限制就只剩下一个
<span class="math inline">\(r\)</span>
了。我们在构建后缀自动机的同时只需要记录每个 <span
class="math inline">\(endpos\)</span> 集合最小的元素 <span
class="math inline">\(val\)</span>，查询时查询所有满足 <span
class="math inline">\(val \leq r\)</span>
的集合的子串数量和即可。考虑维护一个数组 <span
class="math inline">\(c\)</span>，<span
class="math inline">\(c[i]\)</span> 表示 <span class="math inline">\(val
= i\)</span> 的 <span class="math inline">\(endpos\)</span>
集合子串个数和，用 <span class="math inline">\(BIT\)</span>
查前缀和，现在只剩下修改了。</p>
<p>考虑 <span class="math inline">\(endpos\)</span>
树的性质，发现修改操作是把一段到根的路径赋值，同时还有修改父亲等操作，于是考虑动态树，我们不难发现一段实链上的集合，<span
class="math inline">\(val\)</span> 都是相同的，所以在每个节点维护一下
<span class="math inline">\(val,sum\)</span> 值即可，注意 <span
class="math inline">\(push\_down\)</span> 操作时需要把赋值也 <span
class="math inline">\(push\_down\)</span> 下去。</p>
<p>这样做未免显得有些麻烦，我们考虑最终构建的后缀自动机，倒序激活 <span
class="math inline">\(endpos\)</span> 中每一个点，这样就不需要 <span
class="math inline">\(Link\)</span> 和 <span
class="math inline">\(Cut\)</span> 操作，只需要写 <span
class="math inline">\(access\)</span> 就行。</p>
<p>实际上未必需要用后缀树来实现，通过激活点的方式，树已经时静态的了，这本质上还是一个区间染色问题，我们完全可以直接重链剖分，在每条重链上开个栈维护断点，记录下前缀和。</p>
<p>复杂度都是 <span
class="math inline">\(O(nlog_n^2)\)</span>，个人认为类似动态树的方法会好写一些。</p>
<h4 id="思考2">思考2：</h4>
<p>考虑使用后缀数组，回想后缀数组统计不同子串个数的方式，实际上就是排序后减掉相邻两个的
<span
class="math inline">\(lcp\)</span>，于是对原串后缀排序，然后离线询问莫队，拿个
<code>set</code> 维护当前所有串的排名集合，再来个 <span
class="math inline">\(ST\)</span> 表计算 <span
class="math inline">\(lcp\)</span>，插入和删除都很好写，复杂度 <span
class="math inline">\(O(n\sqrt n \ log_n)\)</span>，难以通过本题。</p>
<p>考虑优化，有一个技巧，这种需要查前驱后继的东西，实际上可以用链表搞，加入相对困难一些，因为我们不知道到底应该放在哪里，但删除就很容易了，双向链表上直接删就完事了，所以可以回滚莫队，非常无脑，时间复杂度
<span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<p>稍加卡常即可通过，<span class="math inline">\(ST\)</span>
表查询常数相对较大，卡常应考虑尽量减少查询次数。</p>
<h2 id="section-2">20220210</h2>
<h3 id="考试t3">20220208考试T3</h3>
<h4 id="恶心的题意"><a
href="https://https://local.cwoi.com.cn:8443//contest/C15/problem/C">恶心的题意</a></h4>
<h4 id="思考-2">思考</h4>
<p>发现由于编号连续，所以最后经过的一定是一段连续区间。想到可以枚举右端点，二分左端点。</p>
<p>一个区域到另一个区域的路径可以分为区域到中转站和中转站到中转站两部分，区域到中转站的情况可以只计算到左右两边最近的中转站，所以容易计算。</p>
<p>我们按照右端点顺序激活中转站，问题就是要最小化左端点。</p>
<p>两个中转站只能通过同一条线连接，把最低点也看成中转站，所以可以认为从一个中转站到另一个的代价为两者所在区域编号的较小值。</p>
<p>中转站到中转站的距离可以 <code>Floyd</code>
暴力，我们就已经计算出了每对中转站点相互抵达的代价，所以二分都不需要了，我们可以直接用这个代价计算出最终答案。</p>
<h4 id="实现细节">实现细节</h4>
<p><code>Floyd</code>
的时候，因为加入的中转站并不是按下标顺序，所以需要整个跑一遍。</p>
<h2 id="section-3">20220211</h2>
<h3 id="测试-t1">20220211 测试 T1</h3>
<h4 id="题意-3"><a
href="https://https://local.cwoi.com.cn:8443//contest/C18/problem/A">题意</a></h4>
<h4 id="思考-3">思考</h4>
<p>这道题算是考场上想出来的，考场上摸了一会儿鱼，发现有个地方假了的时候只剩
<span class="math inline">\(5min\)</span> 了，所以紧急修复成了<span
class="math inline">\(50pts\)</span>，实际上不管直接交有 <span
class="math inline">\(80pts\)</span>。</p>
<p>先把最上面那些没有的行删掉。</p>
<p>考虑每一行的可能性，只有穿过和不穿过两种，穿过又可以分为去的时候穿过和回的时候穿过。</p>
<p>来的时候穿过，回的时候一定不会穿过，因为一定不优，于是三进制枚举穿过状态，大的路径框架已经被构建出来了，现在要考虑经过那些没有穿过的点。</p>
<p>被穿过的行不用管，现在就剩没穿过的行，每一行可以从左到右，也可以从右到左，如果两边都有经过，还可以两面包夹，算出每一行的结果，然后加上去就行。</p>
<p>这样可以拿到 <span
class="math inline">\(80pts\)</span>，因为它处理不了这种情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 7</span><br><span class="line">#.....#</span><br><span class="line">.#####.</span><br><span class="line">.#####.</span><br></pre></td></tr></table></figure>
<p>它会穿过第一行和第二行，到第三行后穿过或者是走到底再回来，实际上在穿过第一行走到第二行的时候就应该上去拿掉右上角。</p>
<p>所以把大的路径画出来后，记录每一个边缘位置是否到达过，还要自下而上
<span class="math inline">\(dp\)</span>
一遍求出经过所有未经过的点的最小代价。</p>
<p>提供一种思路，设 <span class="math inline">\(dp[i][j][k]\)</span>
表示到第 <span class="math inline">\(i\)</span>
行，左右最前面的可以已经经过的点为 <span
class="math inline">\(j,k\)</span> 的最小代价，转移的时候看 <span
class="math inline">\(j,k\)</span> 是否大于 <span
class="math inline">\(i\)</span> 或者 <span
class="math inline">\(i\)</span>
的两端是否已经经过，如果可行，就选经过一行三种方案的最小值，如果不行，因为一定有一边已经经过，所以只考虑另一边是否补全和从经过的点走一遍再回来的情况，补全的方案有两种，从上面和从下面，直接转移即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n^3 *
3^n)\)</span>，实际上剪枝后跑的飞快，<span
class="math inline">\(10ms\)</span> 就跑完了。</p>
<h2 id="section-4">20220212</h2>
<h3 id="测试t2">20220212测试T2</h3>
<h4 id="题意-4"><a
href="https://https://local.cwoi.com.cn:8443//contest/C18/problem/B">题意</a></h4>
<h4 id="思考-4">思考:</h4>
<p>考虑直接 <span class="math inline">\(dp\)</span> 转移，设 <span
class="math inline">\(dp[i][j][k][0/1]\)</span> 表示考虑前 <span
class="math inline">\(i\)</span> 个数， 正色子已经用了 <span
class="math inline">\(j\)</span> 个，反色子已经用了 <span
class="math inline">\(k\)</span> 个，是否已经赢了的方案数，直接转移是
<span class="math inline">\(O(n^4 * t)\)</span> 的，可以拿到 <span
class="math inline">\(20pts\)</span> 的好成绩。</p>
<p>考虑优化，转移式子是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">0</span>;j2&lt;=i2;j2++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=t&amp;&amp;i1-j1&gt;i2-j2)</span><br><span class="line">    <span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">1</span>],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">0</span>]*C[n-j1][i1-j1]%mod*C[m-j2][i2-j2]%mod);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">0</span>],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">0</span>]*C[n-j1][i1-j1]%mod*C[m-j2][i2-j2]%mod);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">1</span>],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">1</span>]*C[n-j1][i1-j1]%mod*C[m-j2][i2-j2]%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转移目标</p>
<p><code>dp[i][i1][i2][1]</code></p>
<p>前面一部分</p>
<p><code>1ll*dp[i-1][j1][j2][0]*C[n-j1][i1-j1]</code></p>
<p>和后面一部分</p>
<p><code>C[m-j2][i2-j2]</code></p>
<p>只有前一部分依赖 <span
class="math inline">\(j1\)</span>，考虑能不能预处理前一部分的转移，然后优化一个
<span class="math inline">\(n\)</span></p>
<p>显然是可以的，手推一下式子可以得到一个新的转移。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">&#123;</span><br><span class="line">	sum[j1][i2]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>][<span class="number">1</span>]*C[m][i2]%mod;</span><br><span class="line">	sum2[j1][i2][<span class="number">0</span>]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>][<span class="number">0</span>]*C[m][i2]%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">1</span>;j2&lt;=i2;j2++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j1][j2][<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">Inc</span>(sum[j1][i2],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">1</span>]*C[m-j2][i2-j2]%mod);</span><br><span class="line">		sum2[j1][i2][j2]=sum2[j1][i2][j2<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j1][j2][<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">Inc</span>(sum2[j1][i2][j2],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">0</span>]*C[m-j2][i2-j2]%mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val=C[n-j1][i1-j1];</span><br><span class="line">	<span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">1</span>],<span class="number">1ll</span>*val*sum[j1][i2]%mod);</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> pos=i2+j1-i1,val1=pos&lt;<span class="number">0</span>?<span class="number">0</span>:sum2[j1][i2][pos],val2;</span><br><span class="line">		val2=sum2[j1][i2][i2];<span class="built_in">Dec</span>(val2,val1);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;t)<span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">0</span>],<span class="number">1ll</span>*val*val1%mod);</span><br><span class="line">		<span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">1</span>],<span class="number">1ll</span>*val*val2%mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化到了 <span class="math inline">\(O(n^3*t)\)</span>，记此时的常数
<span class="math inline">\(k = 1\)</span>，它需要约 <span
class="math inline">\(15s\)</span> 通过数据规模最大的测试点。</p>
<p>这份代码可以拿到 <span class="math inline">\(50pts\)</span>
的好成绩，感觉上已经不太能优化复杂度了，我们考虑卡常。</p>
<p>第一步，发现 <span class="math inline">\(n=6\)</span>
的时候只需要转移 <span class="math inline">\(dp[6][n][m][1]\)</span></p>
<p>第二步，发现 <span class="math inline">\(n=1\)</span>
的时候被转移的只有 <span
class="math inline">\(dp[0][0][0][0]\)</span></p>
<p>常数变为 <span class="math inline">\(k = \dfrac{2}{3}\)</span></p>
<p>此时可以拿到 <span class="math inline">\(70pts\)</span>
的好成绩。</p>
<p>继续考虑卡常。</p>
<p>发现其实在 <span class="math inline">\(i&gt;=t\)</span> 时转移 <span
class="math inline">\(dp[i][i1][i2][0]\)</span>
没有意义，直接剪掉。常数没有变化。</p>
<p>发现 <span class="math inline">\(dp[i][i1][i2][1]\)</span>
实际上可以由 <span class="math inline">\(dp[i][i1][i2][0]\)</span>
直接得到，所以只转移 <span
class="math inline">\(dp[i][i1][i2][0]\)</span> ，记作 <span
class="math inline">\(dp[i][i1][i2]\)</span>，常数变为 <span
class="math inline">\(k = \dfrac{1}{3}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&lt;=t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2=i==<span class="number">6</span>?m:<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[j1][i2][<span class="number">0</span>]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>]*C[m][i2]%mod;</span><br><span class="line">            <span class="type">int</span> *p=&amp;sum[j1][i2][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">1</span>;j2&lt;=i2;j2++)</span><br><span class="line">            &#123;</span><br><span class="line">                *p=sum[j1][i2][j2<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">Inc</span>(*p++,<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2]*C[m-j2][i2-j2]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i1=i==<span class="number">6</span>?n:<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=i==<span class="number">6</span>?m:<span class="built_in">max</span>(<span class="number">0</span>,i1-j1);i2&lt;=m;i2++)</span><br><span class="line">                <span class="built_in">Inc</span>(dp[i][i1][i2],<span class="number">1ll</span>*C[n-j1][i1-j1]*sum[j1][i2][i2+j1-i1]%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i2=i==<span class="number">6</span>?m:<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line">            sum[j1][i2][<span class="number">0</span>]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>]*C[m][i2]%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">1</span>;j2&lt;=i2;j2++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line">                <span class="built_in">Inc</span>(sum[j1][i2][<span class="number">0</span>],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2]*C[m-j2][i2-j2]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i1=i==<span class="number">6</span>?n:<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2=i==<span class="number">6</span>?m:<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line">                <span class="built_in">Inc</span>(dp[i][i1][i2],<span class="number">1ll</span>*sum[j1][i2][<span class="number">0</span>]*C[n-j1][i1-j1]%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的成绩还是 <span
class="math inline">\(70pts\)</span>，但我们可以观察一下代码，在 <span
class="math inline">\(i&gt;t\)</span>
后的转移实际上没有任何意义，可以直接计算，优化这一部分，可以拿到 <span
class="math inline">\(90pts\)</span> 的好成绩。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="built_in">min</span>(t,<span class="number">5</span>);i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[j1][i2][<span class="number">0</span>]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>]%mod*C[m][i2]%mod;</span><br><span class="line">            <span class="type">int</span> *p=&amp;sum[j1][i2][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">1</span>;j2&lt;=i2;j2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j1][j2]&gt;=mod)dp[i<span class="number">-1</span>][j1][j2]%=mod;</span><br><span class="line">                *p=sum[j1][i2][j2<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">Inc</span>(*p++,<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2]*C[m-j2][i2-j2]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="built_in">max</span>(<span class="number">0</span>,i1-j1);i2&lt;=m;i2++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i1][i2]+=<span class="number">1ll</span>*C[n-j1][i1-j1]*sum[j1][i2][i2+j1-i1];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][i1][i2]&gt;=<span class="number">8e18</span>)dp[i][i1][i2]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">Inc</span>(dp[<span class="number">6</span>][n][m],(n-i&lt;=m-j)*dp[<span class="number">5</span>][i][j]%mod);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,((<span class="built_in">quick</span>(<span class="number">6</span>,n+m)-dp[<span class="number">6</span>][n][m]%mod)+mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> all=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">Inc</span>(all,<span class="number">1ll</span>*dp[t][i][j]%mod*<span class="built_in">quick</span>(<span class="number">6</span>-t,n+m-i-j)%mod);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,((<span class="built_in">quick</span>(<span class="number">6</span>,n+m)-all)+mod)%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的 <span class="math inline">\(10pts\)</span>
可能需要一些卡常技巧。</p>
<p>我们发现实际上复杂度的瓶颈在数组寻址和取模，考虑优化其中之一，被寻址的数组经过循环变量的调整已经相当连续了，我们考虑优化取模。</p>
<p>用 <code>long long</code> 存 <span
class="math inline">\(dp\)</span>，每 <span
class="math inline">\(8\)</span> 次加法取一次模，可以通过本题。</p>
<p>一个很常见的，在取模运算较多时的优化技巧。</p>
<h3 id="测试t3">20220211 测试T3</h3>
<h4 id="题意-5"><a
href="https://https://local.cwoi.com.cn:8443//contest/C18/problem/C">题意</a></h4>
<h4 id="思考-5">思考：</h4>
<p>这道题暴力思路无非就二进制枚举和容斥。正解的做法很神仙。</p>
<p>在这种 <span class="math inline">\(\text{NP}\)</span>
问题中，我们完全可以考虑将枚举的部分减少，这道题的思路是对稀疏图删点变为森林，然后二进制枚举一些删掉的点的状况再进行树形
<span
class="math inline">\(dp\)</span>，着实是一个很有启发性的思路。</p>
<h2 id="section-5">20220212</h2>
<h3 id="cf1637f">CF1637F</h3>
<h4 id="思考-6">思考:</h4>
<p>对于这种条件为最小值的覆盖问题，我们不妨考虑最大的那个点是如何被覆盖的，首先有一个结论是只会在叶子有基站，证明简单，略去。然后考虑最大的那个点是如何被覆盖的，把它看作根，一定来源于它不同儿子的两个叶子，所以我们考虑其它点的时候一定可以认为这个根上的值为
<span class="math inline">\(\text{INF}\)</span>
，理由不多说了。所以每个点 <span class="math inline">\(u\)</span>
的包含的叶子至少有一个最大值为 <span
class="math inline">\(h_u\)</span>，贪心即可，最后决策最大值的点应该放在哪里，同样的贪心。</p>
<p>实现较为简单，没什么说的。</p>
<h2 id="section-6">20220225</h2>
<h3 id="haltoj116">haltoj116</h3>
<h4 id="思考-7">思考：</h4>
<p>考虑团和独立集的性质，我在考场上就想到了答案一定不多，极大概率无需取模这一特性，于是用类似分治的方式得到了
<span
class="math inline">\(60pts\)</span>，如果我们找出了一个合法解，那么其它合法解的构造也是简单的，考虑合法解的性质，不妨设团的大小为
<span class="math inline">\(s\)</span>
，那么因为独立集只能向团连边，所以独立集中的点最大度数为 <span
class="math inline">\(s\)</span>，而这样又导致了团中的点最小度数增加，所以我们不难发现团中的点一定是度数最大的那一段前缀。</p>
<p>对于度数相同的点，看似无法下手，但是我们知道边的构成是团内加上团和独立集之间，团内的边数我们是知道的，而如果记录一下团中点的总度数，我们可以很轻松的推出独立集间是否有边，我们设团内点的总度数为
<span class="math inline">\(p\)</span>,团的大小为 <span
class="math inline">\(i\)</span>，团内边数为 ，那么其他点之间的边数就为
<span
class="math inline">\((2*m-2*p+i*(i-1))/2\)</span>，所以我们考虑满足
<span class="math inline">\(2m + i * (i-1) = 2p\)</span>
这个条件的选择有什么性质，因为这是成立的必要条件，考虑证明这也是充分条件。如果团内边数不足
<span class="math inline">\(i*(i-1)\)</span>，那么我们发现 <span
class="math inline">\(p\)</span>
这边会减小。考虑如果独立集内边数有边，那么 <span
class="math inline">\(p\)</span>
这边一样相对减少，所以这也是充分条件。</p>
<p>这道题结束了。</p>
<h3 id="haltoj117">haltoj117:</h3>
<h4 id="思考-8">思考：</h4>
<p>考虑在原序列中是前缀 <span class="math inline">\(max\)</span>
的点，它们在新划分的序列中一定也是前缀 <span
class="math inline">\(max\)</span>，如果新增了前缀 <span
class="math inline">\(max\)</span>，那么我们可以很轻松的改变划分情况去除这个前缀
<span class="math inline">\(max\)</span>，所以如果原序列中前缀 <span
class="math inline">\(max\)</span>
的数量为偶数，就一定可以。如果为奇数，我们不妨考虑只有一个序列有新增的前缀
<span class="math inline">\(max\)</span>
的情况。我们考虑从原序列中抽出一个新序列出来，设两个序列的权值之差为
<span class="math inline">\(k\)</span>，如果抽了一个原先的前缀 <span
class="math inline">\(max\)</span>，那么 <span
class="math inline">\(k\)</span> 减少 <span
class="math inline">\(2\)</span>，如果新增了一个前缀 <span
class="math inline">\(max\)</span>，<span
class="math inline">\(k\)</span> 减少量为 <span
class="math inline">\(1\)</span>，所以我们将原先是前缀 <span
class="math inline">\(max\)</span> 的数的权值视为 <span
class="math inline">\(2\)</span>，其余的视为 <span
class="math inline">\(1\)</span>，问题就是是要选一个上升子序列，使得权值和为前缀
<span class="math inline">\(max\)</span>
的个数，这个问题就相当简单了。</p>
<h2 id="section-7">20220228</h2>
<h3 id="abc215h子集容斥的另一种思路">ABC215H(子集容斥的另一种思路)</h3>
<p>考虑霍尔定律，枚举不满足条件的子集 <span
class="math inline">\(mask\)</span>，可以用 <span
class="math inline">\(\text{FMT-DP}\)</span> 计算出必须由 <span
class="math inline">\(mask\)</span>
供给的白菜数量，考虑减少一个子集中的白菜使得不满足条件，就可以计算出最少需要吃多少个。问题变成了统计答案，我们发现对于一个
<span class="math inline">\(mask\)</span>
直接组合数计算然后相加会算重，又因为答案不是全集所以并不能简单容斥。而暴力计算强制每种白菜都选一个的复杂度是
<span class="math inline">\(O(3^n)\)</span> 的，我们仍然考虑应用 <span
class="math inline">\(\text{FMT-DP}\)</span>
计算答案。事实上，这种组合数问题都可以考虑这种方式。</p>
<p>设 <span class="math inline">\(f_{mask}\)</span> 表示所选白菜集合被
<span class="math inline">\(mask\)</span> 包含的方案数，设 <span
class="math inline">\(f&#39;_{mask}\)</span> 表示所选白菜种类集合恰好为
<span class="math inline">\(mask\)</span> 的方案数，列有等式。 <span
class="math display">\[
f&#39;_{mask} = f_{mask} - \sum\limits_{x \sub mask} f&#39;_{mask}
\]</span> 令 <span class="math inline">\(f[i][mask]\)</span>
表示当前子集为 <span class="math inline">\(mask\)</span> ，低 <span
class="math inline">\(i\)</span>
位不一定存在，但高位都严格符合要求的方案总数，列有</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>;mask&lt;<span class="number">1</span>&lt;&lt;n;mask++)&#123;</span><br><span class="line">        f[i][mask]=f[i<span class="number">+1</span>][mask];</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>&lt;&lt;i&amp;mask)f[i][mask]-=f[i<span class="number">+1</span>][mask^(<span class="number">1</span>&lt;&lt;i)],f[i][mask]%=mod;	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从 <span class="math inline">\(i+1\)</span> 推到 <span
class="math inline">\(i\)</span>
的过程中，因为高位已经强制存在了，所以我们减去的就是 <span
class="math inline">\(f[i][mask]\)</span> 中所有不存在第 <span
class="math inline">\(i\)</span> 位，但高位符合要求的情况。</p>
<p>最后计算出来的 <span class="math inline">\(f[0]\)</span> 就是上述的
<span class="math inline">\(f\)</span>。</p>
<p>然后这道题就好做了。</p>
<h2 id="section-8">20220301</h2>
<h3 id="考试-t1sam的进一步理解">考试 T1(SAM的进一步理解)</h3>
<h4 id="题意-6">题意：</h4>
<p>给定一颗字符在点上的 <span
class="math inline">\(\text{Trie}\)</span>，求 <span
class="math inline">\(\text{Trie}\)</span>
代表的所有字符串本质不同子串个数，顺便询问钦定字符大小关系后第 <span
class="math inline">\(k\)</span> 小的子串，保证 <span
class="math inline">\(\text{Trie}\)</span> 上字符随机且答案长度和不超过
<span class="math inline">\(800KB\)</span>。</p>
<h4 id="思考-9">思考：</h4>
<p>考场上想到可以类似 <span class="math inline">\(\text{SAM}\)</span>
一样乱搞，然后就写了 <span class="math inline">\(\text{dfs}\)</span>
构建 <span class="math inline">\(\text{SAM}\)</span>，<span
class="math inline">\(lst\)</span> 指针被置为它父亲插入后的 <span
class="math inline">\(p\)</span>，这个做法在数据随机的情况下是没有问题的，但是如果出现构造数据，它会没掉。</p>
<p>首先是如果拉一条 <span class="math inline">\(a\)</span>
链，链上每个点再挂一个 <span class="math inline">\(b\)</span>，然后
<span class="math inline">\(dfs\)</span> 回跳的时候重置 <span
class="math inline">\(q\)</span> 的来边到 <span
class="math inline">\(np\)</span> 时时间复杂度是 <span
class="math inline">\(O(n^2)\)</span> 的。</p>
<p>我所理解的 <span class="math inline">\(\text{SAM}\)</span>
时间复杂度正确性基于两个东西，一个是 <span
class="math inline">\(p\)</span>
的深度变化情况，这证明了第一次构建边的时候时间正确。在 <span
class="math inline">\(dfs\)</span> 构建 <span
class="math inline">\(SAM\)</span> 的时候，大量回溯操作会导致 <span
class="math inline">\(p\)</span>
深度的异常变化，这样就不对了。第二个是重置 <span
class="math inline">\(q\)</span> 的来边的循环，这个可以分析 <span
class="math inline">\(p\)</span> 的 <span
class="math inline">\(fa\)</span> 所代表最短字符串长度来理解，每次重置
<span class="math inline">\(q\)</span>
的来边，我们都认为是找到了一个更短的 <span
class="math inline">\(np\)</span>
所代表的字符串，不妨看成一个指针在插入的字符串上移动，它只会向右。重置完
<span class="math inline">\(p\)</span>
的来边再插入下个点的过程中，我们至少会跳到 <span
class="math inline">\(np\)</span> 处（只针对单个串），然后重设的 <span
class="math inline">\(p&#39;\)</span> 的 <span
class="math inline">\(fa\)</span> 的最短长度一定可以从 <span
class="math inline">\(np\)</span> 那里继承过来，所以指针只会右移。<span
class="math inline">\(dfs\)</span> 加入时同样导致了这个指针在 <span
class="math inline">\(\text{Trie}\)</span>
上乱跳，复杂度就没有了保证。</p>
<p>然后是正确性相关的问题，这种 <span
class="math inline">\(\text{SAM}\)</span>
写法会导致无效的空节点建立，比如说插入的时候就碰到了满足 <span
class="math inline">\(a[lst].ch[c]\)</span>
存在的情况，这样新建出来的点实际上是无效的，在绝大部分题目中这个无效点是不影响答案的，但是少部分写法会导致爆炸。</p>
<p>接下来讨论下 <span class="math inline">\(\text{BFS}\)</span>
建树的正确性。由于是按深度加点，所以 <span
class="math inline">\(a[lst].ch[c]\)</span>
一定是不存在的，因此绝不会导致无效节点的建立，时间复杂度证明不会，省略。</p>
<p>时间复杂度我并不会证明 emmmm.</p>
<h3 id="abc241h">ABC241H</h3>
<h4 id="思考-10">思考：</h4>
<p>生成函数套路题。</p>
<h2 id="section-9">20220302</h2>
<h3 id="arc136e">ARC136E</h3>
<h4 id="思考-11">思考：</h4>
<p>显然偶数链是很好走的，所以考虑从偶数边怎么到另一个节点，显然偶数只能选一个，我们先考虑不选偶数的情况。</p>
<p>定义 <span class="math inline">\(f[x]\)</span> 为 <span
class="math inline">\(x\)</span> 的最小质因数，<span
class="math inline">\(x\)</span> 能走到 <span
class="math inline">\(y\)</span> 的充要条件是 <span
class="math inline">\(y&gt;x,x+f[x]\leq y-f[y]\)</span>，如果 <span
class="math inline">\((x,y) = 1\)</span>，那么显然，因为 <span
class="math inline">\(x\)</span> 第一步至少走 <span
class="math inline">\(f[x]\)</span>，到 <span
class="math inline">\(y\)</span> 的最后一步至少走 <span
class="math inline">\(f[y]\)</span>。如果 <span
class="math inline">\((x,y) \neq 1\)</span>，设 <span
class="math inline">\(x = p \times f[x]\)</span>，则 <span
class="math inline">\(y\)</span> 至少为 <span
class="math inline">\((p+2)\times f[x]\)</span>，故结论仍然成立。</p>
<p>由此可以 <span class="math inline">\(x\)</span> 走不到 <span
class="math inline">\(y(y&gt;x)\)</span> 的充要条件为 <span
class="math inline">\(x+f[x]&gt;y-f[y]\)</span>，将每个点视为 <span
class="math inline">\((x-f[x],x+f[x]])\)</span>
，题目就是要求出一些区间的集合，使得所有区间有公共点，要求权值最大，不妨枚举公共点，然后差分计算即可。</p>
<p>考虑下偶数，实际上做法类似。</p>
<h2 id="section-10">20220303</h2>
<h3 id="agc027ehaltoj119">AGC027E&amp;&amp;haltoj119</h3>
<h4 id="思考-12">思考：</h4>
<p>观察不变量是这种变换题的思考方向之一，我们设 <span
class="math inline">\(a\)</span> 的权值为 <span
class="math inline">\(1\)</span> ，<span
class="math inline">\(b\)</span> 的权值为 <span
class="math inline">\(2\)</span>，总能发现权值和对 <span
class="math inline">\(3\)</span> 取模的结果不变。</p>
<p>先考虑一个字符串在什么情况下可以变成另一个字符串，权值相同显然是必要条件，其次，源串
<span class="math inline">\(s\)</span> 不能是交替串 <span
class="math inline">\(abababa\)</span>
这类，这有点困难，不妨先考虑变成一个字母的情况。</p>
<p>充要条件为权值相同且不交替，证明考虑归纳法。</p>
<p>现在考虑目标为一个字符串的情况。我们先贪心的匹配，用最少的字母构造出目标串，然后考虑调整剩下的部分使得它满足条件。如果特判掉交替串，我们发现只要权值相同且源串的一个前缀能和目标串贪心匹配上，那么一定可以变成目标串，于是考虑
<span class="math inline">\(dp[i]\)</span> 表示考虑到前 <span
class="math inline">\(i\)</span>
的源串字母，能贪心的对应上多少不同串，显然这样的贪心对应是不重不漏的，转移分为匹配
<span class="math inline">\(i+1\)</span> 和不匹配 <span
class="math inline">\(i+1\)</span> 两种，预处理一个类似 <span
class="math inline">\(nxt\)</span> 的东西可以做到线性。</p>
<h2 id="section-11">20220304</h2>
<h3
id="cf917dhaltoj122初探二项式反演">CF917D&amp;&amp;haltoj122(初探二项式反演)</h3>
<h4 id="思考-13">思考：</h4>
<p>考场上已经观察出原题需要求一张完全图有多少棵最小生成树与给定树至少有
<span class="math inline">\(n-k-1\)</span> 条边相同。<span
class="math inline">\(prufer\)</span> 序列有一个结论，<span
class="math inline">\(n\)</span> 个点 <span
class="math inline">\(k\)</span>
个连通块的图构成有标号无根树的方案总数为 <span class="math display">\[
n^{k-2}\times\prod_{i=1}^{k} sz[i]
\]</span> 显然我不会证明。场上看到 <span
class="math inline">\(n\)</span> 仅为 <span
class="math inline">\(50\)</span> 就想乱搞，误打误撞弄了一个容斥 <span
class="math inline">\(dp\)</span>
出来，实际上正解差不多就是这个。我们考虑钦定选了 <span
class="math inline">\(k\)</span> 条边一定存在的方案总数 <span
class="math inline">\(f(k)\)</span>，由二项式反演的套路可以得知恰好
<span class="math inline">\(k\)</span> 条边存在的方案数 <span
class="math inline">\(g(k)\)</span> 满足 <span class="math display">\[
g(k) = \sum_{i=k}^{n-1}(-1)^{i-k}\times C(i,k) \times f(i)
\]</span> 其中 <span class="math inline">\(C(i,j)\)</span>
表示组合数。</p>
<p>显然我仍然不会证明，但是可以感性理解下，首先 <span
class="math inline">\(f(k)\)</span> 满足以下式子 <span
class="math display">\[
f(k) = \sum_{i=k}^{n-1}C(i,k) \times g(i)
\]</span> 这个很好理解，枚举实际上选了多少条边，钦定 <span
class="math inline">\(k\)</span>
条边的方案数就是从实际选的边中钦定一些出来。注意这个钦定和至少有区别，不是简单的后缀和，因为实际选一条边的方案可以被多种钦定的情况包含。</p>
<p>我不会证明二项式反演的式子，所以我们从容斥的角度来考虑 <span
class="math inline">\(g(k)\)</span>，第一项为钦定 <span
class="math inline">\(k\)</span> 条边，然后减去被多考虑了的存在 <span
class="math inline">\(k+1\)</span>
条边的情况，依此类推。组合数的存在则是因为 <span
class="math inline">\(f(i)\)</span> 会被额外考虑 <span
class="math inline">\(C(i,k)\)</span> 次。</p>
<p><span class="math inline">\(f\)</span> 肯定比 <span
class="math inline">\(g\)</span> 好算，我们现在需要计算的是选 <span
class="math inline">\(k\)</span>
条边，然后得到的联通块组成不同有标号无根生成树的方案数。注意到生成树计数公式中
<span class="math inline">\(n^{k-2}\)</span>
与怎么选边完全无关，所以只需要记录一下 <span class="math inline">\(\prod
sz_i\)</span>，这个就可以 <span
class="math inline">\(dp[i][j][k]\)</span> 表示考虑以 <span
class="math inline">\(i\)</span> 为根的子树，选了 <span
class="math inline">\(j\)</span> 条边，<span
class="math inline">\(i\)</span> 所在连通块大小为 <span
class="math inline">\(k\)</span> 的方案数。优化的话，可以考虑 <span
class="math inline">\(\prod sz_i\)</span>
的组合意义。于是就是需要在每个连通块内选一个代表元，于是状态第三维简化为是否选了代表元，复杂度
<span class="math inline">\(O(n^2)\)</span>。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>写法优美的常用函数</title>
    <url>/2022/07/12/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E5%86%99%E6%B3%95%E4%BC%98%E7%BE%8E%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="写法优美的常用函数">写法优美的常用函数</h2>
<p>收录一些优美的常用函数写法。</p>
<h3 id="分解质因数">分解质因数</h3>
<p>有人根本不会用 <code>do while</code> 和 <code>vector</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">do</span> n/=i; <span class="keyword">while</span>(n%i==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="scc">SCC</h3>
<p>缩点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> low=dfn[u]=++df;st[++top]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])<span class="built_in">cmin</span>(low,<span class="built_in">dfs</span>(v));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!scc[v])<span class="built_in">cmin</span>(low,dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low==dfn[u])&#123;</span><br><span class="line">		++cnt;<span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">do</span> val[cnt]+=a[v=st[top--]],scc[v]=cnt; <span class="keyword">while</span>(v!=u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路-dijskstra">最短路 Dijskstra</h3>
<p>如果 <span class="math inline">\(dis\times n\le 8\times
10^{18}\)</span>，完全可以它们压成一个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;LL,vector&lt;LL&gt;,greater&lt;LL&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">1</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">	dis[s]=<span class="number">0</span>;q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">top</span>()%M;q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;vis[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(vis[t])<span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=a[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=a[i].v,w=a[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[u]+w&gt;=dis[v])<span class="keyword">continue</span>;</span><br><span class="line">			dis[v]=dis[u]+w;q.<span class="built_in">push</span>(dis[v]*M+v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
  </entry>
  <entry>
    <title>网络流相关</title>
    <url>/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="网络流">网络流</h2>
<p>内容主要为自己对网络流的一些理解和一些典例。</p>
<h3 id="一些约定">一些约定：</h3>
<ul>
<li>s 为源点，t 为汇点</li>
<li>对于集合 <span class="math inline">\(S,T,T\subseteq S\)</span>，约定
<span class="math inline">\(S-T\)</span> 为从 <span
class="math inline">\(S\)</span> 中删掉 <span
class="math inline">\(T\)</span> 中每个元素之后的集合</li>
<li>网络流图为 <span class="math inline">\(G=(V,E)\)</span>，边 <span
class="math inline">\((u,v)\)</span> 容量记为 <span
class="math inline">\(c_{u,v}\)</span></li>
</ul>
<h3 id="最大流最小割定理和增广路定理">最大流最小割定理和增广路定理</h3>
<p>这两个定理是网络流问题的核心定理。</p>
<h4 id="内容">内容</h4>
<p>最大流 = 最小割。</p>
<p>残量网络中不存在增广路是当前流为最大流的充要条件。</p>
<h4 id="证明">证明</h4>
<ol type="1">
<li><p>若当前流为最大流，显然不存在增广路。</p></li>
<li><p>若当前流等于某个割，显然当前流为最大流，且该割为最小割。</p></li>
<li><p>若不存在增广路，我们证明当前流等于一个割。</p></li>
</ol>
<p>令 <span class="math inline">\(S=\{v,\exist\
p_{s,v}\}\)</span>，<span class="math inline">\(S\)</span> 即 <span
class="math inline">\(s\)</span> 在残量网络中能到达的点的集合。令 <span
class="math inline">\(T=V-S\)</span>。显然 <span
class="math inline">\((S,T)\)</span> 是一个割，对于当前残量网络 <span
class="math inline">\(G&#39;=(V,E&#39;)\)</span>，一定有 <span
class="math inline">\(\forall x \in S,\forall y\in T\)</span>，边 <span
class="math inline">\((x,y)\)</span> 满流，否则 <span
class="math inline">\(y\in S\)</span>。容易证明当前流恰好为 <span
class="math inline">\(S\)</span> 到 <span
class="math inline">\(T\)</span>
的所有边的容量和，也就是割的大小。因为此时原图 <span
class="math inline">\(S\)</span> 到 <span
class="math inline">\(T\)</span> 所有的边流量为容量，<span
class="math inline">\(T\)</span> 到 <span
class="math inline">\(S\)</span> 的边流量为 <span
class="math inline">\(0\)</span>，所以流量为 <span
class="math inline">\(S\)</span> 到 <span
class="math inline">\(T\)</span> 的边的流量之和，也就是割 <span
class="math inline">\(S,T\)</span>。</p>
<h3 id="算法">算法</h3>
<h4 id="dinic">Dinic</h4>
<p>考虑对残量网络 bfs 分层，强制流量只能流向下一层，再进行一次
dfs，求限制下所有的增广路，搞定。</p>
<p>复杂度 <span class="math inline">\(O(n^2m)\)</span></p>
<p>每次增广复杂度为 <span class="math inline">\(O(nm)\)</span>，共计增广
<span class="math inline">\(n\)</span> 次，因为每次增广都会让 <span
class="math inline">\(dep[t]\)</span> 增加 1。</p>
<p>每次增广的复杂度不是很好证，但加了当前弧优化其实就很松。</p>
<p>代码记在脑子里了，不放了。</p>
<h4 id="isap">ISAP</h4>
<p>咕咕咕</p>
<h4 id="hlpp">HLPP</h4>
<p>咕咕咕</p>
<h3 id="费用流相关">费用流相关</h3>
<p>一般指最小费用最大流，暂时没啥感觉，不写。</p>
<h2 id="最小割">最小割</h2>
<p>非常常见的一个网络流模型应用。</p>
<h3 id="核心思想">核心思想</h3>
<p>通过构造一个图的割到决策方案的映射，其中决策必须可拆分计算，求出最小的代价，一般来说决策的限制如果比较奇怪就应该考虑最小割。</p>
<p>常用于规划 <span class="math inline">\(0/1\)</span>
独立贡献决策问题。</p>
<h3 id="适用条件">适用条件</h3>
<ul>
<li>不能存在负容量边权，我不知道有没有人会，反正我是不会。</li>
</ul>
<h3 id="最大闭合权子图问题">1.最大闭合权子图问题</h3>
<p>给定一张有向图，点带权（权可以为负），选一个子图出来，要求如果 <span
class="math inline">\(u\)</span> 选了那如果存在 <span
class="math inline">\((u,v)\)</span>，那 <span
class="math inline">\(v\)</span> 也要选。求最大权值和。</p>
<p>决策贡献独立，决策类型为 0/1。应该可以最小割。令割中与 <span
class="math inline">\(s\)</span> 同集合的点为选择的点，与 <span
class="math inline">\(t\)</span>
同一个集合的点为未选择的点。那么每个点应该和 <span
class="math inline">\(t\)</span>
连一条流量为权值的相反数的边，代表选它的代价，再对于每条 <span
class="math inline">\((u,v)\)</span> 从 <span
class="math inline">\(u\)</span> 向 <span
class="math inline">\(v\)</span> 连一条 inf 边,代表选了 <span
class="math inline">\(u\)</span> 不选 <span
class="math inline">\(v\)</span>
的代价。考虑这张图的一个最小割，它必然不会包含 inf
边，也就是说，我们选了 <span class="math inline">\(u\)</span> 在 <span
class="math inline">\(s\)</span> 中一定会让 <span
class="math inline">\(v\)</span> 在 <span
class="math inline">\(s\)</span>
中，所以一定合法。然后发现原问题的每一个答案都可以和图上的一个不含 inf
边的割一一对应，故最小割就是原问题的答案的相反数。</p>
<p>这张图有负数，不行，所以考虑先默认选所有正数。那么选负数的代价为相反数，不选正数的代价为本身。</p>
<p>那么应该从 <span class="math inline">\(s\)</span>
向正权点连边，从负权点向 <span class="math inline">\(t\)</span>
连边，最后对于 <span class="math inline">\((u,v)\)</span> 从 <span
class="math inline">\(u\)</span> 向 <span
class="math inline">\(v\)</span> 连 inf 边即可。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>一些科技的总结</title>
    <url>/2022/07/12/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E4%B8%80%E4%BA%9B%E7%A7%91%E6%8A%80%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="总结一些科技">总结一些科技</h2>
<p>主要收录比较神仙的，实用的算法技巧。</p>
<h3 id="快速取模">快速取模</h3>
<h4 id="原理">原理</h4>
<p>找到一个近似 <span class="math inline">\(m^{-1}\)</span> 的形如 <span
class="math inline">\(m&#39;&gt;&gt;k\)</span> 的数。</p>
<p>不妨就取 <span
class="math inline">\(k=64,m&#39;=\lceil\frac{2^{64}}{m}\rceil\)</span></p>
<p>然后 <span class="math inline">\(a\%b =
a-a\times\lfloor\frac{a}{b}\rfloor = a-(a\times
m&#39;&gt;&gt;64)\)</span></p>
<p>纯纯的整数运算，经过误差分析，可以知道后式结果最多多减去一个 <span
class="math inline">\(m\)</span>，判断掉就行。</p>
<p>因为 <span class="math inline">\(a\)</span> 常常是 <span
class="math inline">\(\text{long long}\)</span> 级别的数，所以开
<code>__int128</code></p>
<p>优化据说有 <span class="math inline">\(5-6\)</span> 倍，如果模数是
<code>const</code>，编译器会自动帮忙用这个优化。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">barrett</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> im;<span class="type">int</span> m;</span><br><span class="line">	<span class="built_in">barrett</span>(<span class="type">unsigned</span> m) :<span class="built_in">m</span>(m), <span class="built_in">im</span>(~<span class="number">0ull</span>/m<span class="number">+1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> z=(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)a*b;</span><br><span class="line">		<span class="type">int</span> v=z-((__int128)z*im&gt;&gt;<span class="number">64</span>)*m;</span><br><span class="line">		<span class="keyword">return</span> v&lt;<span class="number">0</span>?v+m:v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="built_in">bt</span>(<span class="number">1</span>);</span><br><span class="line">  bt=<span class="built_in">barrett</span>(p);</span><br><span class="line">  c=<span class="built_in">bt</span>(a,b);</span><br><span class="line"><span class="comment">//c=a*b%p</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项">注意事项</h4>
<ul>
<li>为啥 <code>im,m</code> 用 <code>ull,uint</code>，因为
<code>m=2</code> 时，会爆 <code>long long</code>。</li>
<li>可以重载括号。</li>
</ul>
<h3 id="光速乘">光速乘</h3>
<p>用于计算两个 long long 级别的数乘积对一个 long long
级别的数取模的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">multi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> mod)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> x=(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)a*b-(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)((<span class="type">long</span> <span class="type">double</span>)a*b/mod<span class="number">-0.5</span>)*mod;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=mod?x-mod:x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> A, <span class="type">long</span> <span class="type">long</span> B, <span class="type">long</span> <span class="type">long</span> P)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> C = A * B - (<span class="type">long</span> <span class="type">long</span>)((<span class="type">long</span> <span class="type">double</span>)A * B / P + <span class="number">0.1</span>) * P;</span><br><span class="line">	<span class="keyword">return</span> C &lt; <span class="number">0</span> ? C + P : C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理很简单，long double 的精度误差虽然有，但是我们 -0.5
之和核查范围变成了 [0,1]，肯定不会超出这个。</p>
<p>C++ 标准中要求了 unsigned long long 类型在溢出后保证为原值对 <span
class="math inline">\(2^{64}\)</span> 取模的结果，所以直接用就行。</p>
<p>第二个原理类似，在 G++ 编译器中，O2 中，保证 long long
的溢出行为有定义。</p>
<p>推荐用第一个，各个平台都不会出锅。</p>
<p>如果 <span class="math inline">\(P\leq 10^{14}\)</span> 可以改成
double</p>
<p>判断一下是否减少了就行。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>常用数学结论证明汇总</title>
    <url>/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AE%BA%E8%AF%81%E6%98%8E%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="简单事实">简单事实</h3>
<ol type="1">
<li><span class="math inline">\(\gcd(a,x_1)=1,\gcd(a,x_2)=1 \iff
\gcd(a,x_1x_2)\)</span></li>
<li>若 <span class="math inline">\(n\ |\ m\)</span> 则 <span
class="math inline">\(\phi(n)\ |\ \phi(m)\)</span></li>
<li>若 <span class="math inline">\(\gcd(a,p)=1\)</span>,则 <span
class="math inline">\(ax,x \in [1,p]\)</span> 模 <span
class="math inline">\(p\)</span> 意义下互不相同，反之亦然。</li>
</ol>
<h3 id="模运算和满足的运算率">模运算和满足的运算率</h3>
<p>注：符号均为模 <span class="math inline">\(p\)</span> 意义下。</p>
<ul>
<li>加法交换律</li>
<li>加法结合律</li>
<li>乘法交换律</li>
<li>乘法结合率</li>
<li>如果 <span class="math inline">\(p\)</span> 为质数 ，<span
class="math inline">\(g\)</span> 为 <span
class="math inline">\(p\)</span> 的一个原根，则 <span
class="math inline">\(\log_x(y) = \frac{\log_g(y)}{\log_g(x)} \pmod
{p-1}\)</span></li>
</ul>
<h3 id="复数运算满足的运算性质">复数运算满足的运算性质</h3>
<ul>
<li>加法交换律</li>
<li>加法结合律</li>
</ul>
<h3 id="一些抽象代数内容">一些抽象代数内容</h3>
<h4 id="事实1">事实1</h4>
<p>令 <span class="math inline">\(g\)</span> 为 <span
class="math inline">\(p\)</span> 的一个原根，记 <span
class="math inline">\(\log_g(x) = y\)</span>，模 <span
class="math inline">\(p\)</span> 意义下 <span
class="math inline">\(x\)</span> 的阶数为 <span class="math display">\[
\Large ord = \frac{\phi(p)}{\gcd(\phi(p),\log_g(x))}
\]</span></p>
<h4 id="证明1">证明1</h4>
<p>显然 <span class="math inline">\(g\)</span> 的阶数为 <span
class="math inline">\(\phi(p)\)</span>，又因为 <span
class="math inline">\(g^y = x\)</span>。所以 <span
class="math inline">\(x^{ord} = 1\)</span>。</p>
<p>然后证明 <span class="math inline">\(x^i,i \in [1,ord]\)</span>
互不相同。</p>
<p>反证，如果相同，设为 <span class="math inline">\(i,j(i\ge
j)\)</span>，那么 <span class="math inline">\(g^{yi} = g^{yj}\)</span>
得到 <span class="math inline">\(\phi(x) |\ y(i-j)\)</span> 两边同时除以
<span class="math inline">\(\gcd(\phi(p),y)\)</span>，得到 <span
class="math inline">\(ord |\ y&#39;(i-j)\)</span>，其中 <span
class="math inline">\(\gcd(y&#39;,ord) = 1\)</span> ，得出 <span
class="math inline">\(i-j \ge ord\)</span> 矛盾。</p>
<p>所以 <span class="math inline">\(x\)</span> 的阶数为 <span
class="math inline">\(ord\)</span></p>
<h3 id="裴蜀定理">裴蜀定理</h3>
<h4 id="内容">内容</h4>
<p><span class="math inline">\(\exist\  x,y \in \Z\)</span> 使得 <span
class="math inline">\(ax+by=\gcd(x,y)\)</span></p>
<h4 id="证明">证明</h4>
<p>归纳构造。</p>
<p>先证明 <span class="math inline">\(\exist\ x&#39;,y&#39;\in
\Z\)</span> 使得 <span class="math inline">\(bx&#39;+(a\%b)y&#39; =
\gcd(a,b)\)</span></p>
<p>即 <span class="math inline">\(ay&#39; +
b(x&#39;-\big\lfloor\dfrac{a}{b}\big\rfloor y&#39;) =
\gcd(a,b)\)</span></p>
<p>构造 <span class="math inline">\(x = y&#39;,y=x&#39;-
\big\lfloor\dfrac{a}{b}\big\rfloor y&#39;\)</span> 即可满足条件。</p>
<p>递归证明构造式子，得到边界证明 <span class="math inline">\(\exist \
x,y\)</span> 使得 <span class="math inline">\(\gcd(a,b)x + 0 \times y
=\gcd(a,b)\)</span></p>
<p>令 <span class="math inline">\(x=1,y=0\)</span></p>
<h3 id="欧拉函数是积性函数">欧拉函数是积性函数</h3>
<p>即证明若 <span class="math inline">\(\gcd(n,m) =1,\)</span> 则 <span
class="math inline">\(\phi(n*m) = \phi(n) *\phi(m)\)</span></p>
<h4 id="证明一">证明一</h4>
<p>考虑若干个同余方程组 <span class="math display">\[
x ≡ r_1 \pmod n\\
x ≡ r_2 \pmod m\\
\]</span> 列出 <span class="math inline">\(n,m,nm\)</span>
意义下的最小缩系 <span class="math inline">\(S_n,S_m,T\)</span></p>
<p>容易证明 <span class="math inline">\(\forall\ r_1\in S_n, r_2 \in
S_m\)</span>，存在唯一 <span class="math inline">\(x \in [1,nm]\)</span>
是上同余方程组的解，且 <span class="math inline">\(x \in
T\)</span>。</p>
<p>存在唯一就是 EXCRT， <span class="math inline">\(x\in T\)</span>
由事实 1 显然。</p>
<p>故 <span class="math inline">\(\phi(n*m) \ge \phi(n)
*\phi(m)\)</span></p>
<p>再证明 <span class="math inline">\(\forall\ x\in
T\)</span>，可以对应一个以上同余方程组的解，假设不对应，那么它一定与
<span class="math inline">\(n,m\)</span> 中的一个不互质，由事实 1
推出矛盾。</p>
<p>故 <span class="math inline">\(\phi(n*m) \le \phi(n)
*\phi(m)\)</span></p>
<p>证毕。</p>
<h4 id="证明二">证明二</h4>
<h3 id="欧拉定理">欧拉定理</h3>
<h4 id="内容-1">内容</h4>
<p><span class="math display">\[
\Large 若 \ \gcd(a,m)= 1 ,\ 则\  a^{\phi(m)}≡1\mod m
\]</span></p>
<h4 id="证明-1">证明</h4>
<p>考虑模 <span class="math inline">\(m\)</span>
意义下的最小缩系，即最小完全剩余系删去与 <span
class="math inline">\(m\)</span> 不互质的元素后的剩余系，记为 <span
class="math inline">\(S\)</span>。</p>
<p>构造 <span class="math inline">\(T = \{ax,x \in S\}\)</span></p>
<p>可以证明 <span class="math inline">\(T=S\)</span>， 若 <span
class="math inline">\(\exist\ x_1,x_2\)</span> 使得 <span
class="math inline">\(x_1\neq x_2\)</span> 且 <span
class="math inline">\(ax_1 ≡ ax_2 \pmod m\)</span> ，因为 <span
class="math inline">\(\gcd(a,m)=1\)</span></p>
<p>所以 <span class="math inline">\(m\ |\ x_1 - x_2\)</span>，并推出
<span class="math inline">\(x_1 \neq x_2\)</span>，故 <span
class="math inline">\(T\)</span> 中元素两两不同且均与 <span
class="math inline">\(m\)</span> 互质，即为 <span
class="math inline">\(S\)</span>。</p>
<p>考虑 <span class="math inline">\(T,S\)</span> 中所有元素的乘积，得到
<span class="math inline">\(\prod\limits_{i=1}^{\phi(n)} ax_i ≡
\prod\limits_{i=1}^{\phi(n)} x_i \pmod n\)</span>，又因为 <span
class="math inline">\(\prod\limits_{i=1}^{\phi(n)} x_i\)</span> 与 <span
class="math inline">\(m\)</span> 互质，所以 <span
class="math inline">\(a^{\phi(n)} ≡ 1\pmod n\)</span></p>
<h3 id="扩展欧拉定理">扩展欧拉定理</h3>
<h4 id="内容-2">内容</h4>
<p><span class="math display">\[
\Large 若 \ b≥φ(m) ,\ 则\  a^b≡a^{b \mod φ(m) +φ(m)}\mod m
\]</span></p>
<h4 id="证明-2">证明</h4>
<p>对 <span class="math inline">\(m\)</span> 考虑唯一分解定理。</p>
<p>对于任意因子 <span class="math inline">\(p_i^{k_i}\)</span>，若与
<span class="math inline">\(a\)</span> 互质，那就有 <span
class="math inline">\(a^b≡a^{b \mod φ(m) +φ(m)}\mod
p^{k_i}_i\)</span>。</p>
<p>如果和 <span class="math inline">\(a\)</span> 不互质，因为 <span
class="math inline">\(b\ge \phi(m)\)</span>，那么因为有 <span
class="math inline">\(b\ge \phi(m)\ge k_i\)</span>，所以 <span
class="math inline">\(a^b,a^{(b \mod φ(m)) +φ(m)}\)</span> 都是 <span
class="math inline">\(p^{k_i}_i\)</span> 的倍数。</p>
<p>得到 <span class="math inline">\(a^b - a^{(b \mod φ(m))
+φ(m)}\)</span> 是 <span class="math inline">\(p_i^{k_i}\)</span>
的倍数，故同余。</p>
<h3 id="原根">原根：</h3>
<h4 id="定义">定义：</h4>
<p>如果 <span class="math inline">\(x^1,x^2,x^3 \cdots
x^{\phi(n)}\)</span> 模 <span class="math inline">\(n\)</span>
意义下互不相同，且 <span
class="math inline">\(\gcd(x,n)=1\)</span>，则称 <span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(n\)</span> 的原根。</p>
<h4 id="性质">性质:</h4>
<p>质数 <span class="math inline">\(p\)</span> 的原根的方幂能取遍 <span
class="math inline">\([1,p-1]\)</span></p>
<h4 id="求质数的原根">求质数的原根</h4>
<p>数学大佬证明了一个数 <span class="math inline">\(n\)</span>
的最小正原根不超过 <span
class="math inline">\(n^{\frac{1}{4}+\epsilon}\)</span>，所以枚举每个数，检查所有
<span class="math inline">\(n\)</span> 的约数是否是 <span
class="math inline">\(a\)</span> 的阶，如果不是，那么 <span
class="math inline">\(a\)</span> 为一个原根，复杂度 <span
class="math inline">\(\sqrt n\)</span>，瓶颈在分解质因数。</p>
<h4 id="应用">应用</h4>
<p>开离散对数的时候上原根和换底公式有奇效。</p>
<h4 id="原根存在定理">原根存在定理</h4>
<p>一个数 <span class="math inline">\(x\)</span> 有原根当且仅当 <span
class="math inline">\(x= 2,4,p^n,2\times p^n\)</span>，其中 <span
class="math inline">\(p\)</span> 为奇素数。</p>
<p>证明不会。</p>
<h3 id="中国剩余定理">中国剩余定理</h3>
<p>咕咕咕</p>
<h3 id="平面图欧拉定理">平面图欧拉定理</h3>
<p>顶点数-边数-连通块数+区域数=1</p>
<h3 id="几何体欧拉定理">几何体欧拉定理</h3>
<p>顶点数-边数+面数=2</p>
<h3 id="除法下取整相关">除法下取整相关：</h3>
<ol type="1">
<li><span class="math inline">\(\lfloor\frac{a}{b}\rfloor\ge x\iff b\le
\lfloor\frac{a}{x}\rfloor\)</span>
<ul>
<li>含义：<span
class="math inline">\(b=\lfloor\frac{a}{x}\rfloor\)</span> 是满足 <span
class="math inline">\(\lfloor\frac{a}{b}\rfloor\ge x\)</span> 的最大的
<span class="math inline">\(b\)</span>。</li>
</ul></li>
<li><span class="math inline">\(\lfloor\frac{a}{b}\rfloor&lt; x \iff
b&gt;\lfloor\frac{a}{x}\rfloor\)</span>
<ul>
<li>上面那个反过来。</li>
</ul></li>
<li><span
class="math inline">\(\big\lfloor\dfrac{\lfloor\frac{n}{a}\rfloor}{b}\big\rfloor=\lfloor\dfrac{n}{ab}\rfloor\)</span>
<ul>
<li>设 <span class="math inline">\(n=kab+r,r&lt; ab\)</span>，则 <span
class="math inline">\(\lfloor\frac{n}{a}\rfloor&lt;(k+1)b\)</span>，自然有
<span
class="math inline">\(\big\lfloor\dfrac{\lfloor\frac{n}{a}\rfloor}{b}\big\rfloor\le
\lfloor\dfrac{n}{ab}\rfloor\)</span>。又因为 <span
class="math inline">\(\lfloor\frac{n}{a}\rfloor\ge kb\)</span>，因此
<span
class="math inline">\(\big\lfloor\dfrac{\lfloor\frac{n}{a}\rfloor}{b}\big\rfloor\ge
\lfloor\dfrac{n}{ab}\rfloor\)</span>，得证。</li>
</ul></li>
</ol>
<h3 id="余数相关">余数相关</h3>
<ol type="1">
<li>若 <span class="math inline">\(\gcd(x,y)=1,k\in[0,y)\)</span>，则
<span class="math inline">\(kx\pmod y\)</span> 互不相同。
<ul>
<li>证明反证法，移到同一边然后是倍数。</li>
</ul></li>
</ol>
<h3 id="解析几何相关">解析几何相关</h3>
<ol type="1">
<li><span class="math inline">\((x_0,y_0)\)</span> 关于 <span
class="math inline">\(y=x+m\)</span> 的对称点：<span
class="math inline">\((y_0 - m,x_0 + m)\)</span>。</li>
<li><span class="math inline">\((x_0,y_0)\)</span> 关于 <span
class="math inline">\(y=-x+m\)</span> 的对称点：<span
class="math inline">\((- y_0 + m,- x_0 + m)\)</span>。</li>
</ol>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数学算法汇总</title>
    <url>/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="数学算法介绍">数学算法介绍</h1>
<p>主要介绍一些数学相关的算法。</p>
<h2 id="多项式">多项式</h2>
<ul>
<li>DFT:离散傅里叶变换，方式有两种， FFT 和 NTT。</li>
<li>IDFT:逆离散傅里叶变换。</li>
</ul>
<h3 id="fft-多项式乘法">FFT 多项式乘法</h3>
<p><del>最开始学这玩意的时候感觉非常迷，后面数学水平上去了其实也不难。</del></p>
<p>多项式有两种表示方法，一种是系数法，另一种是点值法，总所周知 <span
class="math inline">\(n\)</span> 个不同点唯一确定一个 <span
class="math inline">\(n-1\)</span> 次多项式。</p>
<p>原理：多项式的两个系数表达式相乘是 <span
class="math inline">\(O(n^2)\)</span> 的，但是其点值表达式相乘却是 <span
class="math inline">\(O(n)\)</span>
的，所以考虑将系数表达式转成点值表达式然后相乘。</p>
<p>事实上，点值表达式和系数表达式的互相转化，如果点值取特殊点，可以做到
<span class="math inline">\(O(n\log
n)\)</span>，即使是任意点，即多项式多点求值和多项式多点插值也可以做到
<span class="math inline">\(O(n \log^2n)\)</span></p>
<p>设最终多项式次数为 <span
class="math inline">\(n-1\)</span>，我们进行多项式乘法时选择的点值叫单位根，即
<span class="math inline">\(x^n=1\)</span> 在复数域上的所有根。</p>
<p>这玩意有一些性质，不过我们得先把次数变为 <span
class="math inline">\(n=2^k\)</span> 形式。</p>
<p>无法想象发明这个东西的人是怎么想到的，可能这就是被记在历史书上的人的水平。</p>
<p><em>以下内容如果将坐标系视为极坐标系会更好理解</em> $$ <span
class="math display">\[\begin{align}
W_n^i &amp;= -W_n^{i+\frac{n}{2}}\\
  
W_{\frac{n}{2}}^{i} &amp;= W_{n}^{2i}\\
\end{align}\]</span> $$ 考虑这样一个问题，对于一个多项式 <span
class="math inline">\(a_0+a_1x+a_2x^2 \cdots a_{n-1}x^{n-1}\)</span>
，我们需要同时求出它在 <span class="math inline">\(W_n^{0},W_n^{1}\cdots
W_n^{n-1}\)</span> 处的取值。发现由于第一个性质，貌似可以偷个懒，因为后
<span class="math inline">\(\frac{n}{2}\)</span> 个 <span
class="math inline">\(W_i\)</span> 就是前 <span
class="math inline">\(\frac{n}{2}\)</span> 个数的相反数。</p>
<p>相反数的性质，奇数次幂的符号要改变。考虑对系数按奇偶性分类，式子变成了这个样子。</p>
<p><span class="math inline">\((a_0+a_2x^2+\cdots
+a_{n-2}x^{n-2})+x(a_1+a_3x^2+\cdots + a_{n-1}x^{n-2})\)</span></p>
<p>然后考虑前后两个部分，都是一个多项式，需要对他们各自求 <span
class="math inline">\(x=W_\frac{2}{n}^0,W_\frac{2}{n}^1\cdots
W_\frac{2}{n}^{\frac{n}{2}-1}\)</span> 处的取值，本质上是求 <span
class="math inline">\(x^2=W_{\frac{2}{n}}^0,W_{\frac{2}{n}}^2\cdots
W_{\frac{2}{n}}^{n-2}\)</span>
处的取值，结合第二个性质，woc，就是两个子问题，解决之后就可以 <span
class="math inline">\(O(n)\)</span> 得到原问题的解，边界显然是 <span
class="math inline">\(n=1\)</span>。</p>
<p>复杂度 <span class="math inline">\(T(n)=2T(\frac{n}{2}) + O(n) =
O(n\log n)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span> now,com *a,<span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	com a1[<span class="number">1</span>&lt;&lt;now],a2[<span class="number">1</span>&lt;&lt;now];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;now;i+=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a1[i/<span class="number">2</span>]=a[i];</span><br><span class="line">		a2[i/<span class="number">2</span>]=a[i<span class="number">+1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FFT</span>(now<span class="number">-1</span>,a1,op);</span><br><span class="line">	<span class="built_in">FFT</span>(now<span class="number">-1</span>,a2,op);</span><br><span class="line">	com w0=(com&#123;<span class="built_in">cos</span>(<span class="number">2.0</span>*Pi/(<span class="number">1</span>&lt;&lt;now)),op*<span class="built_in">sin</span>(<span class="number">2.0</span>*Pi/(<span class="number">1</span>&lt;&lt;now))&#125;),w=(com)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;now<span class="number">-1</span>;i++,w=w*w0)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=a1[i]+w*a2[i];</span><br><span class="line">		a[i+(<span class="number">1</span>&lt;&lt;(now<span class="number">-1</span>))]=a1[i]-w*a2[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果递归的话，常数会比较拉跨。因为递归必然需要复制数组重新弄成一个下标
<span class="math inline">\(1-n\)</span>
的问题，无论用什么办法解决，你的高速缓存都会表示意见很大，所以考虑迭代写法。</p>
<p>本质上递归是一层一层合并了两个数组，那么能不能直接模拟这个合并的过程呢，答案是可以的。</p>
<p>观察发现本质上是将下标二进制 <code>reverse</code>
之后逐层合并的，我们也这么做就行。</p>
<p>求 <code>reverse</code> 可以 <span
class="math inline">\(O(n)\)</span>，如下（如果你不了解运算顺序，请老老实实打括号）</p>
<p>这个原理很简单，不看最后一位，其它位先
<code>reverse</code>，然后处理一下最后一位就行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;lim;i++)res[i]=res[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>|(i&amp;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>-lim;</span><br></pre></td></tr></table></figure>
<p>下面是迭代写法代码，本质是模拟了递归合并的过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(com a[],com b[],<span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;maxn;i++)</span><br><span class="line">    <span class="keyword">if</span>(r[i]&gt;i)<span class="built_in">swap</span>(a[r[i]],a[i]),<span class="built_in">swap</span>(b[r[i]],b[i]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1</span>&lt;&lt;maxn;j+=<span class="number">1</span>&lt;&lt;i)&#123;</span><br><span class="line">			com w0=(com)&#123;<span class="built_in">cos</span>(<span class="number">2.0</span>*Pi/(<span class="number">1</span>&lt;&lt;i)),op*<span class="built_in">sin</span>(<span class="number">2.0</span>*Pi/(<span class="number">1</span>&lt;&lt;i))&#125;,w=(com)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>;k++,w=w*w0)&#123;</span><br><span class="line">				com x=a[j+k],y=a[j+k+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]*w;</span><br><span class="line">				a[j+k]=x+y;</span><br><span class="line">				a[j+k+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]=x-y;</span><br><span class="line">                </span><br><span class="line">				x=b[j+k],y=b[j+k+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]*w;</span><br><span class="line">				b[j+k]=x+y;</span><br><span class="line">				b[j+k+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]=x-y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞完了系数转点值，接下来是点值转系数。</p>
<p>前人告诉我们只需要将单位根改为 <span
class="math inline">\(W_n^{0},W_n^{-1}\cdots
W_n^{-n+1}\)</span>，再做一遍系数转点值的过程就可以得到系数，但是系数会变成原来的
<span class="math inline">\(n\)</span> 倍，除掉就行。</p>
<p>给出简要证明，<span class="math inline">\(i\)</span> 次项的系数为
<span class="math inline">\(a_i\)</span>，转一次点值</p>
<p>之后变为 <span class="math inline">\(b_i\)</span>，再做一次变成 <span
class="math inline">\(c_i\)</span> <span class="math display">\[
\begin{eqnarray}
c_x &amp;=&amp; \sum\limits_{i=0}^{n-1}b_iW_n^{-ix} \\
&amp;=&amp; \sum\limits_{i=0}^{n-1}
W_n^{-ix}\sum\limits_{j=0}^{n-1}a_jW_n^{ij}\\
&amp;=&amp; \sum\limits_{i=0}^{n-1}
\sum\limits_{j=0}^{n-1}a_jW_n^{i(j-x)}\\
\end{eqnarray}
\]</span> 对于 <span class="math inline">\(j=x\)</span>，贡献显然为
<span class="math inline">\(\sum\limits_{i=0}^{n-1}a_xW_n^{i\times0} =
na_x\)</span></p>
<p>对于 <span class="math inline">\(j\neq x\)</span> 贡献为 <span
class="math inline">\(a_j
\sum\limits_{i=0}^{n-1}(W_n^{j-x})^{i}\)</span></p>
<p>对这个式子的求和用等比数列求和公式有贡献为 <span
class="math inline">\(\dfrac{W_n^{n(j-x)}-1}{W_n^{j-x}-1}\)</span></p>
<p>显然分子为 <span class="math inline">\(0\)</span>，分母不为 <span
class="math inline">\(0\)</span>，所以贡献是 <span
class="math inline">\(0\)</span>，所以结果就是 <span
class="math inline">\(na_x\)</span></p>
<p>搞定。</p>
<h3 id="ntt-多项式乘法">NTT 多项式乘法</h3>
<p>FFT 多项式乘法是由缺陷的，由于浮点数精度和运算速度问题，FFT
可能并不能很好的解决一些问题，所以引入了 NTT，NTT
从有限整数域中找到了这样一组具有同样优秀性质的 <span
class="math inline">\(W_n\)</span>，即 <span
class="math inline">\(g\)</span>，也就是原根。</p>
<p>原根的内容可以参考数学证明总结中的介绍。</p>
<p><strong>注意，和 FFT 一样，NTT 也需要严格的按照 <span
class="math inline">\(2^k\)</span> 取次数，因为我们利用了 <span
class="math inline">\(W_n^{2i} = W_{\frac{n}{2}}^{i}\)</span>
这一重要性质</strong></p>
<p>所以能取出较大的 <span class="math inline">\(2^k\)</span>
作为阶的质数才可以作为 NTT 的模数，常见的 NTT 模数是 <span
class="math inline">\(998244353=2^{23}\times 7\times 17 +1\)</span>
，我们可以取它的原根 <span class="math inline">\(g=3\)</span>
作为基本单位根带入，实际上如果要找到一个应用于 <span
class="math inline">\(n\)</span> 的单位根 <span
class="math inline">\(W_n\)</span>，需要取 <span
class="math inline">\(W_n=g^{\frac{p-1}{n}}\)</span>。这样它就满足了我们在
FFT 证明中用到的一切性质。</p>
<p>然后照着 FFT 打一遍就行，只是基本运算这些换为模 <span
class="math inline">\(p\)</span> 意义下的运算就行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;s;i++)</span><br><span class="line">	<span class="keyword">if</span>(rk[i]&gt;i)<span class="built_in">swap</span>(a[rk[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=s;len++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> w=<span class="number">1</span>,wn=<span class="built_in">quick</span>(g,mod<span class="number">-1</span>&gt;&gt;len);</span><br><span class="line">		<span class="keyword">if</span>(type==<span class="number">-1</span>)wn=<span class="built_in">quick</span>(wn,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j+(<span class="number">1</span>&lt;&lt;len)&lt;=<span class="number">1</span>&lt;&lt;s;j+=<span class="number">1</span>&lt;&lt;len,w=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(k=j;k&lt;j+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>);k++,w=<span class="number">1ll</span>*w*wn%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[k],y=a[k+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>)];</span><br><span class="line">				a[k]=(x<span class="number">+1ll</span>*w*y%mod)%mod,a[k+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>)]=(x<span class="number">-1ll</span>*w*y%mod)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它多项式乘法和一些优化">其它多项式乘法和一些优化</h3>
<h4 id="fft-三次变两次">FFT 三次变两次</h4>
<p>FFT 三次变两次，把 <span class="math inline">\(b\)</span> 扔到 <span
class="math inline">\(a\)</span> 的虚部去，变成了 <span
class="math inline">\(A(x) = (a_0+b_0i) + (a_1+b_1i)x+ \cdots +
(a_{n-1}+b_{n-1}i)x^{n-1}\)</span></p>
<p>然后求 <span
class="math inline">\(A^2(x)\)</span>，得到的系数表达式的虚部就是 <span
class="math inline">\(2ab\)</span>。</p>
<p>证明显然，会比 NTT 略快。</p>
<h4 id="任意模数-ntt">任意模数 NTT</h4>
<p>NTT
解决的是模意义下的乘法问题，当然，如果<strong>确保值域不超出模数</strong>，那么模意义下的结果就是正确结果。</p>
<p>如果模数不是 NTT 模数，就需要写任意模数 NTT。</p>
<p>实现方式有两种，其一是拆系数 FFT，其二是多模数 NTT 后用 CRT
合并。</p>
<h5 id="多模数-ntt">多模数 NTT</h5>
<p>一般选取 <code>998244353 1004535809 469726049</code> 作为 NTT
模数，它们的原根都是 <code>3</code>。分别进行 NTT
后，可以得到在模它们意义下的结果，用中国剩余定理合并，得到一个模约 <span
class="math inline">\(5\times 10^{26}\)</span>
的数的结果，一般来说任意的模数不会超过 <span
class="math inline">\(10^9\)</span>，所以乘起来的结果不超过 <span
class="math inline">\(10^{24}\)</span>，直接用合并的结果就行。</p>
<p>提一下实现细节。</p>
<p>一种方式是写个 Num 类，里面放三个 int，重写一下加减乘除，正常做。</p>
<p>另一种方式是写个 Poly 类，封装个乘法，用 for 做三次，都比较阳间。</p>
<p>用 CRT 时记得 __int128。或者用一个科技</p>
<p>一共三个方程，考虑这样合并。</p>
<p>其中 <span class="math inline">\(mod_1^{-1}\)</span> 表示 <span
class="math inline">\(mod_1\)</span> 在 <span
class="math inline">\(mod_2\)</span> 意义下的逆元。 <span
class="math display">\[
x = x_1 \pmod {mod1} \\
x = x_2 \pmod {mod2} \\
k_1 mod_1 + x_1 = x_2 \pmod{mod2}\\
x = (x_2-x_1)mod_1^{-1}mod_1 + x_1  \pmod {mod_2*mod_1}
\]</span></p>
<p>发现这样第二次合并的时候可以直接在模需要的模数 <span
class="math inline">\(p\)</span> 下进行计算。</p>
<p><strong>注意，务必考虑好取模的顺序，计算第二个时不能先对 p
取模，因为可能结果还需要先模上 <span
class="math inline">\(mod_1*mod_2*mod_3\)</span></strong>，</p>
<p>怎样避免 __int128 ?</p>
<p>把 <span class="math inline">\((x_2-x_1)mod_1^{-1}\)</span> 对 <span
class="math inline">\(mod_2\)</span>
取模即可，注意处理正负号，保证<strong>任意时刻</strong>结果在
[0,对应模数) 内。</p>
<h5 id="拆系数-fft">拆系数 FFT</h5>
<p>FFT 精度不高，一般来说 double 跑个 <span
class="math inline">\(10^{14}\)</span> 问题不大（最后除掉 <span
class="math inline">\(n\)</span>
以后的结果，也就是乘出来的多项式的系数，举个例子就是如果跑 <span
class="math inline">\(n=10^4\)</span>，那需要保证 <span
class="math inline">\(a_i,b_i\leq 10^5\)</span>），但是跑 <span
class="math inline">\(10^{24}\)</span> 次方， FFT 表示我做不到，用 long
double 也不行。</p>
<p>所以考虑拆系数，把每个数写成 <span
class="math inline">\(a_1\times2^{15} + a_2\)</span> 的形式。</p>
<p>然后乘法就变成了 <span
class="math inline">\(a_1b_1*2^{30}+(a_1b_2+a_2b_1)*2^{15}+a_2b_2\)</span>。</p>
<p>设新的四个多项式为 <span
class="math inline">\(A_1,A_2,B_1,B_2\)</span></p>
<p>一共 8 次 FFT，但可以优化，考虑复多项式 <span class="math display">\[
P=B_1+B_2i\\
T_1=P\times A_1 \\
T_2=P\times A_2
\]</span></p>
<p>发现需要的系数在 <span class="math inline">\(T_1,T_2\)</span>
的实部和虚部，对这俩做 IDFT，收工。</p>
<p>一共 5 次 DFT。</p>
<p>也可以这样:</p>
<p>先考虑 <span class="math display">\[
P=A_1+A_2i\\
P&#39;=A_1-A_2i\\
Q=B_1+B_2i
\]</span></p>
<p>再考虑： <span class="math display">\[
T_1=PQ=(A_1B_1-A_2B_2)+(A_1B_2+A_2B_1)i\\
T_2=P&#39;Q=(A_1B_1+A_2B_2)+(A_1B_2-A_2B_1)i
\]</span> 最后： <span class="math display">\[
T_1+T_2=2(A_1B_1+A_1B_2i)\\
T_1-T_2=-2(A_2B_2-A_2B_1i)
\]</span></p>
<p>弄出 <span class="math inline">\(T_1,T_2\)</span>
的系数表示法就行。其实复系数多项式乘法和普通系数多项式乘法没有什么区别。</p>
<p>这种 5 次的思路还有其它方式，不一一介绍了。</p>
<p>听说有种方法可以把两次实数域多项式的 DFT 和 IDFT
整成一次复数域的，但我觉得没啥必要会。</p>
<p>DFT 思路是构造一个多项式 <span
class="math inline">\(P=A+Bi\)</span>，对其做 DFT，然后线性求 <span
class="math inline">\(Q=A-Bi\)</span> 的 DFT 结果。</p>
<p>IDFT 思路不会。</p>
<p><strong>更推荐第一种写法，不会出现精度问题，如果效率不够再考虑改成第二种</strong></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统学习笔记</title>
    <url>/2022/07/12/%E6%8A%80%E6%9C%AF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="c-语言编译过程">C 语言编译过程</h3>
<ul>
<li>源文本-------预处理，处理 define,include 等</li>
<li>预处理文本--------编译</li>
<li>汇编文本----------汇编得到二进制文件 .o</li>
<li>目标格式----------链接</li>
<li>可执行文件</li>
</ul>
<h3 id="二进制补码原理和-c-语言处理类型转换">二进制补码原理和 C
语言处理类型转换</h3>
<ul>
<li>二进制补码最高位本质是一个 <span
class="math inline">\(-2^x\)</span></li>
<li>同时处理有符号和无符号整数比较时或者进行其它二元运算时，C
语言会默认无符号且均为正数。</li>
<li>编译器处理一个 <code>-x</code> 的表达式时，会先读 <code>x</code>
然后取反，所以 <code>-2147483648</code> 是不合法的，应该写为
<code>-2147483647-1</code></li>
</ul>
<h3 id="简单的汇编语言">简单的汇编语言</h3>
<ul>
<li><p>操作系统将物理内存抽象为了一个一维数组，所有汇编层面的操作均在一维数组内进行</p></li>
<li><p>每一条汇编指令都可以被描述为两个部分，指令和操作对象，这两部分的<strong>整体</strong>可以被一个或多个字节描述，此规则本质上是一颗哈夫曼树。</p></li>
<li><p>一个程序的汇编指令会被保存在主存上，有一个程序计数器
<code>epi</code> 指出当前执行到的地方。</p></li>
<li><p>常用寄存器名有
<code>eax,ecx,edx,ebx,esi,edi,esp,ebp</code>。前三者的数据由当前程序保存在栈中，后三者的值由下级程序保存，最后二者为帧指针和栈指针，一般不使用。前四个寄存器可以通过
<code>ah,al,ax</code> 等形式访问低二字节和低一字，但都可以用
<code>di</code> 形式访问低一字。</p></li>
<li><p>传送指令分为三种 <code>movb movw movl</code>
分别表示字节，字和双字。传送对应类型时，应该使用对应的寄存器位置。
<code>push,pop</code>
指令为压栈和弹栈，本质上是操作了主存和栈指针。</p></li>
<li><p><code>lea</code> 指令可以快速计算 <code>a+b*(1,2,4,8)+c</code>
，<code>a</code> 必须为常量，<code>b,c</code>
必须为寄存器中的数。</p></li>
<li><p>操作数分为三类，一类是立即数，一类是寄存器，一类是主存数据，访问格式如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$imm //立即数 imm</span><br><span class="line">eg. $0x3f</span><br><span class="line"></span><br><span class="line">E	//寄存器 E</span><br><span class="line">eg. eax</span><br><span class="line"></span><br><span class="line">Imm(e1,e2,s) //主存上 Imm+e1+e2*s 位置上的数据，Imm 可以缺省，后二者可以缺省，e1 缺省时不能省略 &#x27;,&#x27;</span><br><span class="line">eg. 0x3f(eax,ebx,4)</span><br><span class="line">eg. (eax)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>用 <code>test</code> 和 <code>cmp</code>
指令来控指条件，本质上，它们改变了条件寄存器内的值，<code>test x x</code>
等价于 <code>cmp 0 x</code>。执行 <code>cmp</code> 后，<code>jl</code>
等条件跳转语句会在 <code>cmp</code> 成立时执行，<code>jl</code>
表示小于时跳转，<code>cmp x y</code> 可以看作是 <code>y&lt;x</code>
时执行 <code>jl</code></p></li>
<li><p><code>call</code> 指令会将返回地址 (call)
语句后那条语句的地址入栈后跳转到函数所在位置。<code>ret</code>
指令利用返回地址跳转回去，一般来说，用 <code>eax</code>
保存返回内容。</p></li>
<li><p>由于程序寄存器中的某些值会被缓存到主存中，所以使用
<code>gets</code>
等不安全函数读取时，如果读取的内容过长超出了为此缓存区分别的字节后，会污染一些<strong>先前被存储在主存中的寄存器值</strong>，因为超出分配的内存后，会写在外面，通过这样的操作，我们可以改变一些系统寄存器的值，让程序跳转执行一些我们希望让它执行的代码（这样的代码通常被写在我们的输入里），这就是缓冲区攻击，通常操作是改变
<code>ebp</code> 的值使得 <code>ret</code>
操作跳到我们希望的地方。</p></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>语法，语法糖，标准库函数</title>
    <url>/2022/07/12/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    <content><![CDATA[<h1 id="语法语法糖标准库函数">语法，语法糖，标准库函数</h1>
<p>介绍一些有用常用但鲜为人知的 <code>C++</code> 语法，语法糖。</p>
<h2 id="运算顺序">运算顺序</h2>
<p>记好表，记不住打括号，<strong>最好打括号。</strong></p>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 45%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">运算符说明</th>
<th style="text-align: center;">运算符</th>
<th style="text-align: left;">替代方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">第 1 组优先级，无关联性</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/scope-resolution-operator?view=msvc-170">范围解析</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/scope-resolution-operator?view=msvc-170"><code>::</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">第 2 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/member-access-operators-dot-and?view=msvc-170">成员选择（对象或指针）</a></td>
<td style="text-align: center;">或 <code>-&gt;</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/subscript-operator?view=msvc-170">数组下标</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/subscript-operator?view=msvc-170"><code>[]</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/function-call-operator-parens?view=msvc-170">函数调用</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/function-call-operator-parens?view=msvc-170"><code>()</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/postfix-increment-and-decrement-operators-increment-and-decrement?view=msvc-170">后缀递增</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/postfix-increment-and-decrement-operators-increment-and-decrement?view=msvc-170"><code>++</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/postfix-increment-and-decrement-operators-increment-and-decrement?view=msvc-170">后缀递减</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/postfix-increment-and-decrement-operators-increment-and-decrement?view=msvc-170"><code>--</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/typeid-operator?view=msvc-170">类型名称</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/typeid-operator?view=msvc-170"><code>typeid</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/const-cast-operator?view=msvc-170">常量类型转换</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/const-cast-operator?view=msvc-170"><code>const_cast</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/dynamic-cast-operator?view=msvc-170">动态类型转换</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/dynamic-cast-operator?view=msvc-170"><code>dynamic_cast</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/reinterpret-cast-operator?view=msvc-170">重新解释的类型转换</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/reinterpret-cast-operator?view=msvc-170"><code>reinterpret_cast</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/static-cast-operator?view=msvc-170">静态类型转换</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/static-cast-operator?view=msvc-170"><code>static_cast</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">第 3 组优先级，从右到左关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/sizeof-operator?view=msvc-170">对象或类型的大小</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/sizeof-operator?view=msvc-170"><code>sizeof</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/prefix-increment-and-decrement-operators-increment-and-decrement?view=msvc-170">前缀递增</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/prefix-increment-and-decrement-operators-increment-and-decrement?view=msvc-170"><code>++</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/prefix-increment-and-decrement-operators-increment-and-decrement?view=msvc-170">前缀递减</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/prefix-increment-and-decrement-operators-increment-and-decrement?view=msvc-170"><code>--</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/one-s-complement-operator-tilde?view=msvc-170">二进制反码</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/one-s-complement-operator-tilde?view=msvc-170"><code>~</code></a></td>
<td style="text-align: left;"><strong><code>compl</code></strong></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/logical-negation-operator-exclpt?view=msvc-170">逻辑“非”</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/logical-negation-operator-exclpt?view=msvc-170"><code>!</code></a></td>
<td style="text-align: left;"><strong><code>not</code></strong></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/unary-plus-and-negation-operators-plus-and?view=msvc-170">一元求反</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/unary-plus-and-negation-operators-plus-and?view=msvc-170"><code>-</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/unary-plus-and-negation-operators-plus-and?view=msvc-170">一元加</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/unary-plus-and-negation-operators-plus-and?view=msvc-170"><code>+</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/address-of-operator-amp?view=msvc-170">Address-of</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/address-of-operator-amp?view=msvc-170"><code>&amp;</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/indirection-operator-star?view=msvc-170">间接寻址</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/indirection-operator-star?view=msvc-170"><code>*</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/new-operator-cpp?view=msvc-170">创建对象</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/new-operator-cpp?view=msvc-170"><code>new</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/delete-operator-cpp?view=msvc-170">销毁对象</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/delete-operator-cpp?view=msvc-170"><code>delete</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/cast-operator-parens?view=msvc-170">强制转换</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/cast-operator-parens?view=msvc-170"><code>()</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">第 4 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/pointer-to-member-operators-dot-star-and-star?view=msvc-170">指向成员的指针（对象或指针）</a></td>
<td style="text-align: center;">或 <code>-&gt;*</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">第 5 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/multiplicative-operators-and-the-modulus-operator?view=msvc-170">乘法</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/multiplicative-operators-and-the-modulus-operator?view=msvc-170"><code>*</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/multiplicative-operators-and-the-modulus-operator?view=msvc-170">除法</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/multiplicative-operators-and-the-modulus-operator?view=msvc-170"><code>/</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/multiplicative-operators-and-the-modulus-operator?view=msvc-170">取模</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/multiplicative-operators-and-the-modulus-operator?view=msvc-170"><code>%</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">第 6 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/additive-operators-plus-and?view=msvc-170">加法</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/additive-operators-plus-and?view=msvc-170"><code>+</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/additive-operators-plus-and?view=msvc-170">减法</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/additive-operators-plus-and?view=msvc-170"><code>-</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">第 7 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/left-shift-and-right-shift-operators-input-and-output?view=msvc-170">左移</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/left-shift-and-right-shift-operators-input-and-output?view=msvc-170"><code>&lt;&lt;</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/left-shift-and-right-shift-operators-input-and-output?view=msvc-170">右移</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/left-shift-and-right-shift-operators-input-and-output?view=msvc-170"><code>&gt;&gt;</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">第 8 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/relational-operators-equal-and-equal?view=msvc-170">小于</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/relational-operators-equal-and-equal?view=msvc-170"><code>&lt;</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">大于</td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/relational-operators-equal-and-equal?view=msvc-170"><code>&gt;</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">小于或等于</td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/relational-operators-equal-and-equal?view=msvc-170"><code>&lt;=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">大于或等于</td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/relational-operators-equal-and-equal?view=msvc-170"><code>&gt;=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">第 9 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/equality-operators-equal-equal-and-exclpt-equal?view=msvc-170">等式</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/equality-operators-equal-equal-and-exclpt-equal?view=msvc-170"><code>==</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/equality-operators-equal-equal-and-exclpt-equal?view=msvc-170">不相等</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/equality-operators-equal-equal-and-exclpt-equal?view=msvc-170"><code>!=</code></a></td>
<td style="text-align: left;"><strong><code>not_eq</code></strong></td>
</tr>
<tr>
<td style="text-align: left;">第 10 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/bitwise-and-operator-amp?view=msvc-170">位与</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/bitwise-and-operator-amp?view=msvc-170"><code>&amp;</code></a></td>
<td style="text-align: left;"><strong><code>bitand</code></strong></td>
</tr>
<tr>
<td style="text-align: left;">第 11 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/bitwise-exclusive-or-operator-hat?view=msvc-170">位异或</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/bitwise-exclusive-or-operator-hat?view=msvc-170"><code>^</code></a></td>
<td style="text-align: left;"><strong><code>xor</code></strong></td>
</tr>
<tr>
<td style="text-align: left;">第 12 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/bitwise-inclusive-or-operator-pipe?view=msvc-170">位或</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/bitwise-inclusive-or-operator-pipe?view=msvc-170"><code>|</code></a></td>
<td style="text-align: left;"><strong><code>bitor</code></strong></td>
</tr>
<tr>
<td style="text-align: left;">第 13 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/logical-and-operator-amp-amp?view=msvc-170">逻辑与</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/logical-and-operator-amp-amp?view=msvc-170"><code>&amp;&amp;</code></a></td>
<td style="text-align: left;"><strong><code>and</code></strong></td>
</tr>
<tr>
<td style="text-align: left;">第 14 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/logical-or-operator-pipe-pipe?view=msvc-170">逻辑或</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/logical-or-operator-pipe-pipe?view=msvc-170"><code>||</code></a></td>
<td style="text-align: left;"><strong><code>or</code></strong></td>
</tr>
<tr>
<td style="text-align: left;">第 15 组优先级，从右到左关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/conditional-operator-q?view=msvc-170">条件逻辑</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/conditional-operator-q?view=msvc-170"><code>? :</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">转让</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">乘法赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>*=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">除法赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>/=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">取模赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>%=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">加法赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>+=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">减法赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>-=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">左移赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>&lt;&lt;=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">右移赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>&gt;&gt;=</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">按位“与”赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>&amp;=</code></a></td>
<td style="text-align: left;"><strong><code>and_eq</code></strong></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">按位“与或”赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>|=</code></a></td>
<td style="text-align: left;"><strong><code>or_eq</code></strong></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170">按位“异或”赋值</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/assignment-operators?view=msvc-170"><code>^=</code></a></td>
<td style="text-align: left;"><strong><code>xor_eq</code></strong></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/try-throw-and-catch-statements-cpp?view=msvc-170">引发表达式</a></td>
<td style="text-align: center;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/try-throw-and-catch-statements-cpp?view=msvc-170"><code>throw</code></a></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">第 16 组优先级，从左到右关联</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://learn.microsoft.com/zh-cn/cpp/cpp/comma-operator?view=msvc-170">逗号</a></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="标准库">标准库</h2>
<h3 id="函数">函数</h3>
<h4 id="stdswap">std::swap</h4>
<ul>
<li><p>对于除了 <code>array</code> 容器之外的所有标准库容器，都可以
<span class="math inline">\(O(1)\)</span> 交换</p></li>
<li><p>交换数组的复杂度为 <span
class="math inline">\(O(size)\)</span>，对二维数组的某一维使用，会将当前行视为一维数组进行交换。</p></li>
</ul>
<h4 id="memcpy">memcpy</h4>
<p><code>memcpy(dst, src, size)</code></p>
<p>dst:目标数组起始位置</p>
<p>src:源数组起始位置</p>
<p>size:需要复制的字节数</p>
<h4 id="lower_boundupper_bound">lower_bound,upper_bound</h4>
<p>看下实现吧：</p>
<ul>
<li><code>upper_bound</code>
如果对类使用，那么<strong>类的比较函数需要定义为友元函数</strong>。</li>
<li><code>lower_bound</code>
返回第一个大于等于它的位置，<code>upper_bound</code>
返回第一个大于它的位置，<code>comp</code> 为默认小于号。</li>
<li>如果要对不增序列操作，那么 <code>comp</code>
为大于号，<code>lower_bound</code>
返回第一个小于等于它的位置，<code>upper_bound</code>
返回第一个小于它的位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ForwardIt it;</span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step;</span><br><span class="line">    count = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        it = first;</span><br><span class="line">        step = count / <span class="number">2</span>;</span><br><span class="line">        std::<span class="built_in">advance</span>(it, step);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*it, value)) &#123;</span><br><span class="line">            first = ++it;</span><br><span class="line">            count -= step + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ForwardIt it;</span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step;</span><br><span class="line">    count = std::<span class="built_in">distance</span>(first,last);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        it = first; </span><br><span class="line">        step = count / <span class="number">2</span>;</span><br><span class="line">        std::<span class="built_in">advance</span>(it, step);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">comp</span>(value, *it)) &#123;</span><br><span class="line">            first = ++it;</span><br><span class="line">            count -= step + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="atan2">atan2</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">atan2</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回 [actan(y/x)],[-Pi,Pi)</span></span><br><span class="line">    <span class="comment">//计算几何的神，怎么神就不用说了吧。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for_eachbeginendfun">for_each(begin,end,fun)</h4>
<p>对 begin 到 end 区间的每一个元素 x，执行 fun(x)。</p>
<p>如果需要传参，可以利用类的构造函数。</p>
<p>即给类重载一个 <code>()</code> 运算，然后构造输出。</p>
<h4 id="accumulatebeginendstart">accumulate(begin,end,start)</h4>
<p>对 <code>begin end</code> 区间运用 <code>+</code> 操作，起始为
<code>start</code>。</p>
<p>效率不开 <span class="math inline">\(O2\)</span>
时略高于循环，开了没差别。</p>
<h4 id="countbeginendval">count(begin,end,val)</h4>
<p>返回 <code>begin end</code> 中 <code>==val</code> 的数的个数。</p>
<p>开了 <span class="math inline">\(O2\)</span> 效率和循环没差别。</p>
<h2 id="结构体">结构体</h2>
<p>一般来说 <code>class</code> 和 <code>struct</code>
竞赛上差别不大，<code>struct</code> 是默认 <code>public</code> 的
<code>class</code>。</p>
<h3 id="重载括号">重载括号</h3>
<p>重载小括号运算符可以让你把结构体当函数用，其实本质上少写了一个
<code>.&#123;function name&#125;</code>。</p>
<p>它和构造函数不冲突。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">barrett1</span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> m,im;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		ULL z=(ULL)a*b;</span><br><span class="line">		<span class="type">int</span> v=z-((__int128)z*im&gt;&gt;<span class="number">64</span>)*m;</span><br><span class="line">		<span class="keyword">return</span> v&lt;<span class="number">0</span>?v+m:v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;bt1;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c=<span class="built_in">bt1</span>(a,b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">barrett2</span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> m,im;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		ULL z=(ULL)a*b;</span><br><span class="line">		<span class="type">int</span> v=z-((__int128)z*im&gt;&gt;<span class="number">64</span>)*m;</span><br><span class="line">		<span class="keyword">return</span> v&lt;<span class="number">0</span>?v+m:v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;bt2;</span><br><span class="line">c=bt<span class="number">2.f</span>oo(a,b);</span><br></pre></td></tr></table></figure>
<p>两者没有本质区别。</p>
<p>中括号可以重载，一般来说，重载中括号返回的是一个引用，中扩号只接受一个参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">array_2d</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">10005</span>],b[<span class="number">10005</span>];</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> nn,<span class="type">int</span> mm)</span></span>&#123;</span><br><span class="line">    	n=nn,m=mm;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> x)&#123;</span><br><span class="line">		<span class="keyword">return</span> a[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a;</span><br><span class="line">a.<span class="built_in">init</span>(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">a[<span class="number">3</span>]=<span class="number">1</span>;a.b[<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">a[<span class="number">4</span>]=<span class="number">4</span>;</span><br><span class="line">cout&lt;&lt;a[<span class="number">4</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;a[<span class="number">3</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;a[<span class="number">1</span>]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h3 id="构造">构造</h3>
<p>结构体的构造函数可以返回一个结构体实例，也可以允许在声明结构体的时候同时构造。</p>
<p>举个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;string str;</span><br><span class="line">    <span class="built_in">st</span>(<span class="type">int</span> aa,<span class="type">int</span> bb)&#123;</span><br><span class="line">        a=aa;</span><br><span class="line">        b=bb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">st t1=<span class="built_in">st</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="function">st <span class="title">t2</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// st t3; 这句会 CE</span></span><br></pre></td></tr></table></figure>
<p>这两种写法都行，<strong>注意不能变量重名</strong>，不会
<code>CE</code>，但是函数参数里会那个名字会覆盖掉全局的。</p>
<p>注意写了构造函数，所有的构造都必须带参数。</p>
<p>定义结构体的时候还可以给变量赋初值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b=<span class="number">1</span>;string str=<span class="string">&quot;str&quot;</span>;</span><br><span class="line">    <span class="built_in">st</span>(<span class="type">int</span> aa,<span class="type">int</span> bb)&#123;</span><br><span class="line">        a=aa;</span><br><span class="line">        b=bb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">st t1=<span class="built_in">st</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="function">st <span class="title">t2</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// t1.str=&quot;str&quot;,t1.b=3</span></span><br><span class="line"><span class="comment">// t2.str=&quot;str&quot;,t2.b=3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是如果构造函数里写了，就会被覆盖。声明的局部变量写了的初值会固定，没写的初值就随机。</p>
<p>如果没写构造函数，那么会有一个默认的列表构造函数，按照结构体内声明变量的顺序将列表中的每一个值依次赋给对应变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b=<span class="number">1</span>;string str=<span class="string">&quot;str&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">st t1=st&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;huan_yp&#x27;</span>&#125;;</span><br><span class="line">st t2&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;huan_yp&quot;</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实构造函数还有另一种写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;string str;</span><br><span class="line">    <span class="built_in">st</span>(<span class="type">int</span> aa,<span class="type">int</span> bb): <span class="built_in">a</span>(aa), <span class="built_in">b</span>(bb) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">st t1=<span class="built_in">st</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="function">st <span class="title">t2</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>和最开始的写法是等效的。</p>
<p><strong>注意，如果写了构造函数，默认的列表构造函数会调用它，所以如果你想不同参数个数构造，需要填默认参数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;string str;</span><br><span class="line">    <span class="built_in">st</span>() :<span class="built_in">a</span>(), <span class="built_in">b</span>(), <span class="built_in">str</span>()&#123;&#125;</span><br><span class="line">    <span class="comment">//如果没有这一行，下面的第一个构造会 CE</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="built_in">st</span>(<span class="type">int</span> aa, <span class="type">int</span> bb,string cc) :<span class="built_in">a</span>(aa), <span class="built_in">b</span>(bb), <span class="built_in">str</span>(cc)&#123;&#125;</span><br><span class="line"><span class="comment">//    st() :a(), b(), str() &#123;&#125;</span></span><br><span class="line"><span class="comment">//    st(int aa,int bb): a(aa), b(bb) &#123;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line">st t1;</span><br><span class="line">t1=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;str&quot;</span>&#125;;</span><br><span class="line">t1=&#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//最后一行会 CE</span></span><br></pre></td></tr></table></figure>
<p>列表构造式还可以自推导。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b=<span class="number">1</span>;string str=<span class="string">&quot;str&quot;</span>;</span><br><span class="line">    <span class="built_in">st</span>(<span class="type">int</span> aa,<span class="type">int</span> bb)&#123;</span><br><span class="line">        a=aa;</span><br><span class="line">        b=bb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">st t1=&#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">t1=&#123;<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//t1(2,3)</span></span><br><span class="line"><span class="comment">//括号式式不能自推导的，这个的含义参考第一条。</span></span><br></pre></td></tr></table></figure>
<h2 id="语法概念">语法概念</h2>
<h3 id="运算优先级">运算优先级</h3>
<p>容易出问题的是几个位运算。</p>
<p>永远记住，位运算除了左右移位外，优先级<strong>低于比较操作。</strong></p>
<p><strong>比较操作之间，等于和不等的优先级低于大于小于。</strong></p>
<h3 id="引用">引用</h3>
<p>引用可以认为是一个<strong>隐式指针</strong>，不需要 <code>*</code>
的修饰便可以直接访问内容。它既然是一个指针，自然会占用一个
<code>long</code> 的空间。</p>
<h4 id="定义返回一个引用">定义，返回一个引用</h4>
<p>可以在函数中返回一个引用，只需要在函数名前面后加一个
<code>&amp;</code>，定义引用也在变量名加一个
<code>&amp;</code>，和指针类似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> &amp;<span class="title">setValues</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;  </span><br><span class="line">   <span class="type">double</span> &amp;ref = vals[i];    </span><br><span class="line">   <span class="keyword">return</span> ref;   <span class="comment">// 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义引用的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">0</span>,m=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; nn=n,mm=m;</span><br><span class="line">n=<span class="number">10</span>,m=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n,m:%d,%d\n&quot;</span>,n,m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nn,mm:%d,%d\n&quot;</span>,nn,mm); </span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//10,20</span></span><br><span class="line"><span class="comment">//10,0</span></span><br></pre></td></tr></table></figure>
<p>在重载结构体 <code>+=,=</code> 运算符号的时候比较常用。</p>
<p>引用传参应该已经很熟悉了吧。</p>
<h4 id="左值引用和右值引用">左值引用和右值引用</h4>
<p><code>C++11</code> 新概念。<a
href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c">参考阅读</a></p>
<p>一般的，使用引用传参时，如果接受的参数为右值，那么不能修改右值，参数必须声明为
<code>const</code> 类型。</p>
<p>算了，先咕咕咕了吧。</p>
<h2 id="模板">模板</h2>
<p>如果用的不好，容易出现找不到实现的问题。</p>
<p>一个原则：所有东西的类型必须在使用前就得知。</p>
<h3 id="类模板">类模板</h3>
<p>继承的时候需要写明父类的类型参数，如果子类也是模板类，可以用子类的类型模板参数作为父类的类型模板参数。</p>
<h3 id="函数模板">函数模板</h3>
<p>函数模板是可以自动推导类型的，如果出现类型冲突，那么会报
<code>CE</code>。</p>
<p>常见例子是 <code>std::max(1,1ll)</code> 报错。</p>
<p>注意字面量的类型。</p>
<p>指定模板参数可以仅指定一段前缀，剩下的采用自动推导。</p>
<h3 id="多文件的一些问题">多文件的一些问题</h3>
<h4 id="按惯例编写的问题">按惯例编写的问题</h4>
<p>通常情况下，你会在 .h
文件中声明函数和类，而将它们的定义放置在一个单独的 .cpp
文件中。但是在使用模板时，这种习惯性做法将变得不再有用，因为当实例化一个模板时，编译器必须看到模板确切的定义，而不仅仅是它的声明。</p>
<h4 id="定义和声明一起写">定义和声明一起写</h4>
<p>可以将模板的声明和定义都放置在同一个 .h 文件中。这就是为什么所有的
STL 头文件都包含模板定义的原因。</p>
<p>习惯来说，一般把这种包含定义的头文件后缀名写为
<code>.hpp</code>。</p>
<h4 id="使用-export">使用 export</h4>
<p>咕咕咕</p>
<h2 id="static-关键字">Static 关键字</h2>
<p>声明一个静态的东西，可以用来避免命名冲突，也可以用来更好的实现一个类。</p>
<p>Static
关键字声明的东西生命周期是整个程序的生命周期，但作用域仅限定为声明处的作用域。</p>
<p>举个例子，某个函数的执行过程和它被调用的次数有关，这个可以弄个全局变量记一个次数，但是我们也可以在它的内部写个
static 变量记录，这样就不会与外部空间变量名冲突。</p>
<p>所有静态变量的初始值为 0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cnt;</span><br><span class="line">	cout&lt;&lt;++cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fun</span>();cnt=<span class="number">10</span>;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"><span class="built_in">fun</span>();<span class="built_in">fun</span>();cnt++;<span class="built_in">fun</span>();</span><br></pre></td></tr></table></figure>
<p>也可以用静态成员来维护一个类，比如写链表的时候，我们通常要先写个 node
类，然后才能实现 list 类，但我们可以直接将 head
指针作为一个静态变量放入结构体中，这样，这个静态变量就可以被所有结构体的实例访问修改。</p>
<p><strong>注意，如果需要两个链表，那种这种方式是不可取的，因为静态变量
head 对所有该结构体的实例来说都只有一个。</strong></p>
<p>我们当然也可以声明静态成员函数。</p>
<p>对于结构体的静态资源，我们可以用 {结构体名}.{成员名} 来访问。</p>
<h2 id="函数匿名函数">函数，匿名函数</h2>
<p>C++
的函数名，本质上是一个指向某个函数的指针，函数在二进制层面和数据没有差异。</p>
<p>functor (一般译为算子)，也可以调用，但它是一个对象。</p>
<h4 id="函数类">函数类</h4>
<p>C++
的函数可以当作一个对象处理的，<strong>函数名是指向该对象的指针</strong>，比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;x++;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;x--;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doit</span><span class="params">(<span class="type">int</span> &amp;x,function&lt;<span class="type">void</span>(<span class="type">int</span>&amp;)&gt; f)</span></span>&#123;(x);&#125;</span><br><span class="line">n=<span class="number">10</span>;<span class="built_in">doit</span>(n,del);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">n=<span class="number">20</span>;<span class="built_in">doit</span>(n,add);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br></pre></td></tr></table></figure>
<h4 id="匿名函数">匿名函数</h4>
<p>格式：<code>["捕获列表"]("参数列表")-&gt;"返回类型"&#123;"函数体"&#125;</code></p>
<p>捕获列表指的捕获局部变量，在函数中可以使用和修改。</p>
<p>参数列表无参数时可以省略，返回值如果不指定则会自动推导。</p>
<p>捕获列表不可省略，[] 为强制不捕获，[&amp;] 为引用捕获全部，[=]
为取值捕获全部，也可以用变量名 [x,&amp;y] 取值捕获 x，引用捕获 y。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> x&gt;y;&#125;); <span class="comment">//降序排序</span></span><br></pre></td></tr></table></figure>
<p>匿名函数也可以作为一个对象处理。</p>
<h4 id="虚函数">虚函数</h4>
<p>这个东西自己写的时候用的比较少，毕竟不太注重面向对象，</p>
<p>这玩意和 <code>Python</code> 的 <code>abstract_method</code>
类似，我也不知道怎么解释，反正会用就够了。</p>
<p>竞赛中应用的话，可以用来重写 <code>pd_ds</code>
里面的平衡树，但是真的用的很少。</p>
<h2 id="语法糖">语法糖</h2>
<h3 id="函数相关">函数相关</h3>
<h4 id="返回值为-void-的函数">返回值为 void 的函数</h4>
<p>你是否碰到过这样的情况，函数返回值为
void，但是返回又是有条件，并且还需要执行一些简单的操作，用
<code>&#123;&#125;</code> 括起来显得代码冗长，不妨试试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_cool_thing</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(some_condition) <span class="keyword">return</span> <span class="built_in">void</span>(a_simple_expression);</span><br><span class="line">    <span class="built_in">do_cool_thing</span>(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_cool_thing</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(some_condition) <span class="keyword">return</span> <span class="built_in">void</span>(ans++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有返回值的函数">有返回值的函数</h4>
<p><code>,</code> 可以用在 return
语句，会返回最后一个值，当然也可以用在其它 <code>Case</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_v</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>,<span class="number">5</span>;<span class="comment">// return value is 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">new_node</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[++t]=node&#123;<span class="built_in">mt_rand</span>(), <span class="number">1</span>, x, <span class="number">0</span>, <span class="number">0</span>&#125;, t;</span><br><span class="line">    <span class="comment">//can you guess what it do and when we use it?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="列表初始化器">列表初始化器</h3>
<p>这东西说白了就是 <code>&#123;1,2,3,4,5&#125;</code>
这种，注意区分类成员初始化器，后者可以多类型，前者只能单类型。</p>
<h4 id="循环">循环</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:&#123;<span class="number">0</span>,<span class="number">1</span>&#125;)&#123;</span><br><span class="line">	<span class="built_in">do_cool_thing</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分支更少，效率更高，代码更优美！</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>代码技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有点容易忘的基础算法</title>
    <url>/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%82%B9%E5%AE%B9%E6%98%93%E5%BF%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="树链剖分">树链剖分</h2>
<p>常用的树链剖分有重链剖分，实链剖分和长链剖分。</p>
<p>长链剖分主要用于部分和深度有关的树形 <span
class="math inline">\(dp\)</span> 的优化，一般采用指针数组实现。</p>
<p>我们说的树链剖分一般指重链剖分，即选择每个点子树最大的儿子。</p>
<p>不难证明从任何一个点到根都只会经过 <span
class="math inline">\(log_n\)</span> 条重链，这也是其复杂度的保证。</p>
<p>可以将每条重链用一个数据结构维护起来，就能做树上操作了。</p>
<h2 id="动态树">动态树</h2>
<p>动态树是基于实链剖分的数据结构，非常强大，但编码复杂度相对较高。</p>
<p>我使用的是基于 <span class="math inline">\(splay\)</span>
的动态树。</p>
<p>动态树维护的是若干实链，每个实链用一颗平衡树维护。</p>
<p>动态树的核心操作是 <code>access</code>，意味将目标点 <span
class="math inline">\(x\)</span>
到根的路径全部打通，并且只包含这条路径。</p>
<p>其它操作简要介绍一下实现：</p>
<p><code>make_root</code> :先 <code>access</code>，然后把 <span
class="math inline">\(x\)</span> <code>splay</code> 到根，然后翻转整颗
<span class="math inline">\(splay\)</span> ，因为 <span
class="math inline">\(splay\)</span> 外的形态没有改变，所以只要 <span
class="math inline">\(splay\)</span>
内部的形态正确，那么整棵树的形态就正确，如果对于一个 <span
class="math inline">\(splay\)</span>
所有的节点交换了左右儿子，那么就是倒序了这颗 <span
class="math inline">\(splay\)</span> ，<span
class="math inline">\(x\)</span>
又是深度最大的点，所以这样是正确的。</p>
<p><code>link</code> :很简单，直接将目标点 <span
class="math inline">\(x\)</span> <code>splay</code>
到当前根，当然，注意到原树之间的关系是 <span
class="math inline">\(splay\)</span> 根节点的关系，<span
class="math inline">\(splay\)</span> 根节点的父亲其实是 <span
class="math inline">\(splay\)</span>
中深度最小的点的父亲，然后改父亲改成 <span
class="math inline">\(y\)</span> 就行。</p>
<p><code>cut</code> :假设有一个虚根 <span
class="math inline">\(0\)</span>，把 <span
class="math inline">\(x\)</span> <code>make_root</code> ，把 <span
class="math inline">\(y\)</span> <code>access</code> 然后
<code>splay</code> <span
class="math inline">\(y\)</span>,直接双向断开。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//该更新的要更新</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//旋转标记和其它标记的 push_down</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isroot</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;<span class="keyword">return</span> T[T[rt].fa].son[<span class="number">0</span>]!=rt&amp;&amp;T[T[rt].fa].son[<span class="number">1</span>]!=rt;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=T[x].fa,z=T[y].fa,o=T[y].son[<span class="number">1</span>]==x,b=T[x].son[o^<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">isroot</span>(y))T[z].son[T[z].son[<span class="number">1</span>]==y]=x;</span><br><span class="line">	T[y].fa=x;T[x].son[o^<span class="number">1</span>]=y;T[x].fa=z,T[y].son[o]=b,T[b].fa=y;</span><br><span class="line">	<span class="built_in">push_up</span>(y),<span class="built_in">push_up</span>(x);</span><br><span class="line">    <span class="comment">//已经很熟的 rotate 操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> u=x;st[++top]=u;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isroot</span>(u))u=T[u].fa,st[++top]=u;</span><br><span class="line">	<span class="keyword">while</span>(top)<span class="built_in">push_down</span>(st[top--]);</span><br><span class="line">    <span class="comment">//记得先 push_down</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> y=T[x].fa;!<span class="built_in">isroot</span>(x);y=T[x].fa)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isroot</span>(y))<span class="built_in">rotate</span>((T[T[y].fa].son[<span class="number">1</span>]==y)==(T[y].son[<span class="number">1</span>]==x)?y:x);</span><br><span class="line">        <span class="comment">//双旋，其实一般单旋也不会卡。</span></span><br><span class="line">		<span class="built_in">rotate</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//亲切的 splay 操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记得断开和儿子的连接</span></span><br><span class="line">    <span class="comment">//splay 之间是原树的关系连接，但 splay 内部维护的只是一条链，中序遍历 splay 才能得到原树</span></span><br><span class="line">	<span class="keyword">for</span>(;x;y=x,x=T[x].fa)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">splay</span>(x);T[x].son[<span class="number">1</span>]=y;</span><br><span class="line">		<span class="built_in">push_up</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚树">虚树：</h2>
<p>一般用来处理询问很多但规模不大的树上问题。</p>
<h2 id="点分治">点分治</h2>
<p>用来处理树上路径的计数问题，特别是路径长度相关</p>
<h2 id="后缀排序">后缀排序</h2>
<p>对一个字符串的所有后缀排序，约定 <span
class="math inline">\(sa[i]\)</span> 表示排名为 <span
class="math inline">\(i\)</span> 的后缀的起始位置，约定 <span
class="math inline">\(rk[i]\)</span> 表示起始位置为 <span
class="math inline">\(i\)</span> 的后缀的排名。<span
class="math inline">\(height[i]\)</span> 为排名为 <span
class="math inline">\(i,i-1\)</span> 的后缀的 <span
class="math inline">\(lcp\)</span> 。</p>
<p>先按第一个字母基数排序一遍，然后倍增法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)sum[rk[i]=ch[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">128</span>;i++)sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//统计 sum,sum[i] 表示关键字比 i 小的总个数，然后遍历的时候，用每个后缀当前排名访问 sum，</span></span><br><span class="line"><span class="comment">//得到 sum[rk[i]] 为以 i 为起始位置的后缀的排名。</span></span><br><span class="line"><span class="comment">//访问后 sum 需要自减。</span></span><br><span class="line"><span class="comment">//但并不记录这个排名，因为它不准确，相同的会认为是不同，记录排名为 sum[rk[i]] 的后缀的起始位置。</span></span><br><span class="line"><span class="keyword">for</span>(i=n;i&gt;=<span class="number">1</span>;i--)sa[sum[rk[i]]--]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)tp[i]=rk[i];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)rk[sa[i]]=(tp[sa[i]]==tp[sa[i<span class="number">-1</span>]])?m:++m;</span><br><span class="line"><span class="comment">//这里重新计算每个后缀的排名，我们可以简单由 sa 数组得到。</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;;k&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m=s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n-k<span class="number">+1</span>;i&lt;=n;i++)tp[++s]=i;</span><br><span class="line">    <span class="comment">//这些第二关键字为 0 ，所以仍在最前面</span></span><br><span class="line">    <span class="comment">//tp[i] 在这里表示第二关键字排名为 i 的后缀的起始位置</span></span><br><span class="line">    <span class="comment">//这里在按第二关键字安排顺序，第一遍在外面排序的时候不关心第二关键字</span></span><br><span class="line">    <span class="comment">//在倍增里排序关心第二关键字，我们只需要按第二关键字的顺序访问 sum，就能得到正确顺序。</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;sum[i++]=<span class="number">0</span>)<span class="keyword">if</span>(sa[i]&gt;k)tp[++s]=sa[i]-k;</span><br><span class="line">    <span class="comment">//同样是处理第二关键字，按照上一轮排名顺序遍历即可。</span></span><br><span class="line">    <span class="comment">//位置减去 k,得到第二关键字的起始位置。</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)sum[rk[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&gt;=<span class="number">1</span>;i--)sa[sum[rk[tp[i]]]--]=tp[i];</span><br><span class="line">    <span class="comment">//同样的道理，只不过是按第二关键字大小顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)tp[i]=rk[i];</span><br><span class="line">    <span class="comment">//这里的 tp 用来拷贝 rk,因为 rk 在计算时会改变</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)rk[sa[i]]=(tp[sa[i]]==tp[sa[i<span class="number">-1</span>]]&amp;&amp;tp[sa[i]+k]==tp[sa[i<span class="number">-1</span>]+k])?m:++m;</span><br><span class="line">    <span class="comment">//计算每个后缀当前排名</span></span><br><span class="line">    <span class="keyword">if</span>(m==n)<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//后缀排序结束后退出。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算 height 数组</span></span><br><span class="line"><span class="comment">//height 数组满足 height[sa[i]] &gt;= height[sa[i]-1] - 1</span></span><br><span class="line"><span class="comment">//如果 sa[i] = 1，那么 height 没定义，不管。</span></span><br><span class="line"><span class="comment">//原因很简单，以  排名在以 sa[i]-1 为起始点的后缀 x 前一个的后缀 y。</span></span><br><span class="line"><span class="comment">//由定义 lcp(x,y) = height[sa[i]-1]</span></span><br><span class="line"><span class="comment">//将 x 删掉最前一个字符得到以 sa[i] 为起始点的后缀 a， y 删掉最前一个字符得到 b</span></span><br><span class="line"><span class="comment">//那么 lcp(a,b) = lcp(x,y)</span></span><br><span class="line"><span class="comment">//显然 b 排在 a 前面</span></span><br><span class="line"><span class="comment">//显然排名在 a 前一位的那个后缀与 a 的 lcp 不可能少于 height[sa[i]-1]</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    height[rk[i]]=<span class="built_in">max</span>(<span class="number">0</span>,height[rk[i<span class="number">-1</span>]]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(rk[i]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch[i+height[rk[i]]<span class="number">+1</span>]==ch[sa[rk[i]<span class="number">-1</span>]+height[rk[i]]<span class="number">+1</span>])height[rk[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="莫队">莫队</h2>
<p>莫队是暴力数据结构，将询问离线后，以较低的复杂度移动左右端点，然后处理询问。</p>
<p>设移动端点的复杂度为 <span class="math inline">\(O(x)\)</span>
，那么莫队复杂度为 <span class="math inline">\(O(n \sqrt n\times
x)\)</span>，无法将 <span class="math inline">\(x\)</span> 放在 <span
class="math inline">\(\sqrt n\)</span> 下面。</p>
<p>常见的卡常技巧有奇偶性排序等。</p>
<p>如果只能支持插入和删除中的一种操作，那么可以使用回滚莫队，拿一个栈记录操作，基于操作的撤销实现插入或删除。</p>
<p>树上莫队和普通莫队区别不大。</p>
<p>(差一个二次离线要补)</p>
<h3 id="拓展kmp">拓展KMP</h3>
<p>咕咕咕</p>
<h3 id="树哈希">树哈希</h3>
<p>一般来讲，可以这么哈希，<strong>再加上树大小的判断</strong>，就不会出问题。
<span class="math display">\[
f_{now}=1+\sum f_{son(now,i)} \times prime(size_{son(now,i)})
\]</span></p>
<p>但这个哈希是有错的，可以对最小括号序列哈希。</p>
<p>具体的，一颗无标号有根树按照遍历顺序可以得到一个括号序列，即将子树的括号序列拼起来再套一个括号。</p>
<p>然后考虑对这个括号序列哈希，因为遍历顺序无关，所以要最小括号序列。</p>
<p>实际上可以直接对子树哈希值排序之后，按这个顺序往后写，外面添一层括号，对括号序列（二进制串）哈希。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从一道题看CPU底层优化-第一弹</title>
    <url>/2022/07/12/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8BCPU%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96-%E7%AC%AC%E4%B8%80%E5%BC%B9/</url>
    <content><![CDATA[<h2 id="关于某道题的优化">关于某道题的优化</h2>
<h3 id="题意">题意</h3>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span
class="math inline">\(a_i\)</span>，求有多少个区间满足每个数出现次数均为偶数。</p>
<p><span class="math inline">\(n\leq 3\times 10^4,a_i\leq
10^6\)</span></p>
<h3 id="思路">思路</h3>
<p>双指针扫描每个区间，拿个桶，<span class="math inline">\(O(1)\)</span>
更新状态，然后 <span class="math inline">\(O(n^2)\)</span>，可以得到
<span class="math inline">\(40\)</span> 的好成绩。</p>
<h3 id="代码一">代码一</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30005</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,ans;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">unsigned</span> cnt[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;gf.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;gf.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">		now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[a[j]])now+=(cnt[a[j]]&amp;<span class="number">1</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">			cnt[a[j]]+=<span class="number">1</span>;</span><br><span class="line">			ans+=now==<span class="number">0</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化">优化</h3>
<h4 id="高速缓存原理">1.高速缓存原理</h4>
<p>计算机有个东西叫高速缓存，可以优化内存访问延迟。</p>
<p>一次独立的内存操作会读取一个 <span
class="math inline">\(64Byte\)</span> 的 <span
class="math inline">\(cacheline\)</span>，从指令发出到从内存收到数据需要约
<span class="math inline">\(200\)</span> 个 <span
class="math inline">\(CPU\)</span> 周期，而 <span
class="math inline">\(CPU\)</span> 会将一些常用的数据塞进 <span
class="math inline">\(cache\)</span>，也就是高速缓存中，加速读取，寄存器的访问速度是最快的，只需要不到
<span class="math inline">\(1\)</span> 个时间周期，<span
class="math inline">\(L1\)</span> 缓存需要约 <span
class="math inline">\(3\)</span> 个时间周期，<span
class="math inline">\(L2\)</span> 为 <span
class="math inline">\(10\)</span> 个左右，<span
class="math inline">\(L3\)</span> 为 <span
class="math inline">\(20\)</span> 个周期。</p>
<p>具体时间视计算机本身有差别，但基本的比例是这个。</p>
<p>代码一中，我们只关注瓶颈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">now+=<span class="number">-1</span>+((cnt[a[j]]&amp;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">now+=!cnt[a[j]];</span><br><span class="line">cnt[a[j]]+=<span class="number">1</span>;</span><br><span class="line">ans+=now==<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>其中，对于 <code>cnt</code> 的访问和对于 <code>a</code>
的访问，由于高速缓存并不大，所以塞不下
<code>cnt</code>，因此我们每个循环都需要等一个 <code>200</code>
时间周期的延迟，这是相当致命的，实际上等待的延迟并没有 <code>200</code>
时间周期，因为 <span class="math inline">\(CPU\)</span>
将部分数据还是放进来 <code>cache</code>，但具体放哪些是由
<code>CPU</code> 决定的。</p>
<p>对于这个致命的延迟，我们可以将数据离散化，然后就可以得到一个
<code>75pts</code> 的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30005</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,ans;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">unsigned</span> cnt[<span class="number">1024</span>*<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;gf.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;gf.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(b<span class="number">+1</span>,b+n<span class="number">+1</span>);m=<span class="built_in">unique</span>(b<span class="number">+1</span>,b+n<span class="number">+1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b+m<span class="number">+1</span>,a[i])-b;</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">		now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=i;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cnt[a[j]])now+=cnt[a[j]]&amp;<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">			cnt[a[j]]+=<span class="number">1</span>;</span><br><span class="line">			ans+=now==<span class="number">0</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="流水线模式和延迟隐藏">2.流水线模式和延迟隐藏</h4>
<p>现代计算机各类硬件的设计都采用了流水线模式，将每条汇编指令的执行都划分为了不同的流水线。</p>
<p>也就是说 <strong>CPU
可以不间断的向内存发出访问指令，这些指令经过一定延迟后，内存会不间断的向CPU传数据，这个过程中，我们就只等待了一个内存延迟。</strong>打个比方，这玩意就像烧水，水壶很多，灌水和倒水的时间都很短，所以正确的方式是全部烧上等，而不是烧一个等一个。</p>
<p>所以，如果我们能够连续的发出内存访问指令，那么内存延迟可以被有效隐藏，但注意到代码中，访问了内存后执行了一些计算，而内存访问是依赖于这些计算的，这产生了一个依赖，我们必须等待计算完成之后才能进行访问，所以无法有效的隐藏延迟。</p>
<p><strong>向内存写入数据也是需要等待延迟的。</strong></p>
<h4 id="流水线和依赖分析">3.流水线和依赖分析</h4>
<p>上一部分简单介绍了流水线模式，在我们的 <span
class="math inline">\(CPU\)</span> 中，也采用流水线的设计。</p>
<p>一条汇编指令的执行在 <span class="math inline">\(CPU\)</span>
上大致分为五个部分，分别是：取指，访(寄)存，计算，内存操作，写回。</p>
<p><span class="math inline">\(CPU\)</span>
在这五个部分的设计上也采用了流水线，一条指令开始访存时，另一条指令的取指就开始了。</p>
<p>而如果下一条指令对前一条指令有<strong>数据依赖</strong>，那么 <span
class="math inline">\(CPU\)</span>
会通过转发操作消除这种依赖，但如果下一条指令的内容对上一条指令有依赖（比如说
if），那么 <span class="math inline">\(CPU\)</span>
就不得不停止流水线，向流水线中插入气泡以等待。</p>
<p>这会极大降低 <span class="math inline">\(CPU\)</span>
的利用率，因此，内循环中的 <span class="math inline">\(if\)</span>
是相当不应该的。</p>
<h4 id="流水线和分支预测">4.流水线和分支预测</h4>
<p>事实上，硬件的设计者注意到了这种依赖，而 <span
class="math inline">\(CPU\)</span>
会对这种依赖做出预测，预测基于程序计数器的的原理和一些其它统计数据，正确率约在
<span class="math inline">\(65\%\)</span>
左右，如果分支预测出现错误，那么会花费两个时间周期去消除这个错误，所以我们需要通过算术方式避免分支。</p>
<p>方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30005</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,ans;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> cnt[<span class="number">1024</span>*<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;gf.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;gf.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(b<span class="number">+1</span>,b+n<span class="number">+1</span>);m=<span class="built_in">unique</span>(b<span class="number">+1</span>,b+n<span class="number">+1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b+m<span class="number">+1</span>,a[i])-b;</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">		now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=i;j&lt;=n;j++)&#123;</span><br><span class="line">			now+=<span class="number">-1</span>+((cnt[a[j]]&amp;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">			now+=!cnt[a[j]];</span><br><span class="line">			cnt[a[j]]+=<span class="number">1</span>;</span><br><span class="line">			ans+=now==<span class="number">0</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前是最快代码。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>代码技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>AI相关学习资料汇总</title>
    <url>/2022/07/12/%E5%AD%A6%E6%9C%AF/%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/AI%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="一些-ai-相关的资料">一些 AI 相关的资料</h2>
<h3 id="gpu-编程">GPU 编程</h3>
<ul>
<li><a href="https://blog.csdn.net/shuzfan/article/details/76650947">GPU
编程</a></li>
<li><a href="https://www.jianshu.com/p/8c461c1e5e01">CPU,GPU
内存缓存原理以及相关内容在 CUDA 上的应用</a></li>
</ul>
]]></content>
      <categories>
        <category>学术</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>资料</tag>
      </tags>
  </entry>
</search>
