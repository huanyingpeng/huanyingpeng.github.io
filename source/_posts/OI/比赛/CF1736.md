---
title: CF1736总结
mathjax: true
date: 2022-10-15 15:29:58
tags:
categories:
---

## C

这里的 C 指 C2。

首先来一波 $\pm i$ 变成相对简单的判 $> 0$ 问题。

### Method1

考试的时候，比较自然的考虑计算跨过某个数的合法区间总数，发现可以把某个位置开头最远的区间给算出来。

然后就是个二维偏序。

然后对于新修改的元素，计算跨过它的合法区间个数，如果改小了，一定只会有一些数被这个东西限制，我选择做一个极度毒瘤的二维偏序。

如果改大了，一定只会有一些数在此处的限制被放开，再处理每个数放开一次限制后的最大位置即可，对于同一位置，可以处理单点前缀和，然后在上面 `lower_bound`。

显然两个都是可以在线做的，但是考试的时候没有发现被限制的数一定是一个区间，然后就出现了毒瘤。

不知道自己写的什么狗屎离线做法，奇丑无比。

### Method2

上面那个搞什么二维偏序是邪道。

还是考虑求跨过每个数的合法区间个数，某个位置 $x$ 会限制另一个位置 $i$，当且仅当 $a_x+i\le 0$，所有一个位置限制的位置一定是一个前缀，这部分前缀的前缀会在这个位置之前被另外的位置限制，这是是可二分的。

所以改小的影响就好算了，找到被改小的数限制的区间，这一部分求总长度然后减去 $cnt\times x$ 得到答案减小值。

改大会比较麻烦，参考上面的处理方式。

### Conclusion

**多找点性质，又不妨碍做题。**

**多学着点二分，别去搞什么垃圾数据结构二维偏序。**

## D

比较清新的构造题，难度不大，但是场上没想出来。

先假设没有操作，尝试求解该问题，发现它比较困难（似乎不存在多项式做法），所以应该考虑能不能构造出特殊情况。

考场上我看成了 `reverse`，这也是可做的，只需要构造出形如 `0000011111` 的串就行，方法是选上末尾的，插在 `1` 之间的 `0`，然后和前面的 `1` 交换，设 `1` 的个数为 $cnt_1$，那么选择后面 $cnt_1$ 个位置中所有的 `0`，再选出前面所有的 `1`，交换即可。

实际上是循环左移，同样考虑构造特殊情况，这次选择构造 `001100111100` 这种。

如果不是，就选一个，找到下一个同样不满足的，然后移过来，最后一定有偶数个不满足的，用不同的数隔开就行。

**本质上，这个操作相当于选了偶数个相邻数不同的数，把它们 flip。**
