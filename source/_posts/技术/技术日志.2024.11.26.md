## 一些日常可能会用得上的技术（二）

### 写在前面

> 虽然很多人能够熟练掌握一门编程语言，也能用这门编程语言方便的批处理数据，但是每次总要借助这门语言的 编译器/解释器，然后调用一些系统函数之类的，总感觉缺了点意思。
>
> Linux/Windows 其实在 shell 中已经提供了一门完备的编程语言来直接处理文件或者数据，这相比与写一份代码来运行它要有趣很多。
>
> 你不必记下本文的所有细节，只需要知道有这些所介绍的功能即可，记忆会在你的使用过程中一步步完成，AI 能提供的信息会比本文更详尽。

### 一些常用命令

#### grep

```
grep [选项] 模式 [文件...]
```

- 选项
  - `-i`：忽略大小写。
  - `-r`：递归搜索子目录。
- 模式
  - 默认是标准正则。
  - 用 `-F` 参数禁止正则（所有正则符号被视为文本）。
  - 用 `-E` 支持扩展正则表达式。
- 文件
  - 用 `-` 表示标准输入。（第一期讲过 "一切皆文件"）
  - 支持多个文件，每个文件用空格隔开。
  - 文件名可以采用通配符语法（见附录，大部分文件名参数都可以支持通配符）。
    - 通配符语法匹配的并不是相对路径，而是对于每一层目录和文件名独立匹配，也就是说 `f1/*.txt` 不能匹配 `f1/` 子目录下的 .txt 文件。
- Windows 平替
  - 可以去下载一个 [ripgrep](https://github.com/BurntSushi/ripgrep) 加入系统路径后当平替，用法基本一致，命令改为 `rg`。

#### echo

- 用于输出字符串。

  ```
  echo [一个字符串]
  ```

- 常用参数

  - `-e`：指定转义 `\` 相关的换行（`\n`），制表符（`\t`）等。
  - `-E`：指定不转义。

- 备注：

  - 不同操作系统的 `echo` 标准不一样，所以有 `-e-E` 这种看上去反人类的参数。
  - Windows 系统的 `PowerShell` 也有 `echo`，但是它的转义符是 "`"，系统默认发生转义操作。  

#### cat

- 题外话

  - 见下图。

    <img src="https://raw.githubusercontent.com/huan-yp/image_space/master/img/202411252351829.jpg" style="zoom:2%;" />

  - 为什么学计算机的很多人都喜欢猫~~？
  
- 查看文件内容

  ```
  cat [文件...]
  ```

  - 会输出结果到终端。

- 其它用法

  - 写入文件：

    ```
    cat [文件...] >> file.txt
    ```

    - `>`：覆盖写入。
    - `>>`：追加写入。

  - 文件部分可以接受命令行输入，`>` 或者 `>>` 前不填写任何参数就使用命令行输入。

  - 使用 EOF

    ```
    cat > file.txt << EOF
    ```

    - 接下来的输入中，输入 EOF 并回车结束输入，EOF 不会被写入。

    - 如果不使用 << EOF 也不使用管道

#### wc

- 统计文件字数

  ```
  wc [文件...]
  ```

- 常用参数

  - `-l`：统计行数。

- 其它

  - 可以接受命令行输入。

    ```
    command | wc -m
    ```

#### head/tail

```
head [文件名...]
```

- 用于显示文件的最开始/最后 10 行。
- 常用参数：
  - `-n`：紧接着可以指定行数。
- 其它：
  - 支持命令行输入

#### rm

```
rm [文件名...]
```

- 用于删除文件。

- 常用参数：

  - `-r`：用于删除目录。
  - `-f`：忽略警告直接强制删除。

- 某个很厉害的命令：

  ```
  rm -rf /
  ```

  功能是删除本操作系统下所有文件，**请不要执行或者被人忽悠执行该命令！**

  数据无价，谨慎操作。

#### zip

```
zip [选项] [压缩文件名] [被压缩文件/被压缩目录...]
```

- 用于创建压缩文件。
- 常用选项：
  - **-r** 或 **--recursive**：递归地包含目录，即包括指定目录及其所有子目录。
  - **-u** 或 **--update**：更新现有的 zip 文件，添加新文件或更新已存在的文件。如果不用改参数覆盖时会提示。
  - **-x** 或 **--exclude**：后面输入一些 `[被压缩文件/被压缩目录...]`，排除指定的文件或目录。
  - **-v** 或 **--verbose**：详细模式，显示正在处理的文件名。
  - **-q** 或 **--quiet**：安静模式，不显示任何输出。
  - **-0** 到 **-9**：设置压缩级别，从无压缩（0）到最大压缩（9）

#### uzip

```
unzip [压缩文件名] [参数]
```

- 用于解压文件，默认解压到当前目录。

- 常用参数：

  - `-d`：后面接一个目录，解压到这个目录，不存在会创建。
  - `-l`：只查看里面的文件，不解压。

- 其它用法

  - 只解压部分文件

    ```
    unzip [压缩文件名] [要解压的文件在压缩文件中的路径...] [参数]
    ```

### 管道

- 管道的一般用法是 `command1 | command2` ，功能是将 `command1` 的标准输出作为 `command2` 的标准输入运行。

- 举例：

  - 使用 `sort` 对文件内容排序，并用 `uniq` 去除重复行：

    ```
    sort somefile.txt | uniq
    ```

  - 使用 `ls` 列出目录内容，`grep` 过滤特定模式的文件，然后 `sort` 排序结果：

    ```
    ls -l | grep "^-" | sort
    ```

### 变量

#### 声明

```
key=value
```

- `=` 的左右不能用空格。
- `value` 加上双引号被声明为字符串，不加声明为整形变量或者浮点变量。
- PowerShell 的声明使用 `$key=value`。

#### 变量引用

```
${变量名}
$变量名
```

- 第一种方式是为了防止歧义。
- 用 `\` 可以转义 `$`。

#### 运算

- $((expr)) 语法：

  ```
  $((算术表达式))
  ```

  - 举例：

    ```
    a=5
    b=3
    c=$((a + b))
    echo $c  # 输出 8
    ```

- 自增自减：

  ```
  $((a++))
  ```

- PowerShell 特性：

  ```
  $a++
  ```

  - 可以直接这样使用，但是在 `echo` 等命令中这样做不行。

- Shell 特性：

  ```
  let "new_var = var1 + var2"
  ```

  - `new_var` 可以是一个新变量名。

### 总结

- 大部分时候，常用命令的正则表达式、通配符等功能就可以完成大部分需要循环和分支的操作，用得上循环和分支的地方实际上不会很多。就算真的需要用到循环这些操作，这个时候使用 Python 等脚本语言可能会更方便了。
- 好好学习正则表达式。

### 附录

#### 关于一些语法

- 可变参数列表：[文件...] 是一个可变参数列表，习惯上命令行参数用空格隔开，所以它实际上表示 `[文件1]` 或 `[文件1] [文件2]` 或 `[文件1] [文件2] [文件3]` 等等。

#### 关于标准正则（BRE）

- `.`：匹配任意单个字符（除换行符外）。
- `^`：匹配每一行的开头（不占位，第一个字符仍需要被模式匹配）。
  - 也用于脱字，放在 `[]` 内部的最开始表示匹配除了 `[]` 中表达字符之外的所有字符
- `$`：匹配行的结尾。
- `[]`：匹配括号内的任意字符。
- `|`：逻辑或操作符。
- `*`：匹配前面的元素0次或多次。
- `+`：匹配前面的元素1次或多次。
- `-`：行为视上下文而定。
  - 在 `[]` 内它是一个特殊字符，它表示一个范围，例如`[a-z]` 可以匹配任何小写字母。
  - 在 `[]` 外是一个普通字符。
- `?`：匹配前面的元素0次或1次。
- `{n}`：精确匹配n次。
- `{n,}`：至少匹配n次。
- `{n,m}`：至少匹配n次，但不超过m次。
- `\`（反斜杠）：转义特殊字符或表示特殊序列的开始。
- `()`（圆括号）：将多个表达式组合成一个子表达式，用于分组和捕获。

#### 关于拓展正则（ERE）

- `\b`：匹配一个单词字符和非单词字符之间的边界。
- `\d`：等价于`[0-9]`。
- `\D`：等价于`[^0-9]`。
- `\s`：等价于`[ \t\n\r\f\v]`。（空白字符）
- `\S`：等价于`[^ \t\n\r\f\v]`。（非空白字符）
- `\w`：等价于`[a-zA-Z0-9_]`。（单词字符）
- `\W`：等价于`[^a-zA-Z0-9_]`。（非单词字符）
- `\n`：匹配换行符。
- `\t`：匹配制表符。
- `?`：非贪婪匹配（lazy quantifier）。

#### 关于通配符

通配符拥有部分正则的特性，支持不如正则完整，语法有微小差异，具体细节如下：

1. `*`：匹配任意数量的字符（包括零个字符）。
   - 例如：`*.txt` 匹配所有以 `.txt` 结尾的文件。
2. `?`：匹配任意单个字符。
   - 例如：`file?.txt` 匹配 `file1.txt`、`filea.txt` 等。
3. `[...]`：匹配括号内的任意单个字符。
   - 例如：`file[123].txt` 匹配 `file1.txt`、`file2.txt` 和 `file3.txt`。
   - 也可以使用范围：`file[a-z].txt` 匹配 `filea.txt` 到 `filez.txt`。
4. `[!...]` 或 `[^...]`：匹配不在括号内的任意单个字符。
   - 例如：`file[!123].txt` 或 `file[^123].txt` 匹配除了 `file1.txt`、`file2.txt` 和 `file3.txt` 之外的所有以 `.txt` 结尾的文件。
5. `{...}`：匹配花括号内的任意选项（选项之间用逗号分隔）。
   - 例如：`file.{txt,pdf}` 匹配 `file.txt` 和 `file.pdf`。
6. `\`：用于转义自己和以上特殊符号。