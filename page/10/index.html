<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"huanyp.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","display":"post","width_expanded":320,"width_dual_column":240,"padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="幻影彭的彩虹">
<meta property="og:url" content="http://huanyp.cn/page/10/index.html">
<meta property="og:site_name" content="幻影彭的彩虹">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="huan-yp">
<meta property="article:tag" content="算法竞赛, 自动化测试, 工程技术, Python">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://huanyp.cn/page/10/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/10/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>幻影彭的彩虹</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">幻影彭的彩虹</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录青春的扇区</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="huan-yp"
      src="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
  <p class="site-author-name" itemprop="name">huan-yp</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">105</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/huan-yp" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huan-yp" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3051561876@qq.com" title="E-Mail → mailto:3051561876@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/1155409006?spm_id_from=333.1369.0.0" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;1155409006?spm_id_from&#x3D;333.1369.0.0" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/%E6%8A%80%E6%9C%AF/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/%E6%8A%80%E6%9C%AF/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">一些有用的命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:24:19" itemprop="dateCreated datePublished" datetime="2022-07-12T16:24:19+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:47:52" itemprop="dateModified" datetime="2025-02-16T17:47:52+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="设置-pip-默认下载源">设置 pip 默认下载源</h4>
<p><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/%E6%8A%80%E6%9C%AF/%E7%94%9F%E4%BA%A7%E5%8A%9B/Hexo-NexT%20%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/%E6%8A%80%E6%9C%AF/%E7%94%9F%E4%BA%A7%E5%8A%9B/Hexo-NexT%20%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">Hexo-NexT 安装踩坑记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:22:10" itemprop="dateCreated datePublished" datetime="2022-07-12T16:22:10+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-22 11:18:20" itemprop="dateModified" datetime="2025-02-22T11:18:20+08:00">2025-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="博客部署">博客部署</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/618864711">参考</a></p>
<h3 id="环境">环境</h3>
<h4 id="基础">基础</h4>
<ul>
<li>git</li>
<li>nodejs &amp;&amp; npm</li>
</ul>
<h4 id="开工作目录">开工作目录</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p><strong>工作目录</strong>是
<code>blog</code>，记住，这很重要，文件名默认为相对工作目录的名字。</p>
<h4 id="本地预览">本地预览</h4>
<p>工作目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<p><code>localhost:4000</code> 上看。</p>
<h4 id="开-github-pages-仓库">开 GitHub Pages 仓库</h4>
<p>每个账号只能开一个，仓库名 <code>username.github.io</code>。</p>
<h4 id="配源码分支">配源码分支</h4>
<p>创仓库的时候把 main 弄下来，源码（不含
public）放这里，免得被覆盖。</p>
<h4 id="自动部署">自动部署</h4>
<p>工作目录下安自动部署工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p><code>_config.yml</code> 末尾加上（记得照着用户名改动）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># message: Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;)</span></span><br></pre></td></tr></table></figure>
<p>部署：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h3 id="metadata">metadata</h3>
<p>搜 <code>_config.yml</code> 相关配置项：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">幻影彭的彩虹</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;记录青春的扇区&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&#x27;算法竞赛, 自动化测试, 工程技术, Python&#x27;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">huan-yp</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 必须改</span></span><br><span class="line"></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://huanyp.cn</span></span><br></pre></td></tr></table></figure>
<h3 id="主题">主题</h3>
<h4 id="安主题next">安主题（next）</h4>
<p>工作目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<h4 id="写上要用这个主题">写上要用这个主题</h4>
<p><code>_config.yml</code> 里，找到 <code>theme</code>，写上
<code>next</code></p>
<h3 id="next">next</h3>
<p>我用 next 主题。</p>
<h4 id="menu">menu</h4>
<p>配置菜单。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-heartbeat</span></span><br></pre></td></tr></table></figure>
<h4 id="scheme">scheme</h4>
<p>在 <code>themes/next/_config.yml</code> 调 scheme，传统的应该选
<code>Gemini</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<h4 id="dark">dark</h4>
<p>应该没有人喜欢 light，所以调成 dark。</p>
<p>在 <code>themes/next/_config.yml</code> 调 darkmode。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">darkmode: true</span><br></pre></td></tr></table></figure>
<h3 id="背景">背景</h3>
<p>一般要加个背景图片什么的</p>
<h4 id="准备-source-图片">准备 source 图片</h4>
<p>图片放到 <code>themes/next/source/image/background.jpg</code>
里。</p>
<h4 id="改-style">改 style</h4>
<p>找到
<code>themes\next\source\css\_schemes\Gemini\index.styl</code>，加上：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">/images/background-now.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed; //不重复</span><br><span class="line">    <span class="attribute">background-size</span>: cover;      //填充</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 博客内容透明化</span><br><span class="line">// 文章内容的透明度设置</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 搜索框（local-search）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//博客内容透明化</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--content-bg-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那个 [0, 1] 的参数是透明度，自己估摸着调。</p>
<h3 id="友情链接">友情链接</h3>
<h4 id="menu-加-link">menu 加 link</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">友情链接:</span> <span class="string">/links/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br></pre></td></tr></table></figure>
<p>写中文就行。</p>
<h4 id="内联-html">内联 html</h4>
<p>新建 <code>source/links/index.md</code>，写入：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-body&quot;</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;links&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">      &lt;style&gt;</span></span><br><span class="line"><span class="code">         .links-content&#123;</span></span><br><span class="line"><span class="code">         margin-top:1rem;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .link-navigation::after &#123;</span></span><br><span class="line"><span class="code">         content: &quot; &quot;;</span></span><br><span class="line"><span class="code">         display: block;</span></span><br><span class="line"><span class="code">         clear: both;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card &#123;</span></span><br><span class="line"><span class="code">         width: 45%;</span></span><br><span class="line"><span class="code">         font-size: 1rem;</span></span><br><span class="line"><span class="code">         padding: 10px 20px;</span></span><br><span class="line"><span class="code">         border-radius: 4px;</span></span><br><span class="line"><span class="code">         transition-duration: 0.15s;</span></span><br><span class="line"><span class="code">         margin-bottom: 1rem;</span></span><br><span class="line"><span class="code">         display:flex;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card:nth-child(odd) &#123;</span></span><br><span class="line"><span class="code">         float: left;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card:nth-child(even) &#123;</span></span><br><span class="line"><span class="code">         float: right;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card:hover &#123;</span></span><br><span class="line"><span class="code">         transform: scale(1.1);</span></span><br><span class="line"><span class="code">         box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card a &#123;</span></span><br><span class="line"><span class="code">         border:none;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .ava &#123;</span></span><br><span class="line"><span class="code">         width: 3rem!important;</span></span><br><span class="line"><span class="code">         height: 3rem!important;</span></span><br><span class="line"><span class="code">         margin:0!important;</span></span><br><span class="line"><span class="code">         margin-right: 1em!important;</span></span><br><span class="line"><span class="code">         border-radius:4px;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .card-header &#123;</span></span><br><span class="line"><span class="code">         font-style: italic;</span></span><br><span class="line"><span class="code">         overflow: hidden;</span></span><br><span class="line"><span class="code">         width: 100%;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .card-header a &#123;</span></span><br><span class="line"><span class="code">         font-style: normal;</span></span><br><span class="line"><span class="code">         color: #2bbc8a;</span></span><br><span class="line"><span class="code">         font-weight: bold;</span></span><br><span class="line"><span class="code">         text-decoration: none;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .card-header a:hover &#123;</span></span><br><span class="line"><span class="code">         color: #d480aa;</span></span><br><span class="line"><span class="code">         text-decoration: none;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">         .card .card-header .info &#123;</span></span><br><span class="line"><span class="code">         font-style:normal;</span></span><br><span class="line"><span class="code">         color:#a3a3a3;</span></span><br><span class="line"><span class="code">         font-size:14px;</span></span><br><span class="line"><span class="code">         min-width: 0;</span></span><br><span class="line"><span class="code">         overflow: hidden;</span></span><br><span class="line"><span class="code">         white-space: nowrap;</span></span><br><span class="line"><span class="code">         &#125;</span></span><br><span class="line"><span class="code">      &lt;/style&gt;</span></span><br><span class="line"><span class="code">      &lt;div class=&quot;links-content&quot;&gt;</span></span><br><span class="line"><span class="code">         &lt;div class=&quot;link-navigation&quot;&gt;</span></span><br><span class="line"><span class="code">            &lt;div class=&quot;card&quot;&gt;</span></span><br><span class="line"><span class="code">               &lt;img class=&quot;ava&quot; src=&quot;博客图标&quot; /&gt;</span></span><br><span class="line"><span class="code">               &lt;div class=&quot;card-header&quot;&gt;</span></span><br><span class="line"><span class="code">                  &lt;div&gt;</span></span><br><span class="line"><span class="code">                     &lt;a href=&quot;博客链接&quot;&gt;博客名字&lt;/a&gt;</span></span><br><span class="line"><span class="code">                  &lt;/div&gt;</span></span><br><span class="line"><span class="code">                  &lt;div class=&quot;info&quot;&gt;博客简介&lt;/div&gt;</span></span><br><span class="line"><span class="code">               &lt;/div&gt;</span></span><br><span class="line"><span class="code">            &lt;/div&gt;</span></span><br><span class="line"><span class="code">            &lt;div class=&quot;card&quot;&gt;</span></span><br><span class="line"><span class="code">               &lt;img class=&quot;ava&quot; src=&quot;博客图标&quot; /&gt;</span></span><br><span class="line"><span class="code">               &lt;div class=&quot;card-header&quot;&gt;</span></span><br><span class="line"><span class="code">                  &lt;div&gt;</span></span><br><span class="line"><span class="code">                     &lt;a href=&quot;博客链接&quot;&gt;博客名字&lt;/a&gt;</span></span><br><span class="line"><span class="code">                  &lt;/div&gt;</span></span><br><span class="line"><span class="code">                  &lt;div class=&quot;info&quot;&gt;博客简介&lt;/div&gt;</span></span><br><span class="line"><span class="code">               &lt;/div&gt;</span></span><br><span class="line"><span class="code">            &lt;/div&gt;</span></span><br><span class="line"><span class="code">         &lt;/div&gt;</span></span><br><span class="line"><span class="code">      &lt;/div&gt;</span></span><br><span class="line"><span class="code">   &lt;/div&gt;</span></span><br><span class="line"><span class="code">&lt;/div&gt;</span></span><br><span class="line"><span class="code">&#123;% endraw %&#125;</span></span><br></pre></td></tr></table></figure>
<p>要加的时候在这复制 html 就行。</p>
<h3 id="杂项">杂项</h3>
<h4 id="置顶文章">置顶文章</h4>
<p>工作目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall --save hexo-generator-index</span><br><span class="line">npm install --save hexo-generator-index-pin-top</span><br></pre></td></tr></table></figure>
<p>metadata 部分写：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Title</span><br><span class="line"><span class="section">top: true</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>即可置顶。</p>
<h4 id="折叠">折叠</h4>
<p>在 <code>metadata</code> 中加上:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">description: 文件摘要</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>即可折叠.</p>
<h3 id="插件">插件</h3>
<h4 id="搜索插件">搜索插件</h4>
<p>工作目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>主题配置 <code>themes/next/_config.yml</code> 下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="数学插件">数学插件</h4>
<p>一般用 Mathjax。</p>
<p>先安装 <a
target="_blank" rel="noopener" href="https://pandoc.org/installing.html">Pandoc</a>，这个要改系统路径，需要重启终端。</p>
<p>工作目录下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked</span><br><span class="line">npm install hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>
<p>改 <code>themes/next/_config.yml</code> 的 math 配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">all</span></span><br></pre></td></tr></table></figure>
<p>每篇文档的 metadata 部分要写启用 Mathjax：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"><span class="section">mathjax: true</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>参考资料：<a
target="_blank" rel="noopener" href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md">Next
官方有关文档</a>。</p>
<h3 id="常用命令">常用命令</h3>
<ul>
<li><code>hexo g</code> : 生成</li>
<li><code>hexo s</code> : 本地部署</li>
<li><code>hexo d</code> : 远端部署</li>
</ul>
<h3 id="网络相关">网络相关</h3>
<h4 id="cname">CNAME</h4>
<p>hexo d 的时候因为是强制 push 的, github CNAME 文件时会被覆盖,
导致域名解析错误.</p>
<p><a
target="_blank" rel="noopener" href="http://eronana.github.io/2014/11/07/Hexo%E9%83%A8%E7%BD%B2%E5%90%8ECNAME%E8%A2%AB%E8%A6%86%E7%9B%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">解决方式</a></p>
<p>将 <code>CNAME</code> 放入 <code>./source</code>，即存在
<code>./source/CNAME</code> 文件。</p>
<h4 id="seo">SEO</h4>
<p>在 <code>google search console</code>
申请抓取的时候，一定要看清楚是不是 <code>https</code> 协议，如果部署在
<code>github</code> 上，可能会强制
<code>https</code>，导致抓取出现<strong>重定向错误。</strong>如果出现了这个错误，有可能是没用
<code>https</code> 协议。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%983/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%983/" class="post-title-link" itemprop="url">做题3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:13:03" itemprop="dateCreated datePublished" datetime="2022-07-12T16:13:03+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:58:21" itemprop="dateModified" datetime="2025-02-16T17:58:21+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="cf1698f">CF1698F</h3>
<h4 id="思路">思路</h4>
<p>变过来变过去，还 TM 离谱的操作当然要找不变量，算是半个套路。</p>
<p><code>reverse</code>
两端相等的区间，可以发现每两个相邻元素构成的无序对不变，然后第一个元素和最后一个元素不改变。</p>
<p>换句话说，<span class="math inline">\(\{(a_i,a_{i+1},i \in
[1,n)\}\)</span> 这个集合不随 <span class="math inline">\(a\)</span>
中操作改变。或者说，如果从 <span class="math inline">\(a_i\)</span> 到
<span class="math inline">\(a_{i+1}\)</span>
连边，这张无向图是不变的，同时 <span
class="math inline">\(a_1,a_n\)</span>
不改变。这个条件和上个条件之间的转换是解题的关键点之一。</p>
<p>套路又来了，看看样例，集合相同并且首尾相同这个条件貌似挺充分的，所以考虑证明。</p>
<p><strong>对于构造问题，常用的证明方式是数学归纳法。</strong></p>
<p>事实上，如果我们能证明如果第二个数可以成功调整为相同，那么整个数组也可以，因为满足条件的
<span class="math inline">\(a,b\)</span>
如果同时删掉第一个数，仍满足条件。</p>
<p>考虑构造方案，由结论可以知道，如果 <span
class="math inline">\(a\)</span> 中必定存在 <span
class="math inline">\((b_1,b_2)\)</span> 无序对，因为 <span
class="math inline">\(a_2\neq b_2\)</span>，不妨让这对无序对是 <span
class="math inline">\((a_x,a_{x+1}),x\in[2,n)\)</span>，如果 <span
class="math inline">\(a_x=b_2\)</span>，考虑直接将这一对中的 <span
class="math inline">\(a_{x+1}\)</span> 和 <span
class="math inline">\(a_1\)</span> 子数组 <code>reverse</code>
，完事。如果 <span
class="math inline">\(a_{x+1}=b_2\)</span>，事情有点麻烦。</p>
<p><code>if only i could find a pair which...</code></p>
<p>补上那句话，如果能找到一对可以被翻转的，左端点在 <span
class="math inline">\([1,x]\)</span> ，右端点在 <span
class="math inline">\((x,n]\)</span> 的，那么我们就翻转，改变了 <span
class="math inline">\(a_x,a_{x+1}\)</span> 的顺序。</p>
<p>尝试证明一定能找到，即 <span class="math inline">\(\{a_i ,i\in
[1,x]\} \bigcap \{a_i.i\in(x,n]\} \neq \emptyset\)</span></p>
<p>反证法，如果找不到，那么可知 $a_i,i$ 与 <span
class="math inline">\(a_j,j\in (x,n]\)</span> 除开 <span
class="math inline">\((a_i,a_i+1)\)</span> 这一次相邻外均不相邻，考虑
<span class="math inline">\(b_2\)</span> 即 <span
class="math inline">\(a_{x+1}\)</span> 的情况，它与 <span
class="math inline">\(b_3\)</span> 相邻，可知 <span
class="math inline">\(b_3 \in \{a_i.i\in(x,n]\}\)</span>，同理有 <span
class="math inline">\(\forall j\ge
2,b_j\in\{a_i.i\in(x,n]\}\)</span></p>
<p>考虑 <span class="math inline">\(a_2\)</span>，它显然不存在于 <span
class="math inline">\(b\)</span>，故矛盾。</p>
<h4 id="回顾">回顾</h4>
<p>这题比较难的有两个点，一是注意到这个不变量极大可能是充分条件，二是发现
<span class="math inline">\(a_{x+1}=b_2\)</span> 的 case
中一定存在可交换项，搞定了这两个，问题就迎刃而解。关键点在于第二个，找到
<span class="math inline">\(a_{[1,x]},a_{[x+1,n]}\)</span>
交集的关系，并尝试用反证法证明交集不为空是比较困难的。</p>
<h3 id="abc259g">ABC259G</h3>
<p>很有意思的网络流题。</p>
<p>最开始想到二分图相关，因为 <span class="math inline">\(A_{i,j}
&lt;0\)</span>
的限制指向性比较明确，然后发现如果二分图的决策正数话会出现不同块之间相互影响，所以考虑决策负数，决策负数不同联通块互不影响，但是无法计算答案，因为最终还是需要确定到底哪些正数被选了。</p>
<h4 id="解法一">解法一</h4>
<p>题解给出了一个新思路，考虑先只把所有正数选了，然后再来看满足条件的代价。</p>
<p>代价被分为了三类，第一类是顺带选择的负数的代价，如果选了一行或者一列，就会有这一行或列所有负数绝对值之和的代价。</p>
<p>第二类是无法选择正数的代价，如果正数所在的行和列都没被选择，那么就会有这个正数的代价。</p>
<p>第三类是重复选择负数的代价，如果一个负数被行和列同时选择（为了付出更少的第二类和其它第一类代价），那么这个代价是无穷大。</p>
<p>我们需要最小化代价。</p>
<p>0/1 决策问题，考虑套最小割上去，每一行每一列视为一个点。</p>
<p>令与 <span class="math inline">\(s\)</span> 同集合的为选择，与 <span
class="math inline">\(t\)</span>
同集合的为不选，选一行或一列的代价为该行或列负数绝对值之和，从个点到
<span class="math inline">\(t\)</span>
连边就行，行列同时选择负数，代价为
inf，woc，怎么连呢？从行连向列，意义为选了行不选列的代价，从列向行连，意义为选了列不选行的代价。所以我们前面的安排有些问题，需要做出调整。</p>
<p><strong>对于行和列，我们让属于 s,t
所在集合对它们有不同意义，下面让属于 s 的行为不选择，属于 t
的列为不选择</strong>，我们让 <span class="math inline">\(s\)</span>
向行连边，<strong>这条边</strong>表示选该行的代价，让列向 <span
class="math inline">\(t\)</span>
连边，表示选该列的代价。于是，对于一个点，行列都选的代价当且仅当 <span
class="math inline">\(A_{i,j}&lt;0\)</span> 时为
inf，此时从列向行连边，表示都选的代价，行列都不选的代价当且仅当 <span
class="math inline">\(A_{i,j}\ge0\)</span> 时为 <span
class="math inline">\(A_{i,j}\)</span>，此时从行向列连边。</p>
<p>注意，我们的割中如果出现了行列都不选，那么对应的行和列与 <span
class="math inline">\(s,t\)</span>
的边一定没有断开，所以必须断开行到列的边。如果出现了行和列都选的不合法情况，我们发现，断掉的行能到
<span class="math inline">\(t\)</span>，从 <span
class="math inline">\(s\)</span>
一定能到断掉的列。如果不满足，那么这个割就不是最小割，不会被我们考虑。所以我们需要从列到行连边，保证不会给负数打上两个标记。</p>
<p>这种思路和某类 dp
的思路很类似，相当值得学习，其实在原问题的求解中，并没有什么条件来保证不会给一个负数打上两个标记，但是我们在通过最小割求解时，限定了决策的范围和最优性，获得了额外的信息，也就能帮助我们排除掉难处理但是不可能的情况，本质上，这种排除还和我们先假定所有正数都选上的前提有关系，这种解法相当精妙。</p>
<h4 id="解法二">解法二</h4>
<p>从直觉上来看，应该不会选择和为负数的行或者列。考虑一个最终方案，它的答案会是
<span class="math inline">\(\sum 选择的行+\sum 选择的列 -\sum
行列交叉处的正数\)</span>。考虑从这里面剔除和为负数的列或行，发现最终值一定变大。</p>
<p>所以删掉和为负数的行和列。</p>
<p>考虑先把剩下的行和列全选了，然后解决冲突。</p>
<p>解决冲突的方式有三种，一种时不选行，一种是不选列，另一种是硬吃同时选的代价。</p>
<p>这样的建图就很简洁了，从 <span class="math inline">\(s\)</span>
向行，列向 <span class="math inline">\(t\)</span>
连边，对于交点，正数连其值的边，负数连 inf
边。很容易发现一个合法解和一个割一一对应，over。</p>
<h4 id="sum-up">Sum up</h4>
<p><strong>最小割解决实际问题的核心，在于用一个割，或者可能成为最小割的割，来代表一个实际的决策方案，最小割的容量，代表代价，每个点在哪个割集分别代表什么含义并不重要，重要的是割掉每条边的意义，和决策方案与最小割的对应关系。</strong></p>
<p>其实这道题还给我们一个启发，就是在考虑0/1决策问题时，可以先考虑钦定一个决策，再来调整使得它合理或者变优，这可能会使得问题变得简单，也许算是一个套路。</p>
<p><strong>本质上，最小割表达了一种最优的解决决策冲突的方案，我们在 0/1
决策问题钦定决策的过程中，制造了一些冲突，用一个图的割来表达解决着些冲突的方案。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%982/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%982/" class="post-title-link" itemprop="url">做题2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:10:15" itemprop="dateCreated datePublished" datetime="2022-07-12T16:10:15+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 18:01:20" itemprop="dateModified" datetime="2025-02-16T18:01:20+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="section">20220305</h2>
<h3
id="abc242f二项式反演的进一步理解">ABC242F(二项式反演的进一步理解)</h3>
<h4 id="题意">题意：</h4>
<p>给定一个 <span class="math inline">\(n*m\)</span> 的矩阵，需要放
<span class="math inline">\(a\)</span> 个白块 <span
class="math inline">\(b\)</span> 个黑块，让它们互不侵犯，<span
class="math inline">\(n,m\leq 50\)</span>。</p>
<p>最开始看到这道题以为又要挑战 <span
class="math inline">\(\text{npc}\)</span>
了，仔细一看互不侵犯的定义，是不能放在同一行或同一列。</p>
<h4 id="思考">思考：</h4>
<p>很有意思的容斥题，考虑枚举白色占了多大的地盘，设 <span
class="math inline">\(f[i][j]\)</span> 表示允许白色占用了 <span
class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列的方案数，然后组合数容斥。我们可以设
<span class="math inline">\(g[i][j]\)</span> 为白色恰好占用 <span
class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span>
列的方案数，考虑列出二项式反演的式子。思考 <span
class="math inline">\(f,g\)</span> 的关系，这是一类高维容斥问题。</p>
<p>结论如下： <span class="math display">\[
g[i][j] = f[i][j] - \sum\limits_{x\leq i,y\leq j,x+y \neq i+j }
\tbinom{i}{x} \times \tbinom{j}{y} \times g[x][y]
\]</span> 理解这个式子不难，就是减去恰好被占用的部分，注意容斥系数。</p>
<p>我们考虑能不能不用 <span class="math inline">\(g\)</span>
参与这个式子。</p>
<p>回想线性的二项式反演问题，我们有式子： <span class="math display">\[
f(n) = \sum\limits_{i=n}^{m} \tbinom{i}{n} \times g(i)  \Leftrightarrow
g(n) = \sum\limits_{i=n}^{m} (-1)^{n-i}\times\tbinom{i}{n} \times f(i)
\]</span> 其中 <span class="math inline">\(f(n)\)</span> 表示钦定满足
<span class="math inline">\(n\)</span> 个条件的方案数。<span
class="math inline">\(g(n)\)</span> 表示恰好满足 <span
class="math inline">\(n\)</span> 的条件的方案数。</p>
<p>左边很好理解，就是钦定 <span class="math inline">\(n\)</span>
个条件满足的方案数就是从满足 <span class="math inline">\(i\)</span>
个条件的方案中选出 <span class="math inline">\(n\)</span>
个钦定满足。</p>
<p>右边可以稍微变换一下以便理解 <span class="math display">\[
g(n) = f(n)  - \sum\limits_{i=n+1}^{m} \tbinom{i}{n} g(i)
\]</span> 就是钦定 <span class="math inline">\(i\)</span>
个的情况减去恰好有大于 <span class="math inline">\(i\)</span>
个的情况乘上一个组合数，这和上面那个二维的很类似。</p>
<p>给出高位二项式反演公式： <span class="math display">\[
g(n_1,n_2,⋯,n_m)=∑\limits_{k_i = 0}^{n_i}
∏\limits_{i=1}^{m}\tbinom{n_i}{k_i}f(k_1,k_2,⋯,k_m)
\]</span></p>
<p><span class="math display">\[
\ \ \ \ \ \ \ \ \ \ \ \Updownarrow
\]</span></p>
<p><span class="math display">\[
f(n_1,n_2,⋯,n_m)=∑\limits_{k_i=0}^{n_i}∏\limits_{i=1}^{m}(−1)^{n_i−k_i}\tbinom{n_i}{k_i}
g(k_1,k_2,⋯,k_m)
\]</span></p>
<p>第一个二维式子和第二个一维式子很类似，所以考虑推出 <span
class="math inline">\(f,g\)</span> 的关系。 <span
class="math display">\[
f(n,m) = \sum\limits_{i=0}^{n} \sum\limits_{j=0}^{m} g(i,j) \times
\tbinom{n}{i} \times \tbinom{m}{j}
\]</span> 组合解释是钦定 <span class="math inline">\(n\)</span> 行 <span
class="math inline">\(m\)</span> 列可以被占用的方案数就是先从其中选出
<span class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列。然后计算恰好这么多被占用的方案数。
因为行和列是有标号的。</p>
<p>直接代公式有 <span class="math display">\[
g(n,m) = \sum\limits_{i=0}^{n} \sum\limits_{j=0}^{m} (-1)^{n-i+m-j}
\tbinom{n}{i}\times \tbinom{m}{j}\times f(i,j)
\]</span> 结束。</p>
<h3 id="abc242h初步理解-min-max-容斥">ABC242H(初步理解 min-max
容斥)</h3>
<h4 id="题意-1">题意：</h4>
<p>给定 <span class="math inline">\(m\)</span> 条线段，一个长度为 <span
class="math inline">\(n\)</span>
的数轴，每次随机选一条把数轴上对应位置涂黑，问全部涂黑的期望选择次数。</p>
<h4 id="思考-1">思考：</h4>
<p>记 <span class="math inline">\(E(i)\)</span> 表示第 <span
class="math inline">\(i\)</span> 个格子被涂黑的期望时间。记 <span
class="math inline">\(E(S)\)</span> 表示集合 <span
class="math inline">\(S\)</span>
全部被涂黑的期望时间，也就是所有格子中被涂黑时间的最大值，<span
class="math inline">\(E&#39;(S)\)</span> 表示集合 <span
class="math inline">\(S\)</span>
中任意一个被涂黑的期望时间，即最小值。</p>
<p>显然 <span class="math inline">\(E(S) \neq \max\limits_{i\in S}
(E(i))\)</span>，因为期望只有线性性，<span
class="math inline">\(max,min\)</span> 是非线性操作。</p>
<p>但是我们发现一件事 <span class="math inline">\(\max(S) =
\sum\limits_{T \subseteq S} (-1)^{|T| - 1} \min(T)\)</span>，即 <span
class="math inline">\(\text{min-max}\)</span>
容斥的公式在期望意义下也成立。</p>
<p>而对这道题来说，计算一个集合的最小值是容易的，只需要计算出有多少个包含任意一个元素的线段就行了。</p>
<p>我们设 <span class="math inline">\(dp[i][j][k][0/1]\)</span>
表示考虑到第 <span class="math inline">\(i\)</span> 个位置，上一个位置为
<span class="math inline">\(j\)</span>，已经包含 <span
class="math inline">\(k\)</span>
条线段的方案数，集合大小为奇数或偶数的方案数，转移可以预处理 <span
class="math inline">\([l,r]\)</span> 会新增多少线段，做到 <span
class="math inline">\(O(1)\)</span>，事实上最后一维可以省掉，直接带系数转移就行。</p>
<h2 id="section-1">20220309</h2>
<h3 id="haltoj128">haltoj128</h3>
<h4 id="思考-2">思考：</h4>
<p>欧拉图计数相关问题。关于无向欧拉图有一个结论，欧拉子图的个数为 <span
class="math inline">\(2^{m-n+c}\)</span>
个，也就是其生成森林中非树边组成的集合个数，公式中 <span
class="math inline">\(c\)</span> 代表连通块个数。</p>
<p>理解比较容易，考虑构造方案，任意一个非树边集合会唯一对应一种合法方案，选一条非树边则将它覆盖的树边状态反转（选变为不选，不选变为选），可以得到唯一合法方案。</p>
<p>这个选非树边集合的方式给这道题目带来了启发。然而这种类似异或的方式并不便于统计
<span class="math inline">\(|S|^2\)</span>
这种东西。我们考虑它的组合意义。发现其组合意义为每对边在同一子图便贡献两次，一条边在某一子图贡献一次。</p>
<p>一条边的情况是简单的，考虑两条边。</p>
<p>两条非树边是可以任选的，这一部分答案为 <span class="math inline">\(k
* (k-1) * 2^{k-2}\)</span>，因为已经钦定这两边要选，其它的任意选。</p>
<p>一条非树边和一条树边的贡献可以分两种情况，分别是树边是否受到非树边影响。不受影响答案为
<span class="math inline">\((k-cover[v]) * 2^{k-2}\)</span>，<span
class="math inline">\(cover[v]\)</span> 影响这条树边的非树边条数，<span
class="math inline">\(k-2\)</span>
因为钦定了选择的非树边要选，并且影响这条树边的边有一个的选择情况是不能任意，因为要让树边被选择。</p>
<p>如果受到非树边影响，那么答案也为 <span class="math inline">\(cover[v]
* 2^{k-2}\)</span>，但如果 <span class="math inline">\(cover[v] =
1\)</span>，那么答案为 <span
class="math inline">\(2^{k-1}\)</span>。理解方式类似。</p>
<p>两条树边的情况，考虑影响这两条树边的边集，我们断言如果边集完全相同，那么答案为
<span class="math inline">\(2^{k-1}\)</span>，否则答案为 <span
class="math inline">\(2^{k-2}\)</span>，边集完全相同的情况不难理解，如果不完全相同，我们在每条边特有的部分钦定一个来控制该边，所以答案为
<span
class="math inline">\(2^{k-2}\)</span>。如果是包含关系，先钦定里面的，再钦定外面的即可。</p>
<p>如果要选择树边，记得不要考虑 <span class="math inline">\(cover[v] =
0\)</span> 的边。计算 <span class="math inline">\(cover\)</span>
可以树上前缀和，对于两条非树边，需要统计边集相同的个数，这个可以异或哈希，取
<span class="math inline">\(2^{63}\)</span>
为上界，做双哈希，错误概率在本题数据规模下小于 <span
class="math inline">\(10^{-9}\)</span>。</p>
<h3 id="haltoj132分治ntt的思路">haltoj132(分治NTT的思路)</h3>
<h4 id="思考-3">思考：</h4>
<p>假设不考虑 <span class="math inline">\(&#39;&gt;&#39;\)</span>，即令
<span class="math inline">\(&#39;&gt;&#39;\)</span>
为无限制，那么序列会被 <span
class="math inline">\(&#39;&gt;&#39;\)</span>
划分为若干段，记每一段的长度为 <span
class="math inline">\(a\)</span>，那么答案为 <span
class="math display">\[
\dfrac{n!}{\prod a_i !}
\]</span> 我们考虑容斥，枚举一个子集表示那些位置上的 <span
class="math inline">\(&#39;&gt;&#39;\)</span> 强制为 <span
class="math inline">\(&#39;&lt;&#39;\)</span>，也就是不合法的情况，然后就可以用总数减去这些不合法情况得到答案。</p>
<p>上面的那个 <span class="math inline">\(n!\)</span>
在做转移的时候很麻烦，先不管。</p>
<p>设 <span class="math inline">\(dp[i]\)</span> 表示对前 <span
class="math inline">\(i\)</span> 个符号做容斥，考虑到第 <span
class="math inline">\(i\)</span> 个符号后的数字的结果。</p>
<p>注意到这里 <span class="math inline">\(dp[i] \times (i+1)!\)</span>
也就是前缀 <span class="math inline">\(s_i\)</span> 的答案。</p>
<p>顺便设 <span class="math inline">\(f_i\)</span> 表示前 <span
class="math inline">\(i\)</span> 个符号中 <span
class="math inline">\(&#39;&gt;&#39;\)</span> 的个数。</p>
<p>显然有 <span class="math inline">\(dp[0] = 1\)</span></p>
<p>我们得到以下式子： <span class="math display">\[
dp[i] = (-1)^{f_i}\times \dfrac{1}{(i+1)!} +\sum\limits_{s_j =
&#39;&gt;&#39;,j\in[1,i]} dp[j-1] \times (-1)^{f_{i}-f_{j}}
\times\dfrac{1}{(i-j+1)}!
\]</span> 考虑如何理解这个式子。</p>
<p>我们枚举上一个不受限制的位置 <span
class="math inline">\(j\)</span>，然后乘上对应的容斥系数和计算转移系数，最后加上全部受限制的情况。</p>
<p>因为要优化，所以把式子小小的变一下： <span class="math display">\[
dp[i] = (-1)^{f_i}\times \dfrac{1}{(i+1)!} +\sum\limits_{s_{j+1} =
&#39;&gt;&#39;,j\in[0,i-1]} dp[j] \times (-1)^{f_{i}-f_{j+1}}
\times\dfrac{1}{(i-j)}!
\]</span> 传说中的分治 <span class="math inline">\(NTT\)</span>
可以解决这一类 <span class="math inline">\(dp\)</span>
的优化问题，它的核心思路大概是这样的：</p>
<p>分治 <span class="math inline">\(NTT\)</span>
解决形如这样的问题：</p>
<p>假设要求的函数为 <span class="math inline">\(f\)</span>，有另一个函数
<span class="math inline">\(g\)</span>。</p>
<p>满足 <span class="math inline">\(f(i) = \sum\limits_{j\ &lt; i} f(j)
\times g(i-j)\)</span>。</p>
<p>类似于 <span class="math inline">\(\text{CDQ}\)</span>
一样，考虑左边对右边的贡献即可，容易发现这是一个好做的卷积形式。</p>
<p>对于这道题来说，<span class="math inline">\(-1\)</span>
的次幂可以被拆到两边，剩下的事情有手就行。</p>
<h4 id="收获">收获</h4>
<p>容斥原理可以解决这样一类问题，有一个全集 <span
class="math inline">\(S\)</span>，<span
class="math inline">\(|S|\)</span> 好求，现在有若干属性 <span
class="math inline">\(p_i\)</span>，构成集合 <span
class="math inline">\(T\)</span>，需要求满足属性集合 <span
class="math inline">\(T\)</span>
的元素个数。并且可以很容易求出这样一种情况的答案：限定某些属性不满足，其它属性不做要求。</p>
<h2 id="section-2">20220320</h2>
<h3 id="haltoj-7">HaltOJ 7</h3>
<h4 id="思考-4">思考：</h4>
<p>想一下小学的时候做过的奥数题，一个圆里画 <span
class="math inline">\(n\)</span> 条线最多分成几部分，答案是 <span
class="math inline">\(n*(n+1)/2 +
1\)</span>。再考虑下平行线和多点共线的情况，发现答案只和每个交点的情况和交点个数有关。手玩一下可以发现，在逐个加入直线的情况下，部分的个数增量为此条直线和其它所有直线交点个数
<span class="math inline">\(x\)</span>，再加上 <span
class="math inline">\(1\)</span>，注意，相同交点只算一个。</p>
<p>证明可以参考平面欧拉定理，此处不做赘述。</p>
<p>所以我们模拟这个过程，每次加入一条直线判断新增了多少交点，具体可以先暴力枚举直线，求出所有交点之后带上
<span class="math inline">\(eps\)</span> 去重。然后发现 <span
class="math inline">\(y\)</span> 只和 <span
class="math inline">\(x\)</span>
有关，所以只用计算一个。然后我们发现如果按照斜率为第一关键字，截距为第二关键字排序加入线段，那么
<span class="math inline">\(x\)</span> 是一个相当优美的形式 <span
class="math inline">\(\dfrac{j-b}{a-i}\)</span>，<span
class="math inline">\(a,b\)</span> 表示当前线段的斜率和截距，<span
class="math inline">\(i,j\)</span> 表示枚举的线段的斜率和截距，<span
class="math inline">\(i,j\)</span>
的取值都连续，所以这个式子中，分母会取遍 <span
class="math inline">\([1,i]\)</span>，分子会取遍 <span
class="math inline">\([-b,B-j-1]\)</span>，正负数分开考虑，现在问题变成了问
<span class="math inline">\(\dfrac{[1,x]}{[1,y]}\)</span>
中有多少个不同的数，<span class="math inline">\(A^2\)</span>
预处理，<span class="math inline">\(O(1)\)</span>
回答即可，约定每个数在最简分数被统计。</p>
<p>可以莫比乌斯反演优化，这个可以很方便的转化成 <span
class="math inline">\([gcd(x,y)=1]\)</span> 的形式并整除分块计算，可以
<span class="math inline">\(n\sqrt n\)</span>，但没必要。</p>
<h3 id="haltoj8">HaltOJ8</h3>
<h4 id="思考-5">思考</h4>
<p>这道题出出来就展现出对直接 <span class="math inline">\(dp\)</span>
的恶意，无论那种合并方法都无法解决这个问题。我们不妨另辟蹊径，考虑字符串的另一种生成方式——插入。</p>
<p>具体的，我们将不同的花视为不同字符，那么我们需要生成一个字符串，相邻字符不同，每个字符个数指定。</p>
<p>我们发现当前的插入方式仅仅受到当前相同字符位置个数的限制，所以设
<span class="math inline">\(f_i\)</span> 表示考虑到现在，有 <span
class="math inline">\(i\)</span> 个字符相同位置的方案数。</p>
<p>转移可以枚举当前字符划分为多少段，其中有多少段插入相同字符位置，具体每一段放几个可以通过插板法计算方案。这样的转移看上去是
<span
class="math inline">\(O{(10^{5}})^3\)</span>,但是如果我们将字符按个数排序后并按照
<span class="math inline">\(3,1,2,4\)</span>
的顺序插入，因为保证了有两个只有 <span
class="math inline">\(200\)</span>，所以复杂度为 <span
class="math inline">\(O(1+200^2 + 200^3 + 10^5)\)</span>
的复杂度，最后一次转移强制要求了段数和插入相同字符位置的数量，第三次则是因为第二次转移后有效位置仅有
<span class="math inline">\(200\)</span> 个。</p>
<p>听说可以做到 <span class="math inline">\(O(200^2 + 10^5)\)</span>
，但显然我不会。</p>
<h2 id="section-3">20220322</h2>
<h3 id="arc137d">ARC137D</h3>
<h4 id="题意-2">题意</h4>
<p>给定一个序列 <span
class="math inline">\(a\)</span>，反复做前缀异或操作，问若干次操作后
<span class="math inline">\(a_n\)</span> 的值，询问所有 <span
class="math inline">\([1,k]\)</span> 的答案。</p>
<h4 id="思考-6">思考</h4>
<p>考场上一直在考虑分析单纯的 <span class="math inline">\(01\)</span>
系数，而忽略了系数之间的内在其它联系，事实上，对于反复执行的可加前缀操作，设距离为
<span class="math inline">\(d\)</span>，操作次数为 <span
class="math inline">\(k\)</span>，那么贡献应该为从 <span
class="math inline">\((0,0)\)</span> 走到 <span
class="math inline">\((d,k-1)\)</span>
的方案数。证明比较简单，将原点的贡献转移拆分到横坐标即可。</p>
<p>更严谨的证明可以使用归纳法，记贡献函数为 <span
class="math inline">\(f(x,y)\)</span>，<span
class="math inline">\(f(n,k) =
f(n-1,k)+f(n,k-1)\)</span>，那么考虑其组合意义，第一项代表了前 <span
class="math inline">\(n-1\)</span>
项的和，第二项则是自己在上面的步骤中的累计。</p>
<p>那个 <span class="math inline">\(-1\)</span> 很讨厌，先不管。</p>
<p>用组合数的形式表示答案，即为 <span
class="math inline">\(\tbinom{n+k}{n}\)</span>,对其应用卢卡斯定理求出
<span class="math inline">\(\bmod2\)</span> 的结果，发现当且仅当 <span
class="math inline">\(n\&amp;k = 0\)</span> 时有值，那么对于一个固定的
<span class="math inline">\(n\)</span> ，有值的 <span
class="math inline">\(k\)</span> 一定可以描述为一个 <span
class="math inline">\(s\)</span> 在二进制意义下的子集。</p>
<p>然后对其做一次 <span class="math inline">\(\text{FMT}\)</span>
变换即可得到结果。</p>
<p>注意处理被忽略的 <span class="math inline">\(-1\)</span></p>
<h2 id="section-4">20220323</h2>
<h3 id="cf1657d">CF1657D</h3>
<h4 id="思路">思路</h4>
<p>先做乘法转换，这个没啥说的。然后我考虑的是根号分治，先把不在凸包上的扔掉，对于代价大于
<span class="math inline">\(B\)</span>
的，枚举选的个数，然后尺取法搞定，对于代价小于 <span
class="math inline">\(B\)</span>
的，直接计算。场上过了，赛后被叉。实际上，对于这种整除的题目，我们都可以考虑枚举倍数约数，然后可以直接计算代价为
<span class="math inline">\([1,C]\)</span>
的最大权值，然后直接在上面二分就行。</p>
<h3 id="cf1647e">CF1647E</h3>
<h4 id="思路-1">思路</h4>
<p>不难发现充要条件是每个点向 <span class="math inline">\(1\)</span>
的边为最小值。然后考虑 <span class="math inline">\(dp\)</span>，直接对点
<span class="math inline">\(dp\)</span>
不太好做，我们发现它是有关大小的，所以考虑按照向 <span
class="math inline">\(1\)</span> 的边权值从小到大 <span
class="math inline">\(dp\)</span>，每次枚举一段连续的区间，以及填的值转移，转移是一个前缀和乘上一个组合数再乘上一个幂次。</p>
<h3 id="cf1647f">CF1647F</h3>
<h4 id="思路-2">思路：</h4>
<p>看上去就非常暴力，对每个限制建点，两种状态，限制和树上的点的状态推出关系连边，然后暴力确定每个限制的状态看是否冲突即可。实际上这就是模拟了
<span class="math inline">\(\text{2-SAT}\)</span>。</p>
<p>考虑这个东西为什么和 <span
class="math inline">\(\text{2-SAT}\)</span>
的正常做法一样的，正常做法是找强连通分量，
拓扑排序后对每个点选拓扑序大那个值。和我们的暴力模拟过程没啥区别。</p>
<h3 id="haltoj1262-sat-的简单理解">HaltOJ126(2-SAT 的简单理解)</h3>
<h4 id="思考-7">思考：</h4>
<p>有一些比较奇怪的限制，然后每个人在每个点就两种状态，要想起一个东西叫
<span class="math inline">\(\text{2-SAT}\)</span>，我们令 <span
class="math inline">\(statu[i][j]\)</span> 表示 <span
class="math inline">\(i\)</span> 子树内是否有 <span
class="math inline">\(j\)</span>，那么很容易构造出标准的 <span
class="math inline">\(\text{2-SAT}\)</span>
限制，然后我们考虑约束，分类讨论一下。以 <span
class="math inline">\(\text{2-SAT}\)</span> 的形式来说，对于 <span
class="math inline">\(x\)</span> 的每个儿子 <span
class="math inline">\(v\)</span>，两个点都不能同时在 <span
class="math inline">\(v\)</span> 中。同时，如果 <span
class="math inline">\(lca(x,r) \neq x\)</span> ，那么两个人都必须在
<span class="math inline">\(x\)</span> 子树内。如果 <span
class="math inline">\(lca(x,r) = x\)</span>，那么 <span
class="math inline">\(a,b\)</span>
只能有一个在子树外，就是一个为假那么另一个为真，除此以外，如果 <span
class="math inline">\(x \neq r\)</span>，那么 <span
class="math inline">\(a,b\)</span> 不能在 <span
class="math inline">\(x\)</span> 向 <span
class="math inline">\(r\)</span> 的儿子里。</p>
<p>然后跑一个标准的 <span
class="math inline">\(\text{2-SAT}\)</span>。</p>
<p><span class="math inline">\(\text{Tarjan}\)</span> 跑出来的 <span
class="math inline">\(\text{SCC}\)</span> 编号是反拓扑序。</p>
<p><span class="math inline">\(\text{2-SAT}\)</span> 的一些限制：强制
<span class="math inline">\(u\)</span>
为真，那么把假连向真，反之亦然。其它情况下注意逆否命题也要连边</p>
<p><span class="math inline">\(\text{2-SAT}\)</span> 图的一些性质：<span
class="math inline">\(u \rightarrow v \Rightarrow \overline{v}
\rightarrow \overline{u}\)</span></p>
<p><span class="math inline">\(\text{2-SAT}\)</span>
合法性：同一变量的两个状态不在同一 <span
class="math inline">\(\text{SCC}\)</span>
内是存在方案的充要条件，必要性显然，充分性用构造法证明。</p>
<p><span class="math inline">\(\text{2-SAT}\)</span>
方案构造：依次考虑每个变量，选择 <span
class="math inline">\(\text{SCC}\)</span>
编号较小那个值，那么同一变量不会直接冲突，假设先前的点 <span
class="math inline">\(v\)</span> 推出了 <span
class="math inline">\(\overline{u}\)</span>，并且 <span
class="math inline">\(\overline{u} \rightarrow
u\)</span>，因为刚刚提到的性质，一定有 <span
class="math inline">\(u\rightarrow
\overline{v}\)</span>，我们一定会选拓扑序较大的 <span
class="math inline">\(\overline{v}\)</span>，因此选择不会冲突。</p>
<h2 id="section-5">20220325</h2>
<h3 id="cf1656d">CF1656D</h3>
<h4 id="题意-3">题意：</h4>
<ul>
<li><p>您有一个 <span class="math inline">\(n\)</span>，您需要找一个
<span class="math inline">\(k \in[2,\infty)\)</span>，使得 <span
class="math inline">\(n\)</span> 可以被表示为 <span
class="math inline">\(k\)</span> 个模 <span
class="math inline">\(k\)</span>
意义下不同的数，多解可以输出任意一个。</p></li>
<li><p>多测 <span class="math inline">\(T\leq
10^5,n\leq10^{18}\)</span></p></li>
</ul>
<h4 id="思考-8">思考：</h4>
<p>因为要找的 <span class="math inline">\(k\)</span> 个数模 <span
class="math inline">\(k\)</span> 意义下不同，我们又知道任意一个数 <span
class="math inline">\(a\)</span> 都可以表示为 <span
class="math inline">\(a=b \times k +r\)</span>，所以不妨先把模 <span
class="math inline">\(k\)</span> 的余数和，也就是上式中的 <span
class="math inline">\(r\)</span>
提取出来，我们得到了一个新的式子。下面设 <span
class="math inline">\(n\)</span> 为 <span
class="math inline">\(k\)</span> 个数的和。 <span
class="math display">\[
n = c\times k + \dfrac{k\times(k+1)}{2}
\]</span> 其中 <span class="math inline">\(c\)</span> 表示这 <span
class="math inline">\(k\)</span> 个数对应 <span
class="math inline">\(b\)</span>
的和。分母让人很不爽，所以乘过去。至于为什么是 <span
class="math inline">\((k+1)\times k\)</span>，是为了让 <span
class="math inline">\(c\)</span> 可以取到 <span
class="math inline">\([0,\infty)\)</span> <span class="math display">\[
2n = (2c+k+1)\times k
\]</span> <span class="math inline">\(2n\)</span>
的两个因子奇偶性不同，所以如果我们的 <span
class="math inline">\(n\)</span> 为奇数就可以直接令 <span
class="math inline">\(k=2\)</span>，否则我们每次令 <span
class="math inline">\(k\)</span> 取 <span
class="math inline">\(2,4,8,\cdots\)</span>,直到 <span
class="math inline">\(\dfrac{2n}{k}\)</span> 为奇数为止，这个时候记
<span class="math inline">\(res = \dfrac{2n}{k}\)</span>，如果 <span
class="math inline">\(res\)</span> 较大，则取对应的 <span
class="math inline">\(k\)</span>，否则取 <span
class="math inline">\(k=res\)</span>。</p>
<p>注意特判掉一些边界情况，比如 <span class="math inline">\(2\)</span>
的次幂，<span class="math inline">\(2\)</span> 的次幂，还有 <span
class="math inline">\(2\)</span> 的次幂。</p>
<h4 id="参考代码">参考代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type &amp;a,_type b)</span></span>&#123;a=<span class="built_in">min</span>(a,b);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type &amp;a,_type b)</span></span>&#123;a=<span class="built_in">max</span>(a,b);&#125;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">read</span>(n);<span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;<span class="number">1ll</span>&lt;&lt;<span class="number">62</span>;i*=<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="type">int</span> res=<span class="number">2</span>*n/i;</span><br><span class="line">			<span class="keyword">if</span>(res%<span class="number">2</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(res&gt;i)&#123;</span><br><span class="line">					ans=i;</span><br><span class="line">					<span class="keyword">break</span>;	</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					ans=res;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">1</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="cf1656e">CF1656E</h3>
<h4 id="题意-4">题意</h4>
<ul>
<li>您有一棵 <span class="math inline">\(n\)</span>
个点的无向无根树，您需要为每个点安排一个权值 <span
class="math inline">\(a_i\in[-10^5,10^5]\)</span>，使得删掉任意一个点之后剩下连通块的权值和相同，注意安排的权值不能为
<span class="math inline">\(0\)</span>。</li>
<li>多测 <span class="math inline">\(T\leq 10^4,\sum n \leq
10^5\)</span></li>
</ul>
<h4 id="思考-9">思考</h4>
<p>诈骗题。我们考虑指定一个根，就让它是 <span
class="math inline">\(1\)</span>，然后随便删一个点 <span
class="math inline">\(u\)</span>，那么 <span
class="math inline">\(u\)</span>
的所有儿子的子树都必须有同一个值，我们可以尝试安排每一棵子树的权值和，这是可以做到的，因为可以让根控制这个值。不妨安排每颗子树的权值和为
<span class="math inline">\(1\)</span>， 那么我们再安排整个树的权值和为
<span class="math inline">\(2\)</span>，就可以让删掉每个点 <span
class="math inline">\(u\)</span> 后剩下的连通块权值和相同。<span
class="math inline">\(u\)</span> 的所有儿子子树的权值和都为 <span
class="math inline">\(1\)</span>，而除开 <span
class="math inline">\(u\)</span>
的子树后的那个连通块的权值和就是整棵树的权值和 <span
class="math inline">\(2\)</span>，减去 <span
class="math inline">\(u\)</span> 子树的权值和，就是 <span
class="math inline">\(1\)</span>，也和 <span
class="math inline">\(u\)</span> 所有儿子的子树的权值和相同。</p>
<p>但是有一个问题，如果一个点 <span class="math inline">\(u\)</span>
只有一个儿子，那么 <span class="math inline">\(u\)</span>
的权值会被安排为 <span
class="math inline">\(0\)</span>，是不合法的，所以我们需要更改一下安排的方式，对于一个点，设它子树的权值和为
<span class="math inline">\(x\)</span>，
并且它所有儿子的子树的权值和均为 <span
class="math inline">\(y\)</span>，而且整棵树的权值和为 <span
class="math inline">\(x+y\)</span>。这是合法的必要条件，因为我们需要让
<span class="math inline">\(a_i \neq0\)</span>，所以安排根的权值为 <span
class="math inline">\(0\)</span>，其它点按深度模 <span
class="math inline">\(2\)</span>，的值安排 <span
class="math inline">\(-1\)</span> 和 <span
class="math inline">\(1\)</span> 即可。</p>
<h4 id="代码">代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type &amp;a,_type b)</span></span>&#123;a=<span class="built_in">min</span>(a,b);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type &amp;a,_type b)</span></span>&#123;a=<span class="built_in">max</span>(a,b);&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> val[N],fa[N],dep[N],deg[N],tar[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==s)tar[u]=val[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> tar[u]=val[u]=dep[u]%<span class="number">2</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[u]==v)<span class="keyword">continue</span>;</span><br><span class="line">		dep[v]=dep[u]<span class="number">+1</span>,fa[v]=u;<span class="built_in">dfs</span>(v);val[u]-=tar[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">read</span>(n);dep[<span class="number">1</span>]=<span class="number">1</span>;s=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)e[i].<span class="built_in">clear</span>(),val[i]=<span class="number">0</span>,tar[i]=deg[i]=<span class="number">0</span>,fa[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> x,y;<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">			e[x].<span class="built_in">push_back</span>(y),e[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">			deg[x]++,deg[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(deg[i]&gt;deg[s])s=i;</span><br><span class="line">		<span class="built_in">dfs</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,val[i]);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="cf1656f">CF1656F</h3>
<h4 id="题意-5">题意</h4>
<ul>
<li><p>您有 <span class="math inline">\(n\)</span>
个点，每个点有一个权值 <span
class="math inline">\(a_i\)</span>，定义一张有权无向完全图 <span
class="math inline">\(K(t)\)</span> 为每个点 <span
class="math inline">\(i\)</span> 向 <span
class="math inline">\(j\)</span> 连一条权值为 <span
class="math inline">\(a_i\times a_j+(a_i+a_j)\times t\)</span>
的无向边后所构成的图，定义 <span class="math inline">\(f(t)\)</span> 为
<span class="math inline">\(K(t)\)</span>
最小生成树的权值和。您需要对所有的实数 <span
class="math inline">\(t\)</span> 求出 <span
class="math inline">\(f(t)\)</span>
的最大值并输出它，如果最大值不收敛，那么输出 <code>INF</code>。</p></li>
<li><p>多测，<span class="math inline">\(T\leq 10^4,\sum n\leq 2\times
10^5,-10^6\leq a_i\leq 10^6\)</span></p></li>
</ul>
<h4 id="思考-10">思考</h4>
<p><del>场上差那么一点点就 15Ton 了</del></p>
<p>一个瓶颈在排序的线性做法。</p>
<p>记 <span class="math inline">\(d_i\)</span> 表示点 <span
class="math inline">\(i\)</span> 的度数。</p>
<p>判断 <span class="math inline">\(\text{INF}\)</span>
是简单的，只需要看能不能凑出 <span class="math inline">\(\sum a_i\times
d_i\)</span> 分别为正和负或者 <span class="math inline">\(0\)</span>
就行，如果凑不出来，令 <span class="math inline">\(t\)</span>
为正无穷或者负无穷，然后它就不收敛了。</p>
<p>现在已知有解。</p>
<p>考虑固定一个 <span class="math inline">\(t\)</span> 后怎么快速求
<span class="math inline">\(\text{MST}\)</span>。做个恒等变形，权值为
<span class="math inline">\((a_i+t)\times (a_j+t)-t^2\)</span>，把 <span
class="math inline">\(t^2\)</span> 给扔掉。</p>
<p>结论是排序后按正负性断开，<span class="math inline">\(a_1\)</span>
向所有 <span class="math inline">\(a_i\)</span> 大于 <span
class="math inline">\(0\)</span> 的连边， <span
class="math inline">\(a_n\)</span> 向所有 <span
class="math inline">\(a_i\)</span> 小于 <span
class="math inline">\(0\)</span> 的连边，<span
class="math inline">\(0\)</span> 无所谓。</p>
<p>证明可以考虑 <code>Prime</code> 算法的过程，最开始一定是 <span
class="math inline">\(a_1\)</span> 到 <span
class="math inline">\(a_n\)</span>。然后后面不会取到正负性相同的，并且一个点一定是连向
<span class="math inline">\(a_1\)</span> 或者 <span
class="math inline">\(a_n\)</span>。</p>
<p>如果处理一个前缀和，知道正负交界的位置之后可以快速算，从小到大枚举
<span class="math inline">\(t\)</span>，然后双指针维护交界处。</p>
<p>可以证明 <span class="math inline">\(t\)</span> 一定取到每个 <span
class="math inline">\(-a_i\)</span>。如果夹在两坨中间，那么由于具体选哪些边是固定的，根据
<span class="math inline">\(\sum a_i\times d_i\)</span>
正负性调整即可。</p>
<p>不会取到 <span class="math inline">\([a_1,a_n]\)</span>
外面去，因为我们已经判了无解，所以取到边界外面时 <span
class="math inline">\(\sum a_i\times d_i\)</span>
的正负性会导致向里面调整更优。</p>
<h2 id="section-6">20220329</h2>
<h3 id="haltoj129powerful-number-筛">HaltOJ129(Powerful Number 筛)</h3>
<h4 id="思考-11">思考:</h4>
<p>打个表发现 <span class="math inline">\(f\)</span> 是积性函数。</p>
<p>然后 <span class="math inline">\(f(p^c)\)</span>
是好求的，考虑亚线性筛法。</p>
<p>我也不知道为啥会想到 PN 筛，总之这种东西各种筛法都可以尝试一下。</p>
<p>PN
筛和其它亚线性筛法一样，是用来求一些积性函数的前缀和的，它的关键在于构造一个好求的前缀和的
<span class="math inline">\(g\)</span>，满足 <span
class="math inline">\(g(p)=f(p)\)</span>，然后构造一个 <span
class="math inline">\(h\)</span> ，满足 <span class="math inline">\(f=h
* g\)</span>，乘法为迪利克雷卷积。</p>
<p>这里我们构造 <span class="math inline">\(g(x)=1\)</span></p>
<p>积性函数有个性质，<span
class="math inline">\(f(1)=1\)</span>，所以展开下 <span
class="math inline">\(f\)</span>，发现 <span
class="math inline">\(f(p)=1=h(1) * g(p)+h(p) * g(1)\)</span>，然后
<span class="math inline">\(h(p)=0\)</span>，由于 <span
class="math inline">\(h\)</span>
也是个积性函数（迪利克雷卷积的性质），所以 <span
class="math inline">\(h\)</span> 只会在 PN 处有取值，PN
的定义为每个质因子次数都大于等于 <span class="math inline">\(2\)</span>
的数。</p>
<p>可以证明所有比 <span class="math inline">\(n\)</span> 小的 PN 个数是
<span class="math inline">\(O(\sqrt n)\)</span> 的 。</p>
<p>可以预处理 <span class="math inline">\(\sqrt n\)</span>
以内的所有质数，然后枚举指数得到每个 PN，这个 <span
class="math inline">\(dfs\)</span> 的过程中可以记录一下对应的 <span
class="math inline">\(h\)</span>，<span class="math inline">\(h\)</span>
的转移是好做的，因为只需要求 <span
class="math inline">\(h(p^c)\)</span>。</p>
<p>这里不难发现 <span
class="math inline">\(h(p^c)=f(p^c)-f(p^{c-1})\)</span>。</p>
<p>原因是 <span class="math inline">\(g\)</span> 实际上是 <span
class="math inline">\(1\)</span>，而 <span class="math inline">\(f / 1 =
f * \mu\)</span></p>
<h2 id="section-7">20220331</h2>
<h3 id="考试t2"><a
target="_blank" rel="noopener" href="https://https://local.cwoi.com.cn:8443//contest/C39/problem/A">20220330考试T2</a></h3>
<h4 id="思考-12">思考</h4>
<p>限制不好弄，考虑转化限制，不难发现，如果建图，并依次加入有向边，那么任意一个时刻，都需要满足当前图及其补图都是一个传递闭包，即，如果能间接
<span class="math inline">\(a\rightarrow b\)</span> ，那么 <span
class="math inline">\(a,b\)</span> 有边。这样的图不是很多，是 <span
class="math inline">\(n!\)</span> 个的，只需要考虑图之间的转移就行。</p>
<p>这样的图和一个 <span class="math inline">\(n\)</span>
的排列一一对应，构造方案为如果 <span class="math inline">\(a,b\)</span>
为逆序对，那么加入一条边 <span
class="math inline">\((a,b)\)</span>。加入一条边时，只需要枚举相邻的逆序对并交换，转移可以康托展开得到交换后的编号。限制也比较好做，转移的时候看看强制在前面的边在不在里面就行。</p>
<p>复杂度为 <span class="math inline">\(O(n!\times n \times
(n+m))\)</span>，常数较小，可以过。</p>
<h2 id="section-8">20220402</h2>
<h3 id="考试t1"><a
target="_blank" rel="noopener" href="https://https://local.cwoi.com.cn:8443//contest/C41/problem/A">20220401考试T1</a></h3>
<h4 id="思考-13">思考</h4>
<p>对于这种翻转的博弈问题，其实都可以做一个转化：不要翻转颜色，而是在每个翻转的地方再放一个棋子，这样不会改变游戏的胜负性，因为如果原处没有棋子，那么等效，如果有棋子，那么有两个，在
<span class="math inline">\(SG\)</span>
的意义下，这是可以抵消的。如果以组合方式理解，那么因为放了之后如果有人操作了，那么另一个人把它的操作复制一遍即可，由于两个人都是最优操作，所以可以抵消。</p>
<p>有了这个转化，每个棋子都变成了一个独立的游戏，该局面的 <span
class="math inline">\(SG\)</span>
值就不难计算了，按照定义计算出每个位置的 <span
class="math inline">\(SG\)</span> 值然后异或查表即可。</p>
<h3 id="考试t3"><a
target="_blank" rel="noopener" href="https://https://local.cwoi.com.cn:8443//contest/C41/problem/C">20220401考试T3</a></h3>
<h4 id="思考-14">思考</h4>
<p>场上写了个 <span class="math inline">\(O(n^3)\)</span>
卡常卡过去了，实际上 <span class="math inline">\(O(n^2)\)</span>
的有点难想，它是把构造表达式的过程视作了一个添加左右括号的过程，总之非常神仙。</p>
<p>有个对于区间 <span class="math inline">\(dp\)</span>
的常数优化思路，可以改变一下枚举顺序，让数组访问尽量连续，以便最大程度利用好
<span class="math inline">\(L1\)</span>，可以节省大量内存操作时间。</p>
<p>咕一篇常数优化文章。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%981/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%981/" class="post-title-link" itemprop="url">做题1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:08:51" itemprop="dateCreated datePublished" datetime="2022-07-12T16:08:51+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:58:10" itemprop="dateModified" datetime="2025-02-16T17:58:10+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="section">2022.2.7</h2>
<h3 id="cf1634e">CF1634E</h3>
<h4 id="题意">题意：</h4>
<p>给定一些数组，长度都为偶数，需要将每个数组的元素划分到两个可重集合里，要求两个集合相同，问方案或输出无解，<span
class="math inline">\(n,m=10^5\)</span>。</p>
<h4 id="思考">思考：</h4>
<p>考虑每个数组单独划分，不太行，所以不能一个数组一个数组的考虑，显然有解的必要条件是每个数字个数为偶数。所以一个数字一个数字的考虑，其实也不太行，因为这和刚刚那种方法是本质上一样的。</p>
<p>注意到也保证每个数组长度为偶数<del>（这不是废话吗）</del>，都是偶数，不由得让我们想到欧拉回路，所以尝试建图，每个不同的数和数组视为一个点，由数组向数连边，数组内存在一个数，就由数组向这个数连一条边，现在需要给图定向为一张欧拉图，我们将数组向数连的边是为将这个数分到第一个集合，反之则为第二个，构造欧拉图即可。</p>
<h4 id="实现上的问题">实现上的问题：</h4>
<p>存边用 <code>set</code> 存，不然 <code>TLE</code> 没商量。</p>
<p>图不一定联通，所以一定要多起点。</p>
<h2 id="section-1">20220209</h2>
<h3 id="考试-t1">22020208考试 T1</h3>
<h4 id="题意-1">题意：</h4>
<p>定义矩阵 <span class="math inline">\(Mat_n\)</span></p>
<ul>
<li><span class="math inline">\(n = 0\)</span> 时，为一个 <span
class="math inline">\(1\)</span></li>
<li><span class="math inline">\(n &gt; 0\)</span> 时，左上角为 <span
class="math inline">\(0\)</span> 矩阵，其余部分为三个 <span
class="math inline">\(Mat_{n-1}\)</span>。</li>
</ul>
<p>在一个平面上画出两个 <span
class="math inline">\(Mat_n\)</span>，左下角分别为 <span
class="math inline">\((0,0),(x,y)\)</span>，求都为 <span
class="math inline">\(1\)</span> 的位置有多少个。</p>
<h4 id="思考-1">思考：</h4>
<p>考虑旋转矩阵转化为位运算计数问题，转化为求整数对 <span
class="math inline">\((i,j)\)</span> 满足
<code>(i&amp;j) == 0 and ((i+x)&amp;(j-y)) == 0</code></p>
<p>考场上看到要高精就润了，没有认真思考。</p>
<p>实际上可以考虑类似 数位dp 的算法，也不难。</p>
<h3 id="考试-t2后缀自动机复习">22020208考试 T2(后缀自动机复习)</h3>
<h4 id="题意-2">题意：</h4>
<p>给定一个字符串 <span class="math inline">\(s\)</span> ，<span
class="math inline">\(q\)</span> 次询问 <span
class="math inline">\(l,r\)</span>，表示所有 <span
class="math inline">\([l,r]\)</span>
开头的子串中本质不同的子串个数。</p>
<p><span class="math inline">\(n,q = 2 \times 10^5\)</span></p>
<h4 id="思考1">思考1：</h4>
<p>考虑后缀自动机求本质不同子串个数的方式，发现它可以在线完成。</p>
<p>所以反着建后缀自动机。</p>
<p>对于 <span class="math inline">\(r=n\)</span>
的部分分，显然先离线，可以建后缀自动机时统计下每一个结尾的答案，输出即可。</p>
<p>如果 <span class="math inline">\(r \neq
n\)</span>，那么不妨仍然考虑在后缀自动机上如何统计答案。</p>
<p>后缀自动机本质上维护的是 <span class="math inline">\(endpos\)</span>
集合，对于一个询问，如果一个 <span class="math inline">\(endpos\)</span>
集合中包含一个位置 <span
class="math inline">\(x\in[l,r]\)</span>，那么这个 <span
class="math inline">\(endpos\)</span>
集合所代表的子串应该被计入贡献。</p>
<p>后缀自动机上每个子串仅在一个 <span
class="math inline">\(endpos\)</span>
集合中出现，所以可以求出至少有一个元素被包含的集合，并直接加和。</p>
<p>考虑对于每个询问该如何统计答案，限制一共有两个 <span
class="math inline">\(l,r\)</span>，并不好做，然而我们发现后缀自动机是在线构建的，所以如果将询问离线，那么限制就只剩下一个
<span class="math inline">\(r\)</span>
了。我们在构建后缀自动机的同时只需要记录每个 <span
class="math inline">\(endpos\)</span> 集合最小的元素 <span
class="math inline">\(val\)</span>，查询时查询所有满足 <span
class="math inline">\(val \leq r\)</span>
的集合的子串数量和即可。考虑维护一个数组 <span
class="math inline">\(c\)</span>，<span
class="math inline">\(c[i]\)</span> 表示 <span class="math inline">\(val
= i\)</span> 的 <span class="math inline">\(endpos\)</span>
集合子串个数和，用 <span class="math inline">\(BIT\)</span>
查前缀和，现在只剩下修改了。</p>
<p>考虑 <span class="math inline">\(endpos\)</span>
树的性质，发现修改操作是把一段到根的路径赋值，同时还有修改父亲等操作，于是考虑动态树，我们不难发现一段实链上的集合，<span
class="math inline">\(val\)</span> 都是相同的，所以在每个节点维护一下
<span class="math inline">\(val,sum\)</span> 值即可，注意 <span
class="math inline">\(push\_down\)</span> 操作时需要把赋值也 <span
class="math inline">\(push\_down\)</span> 下去。</p>
<p>这样做未免显得有些麻烦，我们考虑最终构建的后缀自动机，倒序激活 <span
class="math inline">\(endpos\)</span> 中每一个点，这样就不需要 <span
class="math inline">\(Link\)</span> 和 <span
class="math inline">\(Cut\)</span> 操作，只需要写 <span
class="math inline">\(access\)</span> 就行。</p>
<p>实际上未必需要用后缀树来实现，通过激活点的方式，树已经时静态的了，这本质上还是一个区间染色问题，我们完全可以直接重链剖分，在每条重链上开个栈维护断点，记录下前缀和。</p>
<p>复杂度都是 <span
class="math inline">\(O(nlog_n^2)\)</span>，个人认为类似动态树的方法会好写一些。</p>
<h4 id="思考2">思考2：</h4>
<p>考虑使用后缀数组，回想后缀数组统计不同子串个数的方式，实际上就是排序后减掉相邻两个的
<span
class="math inline">\(lcp\)</span>，于是对原串后缀排序，然后离线询问莫队，拿个
<code>set</code> 维护当前所有串的排名集合，再来个 <span
class="math inline">\(ST\)</span> 表计算 <span
class="math inline">\(lcp\)</span>，插入和删除都很好写，复杂度 <span
class="math inline">\(O(n\sqrt n \ log_n)\)</span>，难以通过本题。</p>
<p>考虑优化，有一个技巧，这种需要查前驱后继的东西，实际上可以用链表搞，加入相对困难一些，因为我们不知道到底应该放在哪里，但删除就很容易了，双向链表上直接删就完事了，所以可以回滚莫队，非常无脑，时间复杂度
<span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<p>稍加卡常即可通过，<span class="math inline">\(ST\)</span>
表查询常数相对较大，卡常应考虑尽量减少查询次数。</p>
<h2 id="section-2">20220210</h2>
<h3 id="考试t3">20220208考试T3</h3>
<h4 id="恶心的题意"><a
target="_blank" rel="noopener" href="https://https://local.cwoi.com.cn:8443//contest/C15/problem/C">恶心的题意</a></h4>
<h4 id="思考-2">思考</h4>
<p>发现由于编号连续，所以最后经过的一定是一段连续区间。想到可以枚举右端点，二分左端点。</p>
<p>一个区域到另一个区域的路径可以分为区域到中转站和中转站到中转站两部分，区域到中转站的情况可以只计算到左右两边最近的中转站，所以容易计算。</p>
<p>我们按照右端点顺序激活中转站，问题就是要最小化左端点。</p>
<p>两个中转站只能通过同一条线连接，把最低点也看成中转站，所以可以认为从一个中转站到另一个的代价为两者所在区域编号的较小值。</p>
<p>中转站到中转站的距离可以 <code>Floyd</code>
暴力，我们就已经计算出了每对中转站点相互抵达的代价，所以二分都不需要了，我们可以直接用这个代价计算出最终答案。</p>
<h4 id="实现细节">实现细节</h4>
<p><code>Floyd</code>
的时候，因为加入的中转站并不是按下标顺序，所以需要整个跑一遍。</p>
<h2 id="section-3">20220211</h2>
<h3 id="测试-t1">20220211 测试 T1</h3>
<h4 id="题意-3"><a
target="_blank" rel="noopener" href="https://https://local.cwoi.com.cn:8443//contest/C18/problem/A">题意</a></h4>
<h4 id="思考-3">思考</h4>
<p>这道题算是考场上想出来的，考场上摸了一会儿鱼，发现有个地方假了的时候只剩
<span class="math inline">\(5min\)</span> 了，所以紧急修复成了<span
class="math inline">\(50pts\)</span>，实际上不管直接交有 <span
class="math inline">\(80pts\)</span>。</p>
<p>先把最上面那些没有的行删掉。</p>
<p>考虑每一行的可能性，只有穿过和不穿过两种，穿过又可以分为去的时候穿过和回的时候穿过。</p>
<p>来的时候穿过，回的时候一定不会穿过，因为一定不优，于是三进制枚举穿过状态，大的路径框架已经被构建出来了，现在要考虑经过那些没有穿过的点。</p>
<p>被穿过的行不用管，现在就剩没穿过的行，每一行可以从左到右，也可以从右到左，如果两边都有经过，还可以两面包夹，算出每一行的结果，然后加上去就行。</p>
<p>这样可以拿到 <span
class="math inline">\(80pts\)</span>，因为它处理不了这种情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 7</span><br><span class="line">#.....#</span><br><span class="line">.#####.</span><br><span class="line">.#####.</span><br></pre></td></tr></table></figure>
<p>它会穿过第一行和第二行，到第三行后穿过或者是走到底再回来，实际上在穿过第一行走到第二行的时候就应该上去拿掉右上角。</p>
<p>所以把大的路径画出来后，记录每一个边缘位置是否到达过，还要自下而上
<span class="math inline">\(dp\)</span>
一遍求出经过所有未经过的点的最小代价。</p>
<p>提供一种思路，设 <span class="math inline">\(dp[i][j][k]\)</span>
表示到第 <span class="math inline">\(i\)</span>
行，左右最前面的可以已经经过的点为 <span
class="math inline">\(j,k\)</span> 的最小代价，转移的时候看 <span
class="math inline">\(j,k\)</span> 是否大于 <span
class="math inline">\(i\)</span> 或者 <span
class="math inline">\(i\)</span>
的两端是否已经经过，如果可行，就选经过一行三种方案的最小值，如果不行，因为一定有一边已经经过，所以只考虑另一边是否补全和从经过的点走一遍再回来的情况，补全的方案有两种，从上面和从下面，直接转移即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n^3 *
3^n)\)</span>，实际上剪枝后跑的飞快，<span
class="math inline">\(10ms\)</span> 就跑完了。</p>
<h2 id="section-4">20220212</h2>
<h3 id="测试t2">20220212测试T2</h3>
<h4 id="题意-4"><a
target="_blank" rel="noopener" href="https://https://local.cwoi.com.cn:8443//contest/C18/problem/B">题意</a></h4>
<h4 id="思考-4">思考:</h4>
<p>考虑直接 <span class="math inline">\(dp\)</span> 转移，设 <span
class="math inline">\(dp[i][j][k][0/1]\)</span> 表示考虑前 <span
class="math inline">\(i\)</span> 个数， 正色子已经用了 <span
class="math inline">\(j\)</span> 个，反色子已经用了 <span
class="math inline">\(k\)</span> 个，是否已经赢了的方案数，直接转移是
<span class="math inline">\(O(n^4 * t)\)</span> 的，可以拿到 <span
class="math inline">\(20pts\)</span> 的好成绩。</p>
<p>考虑优化，转移式子是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">0</span>;j2&lt;=i2;j2++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=t&amp;&amp;i1-j1&gt;i2-j2)</span><br><span class="line">    <span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">1</span>],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">0</span>]*C[n-j1][i1-j1]%mod*C[m-j2][i2-j2]%mod);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">0</span>],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">0</span>]*C[n-j1][i1-j1]%mod*C[m-j2][i2-j2]%mod);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">1</span>],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">1</span>]*C[n-j1][i1-j1]%mod*C[m-j2][i2-j2]%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转移目标</p>
<p><code>dp[i][i1][i2][1]</code></p>
<p>前面一部分</p>
<p><code>1ll*dp[i-1][j1][j2][0]*C[n-j1][i1-j1]</code></p>
<p>和后面一部分</p>
<p><code>C[m-j2][i2-j2]</code></p>
<p>只有前一部分依赖 <span
class="math inline">\(j1\)</span>，考虑能不能预处理前一部分的转移，然后优化一个
<span class="math inline">\(n\)</span></p>
<p>显然是可以的，手推一下式子可以得到一个新的转移。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">&#123;</span><br><span class="line">	sum[j1][i2]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>][<span class="number">1</span>]*C[m][i2]%mod;</span><br><span class="line">	sum2[j1][i2][<span class="number">0</span>]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>][<span class="number">0</span>]*C[m][i2]%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">1</span>;j2&lt;=i2;j2++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j1][j2][<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">Inc</span>(sum[j1][i2],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">1</span>]*C[m-j2][i2-j2]%mod);</span><br><span class="line">		sum2[j1][i2][j2]=sum2[j1][i2][j2<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j1][j2][<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">Inc</span>(sum2[j1][i2][j2],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2][<span class="number">0</span>]*C[m-j2][i2-j2]%mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val=C[n-j1][i1-j1];</span><br><span class="line">	<span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">1</span>],<span class="number">1ll</span>*val*sum[j1][i2]%mod);</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> pos=i2+j1-i1,val1=pos&lt;<span class="number">0</span>?<span class="number">0</span>:sum2[j1][i2][pos],val2;</span><br><span class="line">		val2=sum2[j1][i2][i2];<span class="built_in">Dec</span>(val2,val1);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;t)<span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">0</span>],<span class="number">1ll</span>*val*val1%mod);</span><br><span class="line">		<span class="built_in">Inc</span>(dp[i][i1][i2][<span class="number">1</span>],<span class="number">1ll</span>*val*val2%mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化到了 <span class="math inline">\(O(n^3*t)\)</span>，记此时的常数
<span class="math inline">\(k = 1\)</span>，它需要约 <span
class="math inline">\(15s\)</span> 通过数据规模最大的测试点。</p>
<p>这份代码可以拿到 <span class="math inline">\(50pts\)</span>
的好成绩，感觉上已经不太能优化复杂度了，我们考虑卡常。</p>
<p>第一步，发现 <span class="math inline">\(n=6\)</span>
的时候只需要转移 <span class="math inline">\(dp[6][n][m][1]\)</span></p>
<p>第二步，发现 <span class="math inline">\(n=1\)</span>
的时候被转移的只有 <span
class="math inline">\(dp[0][0][0][0]\)</span></p>
<p>常数变为 <span class="math inline">\(k = \dfrac{2}{3}\)</span></p>
<p>此时可以拿到 <span class="math inline">\(70pts\)</span>
的好成绩。</p>
<p>继续考虑卡常。</p>
<p>发现其实在 <span class="math inline">\(i&gt;=t\)</span> 时转移 <span
class="math inline">\(dp[i][i1][i2][0]\)</span>
没有意义，直接剪掉。常数没有变化。</p>
<p>发现 <span class="math inline">\(dp[i][i1][i2][1]\)</span>
实际上可以由 <span class="math inline">\(dp[i][i1][i2][0]\)</span>
直接得到，所以只转移 <span
class="math inline">\(dp[i][i1][i2][0]\)</span> ，记作 <span
class="math inline">\(dp[i][i1][i2]\)</span>，常数变为 <span
class="math inline">\(k = \dfrac{1}{3}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&lt;=t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2=i==<span class="number">6</span>?m:<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[j1][i2][<span class="number">0</span>]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>]*C[m][i2]%mod;</span><br><span class="line">            <span class="type">int</span> *p=&amp;sum[j1][i2][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">1</span>;j2&lt;=i2;j2++)</span><br><span class="line">            &#123;</span><br><span class="line">                *p=sum[j1][i2][j2<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">Inc</span>(*p++,<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2]*C[m-j2][i2-j2]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i1=i==<span class="number">6</span>?n:<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=i==<span class="number">6</span>?m:<span class="built_in">max</span>(<span class="number">0</span>,i1-j1);i2&lt;=m;i2++)</span><br><span class="line">                <span class="built_in">Inc</span>(dp[i][i1][i2],<span class="number">1ll</span>*C[n-j1][i1-j1]*sum[j1][i2][i2+j1-i1]%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i2=i==<span class="number">6</span>?m:<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line">            sum[j1][i2][<span class="number">0</span>]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>]*C[m][i2]%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">1</span>;j2&lt;=i2;j2++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line">                <span class="built_in">Inc</span>(sum[j1][i2][<span class="number">0</span>],<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2]*C[m-j2][i2-j2]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i1=i==<span class="number">6</span>?n:<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2=i==<span class="number">6</span>?m:<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line">                <span class="built_in">Inc</span>(dp[i][i1][i2],<span class="number">1ll</span>*sum[j1][i2][<span class="number">0</span>]*C[n-j1][i1-j1]%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的成绩还是 <span
class="math inline">\(70pts\)</span>，但我们可以观察一下代码，在 <span
class="math inline">\(i&gt;t\)</span>
后的转移实际上没有任何意义，可以直接计算，优化这一部分，可以拿到 <span
class="math inline">\(90pts\)</span> 的好成绩。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="built_in">min</span>(t,<span class="number">5</span>);i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=n;j1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">0</span>;i2&lt;=m;i2++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[j1][i2][<span class="number">0</span>]=<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][<span class="number">0</span>]%mod*C[m][i2]%mod;</span><br><span class="line">            <span class="type">int</span> *p=&amp;sum[j1][i2][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j2=<span class="number">1</span>;j2&lt;=i2;j2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j1][j2]&gt;=mod)dp[i<span class="number">-1</span>][j1][j2]%=mod;</span><br><span class="line">                *p=sum[j1][i2][j2<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">Inc</span>(*p++,<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j1][j2]*C[m-j2][i2-j2]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">0</span>;i1&lt;=n;i1++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j1=<span class="number">0</span>;j1&lt;=i1;j1++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="built_in">max</span>(<span class="number">0</span>,i1-j1);i2&lt;=m;i2++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i1][i2]+=<span class="number">1ll</span>*C[n-j1][i1-j1]*sum[j1][i2][i2+j1-i1];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][i1][i2]&gt;=<span class="number">8e18</span>)dp[i][i1][i2]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">Inc</span>(dp[<span class="number">6</span>][n][m],(n-i&lt;=m-j)*dp[<span class="number">5</span>][i][j]%mod);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,((<span class="built_in">quick</span>(<span class="number">6</span>,n+m)-dp[<span class="number">6</span>][n][m]%mod)+mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> all=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">Inc</span>(all,<span class="number">1ll</span>*dp[t][i][j]%mod*<span class="built_in">quick</span>(<span class="number">6</span>-t,n+m-i-j)%mod);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,((<span class="built_in">quick</span>(<span class="number">6</span>,n+m)-all)+mod)%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的 <span class="math inline">\(10pts\)</span>
可能需要一些卡常技巧。</p>
<p>我们发现实际上复杂度的瓶颈在数组寻址和取模，考虑优化其中之一，被寻址的数组经过循环变量的调整已经相当连续了，我们考虑优化取模。</p>
<p>用 <code>long long</code> 存 <span
class="math inline">\(dp\)</span>，每 <span
class="math inline">\(8\)</span> 次加法取一次模，可以通过本题。</p>
<p>一个很常见的，在取模运算较多时的优化技巧。</p>
<h3 id="测试t3">20220211 测试T3</h3>
<h4 id="题意-5"><a
target="_blank" rel="noopener" href="https://https://local.cwoi.com.cn:8443//contest/C18/problem/C">题意</a></h4>
<h4 id="思考-5">思考：</h4>
<p>这道题暴力思路无非就二进制枚举和容斥。正解的做法很神仙。</p>
<p>在这种 <span class="math inline">\(\text{NP}\)</span>
问题中，我们完全可以考虑将枚举的部分减少，这道题的思路是对稀疏图删点变为森林，然后二进制枚举一些删掉的点的状况再进行树形
<span
class="math inline">\(dp\)</span>，着实是一个很有启发性的思路。</p>
<h2 id="section-5">20220212</h2>
<h3 id="cf1637f">CF1637F</h3>
<h4 id="思考-6">思考:</h4>
<p>对于这种条件为最小值的覆盖问题，我们不妨考虑最大的那个点是如何被覆盖的，首先有一个结论是只会在叶子有基站，证明简单，略去。然后考虑最大的那个点是如何被覆盖的，把它看作根，一定来源于它不同儿子的两个叶子，所以我们考虑其它点的时候一定可以认为这个根上的值为
<span class="math inline">\(\text{INF}\)</span>
，理由不多说了。所以每个点 <span class="math inline">\(u\)</span>
的包含的叶子至少有一个最大值为 <span
class="math inline">\(h_u\)</span>，贪心即可，最后决策最大值的点应该放在哪里，同样的贪心。</p>
<p>实现较为简单，没什么说的。</p>
<h2 id="section-6">20220225</h2>
<h3 id="haltoj116">haltoj116</h3>
<h4 id="思考-7">思考：</h4>
<p>考虑团和独立集的性质，我在考场上就想到了答案一定不多，极大概率无需取模这一特性，于是用类似分治的方式得到了
<span
class="math inline">\(60pts\)</span>，如果我们找出了一个合法解，那么其它合法解的构造也是简单的，考虑合法解的性质，不妨设团的大小为
<span class="math inline">\(s\)</span>
，那么因为独立集只能向团连边，所以独立集中的点最大度数为 <span
class="math inline">\(s\)</span>，而这样又导致了团中的点最小度数增加，所以我们不难发现团中的点一定是度数最大的那一段前缀。</p>
<p>对于度数相同的点，看似无法下手，但是我们知道边的构成是团内加上团和独立集之间，团内的边数我们是知道的，而如果记录一下团中点的总度数，我们可以很轻松的推出独立集间是否有边，我们设团内点的总度数为
<span class="math inline">\(p\)</span>,团的大小为 <span
class="math inline">\(i\)</span>，团内边数为 ，那么其他点之间的边数就为
<span
class="math inline">\((2*m-2*p+i*(i-1))/2\)</span>，所以我们考虑满足
<span class="math inline">\(2m + i * (i-1) = 2p\)</span>
这个条件的选择有什么性质，因为这是成立的必要条件，考虑证明这也是充分条件。如果团内边数不足
<span class="math inline">\(i*(i-1)\)</span>，那么我们发现 <span
class="math inline">\(p\)</span>
这边会减小。考虑如果独立集内边数有边，那么 <span
class="math inline">\(p\)</span>
这边一样相对减少，所以这也是充分条件。</p>
<p>这道题结束了。</p>
<h3 id="haltoj117">haltoj117:</h3>
<h4 id="思考-8">思考：</h4>
<p>考虑在原序列中是前缀 <span class="math inline">\(max\)</span>
的点，它们在新划分的序列中一定也是前缀 <span
class="math inline">\(max\)</span>，如果新增了前缀 <span
class="math inline">\(max\)</span>，那么我们可以很轻松的改变划分情况去除这个前缀
<span class="math inline">\(max\)</span>，所以如果原序列中前缀 <span
class="math inline">\(max\)</span>
的数量为偶数，就一定可以。如果为奇数，我们不妨考虑只有一个序列有新增的前缀
<span class="math inline">\(max\)</span>
的情况。我们考虑从原序列中抽出一个新序列出来，设两个序列的权值之差为
<span class="math inline">\(k\)</span>，如果抽了一个原先的前缀 <span
class="math inline">\(max\)</span>，那么 <span
class="math inline">\(k\)</span> 减少 <span
class="math inline">\(2\)</span>，如果新增了一个前缀 <span
class="math inline">\(max\)</span>，<span
class="math inline">\(k\)</span> 减少量为 <span
class="math inline">\(1\)</span>，所以我们将原先是前缀 <span
class="math inline">\(max\)</span> 的数的权值视为 <span
class="math inline">\(2\)</span>，其余的视为 <span
class="math inline">\(1\)</span>，问题就是是要选一个上升子序列，使得权值和为前缀
<span class="math inline">\(max\)</span>
的个数，这个问题就相当简单了。</p>
<h2 id="section-7">20220228</h2>
<h3 id="abc215h子集容斥的另一种思路">ABC215H(子集容斥的另一种思路)</h3>
<p>考虑霍尔定律，枚举不满足条件的子集 <span
class="math inline">\(mask\)</span>，可以用 <span
class="math inline">\(\text{FMT-DP}\)</span> 计算出必须由 <span
class="math inline">\(mask\)</span>
供给的白菜数量，考虑减少一个子集中的白菜使得不满足条件，就可以计算出最少需要吃多少个。问题变成了统计答案，我们发现对于一个
<span class="math inline">\(mask\)</span>
直接组合数计算然后相加会算重，又因为答案不是全集所以并不能简单容斥。而暴力计算强制每种白菜都选一个的复杂度是
<span class="math inline">\(O(3^n)\)</span> 的，我们仍然考虑应用 <span
class="math inline">\(\text{FMT-DP}\)</span>
计算答案。事实上，这种组合数问题都可以考虑这种方式。</p>
<p>设 <span class="math inline">\(f_{mask}\)</span> 表示所选白菜集合被
<span class="math inline">\(mask\)</span> 包含的方案数，设 <span
class="math inline">\(f&#39;_{mask}\)</span> 表示所选白菜种类集合恰好为
<span class="math inline">\(mask\)</span> 的方案数，列有等式。 <span
class="math display">\[
f&#39;_{mask} = f_{mask} - \sum\limits_{x \sub mask} f&#39;_{mask}
\]</span> 令 <span class="math inline">\(f[i][mask]\)</span>
表示当前子集为 <span class="math inline">\(mask\)</span> ，低 <span
class="math inline">\(i\)</span>
位不一定存在，但高位都严格符合要求的方案总数，列有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>;mask&lt;<span class="number">1</span>&lt;&lt;n;mask++)&#123;</span><br><span class="line">        f[i][mask]=f[i<span class="number">+1</span>][mask];</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>&lt;&lt;i&amp;mask)f[i][mask]-=f[i<span class="number">+1</span>][mask^(<span class="number">1</span>&lt;&lt;i)],f[i][mask]%=mod;	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从 <span class="math inline">\(i+1\)</span> 推到 <span
class="math inline">\(i\)</span>
的过程中，因为高位已经强制存在了，所以我们减去的就是 <span
class="math inline">\(f[i][mask]\)</span> 中所有不存在第 <span
class="math inline">\(i\)</span> 位，但高位符合要求的情况。</p>
<p>最后计算出来的 <span class="math inline">\(f[0]\)</span> 就是上述的
<span class="math inline">\(f\)</span>。</p>
<p>然后这道题就好做了。</p>
<h2 id="section-8">20220301</h2>
<h3 id="考试-t1sam的进一步理解">考试 T1(SAM的进一步理解)</h3>
<h4 id="题意-6">题意：</h4>
<p>给定一颗字符在点上的 <span
class="math inline">\(\text{Trie}\)</span>，求 <span
class="math inline">\(\text{Trie}\)</span>
代表的所有字符串本质不同子串个数，顺便询问钦定字符大小关系后第 <span
class="math inline">\(k\)</span> 小的子串，保证 <span
class="math inline">\(\text{Trie}\)</span> 上字符随机且答案长度和不超过
<span class="math inline">\(800KB\)</span>。</p>
<h4 id="思考-9">思考：</h4>
<p>考场上想到可以类似 <span class="math inline">\(\text{SAM}\)</span>
一样乱搞，然后就写了 <span class="math inline">\(\text{dfs}\)</span>
构建 <span class="math inline">\(\text{SAM}\)</span>，<span
class="math inline">\(lst\)</span> 指针被置为它父亲插入后的 <span
class="math inline">\(p\)</span>，这个做法在数据随机的情况下是没有问题的，但是如果出现构造数据，它会没掉。</p>
<p>首先是如果拉一条 <span class="math inline">\(a\)</span>
链，链上每个点再挂一个 <span class="math inline">\(b\)</span>，然后
<span class="math inline">\(dfs\)</span> 回跳的时候重置 <span
class="math inline">\(q\)</span> 的来边到 <span
class="math inline">\(np\)</span> 时时间复杂度是 <span
class="math inline">\(O(n^2)\)</span> 的。</p>
<p>我所理解的 <span class="math inline">\(\text{SAM}\)</span>
时间复杂度正确性基于两个东西，一个是 <span
class="math inline">\(p\)</span>
的深度变化情况，这证明了第一次构建边的时候时间正确。在 <span
class="math inline">\(dfs\)</span> 构建 <span
class="math inline">\(SAM\)</span> 的时候，大量回溯操作会导致 <span
class="math inline">\(p\)</span>
深度的异常变化，这样就不对了。第二个是重置 <span
class="math inline">\(q\)</span> 的来边的循环，这个可以分析 <span
class="math inline">\(p\)</span> 的 <span
class="math inline">\(fa\)</span> 所代表最短字符串长度来理解，每次重置
<span class="math inline">\(q\)</span>
的来边，我们都认为是找到了一个更短的 <span
class="math inline">\(np\)</span>
所代表的字符串，不妨看成一个指针在插入的字符串上移动，它只会向右。重置完
<span class="math inline">\(p\)</span>
的来边再插入下个点的过程中，我们至少会跳到 <span
class="math inline">\(np\)</span> 处（只针对单个串），然后重设的 <span
class="math inline">\(p&#39;\)</span> 的 <span
class="math inline">\(fa\)</span> 的最短长度一定可以从 <span
class="math inline">\(np\)</span> 那里继承过来，所以指针只会右移。<span
class="math inline">\(dfs\)</span> 加入时同样导致了这个指针在 <span
class="math inline">\(\text{Trie}\)</span>
上乱跳，复杂度就没有了保证。</p>
<p>然后是正确性相关的问题，这种 <span
class="math inline">\(\text{SAM}\)</span>
写法会导致无效的空节点建立，比如说插入的时候就碰到了满足 <span
class="math inline">\(a[lst].ch[c]\)</span>
存在的情况，这样新建出来的点实际上是无效的，在绝大部分题目中这个无效点是不影响答案的，但是少部分写法会导致爆炸。</p>
<p>接下来讨论下 <span class="math inline">\(\text{BFS}\)</span>
建树的正确性。由于是按深度加点，所以 <span
class="math inline">\(a[lst].ch[c]\)</span>
一定是不存在的，因此绝不会导致无效节点的建立，时间复杂度证明不会，省略。</p>
<p>时间复杂度我并不会证明 emmmm.</p>
<h3 id="abc241h">ABC241H</h3>
<h4 id="思考-10">思考：</h4>
<p>生成函数套路题。</p>
<h2 id="section-9">20220302</h2>
<h3 id="arc136e">ARC136E</h3>
<h4 id="思考-11">思考：</h4>
<p>显然偶数链是很好走的，所以考虑从偶数边怎么到另一个节点，显然偶数只能选一个，我们先考虑不选偶数的情况。</p>
<p>定义 <span class="math inline">\(f[x]\)</span> 为 <span
class="math inline">\(x\)</span> 的最小质因数，<span
class="math inline">\(x\)</span> 能走到 <span
class="math inline">\(y\)</span> 的充要条件是 <span
class="math inline">\(y&gt;x,x+f[x]\leq y-f[y]\)</span>，如果 <span
class="math inline">\((x,y) = 1\)</span>，那么显然，因为 <span
class="math inline">\(x\)</span> 第一步至少走 <span
class="math inline">\(f[x]\)</span>，到 <span
class="math inline">\(y\)</span> 的最后一步至少走 <span
class="math inline">\(f[y]\)</span>。如果 <span
class="math inline">\((x,y) \neq 1\)</span>，设 <span
class="math inline">\(x = p \times f[x]\)</span>，则 <span
class="math inline">\(y\)</span> 至少为 <span
class="math inline">\((p+2)\times f[x]\)</span>，故结论仍然成立。</p>
<p>由此可以 <span class="math inline">\(x\)</span> 走不到 <span
class="math inline">\(y(y&gt;x)\)</span> 的充要条件为 <span
class="math inline">\(x+f[x]&gt;y-f[y]\)</span>，将每个点视为 <span
class="math inline">\((x-f[x],x+f[x]])\)</span>
，题目就是要求出一些区间的集合，使得所有区间有公共点，要求权值最大，不妨枚举公共点，然后差分计算即可。</p>
<p>考虑下偶数，实际上做法类似。</p>
<h2 id="section-10">20220303</h2>
<h3 id="agc027ehaltoj119">AGC027E&amp;&amp;haltoj119</h3>
<h4 id="思考-12">思考：</h4>
<p>观察不变量是这种变换题的思考方向之一，我们设 <span
class="math inline">\(a\)</span> 的权值为 <span
class="math inline">\(1\)</span> ，<span
class="math inline">\(b\)</span> 的权值为 <span
class="math inline">\(2\)</span>，总能发现权值和对 <span
class="math inline">\(3\)</span> 取模的结果不变。</p>
<p>先考虑一个字符串在什么情况下可以变成另一个字符串，权值相同显然是必要条件，其次，源串
<span class="math inline">\(s\)</span> 不能是交替串 <span
class="math inline">\(abababa\)</span>
这类，这有点困难，不妨先考虑变成一个字母的情况。</p>
<p>充要条件为权值相同且不交替，证明考虑归纳法。</p>
<p>现在考虑目标为一个字符串的情况。我们先贪心的匹配，用最少的字母构造出目标串，然后考虑调整剩下的部分使得它满足条件。如果特判掉交替串，我们发现只要权值相同且源串的一个前缀能和目标串贪心匹配上，那么一定可以变成目标串，于是考虑
<span class="math inline">\(dp[i]\)</span> 表示考虑到前 <span
class="math inline">\(i\)</span>
的源串字母，能贪心的对应上多少不同串，显然这样的贪心对应是不重不漏的，转移分为匹配
<span class="math inline">\(i+1\)</span> 和不匹配 <span
class="math inline">\(i+1\)</span> 两种，预处理一个类似 <span
class="math inline">\(nxt\)</span> 的东西可以做到线性。</p>
<h2 id="section-11">20220304</h2>
<h3
id="cf917dhaltoj122初探二项式反演">CF917D&amp;&amp;haltoj122(初探二项式反演)</h3>
<h4 id="思考-13">思考：</h4>
<p>考场上已经观察出原题需要求一张完全图有多少棵最小生成树与给定树至少有
<span class="math inline">\(n-k-1\)</span> 条边相同。<span
class="math inline">\(prufer\)</span> 序列有一个结论，<span
class="math inline">\(n\)</span> 个点 <span
class="math inline">\(k\)</span>
个连通块的图构成有标号无根树的方案总数为 <span class="math display">\[
n^{k-2}\times\prod_{i=1}^{k} sz[i]
\]</span> 显然我不会证明。场上看到 <span
class="math inline">\(n\)</span> 仅为 <span
class="math inline">\(50\)</span> 就想乱搞，误打误撞弄了一个容斥 <span
class="math inline">\(dp\)</span>
出来，实际上正解差不多就是这个。我们考虑钦定选了 <span
class="math inline">\(k\)</span> 条边一定存在的方案总数 <span
class="math inline">\(f(k)\)</span>，由二项式反演的套路可以得知恰好
<span class="math inline">\(k\)</span> 条边存在的方案数 <span
class="math inline">\(g(k)\)</span> 满足 <span class="math display">\[
g(k) = \sum_{i=k}^{n-1}(-1)^{i-k}\times C(i,k) \times f(i)
\]</span> 其中 <span class="math inline">\(C(i,j)\)</span>
表示组合数。</p>
<p>显然我仍然不会证明，但是可以感性理解下，首先 <span
class="math inline">\(f(k)\)</span> 满足以下式子 <span
class="math display">\[
f(k) = \sum_{i=k}^{n-1}C(i,k) \times g(i)
\]</span> 这个很好理解，枚举实际上选了多少条边，钦定 <span
class="math inline">\(k\)</span>
条边的方案数就是从实际选的边中钦定一些出来。注意这个钦定和至少有区别，不是简单的后缀和，因为实际选一条边的方案可以被多种钦定的情况包含。</p>
<p>我不会证明二项式反演的式子，所以我们从容斥的角度来考虑 <span
class="math inline">\(g(k)\)</span>，第一项为钦定 <span
class="math inline">\(k\)</span> 条边，然后减去被多考虑了的存在 <span
class="math inline">\(k+1\)</span>
条边的情况，依此类推。组合数的存在则是因为 <span
class="math inline">\(f(i)\)</span> 会被额外考虑 <span
class="math inline">\(C(i,k)\)</span> 次。</p>
<p><span class="math inline">\(f\)</span> 肯定比 <span
class="math inline">\(g\)</span> 好算，我们现在需要计算的是选 <span
class="math inline">\(k\)</span>
条边，然后得到的联通块组成不同有标号无根生成树的方案数。注意到生成树计数公式中
<span class="math inline">\(n^{k-2}\)</span>
与怎么选边完全无关，所以只需要记录一下 <span class="math inline">\(\prod
sz_i\)</span>，这个就可以 <span
class="math inline">\(dp[i][j][k]\)</span> 表示考虑以 <span
class="math inline">\(i\)</span> 为根的子树，选了 <span
class="math inline">\(j\)</span> 条边，<span
class="math inline">\(i\)</span> 所在连通块大小为 <span
class="math inline">\(k\)</span> 的方案数。优化的话，可以考虑 <span
class="math inline">\(\prod sz_i\)</span>
的组合意义。于是就是需要在每个连通块内选一个代表元，于是状态第三维简化为是否选了代表元，复杂度
<span class="math inline">\(O(n^2)\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E5%86%99%E6%B3%95%E4%BC%98%E7%BE%8E%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E5%86%99%E6%B3%95%E4%BC%98%E7%BE%8E%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">写法优美的常用函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:07:45" itemprop="dateCreated datePublished" datetime="2022-07-12T16:07:45+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:52:49" itemprop="dateModified" datetime="2025-02-16T17:52:49+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="写法优美的常用函数">写法优美的常用函数</h2>
<p>收录一些优美的常用函数写法。</p>
<h3 id="分解质因数">分解质因数</h3>
<p>有人根本不会用 <code>do while</code> 和 <code>vector</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">do</span> n/=i; <span class="keyword">while</span>(n%i==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="scc">SCC</h3>
<p>缩点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> low=dfn[u]=++df;st[++top]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])<span class="built_in">cmin</span>(low,<span class="built_in">dfs</span>(v));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!scc[v])<span class="built_in">cmin</span>(low,dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low==dfn[u])&#123;</span><br><span class="line">		++cnt;<span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">do</span> val[cnt]+=a[v=st[top--]],scc[v]=cnt; <span class="keyword">while</span>(v!=u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路-dijskstra">最短路 Dijskstra</h3>
<p>如果 <span class="math inline">\(dis\times n\le 8\times
10^{18}\)</span>，完全可以它们压成一个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;LL,vector&lt;LL&gt;,greater&lt;LL&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">1</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">	dis[s]=<span class="number">0</span>;q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">top</span>()%M;q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;vis[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(vis[t])<span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=a[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v=a[i].v,w=a[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[u]+w&gt;=dis[v])<span class="keyword">continue</span>;</span><br><span class="line">			dis[v]=dis[u]+w;q.<span class="built_in">push</span>(dis[v]*M+v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">网络流相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:06:50" itemprop="dateCreated datePublished" datetime="2022-07-12T16:06:50+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:56:02" itemprop="dateModified" datetime="2025-02-16T17:56:02+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="网络流">网络流</h2>
<p>内容主要为自己对网络流的一些理解和一些典例。</p>
<h3 id="一些约定">一些约定：</h3>
<ul>
<li>s 为源点，t 为汇点</li>
<li>对于集合 <span class="math inline">\(S,T,T\subseteq S\)</span>，约定
<span class="math inline">\(S-T\)</span> 为从 <span
class="math inline">\(S\)</span> 中删掉 <span
class="math inline">\(T\)</span> 中每个元素之后的集合</li>
<li>网络流图为 <span class="math inline">\(G=(V,E)\)</span>，边 <span
class="math inline">\((u,v)\)</span> 容量记为 <span
class="math inline">\(c_{u,v}\)</span></li>
</ul>
<h3 id="最大流最小割定理和增广路定理">最大流最小割定理和增广路定理</h3>
<p>这两个定理是网络流问题的核心定理。</p>
<h4 id="内容">内容</h4>
<p>最大流 = 最小割。</p>
<p>残量网络中不存在增广路是当前流为最大流的充要条件。</p>
<h4 id="证明">证明</h4>
<ol type="1">
<li><p>若当前流为最大流，显然不存在增广路。</p></li>
<li><p>若当前流等于某个割，显然当前流为最大流，且该割为最小割。</p></li>
<li><p>若不存在增广路，我们证明当前流等于一个割。</p></li>
</ol>
<p>令 <span class="math inline">\(S=\{v,\exist\
p_{s,v}\}\)</span>，<span class="math inline">\(S\)</span> 即 <span
class="math inline">\(s\)</span> 在残量网络中能到达的点的集合。令 <span
class="math inline">\(T=V-S\)</span>。显然 <span
class="math inline">\((S,T)\)</span> 是一个割，对于当前残量网络 <span
class="math inline">\(G&#39;=(V,E&#39;)\)</span>，一定有 <span
class="math inline">\(\forall x \in S,\forall y\in T\)</span>，边 <span
class="math inline">\((x,y)\)</span> 满流，否则 <span
class="math inline">\(y\in S\)</span>。容易证明当前流恰好为 <span
class="math inline">\(S\)</span> 到 <span
class="math inline">\(T\)</span>
的所有边的容量和，也就是割的大小。因为此时原图 <span
class="math inline">\(S\)</span> 到 <span
class="math inline">\(T\)</span> 所有的边流量为容量，<span
class="math inline">\(T\)</span> 到 <span
class="math inline">\(S\)</span> 的边流量为 <span
class="math inline">\(0\)</span>，所以流量为 <span
class="math inline">\(S\)</span> 到 <span
class="math inline">\(T\)</span> 的边的流量之和，也就是割 <span
class="math inline">\(S,T\)</span>。</p>
<h3 id="算法">算法</h3>
<h4 id="dinic">Dinic</h4>
<p>考虑对残量网络 bfs 分层，强制流量只能流向下一层，再进行一次
dfs，求限制下所有的增广路，搞定。</p>
<p>复杂度 <span class="math inline">\(O(n^2m)\)</span></p>
<p>每次增广复杂度为 <span class="math inline">\(O(nm)\)</span>，共计增广
<span class="math inline">\(n\)</span> 次，因为每次增广都会让 <span
class="math inline">\(dep[t]\)</span> 增加 1。</p>
<p>每次增广的复杂度不是很好证，但加了当前弧优化其实就很松。</p>
<p>代码记在脑子里了，不放了。</p>
<h4 id="isap">ISAP</h4>
<p>咕咕咕</p>
<h4 id="hlpp">HLPP</h4>
<p>咕咕咕</p>
<h3 id="费用流相关">费用流相关</h3>
<p>一般指最小费用最大流，暂时没啥感觉，不写。</p>
<h2 id="最小割">最小割</h2>
<p>非常常见的一个网络流模型应用。</p>
<h3 id="核心思想">核心思想</h3>
<p>通过构造一个图的割到决策方案的映射，其中决策必须可拆分计算，求出最小的代价，一般来说决策的限制如果比较奇怪就应该考虑最小割。</p>
<p>常用于规划 <span class="math inline">\(0/1\)</span>
独立贡献决策问题。</p>
<h3 id="适用条件">适用条件</h3>
<ul>
<li>不能存在负容量边权，我不知道有没有人会，反正我是不会。</li>
</ul>
<h3 id="最大闭合权子图问题">1.最大闭合权子图问题</h3>
<p>给定一张有向图，点带权（权可以为负），选一个子图出来，要求如果 <span
class="math inline">\(u\)</span> 选了那如果存在 <span
class="math inline">\((u,v)\)</span>，那 <span
class="math inline">\(v\)</span> 也要选。求最大权值和。</p>
<p>决策贡献独立，决策类型为 0/1。应该可以最小割。令割中与 <span
class="math inline">\(s\)</span> 同集合的点为选择的点，与 <span
class="math inline">\(t\)</span>
同一个集合的点为未选择的点。那么每个点应该和 <span
class="math inline">\(t\)</span>
连一条流量为权值的相反数的边，代表选它的代价，再对于每条 <span
class="math inline">\((u,v)\)</span> 从 <span
class="math inline">\(u\)</span> 向 <span
class="math inline">\(v\)</span> 连一条 inf 边,代表选了 <span
class="math inline">\(u\)</span> 不选 <span
class="math inline">\(v\)</span>
的代价。考虑这张图的一个最小割，它必然不会包含 inf
边，也就是说，我们选了 <span class="math inline">\(u\)</span> 在 <span
class="math inline">\(s\)</span> 中一定会让 <span
class="math inline">\(v\)</span> 在 <span
class="math inline">\(s\)</span>
中，所以一定合法。然后发现原问题的每一个答案都可以和图上的一个不含 inf
边的割一一对应，故最小割就是原问题的答案的相反数。</p>
<p>这张图有负数，不行，所以考虑先默认选所有正数。那么选负数的代价为相反数，不选正数的代价为本身。</p>
<p>那么应该从 <span class="math inline">\(s\)</span>
向正权点连边，从负权点向 <span class="math inline">\(t\)</span>
连边，最后对于 <span class="math inline">\((u,v)\)</span> 从 <span
class="math inline">\(u\)</span> 向 <span
class="math inline">\(v\)</span> 连 inf 边即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E4%B8%80%E4%BA%9B%E7%A7%91%E6%8A%80%E7%9A%84%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E4%B8%80%E4%BA%9B%E7%A7%91%E6%8A%80%E7%9A%84%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">一些科技的总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:05:26" itemprop="dateCreated datePublished" datetime="2022-07-12T16:05:26+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:53:09" itemprop="dateModified" datetime="2025-02-16T17:53:09+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="总结一些科技">总结一些科技</h2>
<p>主要收录比较神仙的，实用的算法技巧。</p>
<h3 id="快速取模">快速取模</h3>
<h4 id="原理">原理</h4>
<p>找到一个近似 <span class="math inline">\(m^{-1}\)</span> 的形如 <span
class="math inline">\(m&#39;&gt;&gt;k\)</span> 的数。</p>
<p>不妨就取 <span
class="math inline">\(k=64,m&#39;=\lceil\frac{2^{64}}{m}\rceil\)</span></p>
<p>然后 <span class="math inline">\(a\%b =
a-a\times\lfloor\frac{a}{b}\rfloor = a-(a\times
m&#39;&gt;&gt;64)\)</span></p>
<p>纯纯的整数运算，经过误差分析，可以知道后式结果最多多减去一个 <span
class="math inline">\(m\)</span>，判断掉就行。</p>
<p>因为 <span class="math inline">\(a\)</span> 常常是 <span
class="math inline">\(\text{long long}\)</span> 级别的数，所以开
<code>__int128</code></p>
<p>优化据说有 <span class="math inline">\(5-6\)</span> 倍，如果模数是
<code>const</code>，编译器会自动帮忙用这个优化。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">barrett</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> im;<span class="type">int</span> m;</span><br><span class="line">	<span class="built_in">barrett</span>(<span class="type">unsigned</span> m) :<span class="built_in">m</span>(m), <span class="built_in">im</span>(~<span class="number">0ull</span>/m<span class="number">+1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> z=(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)a*b;</span><br><span class="line">		<span class="type">int</span> v=z-((__int128)z*im&gt;&gt;<span class="number">64</span>)*m;</span><br><span class="line">		<span class="keyword">return</span> v&lt;<span class="number">0</span>?v+m:v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="built_in">bt</span>(<span class="number">1</span>);</span><br><span class="line">  bt=<span class="built_in">barrett</span>(p);</span><br><span class="line">  c=<span class="built_in">bt</span>(a,b);</span><br><span class="line"><span class="comment">//c=a*b%p</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项">注意事项</h4>
<ul>
<li>为啥 <code>im,m</code> 用 <code>ull,uint</code>，因为
<code>m=2</code> 时，会爆 <code>long long</code>。</li>
<li>可以重载括号。</li>
</ul>
<h3 id="光速乘">光速乘</h3>
<p>用于计算两个 long long 级别的数乘积对一个 long long
级别的数取模的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">multi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> mod)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> x=(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)a*b-(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)((<span class="type">long</span> <span class="type">double</span>)a*b/mod<span class="number">-0.5</span>)*mod;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=mod?x-mod:x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> A, <span class="type">long</span> <span class="type">long</span> B, <span class="type">long</span> <span class="type">long</span> P)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> C = A * B - (<span class="type">long</span> <span class="type">long</span>)((<span class="type">long</span> <span class="type">double</span>)A * B / P + <span class="number">0.1</span>) * P;</span><br><span class="line">	<span class="keyword">return</span> C &lt; <span class="number">0</span> ? C + P : C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理很简单，long double 的精度误差虽然有，但是我们 -0.5
之和核查范围变成了 [0,1]，肯定不会超出这个。</p>
<p>C++ 标准中要求了 unsigned long long 类型在溢出后保证为原值对 <span
class="math inline">\(2^{64}\)</span> 取模的结果，所以直接用就行。</p>
<p>第二个原理类似，在 G++ 编译器中，O2 中，保证 long long
的溢出行为有定义。</p>
<p>推荐用第一个，各个平台都不会出锅。</p>
<p>如果 <span class="math inline">\(P\leq 10^{14}\)</span> 可以改成
double</p>
<p>判断一下是否减少了就行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AE%BA%E8%AF%81%E6%98%8E%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%BB%93%E8%AE%BA%E8%AF%81%E6%98%8E%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">常用数学结论证明汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:04:07" itemprop="dateCreated datePublished" datetime="2022-07-12T16:04:07+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:54:22" itemprop="dateModified" datetime="2025-02-16T17:54:22+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简单事实">简单事实</h3>
<ol type="1">
<li><span class="math inline">\(\gcd(a,x_1)=1,\gcd(a,x_2)=1 \iff
\gcd(a,x_1x_2)\)</span></li>
<li>若 <span class="math inline">\(n\ |\ m\)</span> 则 <span
class="math inline">\(\phi(n)\ |\ \phi(m)\)</span></li>
<li>若 <span class="math inline">\(\gcd(a,p)=1\)</span>,则 <span
class="math inline">\(ax,x \in [1,p]\)</span> 模 <span
class="math inline">\(p\)</span> 意义下互不相同，反之亦然。</li>
</ol>
<h3 id="模运算和满足的运算率">模运算和满足的运算率</h3>
<p>注：符号均为模 <span class="math inline">\(p\)</span> 意义下。</p>
<ul>
<li>加法交换律</li>
<li>加法结合律</li>
<li>乘法交换律</li>
<li>乘法结合率</li>
<li>如果 <span class="math inline">\(p\)</span> 为质数 ，<span
class="math inline">\(g\)</span> 为 <span
class="math inline">\(p\)</span> 的一个原根，则 <span
class="math inline">\(\log_x(y) = \frac{\log_g(y)}{\log_g(x)} \pmod
{p-1}\)</span></li>
</ul>
<h3 id="复数运算满足的运算性质">复数运算满足的运算性质</h3>
<ul>
<li>加法交换律</li>
<li>加法结合律</li>
</ul>
<h3 id="一些抽象代数内容">一些抽象代数内容</h3>
<h4 id="事实1">事实1</h4>
<p>令 <span class="math inline">\(g\)</span> 为 <span
class="math inline">\(p\)</span> 的一个原根，记 <span
class="math inline">\(\log_g(x) = y\)</span>，模 <span
class="math inline">\(p\)</span> 意义下 <span
class="math inline">\(x\)</span> 的阶数为 <span class="math display">\[
\Large ord = \frac{\phi(p)}{\gcd(\phi(p),\log_g(x))}
\]</span></p>
<h4 id="证明1">证明1</h4>
<p>显然 <span class="math inline">\(g\)</span> 的阶数为 <span
class="math inline">\(\phi(p)\)</span>，又因为 <span
class="math inline">\(g^y = x\)</span>。所以 <span
class="math inline">\(x^{ord} = 1\)</span>。</p>
<p>然后证明 <span class="math inline">\(x^i,i \in [1,ord]\)</span>
互不相同。</p>
<p>反证，如果相同，设为 <span class="math inline">\(i,j(i\ge
j)\)</span>，那么 <span class="math inline">\(g^{yi} = g^{yj}\)</span>
得到 <span class="math inline">\(\phi(x) |\ y(i-j)\)</span> 两边同时除以
<span class="math inline">\(\gcd(\phi(p),y)\)</span>，得到 <span
class="math inline">\(ord |\ y&#39;(i-j)\)</span>，其中 <span
class="math inline">\(\gcd(y&#39;,ord) = 1\)</span> ，得出 <span
class="math inline">\(i-j \ge ord\)</span> 矛盾。</p>
<p>所以 <span class="math inline">\(x\)</span> 的阶数为 <span
class="math inline">\(ord\)</span></p>
<h3 id="裴蜀定理">裴蜀定理</h3>
<h4 id="内容">内容</h4>
<p><span class="math inline">\(\exist\  x,y \in \Z\)</span> 使得 <span
class="math inline">\(ax+by=\gcd(x,y)\)</span></p>
<h4 id="证明">证明</h4>
<p>归纳构造。</p>
<p>先证明 <span class="math inline">\(\exist\ x&#39;,y&#39;\in
\Z\)</span> 使得 <span class="math inline">\(bx&#39;+(a\%b)y&#39; =
\gcd(a,b)\)</span></p>
<p>即 <span class="math inline">\(ay&#39; +
b(x&#39;-\big\lfloor\dfrac{a}{b}\big\rfloor y&#39;) =
\gcd(a,b)\)</span></p>
<p>构造 <span class="math inline">\(x = y&#39;,y=x&#39;-
\big\lfloor\dfrac{a}{b}\big\rfloor y&#39;\)</span> 即可满足条件。</p>
<p>递归证明构造式子，得到边界证明 <span class="math inline">\(\exist \
x,y\)</span> 使得 <span class="math inline">\(\gcd(a,b)x + 0 \times y
=\gcd(a,b)\)</span></p>
<p>令 <span class="math inline">\(x=1,y=0\)</span></p>
<h3 id="欧拉函数是积性函数">欧拉函数是积性函数</h3>
<p>即证明若 <span class="math inline">\(\gcd(n,m) =1,\)</span> 则 <span
class="math inline">\(\phi(n*m) = \phi(n) *\phi(m)\)</span></p>
<h4 id="证明一">证明一</h4>
<p>考虑若干个同余方程组 <span class="math display">\[
x ≡ r_1 \pmod n\\
x ≡ r_2 \pmod m\\
\]</span> 列出 <span class="math inline">\(n,m,nm\)</span>
意义下的最小缩系 <span class="math inline">\(S_n,S_m,T\)</span></p>
<p>容易证明 <span class="math inline">\(\forall\ r_1\in S_n, r_2 \in
S_m\)</span>，存在唯一 <span class="math inline">\(x \in [1,nm]\)</span>
是上同余方程组的解，且 <span class="math inline">\(x \in
T\)</span>。</p>
<p>存在唯一就是 EXCRT， <span class="math inline">\(x\in T\)</span>
由事实 1 显然。</p>
<p>故 <span class="math inline">\(\phi(n*m) \ge \phi(n)
*\phi(m)\)</span></p>
<p>再证明 <span class="math inline">\(\forall\ x\in
T\)</span>，可以对应一个以上同余方程组的解，假设不对应，那么它一定与
<span class="math inline">\(n,m\)</span> 中的一个不互质，由事实 1
推出矛盾。</p>
<p>故 <span class="math inline">\(\phi(n*m) \le \phi(n)
*\phi(m)\)</span></p>
<p>证毕。</p>
<h4 id="证明二">证明二</h4>
<h3 id="欧拉定理">欧拉定理</h3>
<h4 id="内容-1">内容</h4>
<p><span class="math display">\[
\Large 若 \ \gcd(a,m)= 1 ,\ 则\  a^{\phi(m)}≡1\mod m
\]</span></p>
<h4 id="证明-1">证明</h4>
<p>考虑模 <span class="math inline">\(m\)</span>
意义下的最小缩系，即最小完全剩余系删去与 <span
class="math inline">\(m\)</span> 不互质的元素后的剩余系，记为 <span
class="math inline">\(S\)</span>。</p>
<p>构造 <span class="math inline">\(T = \{ax,x \in S\}\)</span></p>
<p>可以证明 <span class="math inline">\(T=S\)</span>， 若 <span
class="math inline">\(\exist\ x_1,x_2\)</span> 使得 <span
class="math inline">\(x_1\neq x_2\)</span> 且 <span
class="math inline">\(ax_1 ≡ ax_2 \pmod m\)</span> ，因为 <span
class="math inline">\(\gcd(a,m)=1\)</span></p>
<p>所以 <span class="math inline">\(m\ |\ x_1 - x_2\)</span>，并推出
<span class="math inline">\(x_1 \neq x_2\)</span>，故 <span
class="math inline">\(T\)</span> 中元素两两不同且均与 <span
class="math inline">\(m\)</span> 互质，即为 <span
class="math inline">\(S\)</span>。</p>
<p>考虑 <span class="math inline">\(T,S\)</span> 中所有元素的乘积，得到
<span class="math inline">\(\prod\limits_{i=1}^{\phi(n)} ax_i ≡
\prod\limits_{i=1}^{\phi(n)} x_i \pmod n\)</span>，又因为 <span
class="math inline">\(\prod\limits_{i=1}^{\phi(n)} x_i\)</span> 与 <span
class="math inline">\(m\)</span> 互质，所以 <span
class="math inline">\(a^{\phi(n)} ≡ 1\pmod n\)</span></p>
<h3 id="扩展欧拉定理">扩展欧拉定理</h3>
<h4 id="内容-2">内容</h4>
<p><span class="math display">\[
\Large 若 \ b≥φ(m) ,\ 则\  a^b≡a^{b \mod φ(m) +φ(m)}\mod m
\]</span></p>
<h4 id="证明-2">证明</h4>
<p>对 <span class="math inline">\(m\)</span> 考虑唯一分解定理。</p>
<p>对于任意因子 <span class="math inline">\(p_i^{k_i}\)</span>，若与
<span class="math inline">\(a\)</span> 互质，那就有 <span
class="math inline">\(a^b≡a^{b \mod φ(m) +φ(m)}\mod
p^{k_i}_i\)</span>。</p>
<p>如果和 <span class="math inline">\(a\)</span> 不互质，因为 <span
class="math inline">\(b\ge \phi(m)\)</span>，那么因为有 <span
class="math inline">\(b\ge \phi(m)\ge k_i\)</span>，所以 <span
class="math inline">\(a^b,a^{(b \mod φ(m)) +φ(m)}\)</span> 都是 <span
class="math inline">\(p^{k_i}_i\)</span> 的倍数。</p>
<p>得到 <span class="math inline">\(a^b - a^{(b \mod φ(m))
+φ(m)}\)</span> 是 <span class="math inline">\(p_i^{k_i}\)</span>
的倍数，故同余。</p>
<h3 id="原根">原根：</h3>
<h4 id="定义">定义：</h4>
<p>如果 <span class="math inline">\(x^1,x^2,x^3 \cdots
x^{\phi(n)}\)</span> 模 <span class="math inline">\(n\)</span>
意义下互不相同，且 <span
class="math inline">\(\gcd(x,n)=1\)</span>，则称 <span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(n\)</span> 的原根。</p>
<h4 id="性质">性质:</h4>
<p>质数 <span class="math inline">\(p\)</span> 的原根的方幂能取遍 <span
class="math inline">\([1,p-1]\)</span></p>
<h4 id="求质数的原根">求质数的原根</h4>
<p>数学大佬证明了一个数 <span class="math inline">\(n\)</span>
的最小正原根不超过 <span
class="math inline">\(n^{\frac{1}{4}+\epsilon}\)</span>，所以枚举每个数，检查所有
<span class="math inline">\(n\)</span> 的约数是否是 <span
class="math inline">\(a\)</span> 的阶，如果不是，那么 <span
class="math inline">\(a\)</span> 为一个原根，复杂度 <span
class="math inline">\(\sqrt n\)</span>，瓶颈在分解质因数。</p>
<h4 id="应用">应用</h4>
<p>开离散对数的时候上原根和换底公式有奇效。</p>
<h4 id="原根存在定理">原根存在定理</h4>
<p>一个数 <span class="math inline">\(x\)</span> 有原根当且仅当 <span
class="math inline">\(x= 2,4,p^n,2\times p^n\)</span>，其中 <span
class="math inline">\(p\)</span> 为奇素数。</p>
<p>证明不会。</p>
<h3 id="中国剩余定理">中国剩余定理</h3>
<p>咕咕咕</p>
<h3 id="平面图欧拉定理">平面图欧拉定理</h3>
<p>顶点数-边数-连通块数+区域数=1</p>
<h3 id="几何体欧拉定理">几何体欧拉定理</h3>
<p>顶点数-边数+面数=2</p>
<h3 id="除法下取整相关">除法下取整相关：</h3>
<ol type="1">
<li><span class="math inline">\(\lfloor\frac{a}{b}\rfloor\ge x\iff b\le
\lfloor\frac{a}{x}\rfloor\)</span>
<ul>
<li>含义：<span
class="math inline">\(b=\lfloor\frac{a}{x}\rfloor\)</span> 是满足 <span
class="math inline">\(\lfloor\frac{a}{b}\rfloor\ge x\)</span> 的最大的
<span class="math inline">\(b\)</span>。</li>
</ul></li>
<li><span class="math inline">\(\lfloor\frac{a}{b}\rfloor&lt; x \iff
b&gt;\lfloor\frac{a}{x}\rfloor\)</span>
<ul>
<li>上面那个反过来。</li>
</ul></li>
<li><span
class="math inline">\(\big\lfloor\dfrac{\lfloor\frac{n}{a}\rfloor}{b}\big\rfloor=\lfloor\dfrac{n}{ab}\rfloor\)</span>
<ul>
<li>设 <span class="math inline">\(n=kab+r,r&lt; ab\)</span>，则 <span
class="math inline">\(\lfloor\frac{n}{a}\rfloor&lt;(k+1)b\)</span>，自然有
<span
class="math inline">\(\big\lfloor\dfrac{\lfloor\frac{n}{a}\rfloor}{b}\big\rfloor\le
\lfloor\dfrac{n}{ab}\rfloor\)</span>。又因为 <span
class="math inline">\(\lfloor\frac{n}{a}\rfloor\ge kb\)</span>，因此
<span
class="math inline">\(\big\lfloor\dfrac{\lfloor\frac{n}{a}\rfloor}{b}\big\rfloor\ge
\lfloor\dfrac{n}{ab}\rfloor\)</span>，得证。</li>
</ul></li>
</ol>
<h3 id="余数相关">余数相关</h3>
<ol type="1">
<li>若 <span class="math inline">\(\gcd(x,y)=1,k\in[0,y)\)</span>，则
<span class="math inline">\(kx\pmod y\)</span> 互不相同。
<ul>
<li>证明反证法，移到同一边然后是倍数。</li>
</ul></li>
</ol>
<h3 id="解析几何相关">解析几何相关</h3>
<ol type="1">
<li><span class="math inline">\((x_0,y_0)\)</span> 关于 <span
class="math inline">\(y=x+m\)</span> 的对称点：<span
class="math inline">\((y_0 - m,x_0 + m)\)</span>。</li>
<li><span class="math inline">\((x_0,y_0)\)</span> 关于 <span
class="math inline">\(y=-x+m\)</span> 的对称点：<span
class="math inline">\((- y_0 + m,- x_0 + m)\)</span>。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/OI/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">数学算法汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 16:02:23" itemprop="dateCreated datePublished" datetime="2022-07-12T16:02:23+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:55:56" itemprop="dateModified" datetime="2025-02-16T17:55:56+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数学算法介绍">数学算法介绍</h1>
<p>主要介绍一些数学相关的算法。</p>
<h2 id="多项式">多项式</h2>
<ul>
<li>DFT:离散傅里叶变换，方式有两种， FFT 和 NTT。</li>
<li>IDFT:逆离散傅里叶变换。</li>
</ul>
<h3 id="fft-多项式乘法">FFT 多项式乘法</h3>
<p><del>最开始学这玩意的时候感觉非常迷，后面数学水平上去了其实也不难。</del></p>
<p>多项式有两种表示方法，一种是系数法，另一种是点值法，总所周知 <span
class="math inline">\(n\)</span> 个不同点唯一确定一个 <span
class="math inline">\(n-1\)</span> 次多项式。</p>
<p>原理：多项式的两个系数表达式相乘是 <span
class="math inline">\(O(n^2)\)</span> 的，但是其点值表达式相乘却是 <span
class="math inline">\(O(n)\)</span>
的，所以考虑将系数表达式转成点值表达式然后相乘。</p>
<p>事实上，点值表达式和系数表达式的互相转化，如果点值取特殊点，可以做到
<span class="math inline">\(O(n\log
n)\)</span>，即使是任意点，即多项式多点求值和多项式多点插值也可以做到
<span class="math inline">\(O(n \log^2n)\)</span></p>
<p>设最终多项式次数为 <span
class="math inline">\(n-1\)</span>，我们进行多项式乘法时选择的点值叫单位根，即
<span class="math inline">\(x^n=1\)</span> 在复数域上的所有根。</p>
<p>这玩意有一些性质，不过我们得先把次数变为 <span
class="math inline">\(n=2^k\)</span> 形式。</p>
<p>无法想象发明这个东西的人是怎么想到的，可能这就是被记在历史书上的人的水平。</p>
<p><em>以下内容如果将坐标系视为极坐标系会更好理解</em> $$ <span
class="math display">\[\begin{align}
W_n^i &amp;= -W_n^{i+\frac{n}{2}}\\
  
W_{\frac{n}{2}}^{i} &amp;= W_{n}^{2i}\\
\end{align}\]</span> $$ 考虑这样一个问题，对于一个多项式 <span
class="math inline">\(a_0+a_1x+a_2x^2 \cdots a_{n-1}x^{n-1}\)</span>
，我们需要同时求出它在 <span class="math inline">\(W_n^{0},W_n^{1}\cdots
W_n^{n-1}\)</span> 处的取值。发现由于第一个性质，貌似可以偷个懒，因为后
<span class="math inline">\(\frac{n}{2}\)</span> 个 <span
class="math inline">\(W_i\)</span> 就是前 <span
class="math inline">\(\frac{n}{2}\)</span> 个数的相反数。</p>
<p>相反数的性质，奇数次幂的符号要改变。考虑对系数按奇偶性分类，式子变成了这个样子。</p>
<p><span class="math inline">\((a_0+a_2x^2+\cdots
+a_{n-2}x^{n-2})+x(a_1+a_3x^2+\cdots + a_{n-1}x^{n-2})\)</span></p>
<p>然后考虑前后两个部分，都是一个多项式，需要对他们各自求 <span
class="math inline">\(x=W_\frac{2}{n}^0,W_\frac{2}{n}^1\cdots
W_\frac{2}{n}^{\frac{n}{2}-1}\)</span> 处的取值，本质上是求 <span
class="math inline">\(x^2=W_{\frac{2}{n}}^0,W_{\frac{2}{n}}^2\cdots
W_{\frac{2}{n}}^{n-2}\)</span>
处的取值，结合第二个性质，woc，就是两个子问题，解决之后就可以 <span
class="math inline">\(O(n)\)</span> 得到原问题的解，边界显然是 <span
class="math inline">\(n=1\)</span>。</p>
<p>复杂度 <span class="math inline">\(T(n)=2T(\frac{n}{2}) + O(n) =
O(n\log n)\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span> now,com *a,<span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	com a1[<span class="number">1</span>&lt;&lt;now],a2[<span class="number">1</span>&lt;&lt;now];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;now;i+=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a1[i/<span class="number">2</span>]=a[i];</span><br><span class="line">		a2[i/<span class="number">2</span>]=a[i<span class="number">+1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FFT</span>(now<span class="number">-1</span>,a1,op);</span><br><span class="line">	<span class="built_in">FFT</span>(now<span class="number">-1</span>,a2,op);</span><br><span class="line">	com w0=(com&#123;<span class="built_in">cos</span>(<span class="number">2.0</span>*Pi/(<span class="number">1</span>&lt;&lt;now)),op*<span class="built_in">sin</span>(<span class="number">2.0</span>*Pi/(<span class="number">1</span>&lt;&lt;now))&#125;),w=(com)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;now<span class="number">-1</span>;i++,w=w*w0)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=a1[i]+w*a2[i];</span><br><span class="line">		a[i+(<span class="number">1</span>&lt;&lt;(now<span class="number">-1</span>))]=a1[i]-w*a2[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果递归的话，常数会比较拉跨。因为递归必然需要复制数组重新弄成一个下标
<span class="math inline">\(1-n\)</span>
的问题，无论用什么办法解决，你的高速缓存都会表示意见很大，所以考虑迭代写法。</p>
<p>本质上递归是一层一层合并了两个数组，那么能不能直接模拟这个合并的过程呢，答案是可以的。</p>
<p>观察发现本质上是将下标二进制 <code>reverse</code>
之后逐层合并的，我们也这么做就行。</p>
<p>求 <code>reverse</code> 可以 <span
class="math inline">\(O(n)\)</span>，如下（如果你不了解运算顺序，请老老实实打括号）</p>
<p>这个原理很简单，不看最后一位，其它位先
<code>reverse</code>，然后处理一下最后一位就行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;lim;i++)res[i]=res[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>|(i&amp;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>-lim;</span><br></pre></td></tr></table></figure>
<p>下面是迭代写法代码，本质是模拟了递归合并的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(com a[],com b[],<span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;maxn;i++)</span><br><span class="line">    <span class="keyword">if</span>(r[i]&gt;i)<span class="built_in">swap</span>(a[r[i]],a[i]),<span class="built_in">swap</span>(b[r[i]],b[i]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1</span>&lt;&lt;maxn;j+=<span class="number">1</span>&lt;&lt;i)&#123;</span><br><span class="line">			com w0=(com)&#123;<span class="built_in">cos</span>(<span class="number">2.0</span>*Pi/(<span class="number">1</span>&lt;&lt;i)),op*<span class="built_in">sin</span>(<span class="number">2.0</span>*Pi/(<span class="number">1</span>&lt;&lt;i))&#125;,w=(com)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>;k++,w=w*w0)&#123;</span><br><span class="line">				com x=a[j+k],y=a[j+k+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]*w;</span><br><span class="line">				a[j+k]=x+y;</span><br><span class="line">				a[j+k+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]=x-y;</span><br><span class="line">                </span><br><span class="line">				x=b[j+k],y=b[j+k+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]*w;</span><br><span class="line">				b[j+k]=x+y;</span><br><span class="line">				b[j+k+(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>)]=x-y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞完了系数转点值，接下来是点值转系数。</p>
<p>前人告诉我们只需要将单位根改为 <span
class="math inline">\(W_n^{0},W_n^{-1}\cdots
W_n^{-n+1}\)</span>，再做一遍系数转点值的过程就可以得到系数，但是系数会变成原来的
<span class="math inline">\(n\)</span> 倍，除掉就行。</p>
<p>给出简要证明，<span class="math inline">\(i\)</span> 次项的系数为
<span class="math inline">\(a_i\)</span>，转一次点值</p>
<p>之后变为 <span class="math inline">\(b_i\)</span>，再做一次变成 <span
class="math inline">\(c_i\)</span> <span class="math display">\[
\begin{eqnarray}
c_x &amp;=&amp; \sum\limits_{i=0}^{n-1}b_iW_n^{-ix} \\
&amp;=&amp; \sum\limits_{i=0}^{n-1}
W_n^{-ix}\sum\limits_{j=0}^{n-1}a_jW_n^{ij}\\
&amp;=&amp; \sum\limits_{i=0}^{n-1}
\sum\limits_{j=0}^{n-1}a_jW_n^{i(j-x)}\\
\end{eqnarray}
\]</span> 对于 <span class="math inline">\(j=x\)</span>，贡献显然为
<span class="math inline">\(\sum\limits_{i=0}^{n-1}a_xW_n^{i\times0} =
na_x\)</span></p>
<p>对于 <span class="math inline">\(j\neq x\)</span> 贡献为 <span
class="math inline">\(a_j
\sum\limits_{i=0}^{n-1}(W_n^{j-x})^{i}\)</span></p>
<p>对这个式子的求和用等比数列求和公式有贡献为 <span
class="math inline">\(\dfrac{W_n^{n(j-x)}-1}{W_n^{j-x}-1}\)</span></p>
<p>显然分子为 <span class="math inline">\(0\)</span>，分母不为 <span
class="math inline">\(0\)</span>，所以贡献是 <span
class="math inline">\(0\)</span>，所以结果就是 <span
class="math inline">\(na_x\)</span></p>
<p>搞定。</p>
<h3 id="ntt-多项式乘法">NTT 多项式乘法</h3>
<p>FFT 多项式乘法是由缺陷的，由于浮点数精度和运算速度问题，FFT
可能并不能很好的解决一些问题，所以引入了 NTT，NTT
从有限整数域中找到了这样一组具有同样优秀性质的 <span
class="math inline">\(W_n\)</span>，即 <span
class="math inline">\(g\)</span>，也就是原根。</p>
<p>原根的内容可以参考数学证明总结中的介绍。</p>
<p><strong>注意，和 FFT 一样，NTT 也需要严格的按照 <span
class="math inline">\(2^k\)</span> 取次数，因为我们利用了 <span
class="math inline">\(W_n^{2i} = W_{\frac{n}{2}}^{i}\)</span>
这一重要性质</strong></p>
<p>所以能取出较大的 <span class="math inline">\(2^k\)</span>
作为阶的质数才可以作为 NTT 的模数，常见的 NTT 模数是 <span
class="math inline">\(998244353=2^{23}\times 7\times 17 +1\)</span>
，我们可以取它的原根 <span class="math inline">\(g=3\)</span>
作为基本单位根带入，实际上如果要找到一个应用于 <span
class="math inline">\(n\)</span> 的单位根 <span
class="math inline">\(W_n\)</span>，需要取 <span
class="math inline">\(W_n=g^{\frac{p-1}{n}}\)</span>。这样它就满足了我们在
FFT 证明中用到的一切性质。</p>
<p>然后照着 FFT 打一遍就行，只是基本运算这些换为模 <span
class="math inline">\(p\)</span> 意义下的运算就行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;s;i++)</span><br><span class="line">	<span class="keyword">if</span>(rk[i]&gt;i)<span class="built_in">swap</span>(a[rk[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=s;len++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> w=<span class="number">1</span>,wn=<span class="built_in">quick</span>(g,mod<span class="number">-1</span>&gt;&gt;len);</span><br><span class="line">		<span class="keyword">if</span>(type==<span class="number">-1</span>)wn=<span class="built_in">quick</span>(wn,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j+(<span class="number">1</span>&lt;&lt;len)&lt;=<span class="number">1</span>&lt;&lt;s;j+=<span class="number">1</span>&lt;&lt;len,w=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(k=j;k&lt;j+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>);k++,w=<span class="number">1ll</span>*w*wn%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[k],y=a[k+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>)];</span><br><span class="line">				a[k]=(x<span class="number">+1ll</span>*w*y%mod)%mod,a[k+(<span class="number">1</span>&lt;&lt;len<span class="number">-1</span>)]=(x<span class="number">-1ll</span>*w*y%mod)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它多项式乘法和一些优化">其它多项式乘法和一些优化</h3>
<h4 id="fft-三次变两次">FFT 三次变两次</h4>
<p>FFT 三次变两次，把 <span class="math inline">\(b\)</span> 扔到 <span
class="math inline">\(a\)</span> 的虚部去，变成了 <span
class="math inline">\(A(x) = (a_0+b_0i) + (a_1+b_1i)x+ \cdots +
(a_{n-1}+b_{n-1}i)x^{n-1}\)</span></p>
<p>然后求 <span
class="math inline">\(A^2(x)\)</span>，得到的系数表达式的虚部就是 <span
class="math inline">\(2ab\)</span>。</p>
<p>证明显然，会比 NTT 略快。</p>
<h4 id="任意模数-ntt">任意模数 NTT</h4>
<p>NTT
解决的是模意义下的乘法问题，当然，如果<strong>确保值域不超出模数</strong>，那么模意义下的结果就是正确结果。</p>
<p>如果模数不是 NTT 模数，就需要写任意模数 NTT。</p>
<p>实现方式有两种，其一是拆系数 FFT，其二是多模数 NTT 后用 CRT
合并。</p>
<h5 id="多模数-ntt">多模数 NTT</h5>
<p>一般选取 <code>998244353 1004535809 469726049</code> 作为 NTT
模数，它们的原根都是 <code>3</code>。分别进行 NTT
后，可以得到在模它们意义下的结果，用中国剩余定理合并，得到一个模约 <span
class="math inline">\(5\times 10^{26}\)</span>
的数的结果，一般来说任意的模数不会超过 <span
class="math inline">\(10^9\)</span>，所以乘起来的结果不超过 <span
class="math inline">\(10^{24}\)</span>，直接用合并的结果就行。</p>
<p>提一下实现细节。</p>
<p>一种方式是写个 Num 类，里面放三个 int，重写一下加减乘除，正常做。</p>
<p>另一种方式是写个 Poly 类，封装个乘法，用 for 做三次，都比较阳间。</p>
<p>用 CRT 时记得 __int128。或者用一个科技</p>
<p>一共三个方程，考虑这样合并。</p>
<p>其中 <span class="math inline">\(mod_1^{-1}\)</span> 表示 <span
class="math inline">\(mod_1\)</span> 在 <span
class="math inline">\(mod_2\)</span> 意义下的逆元。 <span
class="math display">\[
x = x_1 \pmod {mod1} \\
x = x_2 \pmod {mod2} \\
k_1 mod_1 + x_1 = x_2 \pmod{mod2}\\
x = (x_2-x_1)mod_1^{-1}mod_1 + x_1  \pmod {mod_2*mod_1}
\]</span></p>
<p>发现这样第二次合并的时候可以直接在模需要的模数 <span
class="math inline">\(p\)</span> 下进行计算。</p>
<p><strong>注意，务必考虑好取模的顺序，计算第二个时不能先对 p
取模，因为可能结果还需要先模上 <span
class="math inline">\(mod_1*mod_2*mod_3\)</span></strong>，</p>
<p>怎样避免 __int128 ?</p>
<p>把 <span class="math inline">\((x_2-x_1)mod_1^{-1}\)</span> 对 <span
class="math inline">\(mod_2\)</span>
取模即可，注意处理正负号，保证<strong>任意时刻</strong>结果在
[0,对应模数) 内。</p>
<h5 id="拆系数-fft">拆系数 FFT</h5>
<p>FFT 精度不高，一般来说 double 跑个 <span
class="math inline">\(10^{14}\)</span> 问题不大（最后除掉 <span
class="math inline">\(n\)</span>
以后的结果，也就是乘出来的多项式的系数，举个例子就是如果跑 <span
class="math inline">\(n=10^4\)</span>，那需要保证 <span
class="math inline">\(a_i,b_i\leq 10^5\)</span>），但是跑 <span
class="math inline">\(10^{24}\)</span> 次方， FFT 表示我做不到，用 long
double 也不行。</p>
<p>所以考虑拆系数，把每个数写成 <span
class="math inline">\(a_1\times2^{15} + a_2\)</span> 的形式。</p>
<p>然后乘法就变成了 <span
class="math inline">\(a_1b_1*2^{30}+(a_1b_2+a_2b_1)*2^{15}+a_2b_2\)</span>。</p>
<p>设新的四个多项式为 <span
class="math inline">\(A_1,A_2,B_1,B_2\)</span></p>
<p>一共 8 次 FFT，但可以优化，考虑复多项式 <span class="math display">\[
P=B_1+B_2i\\
T_1=P\times A_1 \\
T_2=P\times A_2
\]</span></p>
<p>发现需要的系数在 <span class="math inline">\(T_1,T_2\)</span>
的实部和虚部，对这俩做 IDFT，收工。</p>
<p>一共 5 次 DFT。</p>
<p>也可以这样:</p>
<p>先考虑 <span class="math display">\[
P=A_1+A_2i\\
P&#39;=A_1-A_2i\\
Q=B_1+B_2i
\]</span></p>
<p>再考虑： <span class="math display">\[
T_1=PQ=(A_1B_1-A_2B_2)+(A_1B_2+A_2B_1)i\\
T_2=P&#39;Q=(A_1B_1+A_2B_2)+(A_1B_2-A_2B_1)i
\]</span> 最后： <span class="math display">\[
T_1+T_2=2(A_1B_1+A_1B_2i)\\
T_1-T_2=-2(A_2B_2-A_2B_1i)
\]</span></p>
<p>弄出 <span class="math inline">\(T_1,T_2\)</span>
的系数表示法就行。其实复系数多项式乘法和普通系数多项式乘法没有什么区别。</p>
<p>这种 5 次的思路还有其它方式，不一一介绍了。</p>
<p>听说有种方法可以把两次实数域多项式的 DFT 和 IDFT
整成一次复数域的，但我觉得没啥必要会。</p>
<p>DFT 思路是构造一个多项式 <span
class="math inline">\(P=A+Bi\)</span>，对其做 DFT，然后线性求 <span
class="math inline">\(Q=A-Bi\)</span> 的 DFT 结果。</p>
<p>IDFT 思路不会。</p>
<p><strong>更推荐第一种写法，不会出现精度问题，如果效率不够再考虑改成第二种</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">huan-yp</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
