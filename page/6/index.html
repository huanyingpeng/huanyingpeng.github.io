<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"huanyp.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","display":"post","width_expanded":320,"width_dual_column":240,"padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="幻影彭的彩虹">
<meta property="og:url" content="https://huanyp.cn/page/6/index.html">
<meta property="og:site_name" content="幻影彭的彩虹">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="huan-yp">
<meta property="article:tag" content="算法竞赛, 自动化测试, 工程技术, Python">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://huanyp.cn/page/6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>幻影彭的彩虹</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">幻影彭的彩虹</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录青春的扇区</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="huan-yp"
      src="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
  <p class="site-author-name" itemprop="name">huan-yp</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/huan-yp" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huan-yp" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3051561876@qq.com" title="E-Mail → mailto:3051561876@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/1155409006?spm_id_from=333.1369.0.0" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;1155409006?spm_id_from&#x3D;333.1369.0.0" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/17/OI/%E6%AF%94%E8%B5%9B/CF1746/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/17/OI/%E6%AF%94%E8%B5%9B/CF1746/" class="post-title-link" itemprop="url">CF1746</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-17 09:11:23" itemprop="dateCreated datePublished" datetime="2022-10-17T09:11:23+08:00">2022-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:51:08" itemprop="dateModified" datetime="2025-02-16T17:51:08+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="abc">ABC</h2>
<p>没什么价值的题。</p>
<h2 id="d">D</h2>
<p>首先每次选路径一定会选到根。</p>
<p>要求儿子相差不超过 <span class="math inline">\(1\)</span>。</p>
<p>所以每个点被选的次数弄出来了，那么每个儿子只有两种选法，选 <span
class="math inline">\(\lceil\frac{cnt_u}{cson_u}\rceil,\lfloor\frac{cnt_u}{cson_u}\rfloor\)</span>。</p>
<p>根据经典结论，如果直接动态规划，状态数为 <span
class="math inline">\(O(n)\)</span>。</p>
<h2 id="e1">E1</h2>
<p>趣味题</p>
<p>考虑二分，发现不可二分，因为问 <span
class="math inline">\(S,\overline S\)</span>
是等价的，所以随便糊弄你就行。</p>
<p>所以考虑三分或者四分。</p>
<p>考虑解决 <span class="math inline">\(n=3\)</span> 的基本情况。</p>
<p>先确定问题再处理的方式看上去不太可取。</p>
<p>所以我们多半是需要根据回答来决定下一个问题。</p>
<p>这就是一颗决策树。</p>
<p>问一个时，<span class="math inline">\(Y\)</span> 的限制较强。</p>
<p>不妨先问 <span class="math inline">\(1\)</span>，如果是 <span
class="math inline">\(N\)</span>，那么再问一遍 <span
class="math inline">\(1\)</span> ，还是 <span
class="math inline">\(N\)</span> 则排除 <span
class="math inline">\(1\)</span>，如果是 <span
class="math inline">\(Y\)</span> 则回到最初的 <span
class="math inline">\(Case\)</span>，此时问 <span
class="math inline">\(2\)</span>，如果回答是 <span
class="math inline">\(Y\)</span> 则排除 <span
class="math inline">\(3\)</span>，<span class="math inline">\(N\)</span>
则排除 <span class="math inline">\(2\)</span>。</p>
<p>那么用了 <span class="math inline">\(3\)</span> 步将问题规模变为
<span class="math inline">\(\frac{2}{3}\)</span>。</p>
<p>总步数为 <span class="math inline">\(3\log_\frac{3}{2}(10^5) \approx
85\)</span>，取整之后问题不大。</p>
<h2 id="f">F</h2>
<p>让人眼前一亮的随机化思路。</p>
<p>首先可以带修莫队 <span
class="math inline">\(O(n^{\frac{5}{3}})\)</span>。但是过不了。</p>
<p>先考虑 <span class="math inline">\(k\)</span>
比较小的特殊情况，不妨就是 <span
class="math inline">\(k=2\)</span>。</p>
<p>左想右想，都没有办法比较好的合并信息，因为它没有办法写成经典的偏序计数问题。</p>
<p>没有办法这样合并，那就只能 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>所以我不会。</p>
<p>这是个判定问题，只需要回答 <code>YES NO</code>。</p>
<p>考虑条件，必要条件是比较好找的，显然每个数出现次数为 <span
class="math inline">\(k\)</span>
的倍数是必要条件，若干个必要条件加在一起就是充要条件。</p>
<p>考虑同时判定若干个必要条件，即某些数的出现次数是否为 <span
class="math inline">\(k\)</span>
的倍数，似乎不太可做，但是发现如果随机选取若干个数并判定，那么对于答案为
<code>NO</code> 的所有情况，通过判定的概率至多为<span
class="math inline">\(\frac{1}{2}\)</span>，所以随机对数个子集判定后对于通过的回答
<code>YES</code>，正确率足以接受。</p>
<p><strong>对于一个判定问题，如果有某种检测算法，答案为 <code>YES</code>
一定可以通过，答案为 <code>NO</code>
概率通过，那么运行这个算法对数次后，可以以很高的正确率回答该判定问题。</strong></p>
<p><strong>如果有一个判定问题，某随机算法能以超过 <span
class="math inline">\(50\%\)</span>
的概率给出正确的答案，那运行这个算法对数次取众数即可解决问题</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/17/OI/%E6%AF%94%E8%B5%9B/ARC151/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/17/OI/%E6%AF%94%E8%B5%9B/ARC151/" class="post-title-link" itemprop="url">ARC151</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-17 09:00:18" itemprop="dateCreated datePublished" datetime="2022-10-17T09:00:18+08:00">2022-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:50:55" itemprop="dateModified" datetime="2025-02-16T17:50:55+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="a">A</h2>
<p>胡乱想了一通，做出来了。</p>
<p>形如要求 <span class="math inline">\(f(x)=f(y)\)</span>
的问题，可以考虑 <span
class="math inline">\(f(x)-f(y)=D\)</span>，这样就可以考察 <span
class="math inline">\(x,y\)</span> 独立对 <span
class="math inline">\(D\)</span> 的贡献了。</p>
<p>字典序题，从前往后贪心。</p>
<h2 id="b">B</h2>
<p>字典序的题，一般的方式是考虑从前往后贪心，考虑前 <span
class="math inline">\(i\)</span>
个相等的情况，并查集维护一下前面要求相等的组数，然后就是简单的组合题。</p>
<p>另外一种特有的方式是考虑字典序小于，和字典序大于是等价的，总方案减掉字典序相等的方案除二即可。</p>
<h2 id="c">C</h2>
<p>SG 函数打表，没什么技术含量。</p>
<h2 id="d">D</h2>
<p>很有趣的题。</p>
<p>二进制位相关的题目，刻画一下变换的过程，等价为在图上走。</p>
<p>然后发现如果 <span class="math inline">\(X_i\)</span>
相等是好做的。</p>
<p>我就没啥思路了。</p>
<p>看一下题解。</p>
<p>考虑交换两个 <span class="math inline">\(X_i\)</span>
不同的，发现最终答案不变，因为图上走的过程是等价的，继续选上之前选的边就行。</p>
<p>然后就做完了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/15/OI/%E6%AF%94%E8%B5%9B/CF1736/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/15/OI/%E6%AF%94%E8%B5%9B/CF1736/" class="post-title-link" itemprop="url">CF1736总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-15 15:29:58" itemprop="dateCreated datePublished" datetime="2022-10-15T15:29:58+08:00">2022-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:51:06" itemprop="dateModified" datetime="2025-02-16T17:51:06+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="c">C</h2>
<p>这里的 C 指 C2。</p>
<p>首先来一波 <span class="math inline">\(\pm i\)</span>
变成相对简单的判 <span class="math inline">\(&gt; 0\)</span> 问题。</p>
<h3 id="method1">Method1</h3>
<p>考试的时候，比较自然的考虑计算跨过某个数的合法区间总数，发现可以把某个位置开头最远的区间给算出来。</p>
<p>然后就是个二维偏序。</p>
<p>然后对于新修改的元素，计算跨过它的合法区间个数，如果改小了，一定只会有一些数被这个东西限制，我选择做一个极度毒瘤的二维偏序。</p>
<p>如果改大了，一定只会有一些数在此处的限制被放开，再处理每个数放开一次限制后的最大位置即可，对于同一位置，可以处理单点前缀和，然后在上面
<code>lower_bound</code>。</p>
<p>显然两个都是可以在线做的，但是考试的时候没有发现被限制的数一定是一个区间，然后就出现了毒瘤。</p>
<p>不知道自己写的什么狗屎离线做法，奇丑无比。</p>
<h3 id="method2">Method2</h3>
<p>上面那个搞什么二维偏序是邪道。</p>
<p>还是考虑求跨过每个数的合法区间个数，某个位置 <span
class="math inline">\(x\)</span> 会限制另一个位置 <span
class="math inline">\(i\)</span>，当且仅当 <span
class="math inline">\(a_x+i\le
0\)</span>，所有一个位置限制的位置一定是一个前缀，这部分前缀的前缀会在这个位置之前被另外的位置限制，这是是可二分的。</p>
<p>所以改小的影响就好算了，找到被改小的数限制的区间，这一部分求总长度然后减去
<span class="math inline">\(cnt\times x\)</span> 得到答案减小值。</p>
<p>改大会比较麻烦，参考上面的处理方式。</p>
<h3 id="conclusion">Conclusion</h3>
<p><strong>多找点性质，又不妨碍做题。</strong></p>
<p><strong>多学着点二分，别去搞什么垃圾数据结构二维偏序。</strong></p>
<h2 id="d">D</h2>
<p>比较清新的构造题，难度不大，但是场上没想出来。</p>
<p>先假设没有操作，尝试求解该问题，发现它比较困难（似乎不存在多项式做法），所以应该考虑能不能构造出特殊情况。</p>
<p>考场上我看成了 <code>reverse</code>，这也是可做的，只需要构造出形如
<code>0000011111</code> 的串就行，方法是选上末尾的，插在 <code>1</code>
之间的 <code>0</code>，然后和前面的 <code>1</code> 交换，设
<code>1</code> 的个数为 <span
class="math inline">\(cnt_1\)</span>，那么选择后面 <span
class="math inline">\(cnt_1\)</span> 个位置中所有的
<code>0</code>，再选出前面所有的 <code>1</code>，交换即可。</p>
<p>实际上是循环左移，同样考虑构造特殊情况，这次选择构造
<code>001100111100</code> 这种。</p>
<p>如果不是，就选一个，找到下一个同样不满足的，然后移过来，最后一定有偶数个不满足的，用不同的数隔开就行。</p>
<p><strong>本质上，这个操作相当于选了偶数个相邻数不同的数，把它们
flip。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/12/OI/%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/12/OI/%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/" class="post-title-link" itemprop="url">关于平衡树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-12 20:54:04" itemprop="dateCreated datePublished" datetime="2022-10-12T20:54:04+08:00">2022-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:55:07" itemprop="dateModified" datetime="2025-02-16T17:55:07+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="平衡树">平衡树</h1>
<p>既然标题敢写平衡树，那就需要来谈谈平衡树本身，而不仅仅是实现它的方法。</p>
<h2 id="平衡树本身">平衡树本身</h2>
<p>平衡树是一颗二叉搜索树，每个节点<strong>权值</strong>大于左子树所有节点，小于右子树所有节点。</p>
<p>和线段树相比，它是一种动态结构，适合维护结构动态变化的信息，比如需要支持插入和删除以及翻转的序列，也可以用来维护一棵树（LCT）</p>
<p>和块状链表相比，它只能处理能够快速合并的信息，但是复杂度有所降低。</p>
<h2 id="实现">实现</h2>
<h3 id="splay">Splay</h3>
<p>已经很熟悉的方式，不再多说，不过可以多嘴提一句势能分析。</p>
<h3 id="势能分析原理">势能分析原理</h3>
<p>定义势能函数 <span class="math inline">\(F(S)\)</span> 表示状态 <span
class="math inline">\(S\)</span> 的势能，定义操作代价 <span
class="math inline">\(p_i=c_i+F(S&#39;)-F(S)\)</span>，其中 <span
class="math inline">\(c_i\)</span> 表示操作时间。</p>
<p>求解 <span class="math inline">\(\sum p_i=\sum c_i +
F(S_m)-F(S_0)\)</span></p>
<p>移项得到 <span class="math inline">\(\sum c_i=\sum
p_i+F(S_0)-F(S_m)\)</span></p>
<p>一般来说，<span class="math inline">\(c_i\)</span>
会比较奇怪，但是通过 <span class="math inline">\(F\)</span>
函数的变化值可以去抵消掉这个奇怪的值得到优雅的 <span
class="math inline">\(p_i\)</span>，然后一般来说最后的复杂度和 <span
class="math inline">\(\sum p_i,F(S)\)</span> 同阶</p>
<h3 id="分析-splay-的复杂度和单旋的复杂度">分析 Splay
的复杂度和单旋的复杂度</h3>
<p>定义势能函数，定义单点势能 <span
class="math inline">\(w(u)=\log_2(size_u)\)</span>， <span
class="math inline">\(F(S)=\sum\limits_{u\in S} w(u)=O(n\log
n)\)</span>。</p>
<p>旋转点为 <span class="math inline">\(x\)</span>，父亲为 <span
class="math inline">\(f\)</span>，祖父为 <span
class="math inline">\(g\)</span>。</p>
<h4 id="左旋代价">左旋代价</h4>
<p>注意到 <span
class="math inline">\(size_{x&#39;}=size_{fa}\)</span>。</p>
<p><span class="math inline">\(1+w(x&#39;)+w(fa&#39;)-w(x)-w(fa)\le
1+w(fa)-w(x)\le 1+w(x&#39;)-w(x)\)</span></p>
<h4 id="双左旋代价">双左旋代价</h4>
<p><span
class="math inline">\(1+w(x&#39;)+w(f&#39;)+w(g&#39;)-w(x)-w(f)-w(g)\le
1+w(f&#39;)+w(g&#39;)-w(x)-w(f)\)</span></p>
<p><span class="math inline">\(w(f)\ge w(x),w(f&#39;)\le
w(x&#39;)\)</span></p>
<p><span class="math inline">\(w(x&#39;)-w(x)\ge
w(f&#39;)-w(f)\)</span></p>
<p><span class="math inline">\(1+w(f&#39;)+w(g&#39;)-w(x)-w(f) \le 1+
w(x&#39;)+w(g&#39;)-2w(x)\)</span></p>
<p>若 <span class="math inline">\(w(x&#39;)-w(x) \ge 1\)</span></p>
<p>则 $ 1+ w(x')+w(g')-2w(x)(w(x')-w(x))$</p>
<p>否则因为先旋的 <span class="math inline">\(f\)</span>，所以 <span
class="math inline">\(g&#39;\)</span> 下的点不包括 <span
class="math inline">\(x\)</span> 中的点，所以有 <span
class="math inline">\(size_x\ge size_{g&#39;}\)</span>，因此 <span
class="math inline">\(w(x&#39;)-w(g&#39;) \ge1\)</span></p>
<p>得到 <span class="math inline">\(1+ w(x&#39;)+w(g&#39;)-2w(x)\le
2(w(x&#39;)-w(x))\)</span></p>
<p>综上 <span
class="math inline">\(1+w(x&#39;)+w(f&#39;)+w(g&#39;)-w(x)-w(f)-w(g)\le
3(w(x&#39;)-w(x))\)</span></p>
<h4 id="左右旋代价">左右旋代价</h4>
<p><span class="math inline">\(1+w(x&#39;)+w(f&#39;)+w(g&#39;)\le
1+w(f&#39;)+w(g&#39;)-w(x)-w(f)\le
1+w(f&#39;)+w(g&#39;)-2w(x)\)</span></p>
<p>由于最终 <span class="math inline">\(f&#39;,g&#39;\)</span> 都是
<span class="math inline">\(x&#39;\)</span> 的儿子，所以 <span
class="math inline">\(1+w(f&#39;)+w(g&#39;)-2w(x)\le2w(x&#39;)-2w(x)\)</span></p>
<p>所以 <span class="math inline">\(1+w(x&#39;)+w(f&#39;)+w(g&#39;)\le
2w(x&#39;)-2w(x)\)</span></p>
<h4 id="双旋代价">双旋代价</h4>
<p>注意到只会进行一次 zig 操作，所以可以忽视 zig 的那个
1，其余代价直接相加，得到 <span class="math inline">\(3\)</span>，因此
<span class="math inline">\(p_i=O(\log n)\)</span>。</p>
<p>观察到一次 Splay 操作的每个子操作可以弄成 <span
class="math inline">\(3\)</span> ，然后相加抵消掉得到 <span
class="math inline">\(3+3w(x&#39;)-3w(x)\)</span>，是 <span
class="math inline">\(O(n\log n)\)</span> 级别，势能变化量为 <span
class="math inline">\(O(n\log n)\)</span> 级别，故时间为 <span
class="math inline">\(O(n\log n)\)</span> 级别。</p>
<h4 id="单旋代价">单旋代价</h4>
<p>单旋代价为左旋代价的和，每次 <code>Splay</code> 操作数为 <span
class="math inline">\(O(n)\)</span>，故单旋的复杂度上界是 <span
class="math inline">\(O(n^2)\)</span></p>
<h4 id="总结">总结</h4>
<p>以上势能分析对 Splay 操作的要求是非常严格的，因此如果在查询中没有进行
Splay
操作，那么操作时间无法导致对应的势能变化，最后出现不正确的复杂度。</p>
<h3 id="treap">Treap</h3>
<p>数据随机的情况下，一个堆（每个节点的权值均大于它全部后代的权值）的期望高度是
<span class="math inline">\(\log n\)</span>
的，通过左右旋保证堆的性质，可以保证 Treap 的复杂度，左旋右旋和 Splay
完全相同。</p>
<h3 id="fhq_treap">FHQ_Treap</h3>
<p>元素 <code>val</code>：需要维护的值。</p>
<p>权值 <code>height</code>：随机的，用于保持堆性质的值。</p>
<p>核心操作是 <code>Merge</code> 和 <code>Split</code>。</p>
<p><strong>过程中需要时刻保证满足堆的性质</strong></p>
<h4 id="mergeuv">merge(u,v)</h4>
<p>合并两个子树 <code>u,v</code> ，保证 <code>u</code> 中元素全部小于
<code>v</code>，返回根。</p>
<p>和线段树合并非常像。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u||!v)<span class="keyword">return</span> u^v;</span><br><span class="line">    <span class="keyword">if</span>(height[u]&gt;height[v])&#123;</span><br><span class="line">        son[u][<span class="number">1</span>]=<span class="built_in">merge</span>(son[u][<span class="number">1</span>],v);</span><br><span class="line">        <span class="built_in">push_up</span>(u);<span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        son[v][<span class="number">0</span>]=<span class="built_in">merge</span>(u,son[v][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">push_up</span>(v);<span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="splituxyk">Split(u,x,y,k)</h4>
<p>按照元素值小于等于 <span class="math inline">\(k\)</span>
划分为两颗树，较小的那棵树树根为 <span
class="math inline">\(x\)</span>，较大的那个树根为 <span
class="math inline">\(y\)</span>。</p>
<p>细看这个函数其实相当妙。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==<span class="number">0</span>)&#123;</span><br><span class="line">    	x=y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;=k)&#123;</span><br><span class="line">        x=u;</span><br><span class="line">        <span class="built_in">split</span>(son[u][<span class="number">1</span>],son[u][<span class="number">1</span>],y,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		y=u;</span><br><span class="line">        <span class="built_in">split</span>(son[u][<span class="number">0</span>],x,son[u][<span class="number">0</span>],k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也可以按照子树大小划分，用于文艺平衡树。</p>
<h4 id="其它操作">其它操作</h4>
<ul>
<li>get_l(element)：按照小于 <code>element</code>
划分，然后返回较小那边的大小，重新 merge</li>
<li>get_element(rank)：与 <code>splay</code> 没有差异。</li>
<li>insert(element)：按照小于等于它划分，然后 merge 两遍。</li>
<li>erase(element)：按照小于等于它划分，然后按小于它划分，然后把划分得到的两个儿子
<code>Merge</code> 起来再 merge，然后再
merge，<strong>这样是能够处理元素相同节点的</strong>。</li>
<li>get_prev(element)：按照小于它划分，用 get_element()</li>
<li>get_next(element)：按照小于等于它划分，用 get_element()</li>
<li>合并的时候也可以按概率选择父亲，<span
class="math inline">\(sz\)</span> 较大的权重较大，期望复杂度可以证明是
<span class="math inline">\(O(n\log n)\)</span> 的。</li>
</ul>
<h4 id="某些实验">某些实验</h4>
<p>采用佳老师的神奇插入删除方式：</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202210132101632.png"
alt="image-20221013210116511" />
<figcaption aria-hidden="true">image-20221013210116511</figcaption>
</figure>
<p>可以发现正常的插入方式需要 <span
class="math inline">\(14S\)</span>，<span
class="math inline">\(18S\)</span>
是按子树大小概率合并，加上佳老师优化后变为 <span
class="math inline">\(10S\)</span>，有一定改进。</p>
<p>如果直接实现 get_rank 系列函数可以更快，但是没什么必要了。</p>
<p>手写 get_rank 系列后耗时为 <span
class="math inline">\(9S\)</span>，手写 get_rank
系列，采用正常插入方式，用时 <span
class="math inline">\(12S\)</span>。</p>
<p>全实现的 Splay 需要 11S。</p>
<h3 id="vector">vector</h3>
<p>一般来说，如果数据范围 <span class="math inline">\(\le 5\times
10^4\)</span>，或者时限比较宽松，可以用 <code>vector</code>
实现平衡树。</p>
<h3 id="pb_ds">pb_ds</h3>
<p>自带平衡树，一般用于操作比较简单的情况，如果需要打 Tag 之类的，重写
<code>node_update</code> 不如手写一颗。</p>
<h2 id="可持久化平衡树">可持久化平衡树</h2>
<p>可持久化平衡树一般用于解决强制在线的历史版本问题，对于非强制在线问题，其实可以离线到树上实现一个支持撤销的平衡树。</p>
<p>对于强制在线问题，基本思路都是复制修改过的路径，复用没有修改过的路径。</p>
<p>可以发现其实任何一个版本创建之后就是静态的，所以可持久化数据结构的核心是：<strong>任何时刻访问先前的版本，都能得到正确的结果，任何修改不能影响到先前的版本。</strong></p>
<h3 id="splay-实现">Splay 实现</h3>
<p>其它操作不变，Splay
时复制<strong>涉及</strong>的所有点作为一个新版本。</p>
<p>但是，这玩意的复杂度有问题，<strong>Splay</strong>
的复杂度保证在于对操作进行势能分析，引入可持久化后，势能的变化量会变成
<span class="math inline">\(n^2\log n\)</span> ,因此复杂度会退化。</p>
<p>由于实际应用中，很少存在只能用 Splay 的情况，因此没有必要深究 Splay
的可持久化。</p>
<h3 id="fhq-treap-实现">FHQ-Treap 实现</h3>
<p><strong>听说这种实现有点问题，但是实际中并没有出现过问题，如果觉得不太行可以换下面那种奇怪的实现。</strong></p>
<h4 id="split">Split</h4>
<p>由于操作都是从 <code>Split</code> 开始的，所以每次 <code>Split</code>
前都复制一个版本出来，具体的，像可持久化线段树一样把不变的儿子共用，改变的儿子复制。</p>
<p>Split
的路径上所有点的信息都被改变了，需要复制一遍得到新的，这样原先版本的所有节点不会有任何变化。</p>
<p>大致刻画以下 Split 中被修改的点，它呈一条链</p>
<h4 id="merge">Merge</h4>
<p>Merge
过程中的复制不是必须的，原因是每个被修改的点都是被新建出来的点，这个证明可以考虑归纳，合并深度为
<span class="math inline">\(1\)</span>
的节点时，两点显然都是被复制的，不影响原树，合并任何被复制的两个节点时，较小的那个的右儿子，较大的那个的左儿子要么不存在，要么是被复制的，因为在被复制的节点处，链一定会向下延申。</p>
<p>因此合并时可以不用新建节点。</p>
<h4 id="神奇方法">神奇方法</h4>
<p>佳老师有一个神奇写法，理论常数为 <span
class="math inline">\(\frac{1}{2}\)</span>，具体的，插入和删除时先找到第一个
<code>key</code> 小于当前点 <code>key</code>
的点，然后这个点一定是被插入/删除点的儿子，然后把只对这个儿子做一遍
Split，并把树分到插入点的两个儿子上面去，这个思路同样可以用于一般
FHQ-Treap，运用在普通平衡树中，实际效率改进因子在 <span
class="math inline">\(0.33\)</span> 左右。</p>
<p>一般来说删除就正常搞，不然容易写错。</p>
<p><strong>考试的时候如果不卡常就写正常写法，减少可能的错误。</strong></p>
<p><strong>一般来说，空间得开 50 倍。</strong></p>
<p>注：效率改进因子，若效率改进因子为 <span
class="math inline">\(x\)</span>，原时间 <span
class="math inline">\(t\)</span>，则改进后时间为 <span
class="math inline">\(\frac{t}{1+x}\)</span>。</p>
<h3 id="treap-实现">Treap 实现</h3>
<p>由于期望树高是 <span class="math inline">\(\log n\)</span>
的，所以直接复制所有已经被修改的点的信息</p>
<h3 id="某种奇怪的实现">某种奇怪的实现</h3>
<p>类似 FHQ-Treap，但是 Merge
的时候按照子树大小作为权重，随机选一个做父亲，这样的复杂度是有保证的。</p>
<h2 id="文艺平衡树">文艺平衡树</h2>
<p>文艺平衡树是一类用于维护区间的平衡树，它和正常的平衡树类似，但是用树的结构来决定一个元素的大小，适合用来维护结构动态变化的序列。</p>
<p>一般用 Splay 和 FHQ-Treap 实现。</p>
<p>FHQ-Treap 实现时需要支持按 <code>size</code> 划分。</p>
<h2 id="动态树">动态树</h2>
<p>一般用 Splay 实现，复杂度 <span class="math inline">\(O(n\log
n)\)</span>，进行实链剖分，每条实链被一颗 Splay
维护，思想和文艺平衡树类似，用平衡树树的结构表明了原树节点中的的高度关系。</p>
<p>核心操作是 <code>access</code> 和 <code>make_root</code>。</p>
<h3 id="accessx">access(x)</h3>
<p>使得 <span class="math inline">\(x\)</span>
到树根上的路径成为一条实链，断开 <span class="math inline">\(x\)</span>
和它实儿子的连接，并让 <span class="math inline">\(x\)</span> 成为该
Splay 的根。</p>
<h3 id="make_rootx">make_root(x)</h3>
<p>使得 <span class="math inline">\(x\)</span> 成为树根，操作方式是先
<code>accsess</code>，然后翻转这条实链，使得 <span
class="math inline">\(x\)</span> 的深度最小。</p>
<p>由于虚儿子认父不认子，所以整个结构都没有问题。</p>
<h3 id="实现-1">实现</h3>
<p>一般采用 Splay，FHQ-Treap 也没有问题。</p>
<p>但是不能用一般 Treap，因为一般 Treap
对树结构的要求决定了它无法进行旋转操作。</p>
<p>FHQ-Treap 的复杂度很难证明是 <span class="math inline">\(n\log
n\)</span>，但是可以保证上界为 <span class="math inline">\(O(n\log
n^2)\)</span>，Splay 的复杂度则为 <span class="math inline">\(O(n\log
n)\)</span></p>
<p>似乎有 <span class="math inline">\(O(n\log n)\)</span> 的 FHQ-Treap
实现。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/12/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1012%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/12/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1012%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">20221012考试总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-12 20:43:39" itemprop="dateCreated datePublished" datetime="2022-10-12T20:43:39+08:00">2022-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:22:11" itemprop="dateModified" datetime="2025-02-16T20:22:11+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="考试总结">考试总结</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0132">考试</a></p>
<p>发挥一般</p>
<h3 id="t1">T1</h3>
<p>很趣味的题，考虑计算答案的过程，首先从某个点开始，遇到</p>
<h3 id="t2">T2</h3>
<p>平衡树模板，不做评价，权当练习使用 <code>pb_ds</code>。</p>
<p>其实有平衡树之外的多种解法。</p>
<h4 id="值域分块">值域分块</h4>
<p>对这个东西其实一直不熟悉，如果序列分块不容易解决或者复杂度多一个
<span
class="math inline">\(\log\)</span>，那么考虑对值域分块，记录和每块数值有关的信息。</p>
<p><span class="math inline">\(O(1)\)</span>
改可以只改对应数值块和自身的数据，<span
class="math inline">\(O(1)\)</span>
查可以对块和块内维护前缀信息或者其它预处理信息。</p>
<h4 id="树状数组上二分">树状数组上二分</h4>
<p>写过若干次，但不熟练。</p>
<p>以前缀和树状数组为例，它每个节点 <span
class="math inline">\(x\)</span> 维护的信息是 <span
class="math inline">\((x-lowbit(x),x]\)</span> 区间的全部信息。</p>
<p>更新时一直 +lowbit，保证了恰好能够维护这些信息。</p>
<p>所以如何二分也比较明晰了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> now=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="comment">// 现在认为在 (now,now+1&lt;&lt;i+1]</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>&lt;&lt;i|now&lt;=n&amp;&amp;sum+c[now|<span class="number">1</span>&lt;&lt;i]&lt;k)&#123;<span class="comment">//在 (now|1&lt;&lt;i,now|1&lt;&lt;i+1]</span></span><br><span class="line">        now |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        sum += c[now];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = now + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="t3">T3</h3>
<p>有些价值的题，"优化状压DP" 还是有一些话题可谈。</p>
<h3 id="t4">T4</h3>
<p>李超树模板题，类似 <code>CDQ</code>
分治的思路或者平衡树维护凸包其实很趣味，但是没有什么启发意义。</p>
<p>等有时间了写一份斜率优化的总结。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/12/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1011%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/12/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1011%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">20221011考试总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-12 20:43:33" itemprop="dateCreated datePublished" datetime="2022-10-12T20:43:33+08:00">2022-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:22:06" itemprop="dateModified" datetime="2025-02-16T20:22:06+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="考试总结">20221011 考试总结</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0131">考试</a></p>
<h3 id="t1">T1</h3>
<p>假的可持久化题，弄到树上做撤销就行。</p>
<p>其实写可持久化 FHQ-Treap 更容易</p>
<p>参考 <a href="">关于平衡树</a></p>
<p>还可以用块状链表搞定。</p>
<h3 id="t2">T2</h3>
<p>树套树模板题，但是有一些不同的思考方式。</p>
<p>我采用了线段树套值域线段树，但是需要同时二分多个主席树，不够优雅。</p>
<h4 id="值域树套位置树">值域树套位置树</h4>
<p>一般来说，位置树套值域树更加常见，但如果有些涉及到二分的操作，也许把它们反过来会更加容易，因为反过来之后就可以在数据结构上二分，减少一个
<span class="math inline">\(\log\)</span>。</p>
<p>其实位置树套值域树也可以在数据结构上二分，只是实现起来相对麻烦一些。</p>
<p>可以采用值域线段树套平衡树。</p>
<p>这个时候 FHQ-Treap 的优势就体现出来了，很简单的可以查到 <span
class="math inline">\([l,r]\)</span> 区间内数的个数。</p>
<h4 id="莫队和值域分块">莫队和值域分块</h4>
<p>带修莫队可以处理单点改区间查的问题，修改一共 <span
class="math inline">\(O(n^{\frac{5}{3}})\)</span> 次，查询 <span
class="math inline">\(O(n)\)</span> 次，使用 <span
class="math inline">\(O(\sqrt n)-O(1)\)</span>
的值域分块即可处理问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/10/OI/%E7%AE%97%E6%B3%95/%E4%B8%80%E7%B1%BB%E6%9C%9F%E6%9C%9B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/10/OI/%E7%AE%97%E6%B3%95/%E4%B8%80%E7%B1%BB%E6%9C%9F%E6%9C%9B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">ARC150D-一类期望问题的思考方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-10 21:08:17" itemprop="dateCreated datePublished" datetime="2022-10-10T21:08:17+08:00">2022-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:56:07" itemprop="dateModified" datetime="2025-02-16T17:56:07+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="题意">题意</h2>
<ul>
<li><p>给你一棵有根树，定义一个点合法当且仅当它到根上的点全为黑色，否则不合法。</p></li>
<li><p>最开始所有点为白色，每次选一个不合法的点涂黑，每个点可以被涂黑多次。</p></li>
<li><p>问所有点被涂黑的期望次数</p></li>
</ul>
<h2 id="思考1">思考1</h2>
<p>这次想题引爆了某人概率论基础不扎实的炸弹。</p>
<p>考虑每个点被涂黑的顺序，是一个排列，取到每种排列的概率相同。</p>
<p>考虑使用全期望公式计算，先考虑固定一个排列时的答案。</p>
<p>先假设只有 <span class="math inline">\(3\)</span> 个点，且顺序为
<span class="math inline">\(3,2,1\)</span>，也就是赠券收集问题。</p>
<p>选第一个点的期望次数为 <span
class="math inline">\(1\)</span>，因为所有满足这个排列的样本点都是以
<span class="math inline">\(3\)</span>
开头，选第二个点，期望次数是多少，或者说，选出第一个点后，下一个被选择的点，在顺序为
<span class="math inline">\(3,2,1\)</span> 的前提下，是 <span
class="math inline">\(2\)</span> 的概率是多少？</p>
<h3 id="frac12-的来历"><span class="math inline">\(\frac{1}{2}\)</span>
的来历</h3>
<p>选第二个点时，可以选的点有 <span
class="math inline">\(3,2\)</span>，选择每个点的概率相同，所以概率为
<span class="math inline">\(\frac{1}{2}\)</span></p>
<p><strong>虽然原本每个点概率时相同的，但是我们求的时条件概率，条件概率的样本空间已经被改变了，所以选择每个点的概率不再相同。</strong></p>
<h3 id="frac23-的来历"><span class="math inline">\(\frac{2}{3}\)</span>
的来历</h3>
<p>考虑概率的定义，<span
class="math inline">\(P=\frac{事件大小}{样本空间大小}\)</span>，考虑该条件的集合和事件与条件的交集，因为此题样本空间无限大，所以考虑将一个无限长序列映射到我们的样本空间，容易发现这样的映射不会改变概率函数。</p>
<p>设 <span class="math inline">\(k\)</span> 为已经选取的数的个数，<span
class="math inline">\(n\)</span> 为数的总数。 $$ <span
class="math display">\[\begin{align}

P=&amp;\lim\limits_{m\rightarrow
\infty}\dfrac{n^{m-1}}{\sum\limits_{1\le i\le m} k^{i-1}\times
n^{m-i}}\\
=&amp;\dfrac{n^{m-1}}{\frac{n^{m}}{n-k}}\\
=&amp;\frac{n-k}{n}
\end{align}\]</span> $$ 这是在正确的样本空间算出的正确结果。</p>
<p>从 Beyes 公式考虑： <span class="math display">\[
\begin{align}
P(下一个值为目标|满足排列限制)=&amp;\dfrac{P(下一个值为目标\wedge满足排列限制)}{P(满足排列限制)}\\
=&amp;\dfrac{\frac{1}{n}\times\frac{1}{(n-k-1)!}}{\frac{1}{(n-k)!}}\\
=&amp;\dfrac{n-k}{n}
\end{align}
\]</span> 神奇吧？</p>
<p><strong>贝叶斯公式连接了条件概率和原问题的样本空间。</strong></p>
<h3 id="总结">总结</h3>
<p><strong>样本空间无限大的时候要小心，不能轻易认为两个元素等价，因为此时
<span class="math inline">\(\infty \ne \infty\)</span></strong>。</p>
<p>用贝叶斯公式好好算算吧。</p>
<p>草率的断言概率为 <span
class="math inline">\(\frac{1}{2}\)</span>，很大一部分原因都是认为两个正无穷时相等的。</p>
<p>有了这个东西就可以愉快的推狮子 NTT 了。</p>
<h2 id="思考2">思考2</h2>
<p>其实这种题还有一种更加普遍的做法，期望线性性，考虑每个点被选的次数，相加可以得到最终答案。</p>
<p>期望线性性来源于期望的定义，一个随机变量是一个函数，定义域为样本空间，值域为
<span
class="math inline">\(\R\)</span>，随机变量的期望为其密度函数积分的收敛值。</p>
<p>因此，无论两个随机变量是否独立，它们的期望都是可加的。</p>
<p>感性理解的话，两个随机变量之和的期望等于这样一个随机变量的期望：每个样本点的取值为两个随机变量在该样本点的取值之和，期望可以粗略理解为随机变量在样本空间每个点的平均值，因此随机变量的期望可加。</p>
<p>所以可以考虑每个点被选的期望次数，如果选到了不在这个点到根路径上的点，那么我们忽略这一次选择，这样的忽略不会影响这个点被选的期望次数，然后问题变成了一条链上的最后一个点被选择的期望次数。</p>
<p><strong>注意，我们只关心这个点被选择的期望次数。</strong></p>
<p>考虑怎么求这玩意，因为整个过程在点到根路径上所有点被选择之后才会结束，所以像赠券收集问题一样倒序。假设有
<span class="math inline">\(k\)</span> 个点还没选，总共 <span
class="math inline">\(n\)</span> 个点，其中 <span
class="math inline">\(w\)</span> 个点可以选，那么转移答案是 <span
class="math inline">\(dp[k]=\frac{k}{w}dp[k+1]+\frac{w-k}{w}dp[k]+\frac{1}{w}\)</span></p>
<p>移项得到 <span
class="math inline">\(dp[k]=dp[k+1]+\frac{1}{k}\)</span>，实际上和 <span
class="math inline">\(w\)</span> 无关，所以就很好算了。</p>
<p>官方题解的说法是如果考虑可以选已经 <code>good</code>
的点，最终答案不变，我理解不了这个过程。</p>
<p>upd：其实现在也可以理解了，因为如果选了已经 good
的点，那么再选一次就行了。</p>
<p><strong>有几个比较重要的地方，一是忽略和答案绝对无关的操作，二是考虑计算过程。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/10/OI/%E7%AE%97%E6%B3%95/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B-%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%8F%98%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/10/OI/%E7%AE%97%E6%B3%95/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B-%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%8F%98%E5%BD%A2/" class="post-title-link" itemprop="url">概率期望--三门问题及其变形</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-10 11:47:36" itemprop="dateCreated datePublished" datetime="2022-10-10T11:47:36+08:00">2022-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:54:55" itemprop="dateModified" datetime="2025-02-16T17:54:55+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="事件和条件">事件和条件</h2>
<p>以下概率均为古典概率模型，暂时不讨论几何概型。</p>
<p>这两个东西是我自己定义的，算概率之前，必须搞清楚事件和条件的区别，下面提两个搞不清楚事件和条件导致的问题。</p>
<h3 id="三门问题">三门问题</h3>
<ul>
<li><p>有三个门，一个门后面有汽车，另外两个门后面是山羊。</p></li>
<li><p>你可以先选择一个门，之后主持人打开一个门，门后是山羊</p></li>
<li><p>问此时两个门后有汽车的概率是多少</p></li>
</ul>
<h4 id="思考方式一错误">思考方式一（错误）</h4>
<p>每个门后有山羊的概率是相等的，打开一个门不会影响另外两个门的状态，故另外两个门后有山羊的概率是相等的，故答案为
<span class="math inline">\(50\%\)</span></p>
<h4 id="思考方式二不严谨">思考方式二（不严谨）</h4>
<p>另外两个门有山羊的概率是 <span
class="math inline">\(\frac{2}{3}\)</span>，排除一个选项，所以选择的门后有山羊的概率是
<span class="math inline">\(\frac{1}{3}\)</span>，另一个门的概率为 <span
class="math inline">\(\frac{2}{3}\)</span>。</p>
<h3 id="不知道叫什么名字的问题">不知道叫什么名字的问题</h3>
<p>有个酒鬼，每天各有 <span class="math inline">\(30\%\)</span> 的概率去
<span class="math inline">\(A,B,C\)</span> 三个酒吧，还有 <span
class="math inline">\(10\%\)</span> 的概率呆在家。</p>
<p>一个警察要找他，警察已经找了 <span class="math inline">\(A,B\)</span>
酒吧，都没找到他，问在 <span class="math inline">\(C\)</span>
酒吧找到酒鬼的概率。</p>
<h4 id="思考方式一错误-1">思考方式一（错误）</h4>
<p>在酒吧的概率是 <span class="math inline">\(90\%\)</span>，<span
class="math inline">\(A,B\)</span> 都没找到，说明一定在 <span
class="math inline">\(C\)</span>，所以在 <span
class="math inline">\(C\)</span> 找到酒鬼的概率是 <span
class="math inline">\(90\%\)</span>。</p>
<p>这个思路和上一个问题思考方式二类似，但是是错误的，因此说它不严谨。</p>
<h4 id="思考方式二不严谨-1">思考方式二（不严谨）</h4>
<p>已知不在 <span class="math inline">\(A,B\)</span> 酒吧，那么在 <span
class="math inline">\(C\)</span> 酒吧和在家的概率之比是 <span
class="math inline">\(3:1\)</span>，因此答案为 <span
class="math inline">\(75\%\)</span>。</p>
<p>这种方式的问题在哪里不必多说了。</p>
<h3 id="解释">解释</h3>
<p>思考这个问题前应该回到概率定义的几个要素：样本空间，样本点，事件。</p>
<p>一个事件的概率被定义为事件大小除以样本空间大小。</p>
<h4 id="三门问题-1">三门问题</h4>
<p>第一个问题中，样本空间的大小为 <span
class="math inline">\(3\)</span>，需要计算在某个不被选择的门后面是羊的情况下，选择的门后面是车的概率。</p>
<p>事件的大小为 <span class="math inline">\(1\)</span>，因此概率为 <span
class="math inline">\(\frac{1}{3}\)</span>，另一个不被选择的门后面有车，其事件大小为
<span
class="math inline">\(2\)</span>，因为最初样本空间中在两个门后的样本点都属于该事件（如果是这两个事件之一，那么没被打开的另一扇门后必定是车）。</p>
<p>推广到 <span class="math inline">\(n\)</span>
门问题，主持人随机打开一个<strong>未被选择且没有车的门</strong>，那么样本空间大小为
<span class="math inline">\(1\)</span>，不改变选择的事件大小为 <span
class="math inline">\(n-2\)</span>，改变选择的事件大小为 <span
class="math inline">\(n\)</span>。</p>
<h4 id="酒吧问题">酒吧问题</h4>
<h4 id="事件域">事件域</h4>
<p>通常解决一个概率问题需要明确事件域，即我们关心的所有事件，如果事件域不合法，那么</p>
<h4 id="某个样本空间不正确导致的悖论">某个样本空间不正确导致的悖论</h4>
<p>假设选的门是 <span class="math inline">\(1\)</span> 号，已知 <span
class="math inline">\(2\)</span> 号门没有车，那么 <span
class="math inline">\(3\)</span> 号门有车的概率是 $$</p>
<p>我们需要明确问题中这个概率定义是在哪个样本空间下的，问题中样本空间的大小很明显是
<span class="math inline">\(3\)</span>，而在被开的门后是山羊的事件大小为
<span class="math inline">\(2\)</span></p>
<h2 id="样本空间无限的问题">样本空间无限的问题</h2>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/07/OI/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/07/OI/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">最小生成树和动态规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-07 14:43:38" itemprop="dateCreated datePublished" datetime="2022-10-07T14:43:38+08:00">2022-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:56:31" itemprop="dateModified" datetime="2025-02-16T17:56:31+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="最小生成树-x-动态规划">最小生成树 X 动态规划</h2>
<p>​ |</p>
<p>​ |</p>
<p>​ |</p>
<p>​ /<br />
</p>
<p>​ /<br />
</p>
<p><strong>F1:</strong> <strong>xxxx</strong> <strong>oooo</strong></p>
<p>…………</p>
<h3 id="最小生成树mst">最小生成树(MST)</h3>
<p>常用算法有 Kruscal 和 Prime，以下会谈一些 MST
的性质和两种算法的证明</p>
<h4 id="kruscal-证明参考-oi-wiki">Kruscal 证明（参考 OI-wiki）</h4>
<p>核心思路是证明任意时刻边集均为一颗 MST 的子集。</p>
<p>归纳的，令当前边集 <span class="math inline">\(F\)</span> 属于的 MST
为 <span class="math inline">\(T\)</span>，考虑新加入的一条边 <span
class="math inline">\(e\)</span>，如果 <span class="math inline">\(e\in
T\)</span>，自然成立。</p>
<p>如果 <span class="math inline">\(e\notin T\)</span>，那么 <span
class="math inline">\(e+T\)</span> 构成了一个环，考虑该环上所有边 <span
class="math inline">\(E_i\)</span>，一定满足 <span
class="math inline">\(w_{E_i} \le w_e\)</span>，否则 <span
class="math inline">\(e\)</span> 应该在 <span
class="math inline">\(T\)</span> 中，得到更优的 MST，所以 <span
class="math inline">\(E_i\)</span> 已经在 <span
class="math inline">\(e\)</span> 之前被加入，构成了一条完整的链。</p>
<p>所以不会加入 <span class="math inline">\(e\)</span>，进行下一步。</p>
<h4 id="一些性质">一些性质</h4>
<h4 id="prime">Prime</h4>
<h3 id="动态规划最小生成树">动态规划最小生成树</h3>
<p>一般这种题都是指数级的题，有 <a href="">这道</a>，<a
href="">这道</a>，和 <a href="">这道</a></p>
<h4 id="例题">例题</h4>
<p>给你一张图，问任选 <span class="math inline">\(i\)</span>
条边，使得图联通的方案数有多少种。</p>
<h4 id="method1">Method1</h4>
<p>记录联通性动态规划</p>
<h4 id="mehod2">Mehod2</h4>
<p>考虑 <span class="math inline">\(dp[mask][i]\)</span> 表示子图 <span
class="math inline">\(mask\)</span>
的答案，转移时发现重复了，因为两种不同的子图分配方案最后可能对应到同一种选边方式，所以我们需要一个顺序一类的东西来保证不重复。</p>
<p>一种比较可行的方式是计算记录顺序的情况下的方案，这样可以钦定枚举的两个子图一定是最后连上的，最后除以一个阶乘。</p>
<p>另一种方式是直接容斥，考虑计算选 <span
class="math inline">\(k\)</span>
条边后不联通的答案，枚举得到的两个连通块就是断开的，还是有重复的问题，但是我们可以钦定每种图只会在与
<span class="math inline">\(1\)</span>
相连的连通块处被统计，这是经典的连通图计数方式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/10/06/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1006%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/06/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/1006%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">20221006考试总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-06 21:24:52" itemprop="dateCreated datePublished" datetime="2022-10-06T21:24:52+08:00">2022-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:22:01" itemprop="dateModified" datetime="2025-02-16T20:22:01+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="考试总结">考试总结</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0130">考试</a></p>
<p>​ <strong>成功垫底</strong></p>
<p>​ 难 T</p>
<p>​ 度 1</p>
<p>​ 倒 磕</p>
<p>​ 序 了</p>
<p>​ 自 一</p>
<p>​ 闭 万</p>
<p>​ 场 年</p>
<h3 id="t1">T1</h3>
<p>我不会的题。</p>
<p>求有向图可达点数量实际上不存在低于 <span
class="math inline">\(O(n^2)\)</span>
的算法，所以得考虑给定图的性质。</p>
<p>显然给定的图是个平面图。</p>
<p>然后定义一个东边的点是有效的，当且仅当它能到一个西边的点，一遍 <span
class="math inline">\(BFS\)</span> 可以把有效点找出来。</p>
<p>然后对于所有点，它能到达的有效点集合一定是一段区间，考虑反证，对于某个点，如果被夹在中间的一个有效点到不了，那么如果其它点可以到就只能穿过一些边，这是不可能的。</p>
<p>写拓扑排序是非常傻逼的行为，直接对每个有效点拓展，算出西边每个点到达有效点坐标的最值就行。</p>
<h3 id="t2">T2</h3>
<p>会但是考场写不出来的题。</p>
<h4 id="method1">Method1</h4>
<p>考虑枚举排列计算 <code>MST</code>，本质上需要求前 <span
class="math inline">\(i\)</span> 个边能将图联通的排列一共有多少个。</p>
<p>可以考虑计算出任选 <span class="math inline">\(i\)</span>
条边后图联通的选法有多少种，然后通过容斥计算出恰 <span
class="math inline">\(i\)</span> 个边联通的排列个数。</p>
<p>可以记录联通性动态规划搞定。</p>
<p>复杂度 <span class="math inline">\(O(bell(n)\times m^2)\)</span></p>
<h4 id="method2">Method2</h4>
<p>枚举联通往往可以弄成二进制枚举联通状态，逆序考虑联通块的构成方式，发现求任
<span class="math inline">\(i\)</span>
条边联通的方案数，转移的时候是不强调顺序的，所以枚举子集会导致重复，不妨直接考虑顺序，计算原问题的答案。</p>
<p>设 <span class="math inline">\(dp[mask][i]\)</span> 表示只考虑 <span
class="math inline">\(mask\)</span> 子图，答案为 <span
class="math inline">\(i\)</span>
的排列个数，转移就可以枚举子集，从上一条边的状态转移，需要进行一些排列组合，复杂度
<span class="math inline">\(3^n\times m^4\)</span>。</p>
<h4 id="method3">Method3</h4>
<p>高达 <span class="math inline">\(m^4\)</span>
的多项式复杂度还是太逊了，考虑继续优化。</p>
<p>其实我们很想直接任选 <span class="math inline">\(k\)</span>
条边，然后排除掉不合法的情况，这样能够求出答案至多为 <span
class="math inline">\(k\)</span> 的个数，容斥之后就没有问题了。</p>
<p>所以考虑如何排除不合法的情况，就是边选好了但是图没联通，这个时候我们就可以枚举一个小连通块，可以用若干边连接内部，若干外部边任选，就是一类不合法的情况，但是这样会算重，我们可以钦定枚举的联通块和
<span class="math inline">\(1\)</span> 联通。</p>
<p>复杂度 <span class="math inline">\(O(3^n\times m^2)\)</span>。</p>
<h4 id="总结">总结</h4>
<p>这一类图论上的二进制枚举问题，往往可以先从枚举联通块入手，再考虑子图的答案，最后综合运用容斥等计数手段，得到复杂度优秀的做法。</p>
<h3 id="t3">T3</h3>
<p>非常有意思的题</p>
<h4 id="method1-1">Method1</h4>
<p>考场上的想法，主要受到<a href="还没写">某道题</a>的启发。</p>
<p>只考虑最大值，<span class="math inline">\(O(n)\)</span>
可以扫一遍，单调栈维护当前每一段的最大值与和。</p>
<p>很浪费，因为我们本质上对每个右端点都求了合法左端点区间的答案，考虑能不能复用右端点的答案。</p>
<p>其中一种方式是分块，考虑一段右端点到每个左端点的答案的前缀和，然后查询就可以被拆分了。</p>
<h4 id="method2-1">Method2</h4>
<p>为什么我们会分块，回到那道题，我们有办法通过一些预处理结果得到两个区间并的答案，但是无法快速合并两个预处理结果，所以我们分块，只需要预处理一次。</p>
<p>但是利用随机数的性质我们发现其实可以快速合并预处理的结果。</p>
<p>将问题转化为两种基本形式，相离和重合，这是容易的。</p>
<p>先考虑相离怎么做</p>
<p>考虑利用随机的性质，发现任意一段区间，其有效的贡献个数为 <span
class="math inline">\(\ln\)</span>
个，即从区间首或位开始的最长连续上升序列，然后枚举两个 <span
class="math inline">\(\ln\)</span> 的区间合并，搞定相离的情况，视实现是
<span class="math inline">\(\ln^2\)</span> 或者 <span
class="math inline">\(\ln\)</span>，后者常数较大可能并不优秀。</p>
<p>然后是重合，能不能合并两个重合的区间得到新的区间，可以！转化为一个相离和两个更小的重合问题，因为数量是
<span class="math inline">\(\ln\)</span>
的，所以合并预处理信息是可能的。</p>
<p>但是，为啥要用线段树，因为没有逆元！但是这道题是可以将一个大重合问题减去一个相离和一个小重合问题得到另一个小重合问题的，所以对大重合问题做前缀和即可。</p>
<h4 id="method3-1">Method3</h4>
<p>对于二维统计问题，常常可以考虑固定预处理其中一维，尝试快速通过预处理结果查询第二维。</p>
<p>这道题中，我们可以预处理每个点作为第二个区间中的点时，在第一个区间中每个点的答案。但实际上这个数据量是
<span class="math inline">\(O(n)\)</span>
的，没有办法快速搞定，那不妨考虑只处理其前缀和与后缀和，看看是否能够压缩信息。</p>
<h5 id="一些不太正确的思考">一些不太正确的思考</h5>
<p>考虑单个右端点对一段区间查询，考虑区间最大值，如果落在自身或者空区间，那么答案容易计算，如果落在左区间</p>
<p>考虑它前面第一个比它大的位置，如果不存在或者在空区间，那么答案可以通过前缀和快速计算</p>
<h5 id="正确的思考">正确的思考</h5>
<p>考虑区间相离的基本情况。由于单点我们都没有办法做，所以不太能直接搞，但是容易发现区间重合时可以搞定的，考虑区间最大值的位置，跨过它的答案容易统计，不跨过它，我们处理了每个点为右端点和左端点时答案的前缀和，那么由于不跨过最大值时，在最大值另一侧的答案完全不受同侧的影响，所以前后缀和减去最大值所在位置的前后缀和就可以得到重合的答案。</p>
<p>有了重合，我们可以解决区间相邻的答案，定义求两个区间答案的运算是
<span class="math inline">\(\oplus\)</span>，那么对于两个相邻区间有<span
class="math inline">\((a+b)\oplus(a+b)=a\oplus a+b\oplus b+a\oplus
b\)</span>。</p>
<p>我们能搞定的是 <span class="math inline">\(a\oplus
a\)</span>，对于相离的区间，转化为相邻区间做 <span
class="math inline">\(a\oplus c = (a+b+c)\oplus (a+b+c)-a\oplus a-b
\oplus b-c\oplus c - a\oplus b -b\oplus c\)</span>。</p>
<p>因而搞定了所有情况。</p>
<h5 id="实现">实现</h5>
<p>如果直接这么写，写出来很丑，实际上由更优雅的写法，考虑差分区间，如果左端点大于右端点那么没有问题，<span
class="math inline">\([l_1,r_2]\)</span> 全部统计，那么会有重复 <span
class="math inline">\([l_1,l_2-1]\)</span>
这一段区间就是被重复统计的，当然这个区间可以不存在，需要减去，然后再减去
<span class="math inline">\([r_1+1,r_2]\)</span>
这段有可能不存在的区间的答案，最后加上可能被算重的 <span
class="math inline">\([r_1+1,l_2-1]\)</span> 区间。</p>
<p>反正这个思想挺神的，看上去有问题但确实是对的，比直接写优雅很多。</p>
<h4 id="method4">Method4</h4>
<h5 id="思路">思路</h5>
<p>考虑每个数对答案的贡献，弄出左右两边第一个比它大的数，那么这些区间以内跨过它的，都在它的贡献范围内，左右端点可以弄成
<span class="math inline">\(x,y\)</span> 坐标，这是一个矩阵加。</p>
<p>考虑查询，本质上也是在查询 <span class="math inline">\(x,y\)</span>
坐标各在一段区间内的答案。</p>
<p>于是就是一个修改全部在查询前面的矩阵加矩阵查问题，可以用树状数组解决。</p>
<h5 id="实现-1">实现</h5>
<p>说着轻松，但其实还没写过这种东西，简单思考下怎么做。</p>
<p>首先区间查被差分成 <span class="math inline">\(\ge x,\ge y\)</span>
的区域加一，区间查变成 <span class="math inline">\(\le x,\le y\)</span>
的区域查询，还是回到了二维偏序问题。</p>
<p>点是 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span>，条件是
<span class="math inline">\(x_2\ge x_1\wedge y_2\ge y_1\)</span>，贡献是
<span
class="math inline">\((x_2-x_1)\times(y_2-y_1)\)</span>，是不是很阴间？所以多维护点东西，一个
<span class="math inline">\(cnt\)</span> 树状数组搞定 <span
class="math inline">\(x_2\times y_2\)</span>，两个分别加 <span
class="math inline">\(x,y\)</span> 来搞定 <span
class="math inline">\(x_2\times y_1,x_1\times y_2\)</span>
，再来一个统计 <span class="math inline">\(xy\)</span>
搞定剩下那一项，其实还算好写。</p>
<h3 id="t4">T4</h3>
<p>考虑刻画出图的形态，它是一个基环内向树森林。</p>
<p>容易发现只用将 <span class="math inline">\(1\)</span>
和其它点连边，然后有些点是必须连的，入度为 <span
class="math inline">\(0\)</span> 的，编号非 <span
class="math inline">\(1\)</span> 的点必须连。</p>
<p>先不考虑环，这样连了之后，又有一些点是必连的，而且容易发现连这些点一定最优，所以继续连。</p>
<p>连到不是环上的所有点都连上为止。</p>
<p>现在还剩一些环，环上一些点是合法的，需要用长度为 <span
class="math inline">\(k-1\)</span> 的线段取覆盖环，让所有点合法。</p>
<p>容易发现确定某个起点之后就能贪心了，考虑连续的 <span
class="math inline">\(k+1\)</span>
个不合法点，枚举每一个并确定最少数量，然后取 <span
class="math inline">\(\min\)</span> 就行，因为这连续的 <span
class="math inline">\(k+1\)</span> 个不合法点一定有一个是起点。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">huan-yp</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
