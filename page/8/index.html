<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"huanyp.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","display":"post","width_expanded":320,"width_dual_column":240,"padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="幻影彭的彩虹">
<meta property="og:url" content="https://huanyp.cn/page/8/index.html">
<meta property="og:site_name" content="幻影彭的彩虹">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="huan-yp">
<meta property="article:tag" content="算法竞赛, 自动化测试, 工程技术, Python">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://huanyp.cn/page/8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>幻影彭的彩虹</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">幻影彭的彩虹</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录青春的扇区</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="huan-yp"
      src="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
  <p class="site-author-name" itemprop="name">huan-yp</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/huan-yp" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huan-yp" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3051561876@qq.com" title="E-Mail → mailto:3051561876@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/1155409006?spm_id_from=333.1369.0.0" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;1155409006?spm_id_from&#x3D;333.1369.0.0" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/09/20/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0920%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/20/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2022/0920%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">20220920总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-20 19:27:26" itemprop="dateCreated datePublished" datetime="2022-09-20T19:27:26+08:00">2022-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:21:14" itemprop="dateModified" datetime="2025-02-16T20:21:14+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="某场考试t1"><a
target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0123/problem/A">某场考试T1</a></h2>
<p>怎么说，题不难，但是需要想一下。</p>
<p>考虑右端点进行贪心的思路挺妙的。</p>
<h2 id="某场考试t2"><a
target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0123/problem/B">某场考试T2</a></h2>
<p>比较套路的题，先弄出一个 <span class="math inline">\(t\times
n^4\)</span>
的凑合做，然后发现两维转移系数独立，转移答案为三角形和形式乘上两维系数，可以考虑固定第二维，单独计算第一维不同转移系数对应的式子，每一种系数的变化量为
<span class="math inline">\(O(1)\)</span>，所以一次转移可以做到 <span
class="math inline">\(O(n)\)</span>。</p>
<h2 id="某场考试t3"><a
target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0123/problem/C">某场考试T3</a></h2>
<p>神仙题，考场上猜到树一定有解，但是想的是通过背包来构造解，事实上，可以归纳的证明每棵子树带来的差异可以取
<span class="math inline">\([-sz_u,sz_u]\)</span>
中的任意值，所以对于树暴力构造一条从根到某个点的路径，可以满足路径两边大小相等。</p>
<p>考虑图上的结果。</p>
<p>09
年的一篇集训队论文告诉我们对于图上的问题，往往可以考虑其生成树的解法，从而进行拓展，发现无向图的生成树没有横插边，所以直接选取生成树上的答案，由于没有返祖边，所以原来合法的同样合法。</p>
<h2 id="某场考试t4"><a
target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0123/problem/D">某场考试T4</a></h2>
<p>也是比较套路的题。</p>
<p>很明显本质上是给你个一次函数做路径边权，然后 <span
class="math inline">\(k\)</span> 的值为 <span
class="math inline">\(1\)</span>，所以计算出每个点每个 <span
class="math inline">\(k\)</span> 的值即可。</p>
<p>我选择分层图跑 <span class="math inline">\(dij\)</span>
外加大力卡常，但这是一种非常 <span class="math inline">\(SB\)</span>
的行为，<span class="math inline">\(dij\)</span>
本质上还是保证了转移的无环性，但 <span class="math inline">\(TM\)</span>
这个转移本来就无环还跑你大爷的 <span
class="math inline">\(dij\)</span>，暴力 <span
class="math inline">\(dp\)</span> 出来做凸包就行。</p>
<p>然后从 <span class="math inline">\(n\)</span> 的各个在凸包上的 <span
class="math inline">\(k\)</span>，倒推回去看那些点可能被用到，倒推可以写成记搜，这样只用存一遍边。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/09/19/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%985/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E5%81%9A%E9%A2%985/" class="post-title-link" itemprop="url">20220919小记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-19 20:49:12" itemprop="dateCreated datePublished" datetime="2022-09-19T20:49:12+08:00">2022-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:58:30" itemprop="dateModified" datetime="2025-02-16T17:58:30+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="某道-gcd-题">某道 GCD 题</h2>
<p>给一个 <span class="math inline">\(n\times m\)</span> 矩阵，元素为
<span class="math inline">\(1-n\times m\)</span>
的排列，问你所有子矩阵的 GCD 之和。</p>
<p>反正我想的是考虑一个右下角，移动左上角来统计答案，这样的话考虑到 gcd
的变化次数是<span class="math inline">\(\log\)</span>
的，说不定有救，但是需要完成区间取 GCD，这个不好做。</p>
<p>想一下，这个做法没有利用到每个数只出现一次的性质，通常这种只出现一次的性质往往和倍数这些相联系，不妨换个思路考虑，考虑
<span class="math inline">\(i\)</span>
的倍数的子矩阵的数量，然后发现容斥一下就可以得到答案。统计 <span
class="math inline">\(i\)</span> 的倍数的子矩阵数量不难。</p>
<h2 id="noi2021d1t1">NOI2021D1T1</h2>
<p>我想了一下，链是会做的，<strong>树链剖分</strong>，就是把树变成 <span
class="math inline">\(\log\)</span> 个链来做。</p>
<p>然后其实每条重链按照链的方式来做，重链的交汇处需要特殊处理。</p>
<p>不妨把边下放到点，发现如果一个点的父亲的修改时间晚于该点的修改时间，那么这个点所代表的链就没用，所以对每个点维护两个东西，一个是该点的修改时间，另一个是该点代表的边是否被修改成重边。</p>
<p>查询的时候对链的交界处需要查修改时间判断是否有效。</p>
<p>其实有个更简易的方式，就是把修改看成染色，一条边有贡献当且仅当其两个端点颜色相同，这个很容易用树剖维护。</p>
<p>这两种方式其实体现出处理边的两种方式——下放到点考虑，考虑两个端点的状态。</p>
<p>需要灵活运用这两种方式解题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/09/05/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E8%AE%B020220904/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/05/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E8%AE%B020220904/" class="post-title-link" itemprop="url">随记20220904</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-05 00:22:54" itemprop="dateCreated datePublished" datetime="2022-09-05T00:22:54+08:00">2022-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:49:01" itemprop="dateModified" datetime="2025-02-16T17:49:01+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%94%9F%E6%B4%BB/" itemprop="url" rel="index"><span itemprop="name">生活</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="随记20220904">随记20220904</h2>
<p>双膝折叠，跪坐在算不上柔软的沙发上，两臂枕在凸起的窗沿。我有些懒散的将下巴靠在小臂，又竭力不让窗沿压迫小臂，以免有些脆弱敏感的手部神经受到刺激，<span
class="math inline">\(P=\frac{F}{S}\)</span>，一个非常优美的公式。我开始估算手臂和窗沿的接触面积，我脑袋的半径，以便带入人体平均密度计算出手部受到的压强相当于几个大气压。</p>
<p>不得不说，物理和数学公式都是优美的，只需要用上统一的几个名字，就能尽情将身边的一切等效。或者说，公式本身不够优美，但是人们设计的物理单位是那么的精巧，避免了那些繁杂的常量，一些无比熟悉的数字又飞入脑海，<span
class="math inline">\(e\approx2.718\)</span>,<span
class="math inline">\(\pi\approx3.1415927,G\approx6.67\times
10^{-11}m^3kg^{-1}s^{-2}\cdots\)</span>。</p>
<p>将越跑越远的联想收回来，生活不是科学，生活不需要那些能精确到小数点后几十几百位的数字。生活的美感，是一种无法用任何数学语言描述的美感。</p>
<p>陶渊明的 “采菊东篱下，悠然见南山”，带来田园的悠然自得。</p>
<p>王维的 “大漠孤烟直，长河落日圆”，给出荒凉的独特答案。</p>
<p>马致远的
“枯藤老树昏鸦，小桥流水人家，古道西风瘦马。”，留下秋日的那份伤感。</p>
<p>但我只是一个平常的理科生，对感性的语文并不敏感，但窗外的宁静，也足以让我有感写下一些拙劣幼稚的文字。</p>
<p>我不知道今年的干旱具体给天府之国带来了多大的影响，但是从居民区的停电和学校的被迫放假还是能够管中窥豹。刚回到学校没多久，COVID
就横扫四川所有中学，没有一所逃过延迟开学的结局，即使是强硬如某校，也只不过多坚持了半天，就匆匆将神兽们赶了回去——就在高温假结束后的
2 天。</p>
<p>所以我就在这个时候，趴在了窗前，半夜的街道很冷清，只能听见百草路地铁口
“握紧扶手，注意脚下” 的提醒。目光向上
90度，我甚至能分辨出夜空中的云朵，它们和蓝色的天空还有一丝界限，但其实都很暗，它们一起向目光尽头的高楼收敛。如果你想具体的体会一下，你可以打开
<code>mspaint</code>，天的颜色是 <code>0 60 85</code>，云的颜色是
<code>212 212 212</code>，而它们收敛向 <code>69 24 34</code>。RGB
空间还是很无力，区区 3Byte
无法描绘出世界上的，甚至无法描绘出人肉眼可以分辨的所有颜色。</p>
<p>黯淡的云朵没有动作，视野的右侧有一颗明亮的光点，它是星星。按照不知道从哪里得知的观星技巧，我快速的扫过窗口狭小的天空，又有数十的光点在视野中闪过，但我尝试正眼捕捉，它们又藏入了深色的天空，像是一个个纯黑背景下的白色像素点，于缩放后在显存中被彻底删除，我再也找不到它们。即使有着凹透镜的帮助，变形略显严重的晶状体也失去了精确的将波长仅有
<span class="math inline">\(300-500nm\)</span>
的可见光折射到每一个感光细胞的能力。</p>
<p>一段时间的沉寂后，波浪状的云遮住了唯一那颗被轻易捕捉到的星星，视野渐渐下移，移过
“立德树人”
四个大字，是熟悉的水泥路。很突然，沥青从路面翻起，回到工人的铲子，回到工程车辆，回到工厂，最后在分馏器中重新变成原油，再顺着磕头机的管道流入地底。远处的高楼被荒芜的草地替换，眼前的工地，正热火朝天。。。</p>
<p>又重归沉寂，只有略冷的风打在脸上，我看了看最近都在 1.5km
之外的高楼，并细细感受周遭的气温，思考着这股风的来历，但已经有些陌生的地理和物理知识不再能闪着光告诉我答案。</p>
<p><code>shutdown -f</code>，我告诉大脑，但又用留在海马体里的数据恢复了这段文字，像是被设置了关机命令为休眠的计算机。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/09/03/OI/%E7%AE%97%E6%B3%95/%E4%BB%8E2D1D%E5%88%B01D1D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/03/OI/%E7%AE%97%E6%B3%95/%E4%BB%8E2D1D%E5%88%B01D1D/" class="post-title-link" itemprop="url">从2D1D到1D1D</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-03 09:18:50" itemprop="dateCreated datePublished" datetime="2022-09-03T09:18:50+08:00">2022-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:54:28" itemprop="dateModified" datetime="2025-02-16T17:54:28+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="从区间-dp-到线性-dp">从区间 DP 到线性 DP</h2>
<h3 id="题目">题目</h3>
<p>你有 <span class="math inline">\(n\)</span> 个区间，每个区间是 <span
class="math inline">\(l,r,w\)</span>
三个参数描述，表示左右端点和权值，如果区间有交（包括端点），那么就在有交的两个区间连边，形成一张无向图，有个参数
<span
class="math inline">\(k\)</span>，你需要删去一些区间，使得每个联通块大小不超过
<span class="math inline">\(k\)</span>。</p>
<ul>
<li><p><span class="math inline">\(n\leq 500\)</span></p></li>
<li><p><span class="math inline">\(n\leq 2500\)</span></p></li>
</ul>
<h3 id="思考">思考</h3>
<p>首先这肯定不是一个图论问题，给一张图做这个问题是 <span
class="math inline">\(NP\)</span> 的，所以要利用好区间的性质。</p>
<p>先把区间离散化。</p>
<p>发现可以考虑一段区间 <span
class="math inline">\([l,r]\)</span>，只考虑在区间内的区间，计算其答案，有两种方式，第一种是将区间继续划分成两个子区间，<strong>划分区间的过程，体现出了全局最优的思想</strong>，即我们假定了当前区间内的所有线段全部联通，这样不一定能在此处取到最优解，但一定可以在向下动态规划的过程中得到最优解，另一种是直接在当前区间选最大的
<span class="math inline">\(k\)</span> 个保留。</p>
<p>划分区间的方式，就是选一个地方断开，删掉越过这个地方的所有区间，变成两个子问题。</p>
<p>有了这样的思路，我们很容易设计出一个 <span
class="math inline">\(O(n^3)\)</span> 的区间动态规划出来。</p>
<h3 id="优化">优化</h3>
<p><span class="math inline">\(O(n^3)\)</span> 可以通过 <span
class="math inline">\(n\leq 500\)</span> 的数据点，但是无法通过 <span
class="math inline">\(n\leq 2500\)</span>，所以需要优化为 <span
class="math inline">\(O(n^2)\)</span>，其中预处理 <span
class="math inline">\([l,r]\)</span> 的复杂度是 <span
class="math inline">\(O(n^2\log n)\)</span>
的，但是常数较小能够接受。</p>
<p>于是可以考虑利用区间 <span class="math inline">\(dp\)</span>
的一些常见优化手段，打个表，发现决策点并不单调，所以对于这类 <span
class="math inline">\(2D1D\)</span>
问题我们有点束手无策。但是感觉上记录区间有点浪费，于是考虑能不能线性的搞出来。发现如果设
<span class="math inline">\(dp[i]\)</span> 表示考虑前 <span
class="math inline">\(i\)</span> 个的答案，从 <span
class="math inline">\(j&lt;i\)</span> 转移，<span
class="math inline">\([j,i]\)</span> 采用直接减少到 <span
class="math inline">\(k\)</span>
的方式，也能得到和区间DP方式相同的转移考虑。</p>
<p>所以被优化成了 <span
class="math inline">\(O(n^2)\)</span>。越过每个点的区间总数，是可以动态维护的，均摊
<span class="math inline">\(O(1)\)</span>。</p>
<h3 id="从2d1d到1d1d">从2D1D到1D1D</h3>
<p>其实这类问题，是伪区间DP问题，比较它和真区间DP问题，比如《石子合并》，《优雅的闪电》的差异。它本质上是
1D1D
问题，石子合并很明显就是需要体现区间合并的顺序，所以必须采用区间DP。优雅的闪电的转移，无法被
1D1D 的转移考虑完全，所以仍然需要区间 DP。</p>
<p>关于一些 2D1D 的问题，可以仔细考察它的转移，能否被 1D1D
的形式描述，以便优化。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/08/30/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E5%85%B3%E4%BA%8EC++%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/30/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E5%85%B3%E4%BA%8EC++%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">C++ 容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-30 09:19:43" itemprop="dateCreated datePublished" datetime="2022-08-30T09:19:43+08:00">2022-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:53:24" itemprop="dateModified" datetime="2025-02-16T17:53:24+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="标准库">标准库</h2>
<ul>
<li>STL
内的所有基于比较的容器，都需要定义一个满足<strong>严格弱序</strong>的比较符号
<code>&lt;</code>，要求如下：
<ul>
<li>满足传递性：<span class="math inline">\(a&lt;b,b&lt;c\rightarrow
a&lt;c\)</span></li>
<li>不能同时满足 <span class="math inline">\(a&lt;b\)</span> 且 <span
class="math inline">\(b&lt;a\)</span></li>
<li>如果 <code>!(a&lt;b)&amp;&amp;!(b&lt;a)</code> 那么
<code>a=b</code></li>
</ul></li>
<li>除开 <code>array</code> 之外的所有 <code>STL</code>
容器，定义时都会初始化，即初始化为空或者(全为 <code>0</code>，对于
<code>bitset</code>)。</li>
<li>基于比较的容器，需要定义<strong>友元类型的大小比较符号</strong>，因为实现的时候使用了右值做比较。</li>
</ul>
<h3 id="priority_queue">priority_queue</h3>
<p>默认是大根堆，跑得很快，1 秒 <span class="math inline">\(3\times
10^6\)</span></p>
<p>如果需要实现可以删除的优先队列，<strong>必须保证每次删除时对应元素存在</strong>。</p>
<p>构造方式
<code>priority_queue&lt;type,container,cmp&gt;</code>，<code>container</code>
是实现 <code>priority_queue</code> 的容器，一般用
<code>vector</code>，<code>cmp</code>
是比较算子（因此它是一个类名）。</p>
<p>通过 <code>greater&lt;typename&gt;</code> 可以用重载的
<code>&gt;</code> 构造出一个大于算子。</p>
<h3 id="map">map</h3>
<p>本质上是 <code>set&lt;pair&lt;T1,T2&gt;&gt;</code>，见
<code>set</code>。</p>
<h3 id="set">set</h3>
<h4 id="insert">insert</h4>
<p>可以插入一段区间，支持数组，同类型的 <code>set vector</code>
容器。</p>
<p>开 O2，<span class="math inline">\(1\)</span> 秒 <span
class="math inline">\(1.5\times 10^6\)</span> 次操作。</p>
<p>如果接下来的一段插入有序，开 O2，<span
class="math inline">\(1\)</span> 秒 <span
class="math inline">\(4.5\times 10^6\)</span>
次，所以尽量排序后再插入。</p>
<h4 id="erase">erase</h4>
<p>开 O2，<span class="math inline">\(1\)</span> 秒 <span
class="math inline">\(1.5\times 10^6\)</span> 次操作。</p>
<p>如果接下来的一段插入有序，开 O2，<span
class="math inline">\(1\)</span> 秒 <span
class="math inline">\(4.5\times 10^6\)</span> 次。</p>
<h4 id="迭代器操作">迭代器操作</h4>
<p>开 O2，<span class="math inline">\(1\)</span> 秒 <span
class="math inline">\(10^7\)</span>。</p>
<h4 id="遍历">遍历</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v:st)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=st.<span class="built_in">begin</span>();it!=st.<span class="built_in">end</span>();it++)</span><br></pre></td></tr></table></figure>
<p>以上两种均为 <span class="math inline">\(O(n\log n)\)</span></p>
<p>开 O2，<span class="math inline">\(1\)</span> 秒 <span
class="math inline">\(10^7\)</span> 次操作。</p>
<h3 id="unordered_set">unordered_set</h3>
<p>基础操作相比 <code>set</code> 快 <span
class="math inline">\(2\)</span> 倍。</p>
<p>有序操作和 <code>set</code> 效率差不多。</p>
<h3 id="unoedered_map">unoedered_map</h3>
<p>本质上是 <code>unordered_set&lt;pair&lt;T1,T2&gt;&gt;</code>。</p>
<h3 id="vector">vector</h3>
<p>比较理想的一个容器。</p>
<h4 id="push_back">push_back()</h4>
<p>一个 <code>vector</code> 做 <code>push_back</code> 需要
<code>log</code> 次 <code>new</code>，而 <code>new</code>
操作一般只能接受 <span class="math inline">\(2\times 10^7\)</span>
次，所以尽量避免用太多 <code>vector</code>，如果能事先确定容器的
<code>capacity</code>，最好用 <code>resize</code></p>
<h4 id="iterator-insertiteratorval">iterator insert(iterator,val)</h4>
<p>将 <code>val</code> 插入 <code>iterator</code> 位置，原
<code>iterator</code> 位置往后移动。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>，但是跑得飞快。</p>
<h4 id="iterator-eraseiterator">iterator erase(iterator)</h4>
<p>删除 <code>iterator</code> 位置的值，返回原容器(删除前)下一个位置的
<code>iterator</code>。</p>
<h4 id="iterator">iterator</h4>
<p>这东西的迭代器本质上是个指针，但是不能和指针做强转，<strong>所以
<code>iterator</code> 在被 <code>erase</code> 后会指向错误的数据，不同于
<code>set</code> 这一类基于 <code>RBT</code> 的容器</strong>。</p>
<h4 id="内存过程">内存过程</h4>
<p>调用析构函数之前，<code>vector</code>
的内存不可能被释放，<code>push_back</code> 或者 <code>resize</code>
如果导致了内存改变，<strong>会开辟一块新的内存并将原有数据全部拷贝过去，保证内存地址的连续，同时原有迭代器全部失效。</strong></p>
<p><strong>vector 所有的 <span class="math inline">\(O(n)\)</span>
操作都很快</strong>，如果题目性质决定了很可能 <span
class="math inline">\(O(n^2)\)</span> 卡不满，那么 <code>vector</code>
可以得到很高的分数。</p>
<h2 id="拓展库">拓展库</h2>
<p>一个 <code>C++</code> 拓展库，<code>STL</code>
升级版，<code>C++11</code> 特性。</p>
<h3 id="gp_hash_table">gp_hash_table</h3>
<h4 id="introduction">Introduction</h4>
<p>如名称，哈希表，比 <code>unordered_map</code> 快 <code>3~4</code>
倍，用法完全一样，你值得拥有。</p>
<p>效率 1S 能做 4e7 次基本操作</p>
<p>在 <code>ext/pb_ds/assoc_container.hpp</code> 中。</p>
<p>如果对非标准结构，例如类和 <code>pair</code>
，容器等，需要自己写哈希方法，哈希方式为一个类，重载了 <code>()</code>
运算，该重载必须被声明为常函数，且参数必须为常值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line">__gnu_pbds:: gp_hash_table &lt;<span class="type">int</span>,<span class="type">int</span>,hash_fun&gt; mp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> node &amp;x,<span class="type">const</span> node &amp;y)&#123;</span><br><span class="line">		<span class="keyword">return</span> x.a==y.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash_fun</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> node &amp;a)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">__gnu_pbds:: gp_hash_table&lt;node,<span class="type">int</span>,hash_fun&gt; mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">mp[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(mp.<span class="built_in">find</span>(<span class="number">2</span>) != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mp.<span class="built_in">find</span>(<span class="number">2</span>)-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tests">Tests:</h4>
<p>这里只放关键部分，其余实现见<a
href="huanyp.cn/codes/Tests/hash_table/cmp.cpp">代码</a></p>
<p>测试环境为 Windows10，CPU 型号为 Inter I7-9750H，内存 16GB，
2667Mhz</p>
<p>命中率对速度影响：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gen_data</span>(<span class="number">1e6</span>,<span class="number">4e7</span>,<span class="number">8</span>,<span class="number">7</span>);<span class="comment">//hit rate:87.5%</span></span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//878ms</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//3107ms</span></span><br><span class="line"><span class="built_in">gen_data</span>(<span class="number">1e6</span>,<span class="number">4e7</span>,<span class="number">8</span>);<span class="comment">//hit rate:12.5%</span></span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1351ms</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//4168ms</span></span><br></pre></td></tr></table></figure>
<p>插入和查询次数调整：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gen_data</span>(<span class="number">2e6</span>,<span class="number">4e7</span>,<span class="number">4</span>,<span class="number">1</span>); <span class="comment">//插入 2e6</span></span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1475</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//4728</span></span><br><span class="line"><span class="built_in">gen_data</span>(<span class="number">5e6</span>,<span class="number">4e7</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1445</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//5038</span></span><br><span class="line"><span class="built_in">gen_data</span>(<span class="number">1e7</span>,<span class="number">4e7</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1877</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//6128</span></span><br></pre></td></tr></table></figure>
<p>插入很多，查询很少。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gen_data</span>(<span class="number">2e7</span>,<span class="number">4e6</span>,<span class="number">50</span>,<span class="number">1</span>);</span><br><span class="line">gp.<span class="built_in">clear</span>();um.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Test_Speed</span>(gp);<span class="comment">//1690</span></span><br><span class="line"><span class="built_in">Test_Speed</span>(um);<span class="comment">//8383</span></span><br></pre></td></tr></table></figure>
<p>其实插入操作比较慢是正常的，内存占用大了之后自然就慢了。</p>
<p>另外，手写哈希表探测法还有救，拉链法直接抬走（你写代码的时候考虑过
CPU cache 的感受吗？）。</p>
<p>插入较少且全部在查询前面 <code>cc_hash_table</code> 的效率优于
<code>gp_hash_table</code>。</p>
<h3 id="tree">Tree</h3>
<p>虽然有这个东西，但是还是应该学习如何写平衡树。</p>
<p>效率还可以，开 O2
和以前手写差不多，估计现在手写的会快一些，不过问题不大。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/08/17/%E5%AD%A6%E6%9C%AF/%E5%B7%A5%E5%85%B7/GeogeBra%E8%AE%A1%E7%AE%97%E5%99%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/17/%E5%AD%A6%E6%9C%AF/%E5%B7%A5%E5%85%B7/GeogeBra%E8%AE%A1%E7%AE%97%E5%99%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">GeogeBra计算器简易使用教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-17 11:56:36" itemprop="dateCreated datePublished" datetime="2022-08-17T11:56:36+08:00">2022-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:49:49" itemprop="dateModified" datetime="2025-02-16T17:49:49+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="geogebra-计算器简易教程">Geogebra 计算器简易教程</h2>
<p>如果本文讲的不够精确，可以继续上网搜索教程。</p>
<h3 id="格式">格式</h3>
<p>数学公式格式直接支持 <code>LaTex</code> 和 <code>wolframalpha</code>
提供的数学公式，也可以按照它的提示写。</p>
<p>乘方为 <code>^</code>，分式直接写 <code>/</code>。</p>
<p>内置 <code>ln sin cos</code> 等常用函数，写约定的函数名即可提示。</p>
<p>求导可以直接写 <span class="math inline">\(f&#39;\)</span></p>
<p>积分输入 <code>integral</code>，会提示参数，默认对 <span
class="math inline">\(x\)</span> 做不定积分。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134545.png"
alt="E1" />
<figcaption aria-hidden="true">E1</figcaption>
</figure>
<p>可以看到下面还有一些特殊函数的提示框，可以根据这个输入。</p>
<h3 id="操作">操作</h3>
<p>一般只会用到 <code>Algebra</code> 区域的东西。</p>
<p>鼠标拖动可以调整坐标系显示区域，滚轮调整显示精度。</p>
<p>右下角的三个按钮中前两个可以起到滚轮的作用。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134475.PNG"
alt="E2" />
<figcaption aria-hidden="true">E2</figcaption>
</figure>
<p><code>ctrl+z</code> 撤销上一步操作，<code>ctrl+y</code>
取消上一步撤销操作，一步操作的判定比较迷惑，你认为的多步操作可能被判定为一步。</p>
<h3 id="设置">设置</h3>
<p>右上角有设置图标，见上图，点开后是是这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134442.PNG"
alt="E3" />
<figcaption aria-hidden="true">E3</figcaption>
</figure>
<p>前三个全部默认勾上，不管，第五个 <code>Zoom to fit</code>
是自动调整的合适的大小，基本没用，点开第六个
<code>Settings</code>，主要用这个：</p>
<p>点进去之后只需要调 <code>Basic</code>，其它基本不用管。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134810.PNG"
alt="E4" />
<figcaption aria-hidden="true">E4</figcaption>
</figure>
<p>后面的基本不管，只需要调整
<code>Dimensions</code>，<code>x Min,x Max,y Min, y Max</code>
字面意义，显示的 <span class="math inline">\(x,y\)</span>
坐标的最大值和最小值，如果调整的话会自动调整下面的
<code>xAxis yAxis</code>，也就是 <span
class="math inline">\(x,y\)</span> 坐标的比例，如果点了
<code>xAxis</code> 那个锁定小图标，那么调整 <code>x Min</code>
会自动调整其它两个值(<code>y Min,x Min</code>)以满足比例要求。</p>
<h3 id="变量和函数设置">变量和函数设置</h3>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134339.PNG"
alt="E5" />
<figcaption aria-hidden="true">E5</figcaption>
</figure>
<p>红圈圈出来的可以设置函数和变量，函数左边那个带颜色的框框可以点，点了之后就不再显示图像，当然再点一次就显示。</p>
<p>函数的设置没啥说的，看变量。</p>
<p>变量的那个播放按钮按下后会动态改变变量值，所有相关函数都会同时改变。</p>
<p><strong>如果希望在函数中使用变量，一般先定义变量再写函数。</strong></p>
<p>变量的设置中可以调整范围。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202208171134005.PNG"
alt="E6" />
<figcaption aria-hidden="true">E6</figcaption>
</figure>
<p>在 <code>Slider</code>
选项中调整，调整的时候，<strong>上下界都调整好之后再按回车</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://www.geogebra.org/calculator/fgqtercd">DEMO</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/08/05/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E6%B4%9B%E8%B0%B7P6025%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/05/OI/%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/%E6%B4%9B%E8%B0%B7P6025%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">洛谷P6025题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-05 11:56:36" itemprop="dateCreated datePublished" datetime="2022-08-05T11:56:36+08:00">2022-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:58:15" itemprop="dateModified" datetime="2025-02-16T17:58:15+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="洛谷p6025-题解">洛谷P6025 题解</h2>
<p>提供一个复杂度为的 <span class="math inline">\(O(\log n)\)</span>
的，基于正常分析而非打表的做法，我认为这个做法比当前题解区的所有做法更加优美。</p>
<p>这道题相当不错，考察了线段树和位运算的理解。</p>
<h3 id="题意">题意</h3>
<ul>
<li><p>一颗常规方式构建的线段树，求大小为 <span
class="math inline">\(1,2,3,\cdots n\)</span>
的线段树分别占用的最大空间，即最大下标。</p></li>
<li><p>输出答案的异或和。</p></li>
<li><p><span class="math inline">\(n\leq 10^{15}\)</span></p></li>
</ul>
<p>构建代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">		<span class="comment">//e.g. tree[k]=a[l]</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(k&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">	<span class="comment">//e.g. tree[k]=tree[k&lt;&lt;1]+tree[k&lt;&lt;1|1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原题意是求 <span
class="math inline">\(f(l,r)\)</span>，但很容易转化为求 <span
class="math inline">\(f(1,n)\)</span>，直接求 <span
class="math inline">\(f(1,l-1)\bigoplus f(1,r)\)</span>
即可。</strong></p>
<h3 id="分析">分析</h3>
<h4 id="pts">40PTS</h4>
<p>首先，线段树建立的过程，就是<strong>从根往下走的过程</strong>，往左走，向当前编号的二进制表示后写一个
<span class="math inline">\(0\)</span>，往右走，就写一个 <span
class="math inline">\(1\)</span>。</p>
<p>考虑线段树的最大下标在何处取到，由于右儿子下标相对较大，一个比较显然的想法是一直走右儿子，但是这样是错误的，显然的反例为
<span class="math inline">\(n=3\)</span>，如下图所示。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/7aesc0yg.png" /></p>
<p>这个例子中，<span class="math inline">\([1,3]\)</span>
节点的左儿子比右儿子多一层，所以出现了走左儿子最优的情况。</p>
<p><strong>但是，如果某个节点处左右儿子高度相同，那么很显然应该走右儿子，因为当前这一步决定的位数是最高位。</strong></p>
<p>所以走左儿子，当且仅当左右儿子高度不同，下面分析线段树的高度和长度的关系。</p>
<p>首先，子树构建情况<strong>只和长度有关</strong>，所以我们<strong>只关心长度而非左右端点</strong>，然后，长度为
<span class="math inline">\(2^k\)</span>
的节点，构建出的树为一颗完全二叉树，其高度为 <span
class="math inline">\(k\)</span>。 此时，如果点数继续增大，那么高度为
<span class="math inline">\(k\)</span>
的树就无法容下这么多节点，高度会变为 <span
class="math inline">\(k+1\)</span>，所以，长度为 <span
class="math inline">\((2^k,2^{k+1}]\)</span> 的节点，构建出子树的高度为
<span class="math inline">\({k+1}\)</span>。</p>
<p>容易发现，常规构建方式构建出的子树，其<strong>左儿子的大小不小于右儿子，且差值至多为
1</strong>，因此，如果出现了左右儿子高度不同，一定是左儿子比右儿子高，并且只能是一种情况，即长度的二进制表示为
<span
class="math inline">\(100001\)</span>。即除了最高位和最低位其余位均为
<span
class="math inline">\(0\)</span>，只有这样才会出现左右儿子落在不同区间的情况。</p>
<p>所以我们对于一个 <span
class="math inline">\(n\)</span>，很容易给出一个 <span
class="math inline">\(O(\log n)\)</span> 的计算方式，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> now=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> now;</span><br><span class="line">	<span class="keyword">if</span>(__builtin_popcount(x)==<span class="number">2</span>&amp;&amp;x&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">ask</span>(x<span class="number">+1</span>&gt;&gt;<span class="number">1</span>,now*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ask</span>(x&gt;&gt;<span class="number">1</span>,now*<span class="number">2</span><span class="number">+1</span>);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>__builtin_popcount()</code> 为内置函数，参数为
<code>unsigned</code>， <code>int</code> 也可以使用但不能为负数。</p>
<p>如果希望对 <code>long long</code> 使用，应改为
<code>_builtin_popcountll()</code>。</p>
<p>对每个数暴力求解即可。</p>
<h4 id="pts-1">100PTS</h4>
<p>我们需要观察求解一个数的过程，不妨考虑二进制数 <span
class="math inline">\(1001011\)</span> 的计算过程。</p>
<p>手动模拟一下上述 <span
class="math inline">\(\operatorname{ask()}\)</span>
函数的调用过程，<span class="math inline">\(now\)</span> 变量和 <span
class="math inline">\(x\)</span> 变量的值依次变为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now=00000001 x=1001011</span><br><span class="line">now=00000011 x=0100101</span><br><span class="line">now=00000111 x=0010010</span><br><span class="line">now=00001111 x=0001001</span><br><span class="line">now=00011110 x=0000101</span><br><span class="line">now=00111100 x=0000011</span><br><span class="line">now=01111000 x=0000010</span><br><span class="line">now=11110001 x=0000001</span><br></pre></td></tr></table></figure>
<p>容易发现，在出现 <span class="math inline">\(1001\)</span>
这样的情况之前，我们将 <span class="math inline">\(now\)</span>
左移一位并在后面写上了 <span class="math inline">\(1\)</span>，同时将
<span class="math inline">\(x\)</span> 右移一位。</p>
<p>在出现 <span class="math inline">\(1001\)</span> 之后，我们一直在往
<span class="math inline">\(now\)</span> 后面写 <span
class="math inline">\(0\)</span>，而 <span
class="math inline">\(x\)</span> 的变化则是先右移一位并将最后一位改为
<span class="math inline">\(1\)</span>。</p>
<p>而最后 <span class="math inline">\(x\)</span> 从 <span
class="math inline">\(10\)</span> 变为 <span
class="math inline">\(1\)</span> 时，我们在 <span
class="math inline">\(now\)</span> 末尾添加了一个 <span
class="math inline">\(1\)</span>。</p>
<p>不难发现，一个固定的 <span
class="math inline">\(x\)</span>，我们最终得到的占用下标最大值，<strong>仅仅和它二进制表示下的最高位和第二高的为
<span class="math inline">\(1\)</span>
的位有关</strong>，因为在这之前我们一定会添加 <span
class="math inline">\(1\)</span>，而在这之后一定会往后添加 <span
class="math inline">\(0\)</span> 并在最后添加一个 <span
class="math inline">\(1\)</span>。</p>
<p><strong>注意如果为 <span class="math inline">\(2^k\)</span>
这样不存在次高位的数，我们需要特判。</strong></p>
<p>所以我们有了一个比较显然的想法，即枚举二进制下最高位和次高位的位置，统计能取到这两个位置的数的数量，并异或上对应的权值。</p>
<p>这样的复杂度是 <span class="math inline">\(O(\log^2n)\)</span>
的，我们考虑继续优化。</p>
<p>对于二进制下位数小于 <span class="math inline">\(n\)</span>
的二进制下位数的所有数，实际上会有贡献的只有两个值，分别是 <span
class="math inline">\(2^k\)</span> 和 <span
class="math inline">\(2^k+1\)</span>。因为<strong>如果次高位不为第一位，那么能取到该值的数的个数一定为偶数个（低于次高位的位置可以任意填）</strong>。剩下这两个值的贡献都是可以
<span class="math inline">\(O(1)\)</span> 计算的。</p>
<p>这样就只用考虑二进制下位数和 <span class="math inline">\(n\)</span>
相同的数，同样的道理，如果次高位高于 <span
class="math inline">\(1\)</span>，那么没有贡献，但需要注意的是，如果次高位取到了上界，例如
<span class="math inline">\(10110\)</span> 中，次高位取到了第三位的
<span class="math inline">\(1\)</span>，那么由于必须小于 <span
class="math inline">\(n\)</span>，实际上只有奇数个值可以取到，这样会带来一定的贡献，所以我们需要计算这种情况的答案，复杂度为
<span class="math inline">\(O(\log n)\)</span>。</p>
<p>总复杂度<span class="math inline">\(O(\log n)\)</span>。</p>
<p>可以参考我博客中的一些线段树的总结，会不定期更新。</p>
<p><a
href="https://huanyp.cn/2022/08/04/%E4%BB%8EZKW%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9C%8B%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/">从ZKW线段树看线段树的性质</a></p>
<h3 id="参考代码">参考代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> low(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125; </span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//特判边界情况</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>,h=<span class="built_in">log2</span>(x);</span><br><span class="line">    <span class="comment">//最高位从 10 开始枚举,所以 res 初值应该设置为 1</span></span><br><span class="line">    <span class="comment">//h 为二进制下 x 的位数</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;h;i++)&#123;</span><br><span class="line">		res^=(<span class="number">1ll</span>&lt;&lt;i<span class="number">+1</span>)<span class="number">-1</span>;</span><br><span class="line">		res^=(<span class="number">1ll</span>&lt;&lt;i<span class="number">+1</span>)<span class="number">+1</span>;</span><br><span class="line">        <span class="comment">//注意左移操作的 1 是 long long 级别的数</span></span><br><span class="line">        <span class="comment">//计算 2^k 和 2^k+1 的答案,其它位置没有贡献 </span></span><br><span class="line">	&#125;</span><br><span class="line">	res^=(<span class="number">1ll</span>&lt;&lt;h<span class="number">+1</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//计算 2^h 的答案</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">low</span>(x)==x)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//如果 x=2^h,无需进行下面的步骤</span></span><br><span class="line">	res^=(<span class="number">1ll</span>&lt;&lt;h<span class="number">+1</span>)<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x<span class="number">-1</span>==<span class="number">1ll</span>&lt;&lt;h||x&amp;<span class="number">1</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//如果 x=2^h+1 或者末尾为 1,那么之后取到的值个数一定是偶数,无需计算。</span></span><br><span class="line">	<span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(__builtin_popcountll(x)&gt;<span class="number">2</span>||(x&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">		now=now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//模拟求解的第一步,找到对应的次高位,在这之前往后写 1</span></span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		now&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//模拟求解第二步,往后写 0</span></span><br><span class="line">	now|=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//记得左右还需要异或 1</span></span><br><span class="line">	<span class="keyword">return</span> res^now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="built_in">read</span>(l),<span class="built_in">read</span>(r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(r)^<span class="built_in">solve</span>(l<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/08/05/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8BCPU%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96-%E7%AC%AC%E4%BA%8C%E5%BC%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/05/OI/%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8BCPU%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96-%E7%AC%AC%E4%BA%8C%E5%BC%B9/" class="post-title-link" itemprop="url">从一道题看CPU底层优化-第二弹</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-05 10:30:33" itemprop="dateCreated datePublished" datetime="2022-08-05T10:30:33+08:00">2022-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:53:16" itemprop="dateModified" datetime="2025-02-16T17:53:16+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="题意">题意</h3>
<ul>
<li><p>给定一个序列 <span class="math inline">\(a\)</span>，长度为 <span
class="math inline">\(2^n\)</span>，每次询问给定 <span
class="math inline">\(mask\)</span>，询问 <span
class="math inline">\(b_i=a_{i\bigoplus mask}\)</span> 得到的 <span
class="math inline">\(b\)</span> 序列的最大字段和。</p></li>
<li><p><span class="math inline">\(n\leq 18,q\leq 2\times
10^5\)</span></p></li>
<li><p>原题意参考<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1716/problem/E">题意</a>，这里做了一些不影响做题的转化。</p></li>
</ul>
<h3 id="思考">思考</h3>
<p>我们发现可以类似于线段树一样的去维护最大子段和，即考虑对一层维护其所有可能的交换序列的信息，然后计算一个<strong>节点左右儿子构成的区间</strong>的最大子段和，这样是可以得到正确答案的。</p>
<p>不难发现我们只需要知道一层的<strong>前缀和最大值和最小值</strong>就可以完成向上传递，这样的信息量是
<span class="math inline">\(O(1)\)</span> 的，对于第 <span
class="math inline">\(i\)</span>
层，会影响它的值的只有它下面的状态，因为上面的状态如何不影响该层最大值和最小值的位置，因此不会影响其计算答案的结果。</p>
<p>因此很容易设计出一个 <span class="math inline">\(O(2^n\times
n)\)</span> 的做法，但是我觉得它有点难写。</p>
<p>所以我们考虑只分两层，预处理第一层的前缀和和最大值位置，最小值位置，扫描第二层计算答案，这样的话，复杂度为
<span class="math inline">\(O(2^{\frac{3n}{2}})\)</span> ，约为 <span
class="math inline">\(1.25\times 10^8\)</span>，能卡在边界上。</p>
<h3 id="实现1">实现1</h3>
<p>这是我们的第一份代码，得到了 TLE19 的成绩。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1</span>&lt;&lt;N],ans[<span class="number">1</span>&lt;&lt;N],mx[<span class="number">1</span>&lt;&lt;N],mi[<span class="number">1</span>&lt;&lt;N],sum[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mask1=<span class="number">0</span>;mask1&lt;<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>;mask1++)&#123;</span><br><span class="line">		<span class="type">int</span> gap=<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>,max_val=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i+=gap)&#123;</span><br><span class="line">			mi[i]=mx[i]=i;sum[i]=a[i^mask1],<span class="built_in">cmax</span>(max_val,sum[i]);</span><br><span class="line">			<span class="keyword">for</span>(j=i<span class="number">+1</span>;j&lt;i+gap;j++)&#123;</span><br><span class="line">				sum[j]=sum[j<span class="number">-1</span>]+a[j^mask1];</span><br><span class="line">				<span class="keyword">if</span>(sum[j]&gt;sum[mx[i]])mx[i]=j;</span><br><span class="line">				<span class="keyword">if</span>(sum[j]&lt;sum[mi[i]])mi[i]=j;</span><br><span class="line">				<span class="built_in">cmax</span>(max_val,sum[j]-sum[mi[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> mask2=<span class="number">0</span>;mask2&lt;<span class="number">1</span>&lt;&lt;n;mask2+=gap)&#123;</span><br><span class="line">			ans[mask2^mask1]=max_val;</span><br><span class="line">			<span class="type">int</span> min_val=<span class="number">0</span>,sm=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i+=gap)&#123;</span><br><span class="line">				<span class="built_in">cmax</span>(ans[mask2^mask1],sm+sum[mx[i^mask2]]-min_val);</span><br><span class="line">				<span class="built_in">cmin</span>(min_val,sm+sum[mi[i^mask2]]);</span><br><span class="line">				sm+=sum[(i+gap<span class="number">-1</span>)^mask2];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> q;<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">		<span class="built_in">read</span>(tp1);s^=<span class="number">1</span>&lt;&lt;tp1;</span><br><span class="line">		cout&lt;&lt;ans[s]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="常数分析1">常数分析1</h3>
<p>我们最开始对 <span class="math inline">\(a\)</span> 进行了 <span
class="math inline">\(512\)</span> 次乱序扫描，但容易发现一共进行了
<span class="math inline">\(512\times512\)</span>
次每次扫描的区间大小均为 <span class="math inline">\(512\times4\)</span>
Byte 的扫描，这种方式可以比较好的利用高速缓存，因为被一次 cacheline
读取的 64Byte 数据都被放入了高速缓存并在时间上具有局部性。</p>
<p>注意到第二部分对 <code>sum</code> 计算的前缀和，由于 L3
高速缓存的约能存下 <span class="math inline">\(2^{18}\)</span> 个
<code>long long</code> 数据，但是我们又存储了
<code>sum</code>，并且在第三部分有对 <code>sum</code>
一些固定位置的随机访问，因此，<code>a</code>
数组就被踢出了高速缓存，再次访问的时候需要重复读取，造成了相当大的浪费。</p>
<p>事实上，我们并不需要存储每一个
<code>sum</code>，每一个块需要存储的数据量是 <span
class="math inline">\(O(1)\)</span>
的，对这个做一个优化，我们得到了一份新的代码。</p>
<h3 id="实现2">实现2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 y3647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(_type &amp;x)</span></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch!=<span class="number">45</span>&amp;&amp;(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>))ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="number">45</span>)&#123;f=<span class="number">-1</span>,ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmin</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _type1,<span class="keyword">typename</span> _type2&gt;<span class="function"><span class="type">void</span> <span class="title">cmax</span><span class="params">(_type1 &amp;a,<span class="type">const</span> _type2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> i,j,k,n,s,t,m,tp1,tp2;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line">LL mx[<span class="number">1</span>&lt;&lt;N/<span class="number">2</span>],mi[<span class="number">1</span>&lt;&lt;N/<span class="number">2</span>],sum[<span class="number">1</span>&lt;&lt;N/<span class="number">2</span>],ans[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;.in&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mask1=<span class="number">0</span>;mask1&lt;<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>;mask1++)&#123;</span><br><span class="line">		LL gap=<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>,max_val=<span class="number">0</span>,m=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(mx,<span class="number">0</span>,<span class="built_in">sizeof</span>(mx)),<span class="built_in">memset</span>(mi,<span class="number">0</span>,<span class="built_in">sizeof</span>(mi));</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i+=gap)&#123;</span><br><span class="line">			LL sm=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=i;j&lt;i+gap;j++)&#123;</span><br><span class="line">				sm+=a[j^mask1];</span><br><span class="line">				<span class="keyword">if</span>(sm&gt;mx[i&gt;&gt;m])mx[i&gt;&gt;m]=sm;</span><br><span class="line">				<span class="keyword">if</span>(sm&lt;mi[i&gt;&gt;m])mi[i&gt;&gt;m]=sm;</span><br><span class="line">				<span class="built_in">cmax</span>(max_val,sm-mi[i&gt;&gt;m]);</span><br><span class="line">			&#125;</span><br><span class="line">			sum[i&gt;&gt;m]=sm;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> mask2=<span class="number">0</span>;mask2&lt;<span class="number">1</span>&lt;&lt;n;mask2+=gap)&#123;</span><br><span class="line">			ans[mask2^mask1]=max_val;</span><br><span class="line">			LL min_val=<span class="number">0</span>,sm=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i+=gap)&#123;</span><br><span class="line">				<span class="built_in">cmax</span>(ans[mask2^mask1],sm+mx[(i^mask2)&gt;&gt;m]-min_val);</span><br><span class="line">				<span class="built_in">cmin</span>(min_val,sm+mi[(i^mask2)&gt;&gt;m]);</span><br><span class="line">				sm+=sum[(i^mask2)&gt;&gt;m];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> q;<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">		<span class="built_in">read</span>(tp1);</span><br><span class="line">		s^=<span class="number">1</span>&lt;&lt;tp1;</span><br><span class="line">		cout&lt;&lt;ans[s]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="常数分析2">常数分析2</h3>
<p>我们将 <code>a</code> 从 <code>long long</code> 改为了
<code>int</code>，提升了 cacheline 读取效率，并只额外存储了 <span
class="math inline">\(512\times3\times8 \text{ Byte}\)</span>
的块信息，这样在以后的计算中，对大数组的随机访问可以变为对小数组的访问，大大提升了高速缓存利用率。</p>
<p>可以通过此题。</p>
<h3 id="further-explore">Further Explore</h3>
<p>继续对代码进行修改，观察其时间变化。</p>
<p>最初代码用时为 <code>1450ms</code></p>
<h4 id="e1">E1</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LL sm=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;i+gap;j++)&#123;</span><br><span class="line">    sm+=a[j^mask1];</span><br><span class="line">    <span class="keyword">if</span>(sm&gt;mx[i&gt;&gt;m])mx[i&gt;&gt;m]=sm;</span><br><span class="line">    <span class="keyword">if</span>(sm&lt;mi[i&gt;&gt;m])mi[i&gt;&gt;m]=sm;</span><br><span class="line">    <span class="built_in">cmax</span>(max_val,sm-mi[i&gt;&gt;m]);</span><br><span class="line">&#125;</span><br><span class="line">sum[i&gt;&gt;m]=sm;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum[i&gt;&gt;m]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;i+gap;j++)&#123;</span><br><span class="line">    sum[i&gt;&gt;m]+=a[j^mask1];</span><br><span class="line">    <span class="keyword">if</span>(sum[i&gt;&gt;m]&gt;mx[i&gt;&gt;m])mx[i&gt;&gt;m]=sum[i&gt;&gt;m];</span><br><span class="line">    <span class="keyword">if</span>(sum[i&gt;&gt;m]&lt;mi[i&gt;&gt;m])mi[i&gt;&gt;m]=sum[i&gt;&gt;m];</span><br><span class="line">    <span class="built_in">cmax</span>(max_val,sum[i&gt;&gt;m]-mi[i&gt;&gt;m]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>预期效率降低，原因为全局变量不会放入寄存器。</p>
<p>实际效率未降低，原因推测为 <span class="math inline">\(O2\)</span>
优化自动使用了该优化。</p>
<p>继续进行本机测试，共 <code>9</code> 次随机数据，运行时间分别为
<code>16339ms 16339ms</code>，符合预期，不开启优化时，全局变量一定不会放入寄存器。</p>
<h4 id="e2">E2</h4>
<p><code>a</code> 数组改为 <code>long long</code> 类型。</p>
<p>预期由于高速缓存溢出，效率下降，实际未发生效率下降，应该是不明高速缓存机制原因。</p>
<h4 id="defin-int-long-long">#defin int long long</h4>
<p>预期由于高速缓存溢出，效率下降，<code>64bit</code>
编译器和机子，实际效率有提升，<code>9</code> 组时间分别为
<code>16636ms 16167ms</code>。</p>
<p>开启 <code>O2</code> 后无明显差异，分别为
<code>5577ms 5561ms</code></p>
<p><code>32bit</code> 编译器，<code>64bit</code> 机子，<code>O2</code>
效率出现明显下降，分别为 <code>11839ms 14920ms</code></p>
<h3 id="conclusion">Conclusion</h3>
<ul>
<li>O2
优化后，编译器会自动完成很多代码层面上的优化，我们更需要关注的是算法常数本身</li>
<li>高速缓存的利用情况很大程度决定了代码的效率，编写需要卡常的程序时应该尤为注意，滚动数组能有效提升高速缓存利用率，分块处理减少数组大小也是提升效率的一种可行方案。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/08/04/OI/%E7%AE%97%E6%B3%95/%E4%BB%8EZKW%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9C%8B%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/04/OI/%E7%AE%97%E6%B3%95/%E4%BB%8EZKW%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9C%8B%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/" class="post-title-link" itemprop="url">从ZKW线段树看线段树的性质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-04 20:40:11" itemprop="dateCreated datePublished" datetime="2022-08-04T20:40:11+08:00">2022-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:54:33" itemprop="dateModified" datetime="2025-02-16T17:54:33+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="从zkw线段树看线段树的性质">从ZKW线段树看线段树的性质</h2>
<p>最近遇到了很多线段树性质相关的题目，故在此做一个总结。</p>
<h3 id="常规建树">常规建树</h3>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性质">性质</h4>
<ul>
<li>左儿子长度不小于右儿子。</li>
<li>节点编号 <code>rt</code>
描述了从根到自身的父子关系，也间接描述了该点长度和根节点长度的关系，具体的，根节点的最大或最小长度是一个关于该节点长度的一次函数，这个一次函数只由
<code>rt</code> 决定。</li>
<li>编号最大的节点不一定是 <code>r</code>，事实上可以在 <span
class="math inline">\(\log n\)</span>
的时间内求出，如果左儿子多一层，那么一定在左儿子，否则在右儿子，<strong>决定某个儿子是否会多一层，当且仅当目前长度为奇数，且
popcount 值为 2</strong>。</li>
</ul>
<h4 id="例题">例题</h4>
<p><a
target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=7204">一道简单的题</a></p>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6025">一道比较简单的题</a></p>
<h3 id="非常规建树">非常规建树</h3>
<p>非常规建树一般会指定建树的 <code>mid</code> 位置。</p>
<h4 id="区间覆盖数">区间覆盖数</h4>
<p>即覆盖一个区间 <span class="math inline">\([l,r]\)</span>
的最小线段数。</p>
<p>先转成 <span class="math inline">\((l,r)\)</span>，然后依次跳叶节点
<span class="math inline">\(l,r\)</span> 的父亲，先判断 <span
class="math inline">\(l,r\)</span>
的父亲是否相同，相同就可以走人了。</p>
<p>如果 <span class="math inline">\(l\)</span>
作为左儿子跳上去，那么该节点的右儿子会对该区间贡献一次，因为该节点的右儿子的父亲超出了区间，但自身在区间内。如果
<span class="math inline">\(r\)</span>
作为右儿子跳上去，那么该节点的左儿子会对区间贡献一次，原因同理，如此就可以找到区间覆盖数，这也是
ZKW线段树 的原理。</p>
<h4 id="例题-1">例题</h4>
<p>给定一个指定 <code>mid</code> 节点的线段树，需要支持
<code>rotate</code> 一个节点，<code>rotate</code> 定义为伸展树(splay)的
<code>rotate</code>，强制在线询问区间覆盖数。</p>
<p>先考虑没有修改，那么就是找到 <span class="math inline">\(l,r\)</span>
的 <span class="math inline">\(lca\)</span>，然后一路统计 <span
class="math inline">\(l\)</span>，<span class="math inline">\(r\)</span>
作为左右儿子的次数即可，可以用倍增快速解决。</p>
<p>修改本质上就是断边和加边，用 LCT 维护。</p>
<h3 id="zkw线段树简介">ZKW线段树简介</h3>
<h4 id="建树">建树</h4>
<p>为了方便，需要建一棵有 <span class="math inline">\(2^k\)</span>
个节点的树，主要是为了让高度相同，求出第一个不小于 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(2\)</span>
的次幂的方式：<code>k=32-__builtin_clz(n-1)</code>。</p>
<p><strong>建树时注意没有数据的地方应该弄成
"0"，且注意初始数组大小，并且要开 <span
class="math inline">\(2^k+5\)</span> 以免溢出。</strong></p>
<p>建树时记录单点的编号。</p>
<h4 id="单点修改">单点修改</h4>
<p>直接从下往上改就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    a[rt].mx1=c;<span class="keyword">while</span>(rt!=<span class="number">1</span>)<span class="built_in">push_up</span>(rt&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间查询">区间查询</h4>
<p>个人习惯闭区间，且有效区间落在 <span
class="math inline">\([1,n]\)</span>。</p>
<p>查询时看是否为兄弟节点，如果是就停下，否则对于左端点，是左子树则加上兄弟右子树。对于右端点，是右子树则加上兄弟左子树。<strong>另外需要加上两个端点。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> lrt,<span class="type">int</span> rrt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lrt==rrt)<span class="keyword">return</span> a[lrt];</span><br><span class="line">    node ret=a[lrt]+a[rrt];</span><br><span class="line">    <span class="keyword">while</span>(lrt&gt;&gt;<span class="number">1</span>!=rrt&gt;&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(~lrt&amp;<span class="number">1</span>)ret=ret+a[lrt<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">if</span>(rrt&amp;<span class="number">1</span>)ret=ret+a[rrt<span class="number">-1</span>];</span><br><span class="line">        lrt&gt;&gt;=<span class="number">1</span>,rrt&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意特判区间长度为 <span class="math inline">\(1\)</span>
的情况。</strong></p>
<h4 id="区间修改">区间修改</h4>
<p>由于是从下往上查询，所以只能采用标记永久化的方式，像查询那样做修改，在对应的点上打
Tag。</p>
<h4 id="效率">效率</h4>
<p>对于 <span class="math inline">\(10^5,3\times 10^5,10^6\)</span>
的随机数据进行了测试，效率改进因子约为 <span
class="math inline">\(0.4\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://huanyp.cn/2022/08/03/OI/%E7%AE%97%E6%B3%95/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%92%8C%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/03/OI/%E7%AE%97%E6%B3%95/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%92%8C%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">简单数论函数和应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-03 13:27:13" itemprop="dateCreated datePublished" datetime="2022-08-03T13:27:13+08:00">2022-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:55:29" itemprop="dateModified" datetime="2025-02-16T17:55:29+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简单数论函数和应用">简单数论函数和应用</h1>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/number-theory/mobius/">OI-WIKI
莫比乌斯反演</a></li>
<li><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/poly/dgf/#dirichlet">OI-WIKI
迪利克雷卷积</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/An-Amazing-Blog/ji-miao-di-mu-bi-wu-si-fan-yan">从莫比乌斯到欧拉</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">莫比乌斯反演-从基础开始</a></li>
</ul>
<h2 id="部分定义和约定">部分定义和约定</h2>
<h3 id="符号">符号</h3>
<ul>
<li><span class="math inline">\(\operatorname{id}\)</span> ：<span
class="math inline">\(\operatorname{id}\)</span> 数论函数，<span
class="math inline">\(\operatorname{id}(x)=x\)</span></li>
<li><span class="math inline">\(\epsilon\)</span> : 单位函数 <span
class="math inline">\(\epsilon(x)=[x=1]\)</span></li>
<li><span class="math inline">\([]\)</span>
：中扩号表达式，中扩号内条件成立则为 <span
class="math inline">\(1\)</span>，否则为 <span
class="math inline">\(0\)</span></li>
<li><span class="math inline">\(\boldsymbol{1}\)</span>：<span
class="math inline">\(\boldsymbol{1}\)</span> 函数，若 <span
class="math inline">\(f(n)=\boldsymbol{1}\)</span>，则 <span
class="math inline">\(\forall x \in N^+,f(x)=1\)</span></li>
</ul>
<h3 id="数论函数">数论函数</h3>
<ul>
<li><p>一个数论函数定义域为正整数，值域为复数。</p></li>
<li><p>一个数论函数为积性函数，当且仅当 <span
class="math inline">\(\forall (a,b),\gcd(a,b)=1\rightarrow f(a\times
b)=f(a)\times f(b)\)</span></p></li>
<li><p>一个数论函数为完全积性函数，当且仅当 <span
class="math inline">\(\forall a,b,f(a\times b)=f(a)\times
f(b)\)</span></p></li>
</ul>
<h3 id="迪利克雷卷积">迪利克雷卷积</h3>
<p>迪利克雷卷积为数论函数的乘法操作，定义两个数论函数的迪利克雷卷积定义为
<span class="math display">\[
g=f*h,g(n)=\sum\limits_{d|n} f(d)\times h(\frac{n}{d})
\]</span></p>
<p>迪利克雷卷积的除法操作就是逆操作，一般只能构造得到。</p>
<p>迪利克雷卷积的性质（证明见下一部分）：</p>
<ul>
<li>两个积性函数的迪利克雷卷积仍是积性函数。</li>
<li>两个积性函数的迪利克雷卷积除法结果仍是积性函数。</li>
</ul>
<p><strong>为了方便，以下所有数论函数的乘法未经说明均为迪利克雷卷积。</strong></p>
<h3 id="常见积性函数">常见积性函数</h3>
<ul>
<li>欧拉函数 <span class="math inline">\(\phi(n)\)</span></li>
<li>莫比乌斯函数 <span class="math inline">\(\mu(n)\)</span></li>
<li>约数个数函数 <span class="math inline">\(d(n)\)</span></li>
</ul>
<h2 id="一些结论的简单证明">一些结论的简单证明</h2>
<h3 id="迪利克雷卷积的性质">迪利克雷卷积的性质</h3>
<h4 id="简单性质">简单性质</h4>
<ul>
<li>积性函数 <span class="math inline">\(f\)</span>，满足 <span
class="math inline">\(f(1)=1\)</span></li>
</ul>
<h4 id="逆元存在且唯一">逆元存在且唯一</h4>
<p>所有数论函数存在逆元，即对于所有 <span
class="math inline">\(f\)</span>，存在 <span
class="math inline">\(g\)</span> 使得 <span
class="math inline">\(f*g=\epsilon\)</span>，直接构造对应的 <span
class="math inline">\(g(n)\)</span> 即可。 <span class="math display">\[
g(n)=-\dfrac{\sum\limits_{d|n,d\neq n}{f(d)\times
g(\frac{n}{d})}}{f(1)}\\
g(1)=\frac{1}{f(1)}
\]</span> 因此数论函数的逆元存在且唯一。</p>
<h4 id="交换律">交换律</h4>
<p><span class="math inline">\(f * g=g * f\)</span>，显然成立</p>
<h4 id="结合律">结合律</h4>
<p><span class="math inline">\(f * g * h=f * (g *
h)\)</span>，成立，但不显然。</p>
<p>令 <span class="math inline">\(f * g * h=f_1,f * (g * h)=f_2,f *
g=a,g * h=h * g=b\)</span> <span class="math display">\[
f_1(n)=\sum\limits_{d_1|n} a(d_1)\times
h(\frac{n}{d_1})=\sum\limits_{d_1|n}\sum\limits_{d_2|d_1} f(d_2)\times
g(\frac{d_1}{d_2})\times h(\frac{n}{d_1})
\]</span></p>
<p><span class="math display">\[
f_2(n)=\sum\limits_{d_1|n} b(d_1)\times
f(\frac{n}{d_1})=\sum\limits_{d_1|n}\sum\limits_{d_2|d_1} h(d_2)\times
g(\frac{d_1}{d_2})\times f(\frac{n}{d_1})
\]</span> 对于任意一组满足 <span
class="math inline">\(d_1|n,d_2|d_1\)</span> 的 <span
class="math inline">\(d_1,d_2\)</span>，构造 <span
class="math inline">\(d_2&#39;=\frac{n}{d_1},d_1&#39;=\frac{n}{d_2}\)</span>
，容易发现这样的构造是一一对应的，满足 <span
class="math inline">\(f(d_2)\times g(\frac{d_1}{d_2})\times
(\frac{n}{d_1})=f(\frac{n}{d_1&#39;}) \times
g(\frac{d_1&#39;}{d_2&#39;}) \times h(d_2&#39;))\)</span> 。</p>
<p>因此对于上式中的每一项，下式都有一项与之一一对应，因此上下式相等。</p>
<h4 id="分配律">分配律</h4>
<p><span class="math inline">\(f*(g+h)=f*g+f*h\)</span></p>
<p>显然成立。</p>
<h4
id="两个积性函数的迪利克雷卷积为积性函数">两个积性函数的迪利克雷卷积为积性函数</h4>
<p><span class="math inline">\(f,h\)</span> 为积性函数，则 <span
class="math inline">\(f*g=h\)</span>，<span
class="math inline">\(h\)</span> 为积性函数。</p>
<p><span class="math inline">\(\forall a,b \ , \gcd(a,b)=1\ ,h(a\times
b)=h(a)\times h(b)\)</span>，满足 <span class="math display">\[
\begin{align}
h(a\times b)=&amp;\sum\limits_{d_1|a}\sum\limits_{d_2|b}f(d_1\times
\frac{b}{d_2})\times g(\frac{a}{d_1}\times d_2)\\
=&amp;\sum\limits_{d_1|a}\sum\limits_{d_2|b}f(d_1)\times
f(\frac{b}{d_2})\times g(\frac{a}{d_1})\times g( d_2)\\
=&amp;\sum\limits_{d_1|a} f(d_1)\times
g(\frac{a}{d_1})\sum\limits_{d_2|b} f(\frac{b}{d_2})\times g(d_2)\\
=&amp;h(a)\times h(b)
\end{align}
\]</span></p>
<h4
id="两个积性函数的迪利克雷卷积除法为积性函数">两个积性函数的迪利克雷卷积除法为积性函数</h4>
<p>证明 <span class="math inline">\(f,h\)</span> 为积性函数，且 <span
class="math inline">\(h*g=f\)</span>，则 <span
class="math inline">\(g\)</span> 为积性函数。</p>
<p>令 <span class="math inline">\(h&#39;*h=\epsilon\)</span>，则 <span
class="math inline">\(g=f*h&#39;\)</span></p>
<p>即证明积性函数的逆元也为积性函数。</p>
<p><a
target="_blank" rel="noopener" href="https://oi-wiki.org/math/poly/dgf/#%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%86%E5%85%83%E4%B9%9F%E6%98%AF%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0">证明</a></p>
<p>使用了数学归纳法。</p>
<h4 id="完全积性函数相关">完全积性函数相关</h4>
<p>若 <span class="math inline">\(w\)</span> 是完全积性函数，则 <span
class="math display">\[
(g\cdot w) * (f \cdot w) = (g * f)\cdot w
\]</span></p>
<h3 id="常见的积性函数关系">常见的积性函数关系</h3>
<ul>
<li><span class="math inline">\(\mu*
\boldsymbol{1}=\epsilon\)</span></li>
<li><span class="math inline">\(\phi*
\boldsymbol{1}=\operatorname{id}\)</span></li>
<li><span class="math inline">\(\mu * \operatorname{id} =
\phi\)</span></li>
</ul>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p><strong>莫比乌斯反演的常见做法是用其它易于交换求和符号的项替换掉不容易求和的相关项。</strong></p>
<p>不容易交换求和的项一般有 <span class="math inline">\(d,\gcd\)</span>
等。</p>
<h3 id="数论分块">数论分块</h3>
<p>莫比乌斯反演或者其它数数题中常用的优化方式。</p>
<p>核心原理是对于 <span class="math inline">\([1,n]\)</span> 中所有数
<span class="math inline">\(i\)</span>，<span
class="math inline">\(\frac{n}{i}\)</span> 的结果只有 <span
class="math inline">\(\sqrt{n}\)</span> 个。</p>
<p>证明是容易的，对于 <span
class="math inline">\([1,\sqrt{n}]\)</span>，一共有 <span
class="math inline">\(\sqrt{n}\)</span> 个值，对于 <span
class="math inline">\([\sqrt{n},n]\)</span>，一共也只有 <span
class="math inline">\(\sqrt{n}\)</span> 个值。</p>
<p>枚举的方式是先枚举一个 <span
class="math inline">\(l\)</span>，然后计算出一个最大的 <span
class="math inline">\(r\)</span>，满足 <span
class="math inline">\(\frac{n}{r}=\frac{n}{l}\)</span>，容易证明 <span
class="math inline">\(r=\big\lfloor\dfrac{n}{\lfloor\frac{n}{l}\rfloor}\big\rfloor\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=n;l=r<span class="number">+1</span>,r=n/(n/l))&#123;</span><br><span class="line">	<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫比乌斯函数">莫比乌斯函数</h3>
<h4 id="定义">定义</h4>
<p><span class="math display">\[
\mu(n)=
\begin{cases}
1&amp;n=1\\
0&amp;n\text{ 含有平方因子}\\
(-1)^k&amp;k\text{ 为 }n\text{ 的本质不同质因子个数}\\
\end{cases}
\]</span></p>
<h4 id="muboldsymbol1epsilon"><span
class="math inline">\(\mu*\boldsymbol{1}=\epsilon\)</span></h4>
<p>这是核心结论了。</p>
<p>考虑证明 <span class="math inline">\(\forall
n&gt;1,\mu(n)=0\)</span>。</p>
<p>考虑每个约数的贡献，显然每个质因子只需要考虑一次，如果质因子出现多次，那么根据定义贡献为
<span class="math inline">\(0\)</span>。</p>
<p>设有 <span class="math inline">\(k\)</span>
个质因子，那么选出奇数个和选出偶数个的方案显然是相等的，所以和为 <span
class="math inline">\(0\)</span>。</p>
<h3 id="莫比乌斯反演-1">莫比乌斯反演</h3>
<h4 id="一般形式">一般形式</h4>
<p><span class="math display">\[
\begin{align}
f*\bold{1}=g\iff&amp; g*\mu=f \\
g(n)=\sum\limits_{d|n}f(d)\iff&amp; f(n)=\sum\limits_{d|n}\mu(d)\times
g(\frac{n}{d})
\end{align}
\]</span></p>
<p>证明是显然的，因为 <span
class="math inline">\(\boldsymbol{1}*\mu=\epsilon\)</span></p>
<h4 id="常用">常用</h4>
<p><span
class="math inline">\([\gcd(i,j)=1]=\sum\limits_{d|\gcd(i,j)}\mu(d)\)</span></p>
<p>枚举 <span class="math inline">\(d\)</span>，即可快速计算。</p>
<h4 id="欧拉反演">欧拉反演</h4>
<p>名字是<a target="_blank" rel="noopener" href="https://0x131cc05.github.io/">杰哥</a>取的。</p>
<h5 id="常用形式">常用形式</h5>
<p><span
class="math inline">\(\gcd(i,j)=\sum\limits_{d|\gcd(i,j)}\phi(d)\)</span></p>
<h5 id="证明">证明</h5>
<p>即证明 <span
class="math inline">\(\phi*\boldsymbol{1}=\operatorname{id}\)</span>
。</p>
<p>我们只需要证明 <span
class="math inline">\(\phi*\boldsymbol{1}\)</span> 在 <span
class="math inline">\(p^c\)</span> 处取值为 <span
class="math inline">\(\operatorname{id}(p^c)\)</span>，由于 <span
class="math inline">\(\phi,\boldsymbol{1},\operatorname{id}\)</span>
均为积性函数，自然在所有位置成立。 <span class="math display">\[
\begin{align}
(\phi*\boldsymbol{1})(p^c)=&amp;1+\sum _{i=1}^{c} (p-1)\times p^{i-1}\\
=&amp; 1+\frac{p^c-1}{p-1}\times(p-1)\\
=&amp;p^c\\
=&amp;\operatorname{id}(p^c)
\end{align}
\]</span></p>
<h2 id="筛法">筛法</h2>
<p>介绍四大筛法。</p>
<p>四大筛法通常用于求一些<strong>积性函数</strong>的前缀和。</p>
<p>假设要求 <span class="math inline">\(f\)</span> 的前缀和。</p>
<p>记 <span class="math inline">\(F(n) = \sum\limits_{i=1}^n
f(i),H(n)=\sum\limits_{i=1}^n h(i),G(n)=\sum\limits_{i=1}^n
g(i)\)</span>。</p>
<h3 id="杜教筛">杜教筛</h3>
<p>杜教筛的核心是构造两个容易求前缀和的函数 <span
class="math inline">\(g,h\)</span>，满足 <span class="math inline">\(h =
f * g\)</span>。</p>
<p>有 <span class="math display">\[
\begin{align}
H(n)&amp;=\sum\limits_{i=1}^n h(i)\\
&amp;=\sum_{i=1}^n\sum_{d|i}g(d)f(\frac{i}{d})\\
&amp;=\sum_{d=1}^ng(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} f(i)
\end{align}
\]</span> 将右边 <span class="math inline">\(d\ge 2\)</span>
的项移到左边 <span class="math display">\[
H(n)-\sum\limits_{d=2}^ng(d)F(\lfloor\frac{n}{d}\rfloor)=F(n)g(1)
\]</span> <span class="math inline">\(H(n)\)</span> 是好求的，然后 <span
class="math inline">\(g(1)=1\)</span>，后面的项对 <span
class="math inline">\(n\)</span> 数论分块。</p>
<p>然后有一个结论 <span
class="math inline">\(\big\lfloor\dfrac{\lfloor\frac{n}{a}\rfloor}{b}\big\rfloor=\lfloor\dfrac{n}{ab}\rfloor\)</span>。因此要求的项只有
<span class="math inline">\(\sqrt n\)</span> 项。</p>
<p>线性筛前 <span class="math inline">\(n^\frac{2}{3}\)</span>
项的前缀和，可以取到最优复杂度 <span
class="math inline">\(n^\frac{2}{3}\)</span>。复杂度证明见 OI-WIKI，<a
target="_blank" rel="noopener" href="https://oi-wiki.org/math/number-theory/du/#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E5%89%8D%E7%BC%80%E5%92%8C">证明</a>。</p>
<h3 id="pnpowerful-number-筛">PN(Powerful Number) 筛</h3>
<p>定义 Powerful Number 是每个质因数质数不小于 <span
class="math inline">\(2\)</span> 的数。</p>
<p>如果能构造一个<strong>容易求前缀和的积性函数 <span
class="math inline">\(g(x)\)</span>，满足 <span
class="math inline">\(g(p)=f(p)\)</span></strong>，那么我们就可以在
<span class="math inline">\(O(\sqrt n)\)</span> 的时间复杂度内计算 <span
class="math inline">\(F(n)\)</span>。</p>
<p>具体的，考虑构造 <span class="math inline">\(h = f / g\)</span>，所以
<span class="math inline">\(f(p) = h(1)g(p) + h(p)g(1)\)</span>，由于
<span class="math inline">\(g(p) =f (p)\)</span>，所以有 <span
class="math inline">\(h(p)\)</span> 处取值为 <span
class="math inline">\(0\)</span>，由于 <span
class="math inline">\(g,f,h\)</span> 都是积性函数，所以 <span
class="math inline">\(h\)</span> 仅在 Powerful Number
处有取值，其余处取值为 <span class="math inline">\(0\)</span>。</p>
<p>考虑 <span class="math display">\[
\begin{align}
F(n)&amp;=\sum_{i=1}^nf(i)\\
&amp;=\sum_{i=1}^n\sum_{d|i}h(d)g(\frac{i}{d})\\
&amp;=\sum_{d=1}^nh(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}g(i)
\end{align}
\]</span> 枚举所有 Powerful Number，计算 <span
class="math inline">\(h(d)G(\lfloor\frac{n}{d}\rfloor)\)</span>
即可，Powerful Number 的个数是 <span class="math inline">\(O(\sqrt
n)\)</span> 的。</p>
<p>构造 <span class="math inline">\(h\)</span> 的话，可以直接用 <span
class="math inline">\(g * h =
f\)</span>，并使用卷积的定义构造，当然，<span
class="math inline">\(f(p^c)\)</span> 必须要容易求。</p>
<h3 id="州阁筛">州阁筛</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">huan-yp</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
