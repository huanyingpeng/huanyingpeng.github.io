<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"huanyp.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","display":"post","width_expanded":320,"width_dual_column":240,"padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="幻影彭的彩虹">
<meta property="og:url" content="http://huanyp.cn/index.html">
<meta property="og:site_name" content="幻影彭的彩虹">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="huan-yp">
<meta property="article:tag" content="算法竞赛, 自动化测试, 工程技术, Python">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://huanyp.cn/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>幻影彭的彩虹</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">幻影彭的彩虹</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录青春的扇区</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="huan-yp"
      src="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
  <p class="site-author-name" itemprop="name">huan-yp</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/huan-yp" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huan-yp" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3051561876@qq.com" title="E-Mail → mailto:3051561876@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/1155409006?spm_id_from=333.1369.0.0" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;1155409006?spm_id_from&#x3D;333.1369.0.0" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-12T00:00:00+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:58:41" itemprop="dateModified" datetime="2025-02-16T17:58:41+08:00">2025-02-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><del>在无数久的 🐦咕咕咕 后一个博客它建成了！</del></p>
<p>在无数久的 🐦咕咕咕 后这个博客它复活了！</p>
<p>博客主要会收录这些东西：</p>
<ul>
<li><p>OI/ACM 相关</p>
<ul>
<li>考试技巧</li>
<li>题解</li>
<li>算法理解</li>
</ul></li>
<li><p>学习笔记</p></li>
<li><p>面向各种人群的科普</p></li>
<li><p>我的开源项目</p></li>
<li><p>生活中有趣的事</p></li>
<li><p>一些奇思妙想</p></li>
</ul>
<p>我是谁：</p>
<ul>
<li>如果你线下认识我，可以叫我 "毛Ker" 或者 "老毛"</li>
<li>如果你线上认识我，可以叫我 "彭彭"。</li>
<li>这些 ID
都是我：<code>huan-yp</code>，<code>幻影彭</code>，<code>huan_yp</code>，<code>huan_yp2002</code>。</li>
</ul>
<p>联系我：</p>
<ul>
<li>QQ：3051561876</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2025/02/22/%E6%8A%80%E6%9C%AF/%E7%94%9F%E4%BA%A7%E5%8A%9B/Docker%20%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/22/%E6%8A%80%E6%9C%AF/%E7%94%9F%E4%BA%A7%E5%8A%9B/Docker%20%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Docker 实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-22 10:58:19 / 修改时间：10:59:04" itemprop="dateCreated datePublished" datetime="2025-02-22T10:58:19+08:00">2025-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="查看镜像和容器">查看镜像和容器</h2>
<ul>
<li><p>显示本地所有镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li>
<li><p>显示所有正在运行的容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li>
<li><p>显示所有容器（包括停止的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="运行容器">运行容器</h2>
<ul>
<li><p>从镜像新建并运行一个容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run &lt;image_name&gt;</span><br></pre></td></tr></table></figure>
<p>可选参数表：</p>
<ul>
<li><code>-d</code>：以守护模式运行。</li>
<li><code>-it</code>：保持 STDIN
打开并分配一个伪终端。（建永远选上这个）</li>
<li><code>--name &lt;name&gt;</code>：给容器起个名，易于区分。</li>
<li><code>-p &lt;host_port&gt;:&lt;client_port&gt;</code>
：进行端口映射，可以有多个
<code>-p &lt;host_port&gt;:&lt;client_port&gt;</code>
字段。也支持端口段映射，比如 <code>-p 8000-8010:8000-8010</code>。</li>
<li><code>-e &lt;key&gt;=&lt;value&gt;</code>：设置启动时环境变量。</li>
</ul>
<p>其它事项：</p>
<ul>
<li>一般来说，如果不指定
<code>-d</code>，退出终端时，容器会自动退出。</li>
<li><code>-d</code>，<code>--name</code>，<code>-p</code>
必须在通过镜像创建容器时确定，之后一般无法改变。</li>
<li>如果本地没有 <code>&lt;image_name&gt;</code>
镜像，会自动从远端拉去。</li>
</ul></li>
<li><p>启动一个被退出的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;container_name&gt;</span><br></pre></td></tr></table></figure>
<p>可选参数表：</p>
<ul>
<li><code>-ia</code>：启动交互模式并附加到一个终端上。</li>
</ul>
<p>其它事项：</p>
<ul>
<li><code>&lt;container_name&gt;</code> 支持前缀匹配，不需要全名。</li>
</ul></li>
<li><p>附加到一个已经启动的容器中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;container_name&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p>可选参数：</p>
<ul>
<li><code>-it</code>：保持 STDIN 打开并进入交互式 shell。</li>
</ul></li>
<li><p>在一个已经运行的容器中执行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec &lt;container_name&gt; &lt;COMMAND&gt; &lt;ARGS...&gt;</span><br></pre></td></tr></table></figure>
<p>可选参数：</p>
<ul>
<li><code>-d</code>：后台运行命令，不进入容器。</li>
<li><code>-e &lt;key&gt;=&lt;value&gt;</code>：设定环境变量。</li>
<li><code>-w</code>：指定命令执行的工作目录。</li>
</ul></li>
</ul>
<h2 id="容器的生命周期">容器的生命周期</h2>
<p>容器的生命周期与主进程（PID=1
的进程）绑定，主进程退出时容器生命周期结束。</p>
<ol type="1">
<li><p>当以 <code>docker run -it</code>
运行容器时，<strong>主进程是终端进程</strong>，终端退出则容器退出。</p></li>
<li><p>当以 <code>docker start -ia</code> 恢复容器运行时，
<strong>主进程是终端进程</strong>，终端退出则容器退出。</p></li>
<li><p>当以 <code>docker start</code>
恢复容器运行时，<strong>主进程是一个守护进程</strong>，再使用
<code>docker exec -it /bin/bash</code>
启动容器终端时，终端不作为主进程，退出对容器无影响。</p></li>
<li><p>当以 <code>docker run -d</code>
运行容器时，<strong>主进程是守护进程</strong>，再使用
<code>docker exec -it /bin/bash</code>
启动容器终端时，终端不作为主进程，退出对容器无影响。（该情况下，主动
<code>docker stop</code> 容器再用 <code>docker start -ia</code>
恢复时，主进程是终端进程而不是守护进程）</p></li>
</ol>
<h2 id="操作容器">操作容器</h2>
<ul>
<li><p>删除容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -rm &lt;container_name&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="制作镜像">制作镜像</h2>
<h3 id="直接用-container-制作">直接用 container 制作</h3>
<p>制作步骤：</p>
<ul>
<li><p><code>docker run -it</code> 一个基础镜像。</p></li>
<li><p>用终端进行必要的修改。</p></li>
<li><p><code>exit</code> 退出基础镜像并让它停止。</p></li>
<li><p>执行 <code>commit</code> 制作镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;container_name&gt; &lt;image_name&gt;[:&lt;version&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不使用 <code>[:version]</code>，默认使用
<code>latest</code>。</li>
</ul></li>
</ul>
<h3 id="用-dockerfile-制作">用 Dockerfile 制作</h3>
<p>用 container
制作虽然方便，但把所有操作打包到一个层非常不利于维护，所以有条件的话都建议用
Dockerfile 来制作。</p>
<p>一个经典的 Dockerfile 如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> image_name:tag</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> YOUR_NAME <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> var_name value</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> file_path destination_directory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">command</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> port_number</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;command&quot;</span>, <span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>FROM</code>：指定基础镜像。</li>
<li><code>MAINTAINER</code>：指定作者信息。</li>
<li><code>ENV</code>：设置环境变量，它在<strong>构建阶段</strong>和<strong>容器生命周期内</strong>均有效。</li>
<li><code>COPY</code>：从宿主机拷贝文件过来。</li>
<li><code>WORKDIR</code>：设置工作目录，如果不存在，会递归创建。</li>
<li><code>RUN</code>：执行必要的构建命令。</li>
<li><code>EXPOSE</code>：明确要暴露的端口号，但还是需要在
<code>docker -run</code> 时使用 <code>-p</code> 指定。</li>
<li><code>CMD</code>：定义 <code>docker run</code> 时的默认命令。</li>
</ul>
<p>制作步骤如下：</p>
<ul>
<li><p><strong>准备</strong></p>
<p>建一个目录，里面创建一个名为 <code>Dockerfile</code>
的文件，在里面写命令。</p>
<p>目录里加上可能要拷贝进去的文件。</p></li>
<li><p><strong>构建</strong></p>
<p><code>Dockerfile</code> 的所在目录下执行以下代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t [&lt;image_name&gt;[:&lt;version&gt;]] &lt;cwd&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t</code>：一般<strong>必选</strong>，指定镜像名和版本。</li>
<li><code>cwd</code>：一般就写 <code>.</code> 了。</li>
</ul></li>
<li><p><strong>测试</strong></p>
<p>看一下构建成功没有。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其它常用命令">其它常用命令</h3>
<ul>
<li><p>打 tag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag &lt;image&gt;:&lt;old_version&gt; &lt;image&gt;:&lt;new_version&gt;</span><br></pre></td></tr></table></figure>
<p>一般创建的时候你会写 <code>&lt;image&gt;</code> 和
<code>&lt;version&gt;</code>。</p>
<p>可以把 <code>&lt;version&gt;</code> 看成一个指针，创建 image
的时候你让 <code>&lt;version&gt;</code> 指向了它。</p>
<p><code>docker tag</code> 的作用就是将 <code>&lt;new_version&gt;</code>
也指向 <code>&lt;version&gt;</code> 指向的对象，用以下 cpp
代码理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Image *old_version = <span class="keyword">new</span> <span class="built_in">Image</span>();</span><br><span class="line">Image *new_version = old_version;</span><br></pre></td></tr></table></figure></li>
<li><p>镜像保存到文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;filename&gt; &lt;image_name&gt;[:&lt;version&gt;]</span><br></pre></td></tr></table></figure></li>
<li><p>从文件加载镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i &lt;filename&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>容器保存到文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export -o &lt;filename&gt; &lt;container_name&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从文件将容器<strong>加载为镜像</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import &lt;filename&gt; &lt;image_name&gt;[:&lt;version&gt;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="跨设备传输">跨设备传输</h2>
<h3 id="推送到-dockerhub">推送到 DockerHub</h3>
<p>有时候会把 image 推送到 DockerHub 上方便跨设备传输，步骤如下：</p>
<ol type="1">
<li><p>注册一个 <a target="_blank" rel="noopener" href="https://hub.docker.com/">DockerHub</a>
账号。</p></li>
<li><p>终端登录 DockerHub：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>
<p>在提示下输入账号密码即可。</p></li>
<li><p>tag 你的镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag &lt;image_name&gt;:&lt;version&gt; &lt;username&gt;/&lt;image_name&gt;:&lt;version&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>push 它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push &lt;username&gt;/&lt;image_name&gt;:&lt;version&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意事项：</p>
<ul>
<li><p>如果你的 <code>latest</code> 版本同时也是 <code>1.0</code>
版本，那么需要<strong>同时把两个标签推送上去</strong>才行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker push &lt;username&gt;/&lt;image_name&gt;:&lt;latest&gt;</span><br><span class="line">docker push &lt;username&gt;/&lt;image_name&gt;:&lt;1.0&gt;</span><br></pre></td></tr></table></figure>
<p>但是显然只会推一次数据，第二次只是推个标签而已。</p></li>
</ul>
<h3 id="用传输介质传输">用传输介质传输</h3>
<p>参考上面的
<code>docker save/load</code>，<code>docker export/import</code> 并使用
U 盘或者网线等介质传输。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2025/02/20/%E5%AD%A6%E6%9C%AF/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/20/%E5%AD%A6%E6%9C%AF/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">神经网络学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-20 16:00:00" itemprop="dateCreated datePublished" datetime="2025-02-20T16:00:00+08:00">2025-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-21 17:05:02" itemprop="dateModified" datetime="2025-02-21T17:05:02+08:00">2025-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">学术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前置知识">前置知识</h2>
<h3 id="导数-vs-微分">导数 VS 微分</h3>
<p><strong>导数就是导函数。</strong></p>
<p><span class="math inline">\(f\)</span> 的微分 <span
class="math inline">\(df\)</span> 可以看作一个函数，（一维的情况下）它将
<span class="math inline">\(dx\)</span> 映射到 <span
class="math inline">\(f&#39;(x)dx\)</span>。</p>
<p><em><span class="math inline">\(dx\)</span>
怎么理解看个人，我没有把它当成函数，而是把它当成了一个单纯的记号。</em></p>
<h3 id="梯度-vs-微分">梯度 VS 微分</h3>
<p><strong>梯度是高维意义下的导数。</strong></p>
<ol type="1">
<li><p><strong>梯度的定义</strong>：
梯度是一个向量，包含函数的所有<strong>偏导数</strong>。对于函数 <span
class="math inline">\(f(x,y)\)</span>，其梯度为： <span
class="math display">\[
\nabla f = \left( \frac{\partial f}{\partial x}, \frac{\partial
f}{\partial y} \right)
\]</span> 梯度指向函数值增加最快的方向。</p></li>
<li><p><strong>微分的定义</strong>：
微分描述了函数在<strong>自变量微小变化时的改变</strong>。对于函数 <span
class="math inline">\(f(x,y)\)</span>，其微分 <span
class="math inline">\(df\)</span> 为： <span class="math display">\[
df = \frac{\partial f}{\partial x} dx + \frac{\partial f}{\partial y} dy
\]</span></p>
<p>这表示函数在自变量 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 分别变化 <span
class="math inline">\(dx\)</span> 和 <span
class="math inline">\(dy\)</span> 时的总变化。</p></li>
</ol>
<h3 id="常用函数">常用函数</h3>
<ul>
<li><strong>sigmoid</strong>：记作 <span
class="math inline">\(\sigma(x)\)</span>，<span
class="math inline">\(\sigma(x) = \frac{1}{1+e^{-x}}\)</span>。</li>
<li><strong>双曲正切函数</strong>：记作 <span
class="math inline">\(\tanh(x)\)</span>，<span
class="math inline">\(\tanh(x) =
\frac{e^x-e^{-x}}{e^x+e^{-x}}\)</span>。</li>
</ul>
<h3 id="常用记号">常用记号</h3>
<ul>
<li><strong>逐元素相乘（Hadamard Product）</strong>：<span
class="math inline">\(A \odot B = C\)</span> 表示张量 <span
class="math inline">\(A,B\)</span> 逐元素得到一个同结构的张量 <span
class="math inline">\(C\)</span>。</li>
<li><strong>矩阵乘法</strong>：<span class="math inline">\(A\cdot B =
C\)</span> 表示两个矩阵按矩阵乘法规则乘出来是 <span
class="math inline">\(C\)</span>，<strong>没有特殊说明一定不是点乘</strong>。</li>
</ul>
<h2 id="神经网络">神经网络</h2>
<h3 id="权重矩阵">权重矩阵</h3>
<p>权重矩阵用于在层之间做转移，是神经网络结构的主要组成部分。</p>
<h3 id="激活函数">激活函数</h3>
<p>激活函数用于调整函数结构，使神经网络能够学习复杂的非线性函数。</p>
<h3 id="偏置项">偏置项</h3>
<p>偏置项用于对激活范围进行调整，能够有效提升模型表达能力。</p>
<p>没有偏置项时，激活函数的输出只取决于输入信号的加权和，这样拟合会让模型变得复杂，引入偏置项能够有效改善学习过程。</p>
<h3 id="反向传播算法">反向传播算法</h3>
<p>通过链式求导法则，计算每一项的梯度，以减少损失函数为目的按照梯度调整权重矩阵和偏置项的值。</p>
<h4 id="不完全可微函数的处理">不完全可微函数的处理</h4>
<p>激活函数有时候不是完全可微的，例如 ReLU
函数，这个时候会采取某些方式来处理。</p>
<ol type="1">
<li><strong>归到某一边：</strong>反正概率挺小的，直接认为可导归到其中一边就行。</li>
<li><strong>使用次梯度：</strong>如果它是个凸函数，可以用次梯度近似替代。</li>
<li><strong>用可导函数近似：</strong>找个长得差不多的可导函数，不可微的点用这个函数的微分替代。</li>
</ol>
<h3 id="批次训练与梯度累计">批次训练与梯度累计</h3>
<p>神经网络一般采用批次训练的方式，利用 GPU
的并行计算能力，一个批次跑出多个数据的 loss
和梯度。然后取平均后进行一次下降。</p>
<p>一般来说 batch_size
设置大一点可以让学习过程更加稳定，减少个别数据的极端偏移。</p>
<p>有时候显存不够甚至可以多跑几次积累一下梯度，然后进行更新。</p>
<p><em>注意这里是对<strong>梯度</strong>取平均，不是对 loss
或者中间过程的值取平均。</em></p>
<h3 id="过拟合与缓解方式">过拟合与缓解方式</h3>
<h4 id="early-stop">Early Stop</h4>
<p>训到训练集 Loss 连续一段时间不再下降时就停止。</p>
<h4 id="l1l2-standardization">L1/L2 Standardization</h4>
<p>给 Loss 加个正则化项：</p>
<ul>
<li>L1 正则化：<span
class="math inline">\(\lambda\sum|w_i|\)</span></li>
<li>L2 正则化：<span class="math inline">\(\lambda\sum
w_i^2\)</span></li>
</ul>
<p>为啥有用：</p>
<ul>
<li>L1
促进一些参数变零，可以实现<strong>特征选择</strong>，以去除不重要的特征。</li>
<li>L2 鼓励减小参数大小，降低对训练数据的敏感性。</li>
<li>总的来说都是<strong>限制了模型复杂度以减小过拟合的可能</strong>。</li>
</ul>
<h4 id="dropout">Dropout</h4>
<p>实现方式：</p>
<ul>
<li><strong>每轮训练</strong>的时候以一个概率 <span
class="math inline">\(p\in[0.2,0.5]\)</span> 让（特定的 Dropout
层）激活函数变零。</li>
<li>测试的时候启用全部神经元，同时乘上一个系数 <span
class="math inline">\((1-p)\)</span> 补偿训练过程的丢弃。</li>
</ul>
<p>为啥有用：</p>
<ul>
<li>取平均作用：不同轮次的 Dropout
可以视作不同的神经网络，产生不同的过拟合，能够相互抵消。</li>
<li>减少共适性关系：不应该对某些特定的特征特别敏感，迫使神经网络学习到具有鲁棒性的特征。</li>
</ul>
<h3 id="其它训练技巧">其它训练技巧</h3>
<h4 id="batch-normalization">Batch Normalization</h4>
<p>实现方式：</p>
<ul>
<li>在神经网络的每一层输入层前加一个 BN 层，将输入归一化为均值为
0，方差为 1 的输入。</li>
<li>BN 层增加两个可学习参数 <span class="math inline">\(\gamma,
\beta\)</span>，用于对归一化后的数据进行线性变换。</li>
</ul>
<p>生效原理：</p>
<ul>
<li>缓解内部协变量偏移问题：使各层输入分布稳定，加速网络收敛，对于深度神经网络作用更大。</li>
<li>提升梯度传播效率：使输入保持在激活函数非饱和区内，有利于缓解梯度消失和梯度爆炸，同时也能避免参数初始化时使训练陷入困境。</li>
<li>增强泛化能力*：由于 <span
class="math inline">\(\gamma,\beta\)</span>
是可学习的，因此训练过程会对数据进行一些小扰动，可能能增强泛化能力。</li>
</ul>
<h2 id="卷积神经网络cnn">卷积神经网络（CNN）</h2>
<h3 id="卷积层">卷积层</h3>
<h4 id="卷积核">卷积核</h4>
<ul>
<li><p>我不懂为啥要叫卷积，但是卷积核是对对应的小矩阵做<strong>点乘</strong>，然后得到一个数作为特征值。</p></li>
<li><p>一个卷积层可能有多个卷积核，不同卷积核可以提取不同的特征，最后卷出来的结果是个张量。</p></li>
</ul>
<h4 id="参数">参数</h4>
<ul>
<li><p>大小：常见的有 3x3 和
5x5，较小的卷积核能够捕捉精细特征，较大的可以捕获更广泛的上下文信息。</p></li>
<li><p>步长：决定卷积核在数据上滑动的间隔，步长越大，特征图输出越小。</p></li>
<li><p>填充：在图像边缘添加额外像素，控制输出特征图的大小。</p></li>
<li><p>权重：卷积核每个位置的值叫做权重，这个是可以学习的。</p></li>
<li><p>偏置：每个卷积核有一个偏置值，也是可以学习的。</p></li>
</ul>
<h4 id="作用">作用</h4>
<p>有效提取各种局部特征。</p>
<h3 id="池化层">池化层</h3>
<h4 id="结构">结构</h4>
<ul>
<li>池化窗口：一般设置为 2x2 或者 3x3，决定每次考虑的局部区域大小</li>
<li>池化方式：最大池化或者平均池化，前者取最大值并保留，后者取平均值并保留。</li>
<li>池化步长：和卷积层的步长差不多，决定特征图大小用的。</li>
</ul>
<h4 id="用途">用途</h4>
<p>降低特征图维度，减少计算量，同时保留重要的局部特征信息。</p>
<h3 id="全连接层">全连接层</h3>
<p>一般放在最后几层，用于整合前面提取的特征，输出最终的结果。</p>
<h3 id="优势">优势</h3>
<ul>
<li>天然适用于处理图像，能够有效提取图像局部特征并完成图像相关任务。</li>
</ul>
<h3 id="一般使用方式">一般使用方式</h3>
<ul>
<li>通常会堆很多层，非常深，一层卷积带一层池化这样。</li>
</ul>
<h3 id="改进">改进</h3>
<h4 id="resnet">ResNet</h4>
<p>引入了残差块，解决了深层神经网络梯度消失的问题。<del>卧槽了这 TM
也能管用。</del></p>
<p>残差块是在两个卷积层的基础上直接拉了一个恒等偏置过来。假设一个残差块的输入是
<span class="math inline">\(x\)</span>，输出 <span
class="math inline">\(H(x)\)</span>，卷积层结构是 <span
class="math inline">\(F(x, W_i)\)</span>，那么令： <span
class="math display">\[
H(x) = x + F(x, W_i)
\]</span></p>
<p>参与学习的参数只有 <span
class="math inline">\(W_i\)</span>，这样反向传播链式求导的时候梯度能直接从
<span class="math inline">\(x\)</span>
这一项传到前面去，神秘的解决了梯度消失问题。</p>
<h2 id="循环神经网络rnn">循环神经网络（RNN）</h2>
<h3 id="结构-1">结构</h3>
<h4 id="输入">输入</h4>
<ol type="1">
<li><strong>当前时刻的输入</strong> <span
class="math inline">\(x_t\)</span>：表示当前时间步的输入数据，例如在自然语言处理中，*<span
class="math inline">\(x_t\)</span> 可以是一个单词的嵌入向量。</li>
<li><strong>上一时刻的隐藏状态</strong> <span
class="math inline">\(h_{t-1}\)</span>：表示上一时间步的输出状态，用于传递之前的信息。</li>
</ol>
<h4 id="输出">输出</h4>
<ol type="1">
<li><strong>当前时刻的隐藏状态</strong> <span
class="math inline">\(h_t\)</span>：用于传递给下一个时间步。</li>
<li><strong>当前时刻的输出</strong> <span
class="math inline">\(y_t\)</span>（可选）：在某些任务中，RNN
的每个时间步都会产生一个输出，例如在字符级语言模型中，<span
class="math inline">\(y_t\)</span> 可以表示下一个字符的概率分布。</li>
</ol>
<h4 id="状态公式">状态公式</h4>
<p><span class="math display">\[
h_t=\sigma(W_{hh}h_{t-1}+W_{xh}x_t+b_t)
\]</span></p>
<ul>
<li><span class="math inline">\(W_{hh}\)</span>：隐藏状态转移公式。</li>
<li><span
class="math inline">\(W_{xh}\)</span>：输入到隐藏贡献公式。</li>
<li><span class="math inline">\(\sigma\)</span>：激活函数。</li>
<li><span class="math inline">\(b_h\)</span>：偏置项。</li>
</ul>
<h4 id="训练过程">训练过程</h4>
<p>一般用 BackPropagation Through
Time（BPTT）算法进行权重更新，过程如下：</p>
<ul>
<li>前向传播：从 <span class="math inline">\(t=1\)</span>
开始一次计算隐藏状态和输出。</li>
<li>计算损失：计算所有输出的损失函数。</li>
<li>反向传播：从 <span class="math inline">\(t=T\)</span>
开始依次计算每个时间步的梯度，最后梯度加在一起更新。</li>
</ul>
<h3 id="优缺点">优缺点</h3>
<h4 id="优势-1">优势</h4>
<ul>
<li>能处理变长的输入。</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>梯度消失：处理过长的序列时，容易发生梯度消失，导致无法捕捉长距离的依赖。</li>
<li>梯度爆炸：处理过长的序列时，容易发生梯度爆炸，导致权重更新过大，训练过程不稳定。</li>
</ul>
<h2 id="长短期记忆网络lstm">长短期记忆网络（LSTM）</h2>
<p>RNN 的问题很大，所以衍生出了 RNN 的变体：LSTM。</p>
<p>LSTM 通过门控机制巧妙地解决了 RNN
的长距离依赖问题。遗忘门能够控制信息的遗忘，输入门能够选择性地添加新信息，而输出门则能够控制信息的输出。这三个门的协同作用使得
LSTM 能够有效地学习和存储长期序列信息，并且能够避免梯度消失问题。</p>
<h3 id="结构-2">结构</h3>
<p>LSTM 的核心是<strong>记忆单元（cell）</strong>。</p>
<h4 id="关键状态">关键状态</h4>
<ul>
<li><p><strong>记忆状态</strong>：cell
状态能够长时间的存储时间序列中的信息，其信息数据受<strong>门</strong>的控制，能够将所需的信息稳定的沿时间轴传递。</p></li>
<li><p><strong>隐藏状态</strong>：同基础 RNN 的隐藏状态。</p></li>
</ul>
<h4 id="门">门</h4>
<ul>
<li><strong>遗忘门</strong>：
<ul>
<li>功能：决定 cell 中旧信息的遗忘程度。</li>
<li>运行：通过一个 sigmoid 函数来产生一个值在 0 和 1 之间的遗忘率。0
表示完全遗忘，1
表示完全保留。它接受前一时间步的隐藏状态和当前时间步的输入作为输入，产生遗忘矩阵
<span class="math inline">\(f_t\)</span> 作为输出。</li>
<li>公式：<span class="math inline">\(f_t=\sigma(W_f\cdot [h_{t-1},
x_t]+b_f)\)</span>。</li>
</ul></li>
<li><strong>输入门</strong>：
<ul>
<li>功能：决定是否需要将新的信息存储到细胞状态中。</li>
<li>运行方式：输入门同样通过一个 sigmoid 函数计算一个值在 0 和 1
之间的输入率。这个输入率决定了有多少新信息会被允许存储到细胞状态中，输入同遗忘门。</li>
<li>公式表示：<span class="math inline">\(i_t=\sigma(W_i\cdot [h_{t-1},
x_t]+b_i)\)</span></li>
</ul></li>
<li><strong>输出门</strong>：
<ul>
<li>功能：决定当前时间步的输出。</li>
<li>运行方式：通过 sigmoid
函数计算一个输出矩阵，决定细胞状态信息的输出率，输出率描述了多大比例的细胞状态信息会被激活并传递出去。</li>
<li>公式表示：<span class="math inline">\(o_t=\sigma(W_o\cdot[h_{t-1},
x_t]+b_o)\)</span>。</li>
</ul></li>
</ul>
<h3 id="状态更新">状态更新</h3>
<h4 id="计算候选细胞状态">计算候选细胞状态</h4>
<p><span class="math display">\[
\tilde{C_t}=\tanh{W_C\cdot[h_{t-1}, x_t]+b_C}
\]</span></p>
<p>候选细胞状态描述了当前信息对长期记忆的影响，参与细胞状态的更新。</p>
<h4 id="更新细胞状态">更新细胞状态</h4>
<p><span class="math display">\[
C_t=f_t\odot C_{t-1}+i_t\odot \tilde{C_t}
\]</span></p>
<p>新细胞状态由上次细胞状态遗忘一部分，加上当前信息的候选状态补充进去。</p>
<h4 id="更新隐藏状态">更新隐藏状态</h4>
<p><span class="math display">\[
h_t = o_t\odot \tanh{C_t}
\]</span></p>
<p>隐藏状态通过当前的记忆来更新。</p>
<h3 id="bilstm">BiLSTM</h3>
<p>BiLSTM 对传统的 LSTM 的扩展。相较于传统的单向 LSTM
只能捕捉序列中过去的信息，BiLSTM
能够同时捕捉序列中的过去和未来信息。</p>
<h4 id="结构-3">结构</h4>
<p>BiLSTM 就是两个 LSTM
拼接起来的，一个输入的是正向序列，另一个输入反向序列。</p>
<p>两个序列算出对应位置的 <span
class="math inline">\(h^{f}_t,h_{t}^{b}\)</span> 后，再拼接成一个新向量
<span class="math inline">\(h_t\)</span>。</p>
<p>最后从 <span class="math inline">\(h_t\)</span>
里面解析信息出来。</p>
<h3 id="grm">GRM</h3>
<p>GRM 是 LSTM
爆改过来的，减少了门的数量以降低复杂度但效果能得到一定保证。</p>
<p>GRU
通过更新门和重置门的协同作用，实现了对隐藏状态的有效更新。更新门决定了保留多少过去的信息，重置门决定了当前输入对隐藏状态的影响程度。这种门控机制使得
GRU 能够在低计算成本下处理长期依赖序列数据，避免了传统 RNN
中的梯度消失问题。</p>
<h4 id="结构-4">结构</h4>
<ol type="1">
<li><strong>更新门（Update Gate）</strong>：
<ul>
<li>决定当前隐藏状态中保留多少过去的信息，以及从当前输入中引入多少新信息。</li>
<li>其计算公式为：<span class="math inline">\(z_t =
\sigma(W_z\cdot[h_{t-1}, x] + b_z)\)</span>。</li>
</ul></li>
<li><strong>重置门（Reset Gate）</strong>：
<ul>
<li>决定当前输入信息对当前隐藏状态的影响程度，控制对过去信息的依赖。</li>
<li>其计算公式为：<span class="math inline">\(r_t =
\sigma(W_r\cdot[h_{t-1}, x] + b_r)\)</span>。</li>
</ul></li>
</ol>
<h4 id="状态转移">状态转移</h4>
<ol type="1">
<li><p><strong>计算候选隐藏状态</strong>： <span class="math display">\[
\tilde{h_t} = \tanh(W_h\cdot[h_{t-1}, x] + b_h)
\]</span></p>
<p>在考虑重置门的作用后，通过当前输入和<strong>经过重置门处理后的前一时刻隐藏状态</strong>计算得到。</p></li>
<li><p><strong>隐藏状态更新</strong>： <span class="math display">\[
h_t=z_t\odot h_{t-1}+(1-z_t)\odot\tilde{h_t}
\]</span></p>
<p>最终的隐藏状态由更新门控制，结合了前一时刻的隐藏状态和当前的候选隐藏状态。</p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2025/02/17/%E6%8A%80%E6%9C%AF/%E5%9F%BA%E7%A1%80/OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/17/%E6%8A%80%E6%9C%AF/%E5%9F%BA%E7%A1%80/OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">OSI 七层模型简单理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-17 23:40:24 / 修改时间：23:50:46" itemprop="dateCreated datePublished" datetime="2025-02-17T23:40:24+08:00">2025-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章是以<strong>现代计算机网络硬件</strong>为基础编写的，主要介绍了现代硬件环境下应该了解的网络知识，能够为网络编程打下一个较好的基础。</p>
<p>第一次接触不一定能理解全部内容，但当你对网络编程有一定了解后，也可以回来再看看？</p>
<h2 id="物理层">物理层</h2>
<ul>
<li><p>这一层是电子信息系的事，不是计算机系的事。</p></li>
<li><p>这一层可以实现在<strong>两台设备间不稳定的传输数据</strong>。</p></li>
<li><p>这一层数据传输的基本单位是 bit。</p></li>
</ul>
<h2 id="数据链路层">数据链路层</h2>
<p>这一层的主要设备是交换机。</p>
<p>多台主机和交换机，网线构成了一个 LAN。</p>
<h3 id="数据单位">数据单位</h3>
<p>数据层的数据传输单位是 Frame
(帧)，帧包括帧头，帧体，帧尾，帧头包括数据 src 和 dst 的 MAC
地址，帧尾包含一些校验信息。</p>
<p>数据链路层保证了 LAN 中数据传输的可靠性。</p>
<p>以其中一种机制为例：</p>
<ul>
<li>发送方在发送帧的时候，会等待一个 ACK 确认，如果没有等到 ACK
确认，则会重传该帧，直到所有数据帧得到 ACK 确认时结束传输。</li>
<li>接收方会根据帧尾的校验信息确认帧体数据无误，无误后发送 ACK
确认。</li>
</ul>
<h3 id="交换机功能">交换机功能</h3>
<p>数据链路层中，每台设备具有唯一 MAC
地址（这是出厂时烧在网卡上的唯一标识）。</p>
<p>交换机主要用于根据数据帧的 MAC 地址在主机间正确转发数据帧。</p>
<h3 id="mac-地址学习">MAC 地址学习</h3>
<p>交换机有若干个口可以插，如果可能，交换机收到数据后，只会往目标 MAC
的那个端口发。</p>
<p>如果交换机没记录目标 MAC 的端口，则会进行依次广播，根据 ACK
机制，在目标计算机回传 ACK 包时，记录这条信息，并将 MAC 对应上。</p>
<p>这是大部分交换机采用的策略。</p>
<p>当然，有更加复杂的机制来处理诸如 "把 1 口的线转插到 2 口"
这种事。</p>
<p>一个端口能对应多个 MAC
地址，所以你把交换机和交换机插在一起，也能正常组网。</p>
<h2 id="网络层">网络层</h2>
<p>网络层的主要设备是<strong>路由器（Router）</strong>，主要协议是
<strong>IP 协议</strong>。</p>
<p>数据链路层组网完毕后，形成一个 LAN，通过路由器，可以将若干个 LAN
连接成一个更大的 LAN。</p>
<p>我们说的 Internet，就是一个世界范围的 LAN。</p>
<p><em>MAN、WAN 本质都是 LAN，只是规模不同。</em></p>
<h3 id="ip-协议">IP 协议</h3>
<h4 id="公网-ip-和私网-ip">公网 IP 和私网 IP</h4>
<p>公网IP地址（Public IP
Address）是指在全球互联网范围内可以直接访问的IP地址。这些地址是<strong>唯一</strong>的。</p>
<p>众所周知，公网 IP 是从 <code>0.0.0.0</code> 到
<code>255.255.255.255</code>
的，其中有三段不会被分配，可以用于建立<strong>子网</strong>：</p>
<ul>
<li><code>10.0.0.0 - 10.255.255.255</code>，又记作
<code>10.0.0.0/8</code>。</li>
<li><code>172.16.0.0 - 172.31.255.255</code>，又记作
<code>172.16.0.0/12</code>。</li>
<li><code>192.168.0.0 - 192.168.255.255</code>，又记作
<code>192.168.0.0/16</code>。</li>
</ul>
<p><em>后面那个数字指<strong>前缀长度</strong>。</em></p>
<p>一般的电脑是没有公网 IP 的，所以不能直接在互联网上被访问。</p>
<p>但是你能 <code>ipconfig/ifconfig</code> 出来一个 IP
地址，注意观察的话：</p>
<ul>
<li><p>以你车的校园网为例，它采用了 <code>10.0.0.0/8</code>
这个区段，大概能支持 <span class="math inline">\(1.6\times10^7\)</span>
个设备，对你车来说是够用了。</p></li>
<li><p>以你家的无线网为例，它采用了 <code>192.168.0.0/16</code>
这个区段，大概能支持 <span class="math inline">\(6.5\times 10^4\)</span>
个设备，对你家来说是够用了。</p></li>
</ul>
<h4 id="ip-协议的特点">IP 协议的特点</h4>
<ul>
<li><strong>无连接</strong>：IP协议是无连接的，即它不需要在发送数据前建立连接。给个
IP 地址，IP 协议就能尝试去把数据发过去。</li>
<li><strong>尽力而为的传输</strong>：IP协议只负责将数据报发送到目的地，但不保证数据的顺序、完整性或可靠性。数据丢失、重复或乱序需要由上层协议处理。</li>
</ul>
<h4 id="ip-协议可达性">IP 协议可达性</h4>
<p>两台机子能够<strong>使用 IP 协议相互通信</strong>当且仅当：</p>
<ul>
<li>两台机子处于同一子网下</li>
<li>两台机子都拥有公网 IP。</li>
</ul>
<p>没有特殊说明，后面的讨论中，默认是以上两种情况。</p>
<p><em>注意这里的限定，平时你的机子和百度通信，你是没有公网 IP
的，和百度也不在一个子网下，这个时候你们就不是用 IP
协议直接通信的，而是有更复杂的机制。</em></p>
<h3 id="子网划分">子网划分</h3>
<p>实际应用过程中，会对子网做更细一步的划分。</p>
<p>不过要注意，在<strong>第一次的划分</strong>中，所有的 IPV4
地址被保留了三段作为私有地址，这三段私有地址可以被多个子网使用。</p>
<p>也就是说，在整个 Internet 中，可以有多个子网 S1, S2,
S3....，它们都使用同一段私有地址。（例如你家和小明家宽带都用的
<code>192.168.0.0(16)</code> 这一段）</p>
<p>但是，对子网的下一步划分，就无法多次使用同一段了，这个层次的划分局限于<strong>将子网的私有地址分成若干块，每一个小子网得到一块。</strong>不同的小子网无法使用同一个
IP。</p>
<p>当然，小子网可以继续做划分。</p>
<p>最后，有一个子网中的所有设备都被数据链路层（交换机和以太网线）连接起来了，如果两台设备处于这样一个子网中，我们称这两个设备<strong>相邻</strong>。有时候<strong>相邻</strong>会和<strong>处于同一子网中</strong>混淆。</p>
<h4 id="子网掩码">子网掩码</h4>
<p>子网掩码用于判断两个 IP 地址是否处于同一个子网（不是指相邻）。</p>
<p>上文介绍了一个复杂的子网划分机制，子网掩码用于判断两个 IP
地址是否处于同一子网。</p>
<p>例如，有子网 A，B，C，其中 B，C 是 A 子网划分出来的两个子网，其中</p>
<ul>
<li>A
<ul>
<li>IP 段：<code>192.168.0.0/16</code></li>
<li>子网掩码：<code>255.255.0.0</code></li>
</ul></li>
<li>B
<ul>
<li>IP 段：<code>192.168.1.0/24</code></li>
<li>子网掩码：<code>255.255.255.0</code></li>
</ul></li>
<li>C
<ul>
<li>IP 段：<code>192.168.2.0/24</code></li>
<li>子网掩码：<code>255.255.255.0</code></li>
</ul></li>
</ul>
<p>那么，对于
M1：<code>192.168.2.16</code>，M2：<code>192.168.1.16</code>，M3：<code>192.168.1.17</code>
三台机器来说，在子网 A 处，M1，M2，M3 处于同一子网，但在子网 B，C 处，M1
和 M2 不处于同一子网。</p>
<p>一般的子网掩码的低若干位是 0，IP
和子网掩码<strong>按位与</strong>，结果相同则处于同一子网。</p>
<p>主机发送数据包时，根据目标 IP
地址和子网掩码计算是否处于同一子网，如果处于同一子网，则直接走<strong>数据链路层</strong>发送过去。</p>
<h4 id="默认网关">默认网关</h4>
<p>一个子网一般只有一个默认网关，这个默认网关一般就是路由器，路由器的有关知识会在下一部分讲到。</p>
<p>如果你用 "网络属性" 去看过 IPV4
地址协议，就会看到这个选项是和子网掩码在一起的。</p>
<ul>
<li>默认网关和路由器：路由器负责处理不同子网之间的通信，它的每个槽接入的是不同的子网。如果
IP 协议发送的数据的目标 IP
不在同一子网，则会发往默认网关，默认网关再来处理这个数据，将它发往正确的地方。</li>
<li>自动 DHCP：现在一般不用手动去设置默认网关、IP
地址、子网掩码，都是采用 "自动DHCP" 方式自动分配。</li>
</ul>
<h3 id="路由">路由</h3>
<h4 id="arp-协议">ARP 协议</h4>
<p><strong>ARP
协议的工作范围是子网</strong>，以下场景均发生在同一子网内。</p>
<p>ARP 协议是介于数据链路层和网络层之间的协议，用于通过 IP 地址查询 MAC
地址。</p>
<p>IP 协议的数据包是对数据链路层的数据包外面包了一个，但是有个问题。IP
协议的标准是：知道 IP 就能尝试发过去。但是数据链路层的包里是需要包括 MAC
地址的，那我不知道 MAC 地址怎么办？</p>
<p>这个时候需要 ARP 发挥作用，在不知道 MAC 地址时，主机会发送一次 ARP
<strong>广播</strong>，查询目标 IP 对应的 MAC
地址，目标主机收到查询后（查询中包含源主机的
MAC），会向源主机发送一次回复，源主机得到对应的 MAC 地址。</p>
<p><em>交换机如何处理 ARP 广播：广播类消息的 MAC
会设置为<strong>泛洪帧</strong>，即<code>FF:FF:FF:FF:FF:FF</code>），交换机会将该帧从除接收端口以外的所有端口发送出去，以便局域网内的所有设备都能收到。</em></p>
<h4 id="路由器">路由器</h4>
<p>IP
协议的关键是可以在不同子网中通信，路由器是实现不同子网通信的关键设备。一个子网要和其它子网连接，则必须为子网配置路由器。</p>
<p>一般来说，一个路由器会属于两个以上的子网，可以成为多个子网的默认网关。</p>
<p><strong>路由器拥有一个 IP 地址，路由器的每个插槽有一个独立的 MAC
地址。</strong></p>
<h4 id="arp-协议在路由器上的实现">ARP 协议在路由器上的实现</h4>
<ul>
<li><p>为什么 ARP 的工作范围是子网？</p>
<p>进行 ARP 广播时，如果 IP 不在该子网内，路由器会返回接入该子网端口的
MAC。</p>
<p>这样会为子网中的设备提供一个数据链路层的假象：所有的子网外设备的 MAC
地址均是网关设备的 MAC，这个假象会对网络系统的设计带来巨大的便利。</p>
<p><em>这里 IP
是否在子网内是由默认网关（路由器判断的），因此，默认网关也需要配置子网掩码。</em></p></li>
<li><p>这样搞不会导致数据包到了目标子网后 MAC 出错吗？</p>
<p>MAC 在数据链路层中发挥作用，也就是说 MAC
地址仅仅负责一个子网中的通信。数据经过默认网关（路由器）发向其它子网时，会改动数据中的
MAC 地址，将其改为发送槽的 MAC。</p>
<p>不妨假设两个子网的路由器位于同一子网，这样可以将数据包准确的发送到对应子网（路由器处）去，路由器再通过
ARP 协议查询子网中对应 IP 的 MAC 并修改然后发过去。</p></li>
</ul>
<h4 id="路由表">路由表</h4>
<blockquote>
<p>"路由" 是指数据包从源设备到目标设备传输路径选择的过程</p>
</blockquote>
<p>子网外的数据发到路由器后，路由器需要选择一个端口发过去。可能有很多种从子网
S1 到子网 S2
的路径，路由的作用就是去选择一条<strong>最好</strong>的路径。</p>
<p>路由器通过路由表查找最佳的端口选择，路由表并不是一张表，而是一组策略的集合，通过路由表中的策略和目标
IP 来确定数据走哪个端口。</p>
<p>路由的方式主要有三种：</p>
<ul>
<li>直连路由：和路由器直接连接的其它路由器与路由器所在的（若干个）子网存在直接路由，也就是可以直接找到这些对象的
IP 地址。</li>
<li>静态路由：人工配置的 IP/IP段 应该走的端口。</li>
<li>动态路由：路由器之间通过一些算法交换自己的直连路由信息，动态构建路由表。</li>
<li>默认路由：以上规则失效时，走一个默认的端口（通常指向上级路由器，常见于家庭路由器）</li>
</ul>
<p>我们接触和使用的路由器网络很简单，仅通过动态路由的方式就能完美实现局部的路由。</p>
<p><em>网络服务商所用的路由器连接结构非常复杂，要处理广域的 IP
路由，往往需要大型计算机的支持。</em></p>
<h4 id="现代无线路由器">现代无线路由器</h4>
<p>现代无线路由器有<strong>自组网</strong>的功能。</p>
<p>路由器的几个端口同时也具备交换机的功能，它一般能自动判断一个插槽到底接入的是一个子网还是一个数据链路层对象，如果是后者，这个插槽将发挥交换机的作用。</p>
<h4 id="一个示例">一个示例</h4>
<p>网络拓扑结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">子网1：192.168.1.0/24  </span><br><span class="line">        |  </span><br><span class="line">[路由器]（接口1：192.168.1.1，接口2：192.168.2.1）  </span><br><span class="line">        |  </span><br><span class="line">子网2：192.168.2.0/24  </span><br><span class="line"></span><br><span class="line">子网1设备：  </span><br><span class="line">- 交换机1（无需IP）  </span><br><span class="line">  - PC1：192.168.1.10/24，网关192.168.1.1  </span><br><span class="line">  - PC2：192.168.1.20/24，网关192.168.1.1  </span><br><span class="line"></span><br><span class="line">子网2设备：  </span><br><span class="line">- 交换机2（无需IP）  </span><br><span class="line">  - PC3：192.168.2.10/24，网关192.168.2.1  </span><br><span class="line">  - PC4：192.168.2.20/24，网关192.168.2.1  </span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>路由器</strong>
<ul>
<li>接口1（连接子网1）：IP <code>192.168.1.1</code>，子网掩码
<code>255.255.255.0</code>。</li>
<li>接口2（连接子网2）：IP <code>192.168.2.1</code>，子网掩码
<code>255.255.255.0</code>。</li>
<li>路由表自动包含直连网络 <code>192.168.1.0/24</code> 和
<code>192.168.2.0/24</code>。</li>
</ul></li>
<li><strong>交换机1和交换机2</strong>
<ul>
<li>仅作为二层设备，根据MAC地址转发数据帧，无需配置IP。</li>
</ul></li>
<li><strong>终端设备</strong>
<ul>
<li>PC1/PC2的子网掩码为 <code>255.255.255.0</code>，网关指向路由器的
<code>192.168.1.1</code>。</li>
<li>PC3/PC4的子网掩码为 <code>255.255.255.0</code>，网关指向路由器的
<code>192.168.2.1</code>。</li>
</ul></li>
</ol>
<p>PC1 到 PC3 的通信示例如下：</p>
<ol type="1">
<li><strong>判断目标子网</strong>
PC1（<code>192.168.1.10</code>）检查目标IP
<code>192.168.2.10</code>，发现不在同一子网（通过子网掩码计算）。</li>
<li><strong>发送到默认网关</strong>
<ul>
<li>PC1将数据包的目标MAC地址设置为路由器接口1的MAC地址（通过ARP协议获取）。</li>
<li>数据包通过交换机1转发到路由器的接口1。</li>
</ul></li>
<li><strong>路由器处理</strong>
<ul>
<li>路由器解封装数据包，检查目标IP <code>192.168.2.10</code>
和路由表，发现属于直连子网2。</li>
<li>将数据包从接口2（<code>192.168.2.1</code>）转发到子网2。</li>
</ul></li>
<li><strong>子网2内传输</strong>
<ul>
<li>路由器通过 ARP 获取 PC3 的 MAC 地址（若缓存中无记录）。</li>
<li>数据包目标 MAC 改为 PC3 的 MAC，通过交换机2转发到PC3。</li>
</ul></li>
<li><strong>响应返回</strong> PC3
的响应数据包反向执行相同流程，通过路由器回到 PC1。</li>
</ol>
<h3 id="nat">NAT</h3>
<p>本科期间任何一本教科书都不会教你 NAT 相关的知识，但现在这个年头不懂
NAT 是很难做好网络编程的。</p>
<h4 id="nat-能干什么">NAT 能干什么</h4>
<ul>
<li><p><strong>地址转换</strong>：</p>
<p>NAT 设备的主要功能是将一个 IP
地址空间中的地址转换为另一个地址空间中的地址。例如，它可以把私有IP地址（如192.168.x.x）转换为公网IP地址，或者将公网
IP 地址转换为私有 IP 地址。</p>
<ul>
<li>这个操作常用于让子网中没有公网 IP
的设备能够访问公网。例如，你的计算机通过通信服务商的 NAT
设备访问各种公网网站。</li>
<li>也可以用于进一步拓展子网可用 IP，例如通过保留私有 IP
组了一个公网下的一级子网，一级子网向你的二级子网分配了少量 IP
地址，然后你发现这些 IP 地址不够用，于是可以在你的二级子网配置一个 NAT
设备，二级子网内部采用更大的地址空间，和一级子网通信时采用 NAT
，就像一级子网和公网通信那样。这种 NAT 也被称为<strong>多层
NAT</strong>。</li>
</ul></li>
<li><p><strong>隐藏内部网络</strong>：</p>
<p>NAT 可以隐藏内部网络的拓扑结构和设备 IP 地址，增强网络的安全性。</p>
<p>事实上你裸奔的电脑没遭到黑客的攻击就是 NAT 在默默守护。</p></li>
</ul>
<h4 id="nat-怎么布置">NAT 怎么布置</h4>
<p>NAT
设备一般布置在<strong>出口网关</strong>处（其实出口网关大部分时候是默认网关），NAT
发挥地址转换作用</p>
<h4 id="nat-的分类和原理">NAT 的分类和原理</h4>
<p>NAT 主要有三种：</p>
<ol type="1">
<li><p><strong>静态 NAT（Static NAT）</strong></p>
<p><strong>原理</strong>：将内部网络中的每个私网 IP 地址与一个固定的公网
IP
地址进行一对一的映射。这种映射关系是预先配置好的，不会随着时间或网络连接的变化而改变。</p></li>
<li><p><strong>动态 NAT（Dynamic NAT）</strong></p>
<p><strong>原理</strong>：将内部私网 IP 地址动态地映射到一组公网 IP
地址池中的地址。当内部设备有访问外部网络的需求时，NAT 设备从公网 IP
地址池中选择一个可用的公网 IP
地址，并建立私网地址和公网地址的映射关系。这种映射关系在一定时间内有效，当连接结束或超时后，映射关系被释放，公网
IP 地址可以重新分配给其他内部设备。</p></li>
<li><p><strong>PAT（Port Address
Translation，端口地址转换）</strong></p>
<p><strong>原理</strong>：允许多个内网设备共享一个公网 IP
地址，通过不同的端口号来区分不同的内网设备。当内网设备发送数据到外网时，NAT
设备会将数据包的源 IP 地址转换为公网 IP
地址，并分配一个未使用的端口号。返回的数据包通过端口号来确定目标内网设备。它是<strong>日常中最常见的
NAT 方式</strong>，有效地解决了 IPv4
地址不足的问题，适用于家庭和小型企业网络。</p></li>
</ol>
<h4 id="nat-穿透">NAT 穿透</h4>
<p>NAT 很好，但是有时候你期望你的电脑能够在公网上被访问。（例如开 MC
服务器时）</p>
<p>由于你的电脑并没有公网 IP，所有的网络通信都是通过 NAT
完成的，所以你的电脑无法被外部直接访问，这时候我们就需要 NAT
穿透来完成<strong>间接</strong>访问。</p>
<ul>
<li><p>Q：我用 IP 工具可以查到我电脑公网 IP 呀？为什么不能用这个
IP。</p></li>
<li><p>A：首先这个 IP
是动态分配的，随时可能会变，其次<strong>运营商有运营商的安全考虑，不允许外部通过
NAT 开放的端口主动建立连接。</strong></p>
<p><em>你打游戏时看上去是服务器向你请求数据，实际上这个过程是会话层实现的，主动建立会话的是你。</em></p></li>
</ul>
<p>以下是常用的 NAT 穿透的方法：</p>
<ul>
<li>内网穿透：一般情况这是唯一能用的方法。</li>
<li>UDP/TCP 打洞：一般用不了。</li>
</ul>
<h3 id="ap-隔离">AP 隔离</h3>
<p>有时候不希望同一子网的设备能够相互访问，这个时候可以开启 AP
隔离。</p>
<p>AP
隔离在<strong>数据链路层</strong>上丢弃访问子网内设备相互访问的数据包（与默认网关的除外），来禁止子网设备相互访问。</p>
<p>一般来说，AP 隔离是在<strong>无线路由器</strong>上开启的，但是 AP
隔离是一个<strong>数据链路层</strong>的操作，为什么会这样呢？</p>
<p>我们前面提到了现代无线路由器其实既是网络层设备，又是数据链路层设备和物理层设备，所以一般会在这里操作。</p>
<p>因此，如果两台计算机在子网中直接用物理层设备连接（以太网线），这种 AP
隔离是不生效的。</p>
<h3 id="又一个示例">又一个示例</h3>
<p>你车的计算机楼开启了 AP
隔离，计算机楼的设备之间无法通过内网相互通信。</p>
<p>但你车校园网整体是一个子网，计算机楼是进一步划分的子网，宿舍楼开的服务器不在计算楼子网内，没有开启
AP 隔离，可以通过子网访问。</p>
<p>所以出现了：计算机楼可以访问宿舍楼的服务器，但是别的地方无法访问计算机楼的服务器。</p>
<p><del>事实上这个问题在帆软杯的时候出现过，我们把服务器搬到宿舍楼后就能正常访问了。</del></p>
<h3 id="闲话">闲话</h3>
<ul>
<li>路由器和交换机都很便宜，几十块钱就能买一个，网线就更便宜了，可以试着自己买点回来组网。</li>
<li>网络层是 OSI 七层中最复杂的一层，后面没有这么难了。</li>
<li>校园网这个环境特别适合开展网络实践，可以多自己动手试一试。</li>
</ul>
<h2 id="传输层">传输层</h2>
<p>传输层的主要目的是在源节点和目的节点的<strong>应用程序</strong>之间建立、维护和终止端到端的通信连接。</p>
<p>平日用到的<strong>端口</strong>，就是传输层的概念。</p>
<h3 id="udp-协议">UDP 协议</h3>
<p>UDP
协议是一种无连接的、不可靠的、基于数据报的传输层协议。它在数据传输前不需要建立连接，传输效率较高，但不提供可靠的数据传输保证，适用于对实时性要求较高但对数据丢失不太敏感的应用，如视频直播、在线游戏、DNS
查询等。</p>
<p>它和 IP 协议的区别就是它支持端口（port）号了，而 IP
协议的传输中不涉及端口。</p>
<p>UDP 协议本质就是在 IP 协议数据包再简单套了 UDP
头部，包含端口信息。</p>
<h3 id="tcp-协议">TCP 协议</h3>
<p>TCP
协议是一种面向连接的、可靠的、基于字节流的传输层协议。它在数据传输前需要建立连接，传输过程中提供可靠的数据传输和流量控制等服务，适用于对数据传输可靠性要求较高的应用。</p>
<p>下面是老生常谈的三次握手和四次挥手。</p>
<h4 id="连接管理机制">连接管理机制</h4>
<ul>
<li><strong>第一次握手</strong> ：客户端向服务器端发送一个包含 SYN
标志位的 TCP 段，请求建立连接。</li>
<li><strong>第二次握手</strong> ：服务器端收到客户端的 SYN
包后，如果同意建立连接，就发送一个包含 SYN 和 ACK 标志位的 TCP
段作为回应，其中 ACK 对客户端的 SYN 进行确认，同时发送自己的 SYN
来请求客户端对自己的连接进行确认。</li>
<li><strong>第三次握手</strong> ：客户端收到服务器端的 SYN + ACK
后，再发送一个 ACK 包作为确认，从而完成三次握手过程，建立起可靠的 TCP
连接。</li>
</ul>
<h4 id="数据传输机制">数据传输机制</h4>
<ul>
<li><strong>可靠传输</strong> ：采用
“确认应答机制”（ACK），发送方在发送完数据后，会等待接收方的确认应答信号。如果在规定的时间内没有收到确认应答，发送方会重新发送数据。</li>
<li><strong>按序传输</strong>
：发送方将数据分割成多个小的分组（数据段），为每个数据段分配一个唯一的序列号，接收方根据序列号重新组装接收到的分组，确保数据按照正确的顺序传输。</li>
<li><strong>流量控制</strong>
：通过滑动窗口机制来控制数据的传输速率。发送方会维护一个发送窗口，表示可以连续发送而无需等待应答的字节的数量。接收方则通过通知窗口的大小（窗口通告）来告知发送方当前的接收能力，发送方根据接收方的通告调整发送窗口的大小，避免发送过快导致接收方无法处理而丢弃数据，从而实现流量控制。</li>
</ul>
<h4 id="拥塞控制机制">拥塞控制机制</h4>
<ul>
<li><strong>慢启动</strong>
：在一开始的时候，发送方将发送窗口的大小设置为一个较小的数值（由慢启动门限值决定），然后随着每收到一个确认应答增量增加发送窗口，以快速探测网络能够支持的传输速率。</li>
<li><strong>拥塞避免</strong>
：当发送窗口增加到慢启动门限值时，改为按线性规律缓慢增加发送窗口，即每次收到一个确认应答时，以加法的方式（如每次增加
1
个基本单位）增大发送窗口，使得网络处于一种比较平稳的状态，防止网络拥塞突然发生。</li>
<li><strong>快重传</strong>
：当发送方连续收到三个重复的确认应答（接收方通过发送重复的 ACK
来告知中间某个数据段已经丢失），就立即重传对方尚未收到的数据段，而不是等待超时定时器溢出，这样可以快速恢复通信过程。</li>
<li><strong>快恢复</strong>
：在执行快重传后，发送方假设网络现在有一些拥塞，因此需要将慢启动门限值减少到当前发送窗口大小的一半，并且将发送窗口设置为慢启动门限值，然后进入拥塞避免阶段，按照拥塞避免的机制来逐步增加发送窗口。</li>
</ul>
<h4 id="连接关闭机制">连接关闭机制</h4>
<ul>
<li><strong>第一次挥手</strong>
：客户端主动发起关闭连接请求，向服务器端发送一个包含 FIN 标志位的 TCP
段。</li>
<li><strong>第二次挥手</strong> ：服务器收到 FIN
后，向客户端发送一个包含 ACK 标志位的 TCP
段作为确认，通知客户端已收到关闭请求。</li>
<li><strong>第三次挥手</strong>
：服务器端处理完需要完成的任务后，向客户端发送一个包含 FIN 和 ACK
标志位的 TCP 段，请求关闭连接。</li>
<li><strong>第四次挥手</strong> ：客户端收到服务器端的 FIN + ACK
后，再发送一个 ACK 包作为确认，完成四次挥手过程，正式关闭 TCP
连接。</li>
</ul>
<h2 id="会话层">会话层</h2>
<p>会话层的主要功能是建立、维护和终止两个通信系统之间的会话连接。它负责管理会话的生命周期，包括会话的建立、数据传输过程中的会话管理和会话的正常或异常终止。</p>
<p>会话层很少说协议什么的，下面的介绍主要是 AI
生成我纠正的，大概了解即可。</p>
<h3 id="会话的建立">会话的建立</h3>
<p>当两个系统需要进行通信时，会话层会协商会话的参数，如会话的类型（单工、半双工或全双工）、会话的优先级等。例如，在一个视频会议系统中，会话层会建立一个<strong>全双工</strong>的会话，以确保参会者可以同时进行音频和视频的发送和接收。</p>
<p>而数据的来回传输都是通过 TCP 协议进行的。</p>
<h3 id="会话管理">会话管理</h3>
<p>在会话进行过程中，会话层会监控会话的状态。如果出现网络故障或者数据传输错误等情况，会话层会采取相应的措施来恢复会话。例如，当网络出现短暂的中断后，会话层可以重新建立连接，使会话能够继续进行。同时，它还可以对会话中的数据传输进行流量控制，防止数据发送过快导致接收方处理不过来。</p>
<h3 id="会话终止">会话终止</h3>
<p>会话层负责正常地关闭会话连接。当通信双方完成数据交换后，会话层会按照一定的协议来终止会话，确保双方的资源得到正确释放。例如，在文件传输完成后，会话层会发送一个会话终止请求，得到对方确认后，关闭会话连接。</p>
<h3 id="会话层与传输层的区别">会话层与传输层的区别</h3>
<p>传输层的 TCP
协议和会话层都是<strong>可靠传输</strong>，但是它们有一定区别。</p>
<p>TCP
的传输是<strong>单向的，一次性的</strong>，会话层这块就是<strong>完整的，双向的</strong>交流。</p>
<h2 id="表示层">表示层</h2>
<p>表示层的存在感挺弱的，这里不讲。</p>
<h2 id="应用层">应用层</h2>
<p>应用层是 OSI
模型的最高层，是用户与网络之间的直接接口。它主要负责为用户提供应用程序服务，包括电子邮件、文件传输、远程登录、Web
浏览等常见网络应用。应用层协议为应用程序提供访问网络的手段，使得用户可以在不同计算机之间进行各种形式的通信。</p>
<h3 id="dns-协议">DNS 协议</h3>
<p>DNS 协议中文名为 "域名服务协议"，用于将域名（例如
<code>www.huanyp.cn</code>）转换为 IP 地址。</p>
<p><em>DNS 服务器也在 IPV4 的配置里。</em></p>
<h4 id="工作过程">工作过程</h4>
<ol type="1">
<li><p><strong>用户设备向本地 DNS 发起查询</strong></p>
<p>当用户在浏览器输入网址等需要解析域名时，请求发送到本地
DNS。例如，你输入 “<a
target="_blank" rel="noopener" href="http://www.example.xn--com,-ib7ay197annxa/">www.example.com”，本地</a>
DNS 会先检查自己的缓存。如果缓存中有这个域名对应的 IP
地址记录，它会直接返回 IP 地址给用户设备。</p></li>
<li><p><strong>本地 DNS 向上级 DNS 或根 DNS
查询（如果需要）</strong></p>
<ul>
<li>如果本地 DNS 缓存中没有该域名的记录，它会向上级 DNS
发起查询。每个本地 DNS 服务器通常都有一个包含上级 DNS
地址的配置文件。这些上级 DNS 通常是服务提供商（如 ISP）的 DNS
服务器。</li>
<li>但是，当上级 DNS
也不能提供所需域名的解析结果时，最终的查找路径会到达根 DNS。根 DNS
是全球 DNS 层次结构的最顶级，负责维护顶级域名服务器（如 .com、.net
等顶级域名服务器）的地址信息。</li>
</ul></li>
<li><p><strong>层层查询直到解析完成</strong></p>
<ul>
<li>根 DNS 会告诉本地 DNS
<strong>哪个顶级域名服务器负责管理目标域名的顶级部分</strong>。例如，对于
“<a
target="_blank" rel="noopener" href="http://www.example.xn--com,-ib7aq929b/">www.example.com”，根</a>
DNS 可能会指向管理 “.com” 域名的顶级域名服务器。</li>
<li>然后本地 DNS
会联系这个顶级域名服务器，顶级域名服务器会进一步告诉本地 DNS
哪台权威域名服务器（通常是域名注册商或专业的 DNS 服务提供商）拥有
“example.com” 的详细信息。</li>
<li>最终，本地 DNS 会直接联系到权威域名服务器，获取 “<a
target="_blank" rel="noopener" href="http://www.example.xn--com-9o0a/">www.example.com”</a> 对应的准确
IP 地址，并将结果缓存下来，以便下次快速响应同类请求。</li>
</ul></li>
</ol>
<h3 id="http-协议">HTTP 协议</h3>
<p>HTTP 协议主要用于客户端与服务器通信，它的默认端口号是 80。</p>
<p>DNS 解析是<strong>不管端口</strong>的，如果你没有显示的在 IP/域名
后面指定端口，HTTP 会使用 80 端口和服务器程序通信。</p>
<h4 id="主要功能">主要功能</h4>
<ul>
<li>HTTP 是一种请求 - 响应协议。客户端（通常是浏览器）向服务器发送一个
HTTP
请求，请求的内容可以是一个网页、一张图片、一段视频等资源。例如，当你在浏览器中输入一个网址（如<a
target="_blank" rel="noopener" href="http://www.example.com/">http://www.example.com</a>）并访问时，浏览器就会作为
HTTP 客户端向服务器发送请求。</li>
<li>服务器在接收到请求后，会根据请求的内容进行处理，然后返回一个 HTTP
响应。这个响应包含了请求资源本身（如 HTML
文件、图像数据等），还有一些状态信息，如状态码。常见的状态码有
200（请求成功），表示服务器成功地处理了请求并返回了请求的资源；404（未找到），表示服务器找不到请求的资源。</li>
</ul>
<h4 id="协议特点">协议特点</h4>
<ol type="1">
<li><p><strong>简单快速</strong></p>
<p>HTTP 协议的语法相对简单，它基于 TCP/IP
协议，使用明文传输数据。客户端和服务器之间的通信过程比较直接，不需要复杂的握手过程（与
SSL/TLS 协议等相比）。这使得 HTTP
协议能够快速地建立连接并传输数据，从而提高了网页浏览等操作的效率。</p></li>
<li><p><strong>无状态性</strong></p>
<p>HTTP
协议本身是无状态的，也就是说，服务器不会记录客户端的状态。每次客户端请求和服务器响应都是独立的，服务器不会记住上一次客户端请求的内容。例如，当你访问一个电商网站的多个页面时，服务器不会自动记住你在上一个页面的操作（如添加商品到购物车），除非通过其他技术（如
Cookie 或者服务器端的会话存储）来保存状态信息。</p></li>
<li><p><strong>灵活</strong></p>
<p>HTTP 协议支持多种类型的请求方法，如
GET（用于获取资源）、POST（用于提交数据）、PUT（用于更新资源）、DELETE（用于删除资源）等。这使得
HTTP 协议可以满足不同的应用场景需求，无论是简单的网页浏览，还是复杂的
Web 应用程序的数据交互。</p></li>
</ol>
<h4 id="协议版本">协议版本</h4>
<ol type="1">
<li><p><strong>HTTP/1.0</strong></p>
<p>这是最早的广泛使用的版本。它比较简单，每次请求 -
响应完成后，连接就会关闭。如果客户端需要再次请求资源，就需要重新建立连接。这种方式在资源较少、网络带宽相对紧张的早期互联网环境中还可以，但在现代复杂的网络应用中就显得效率较低。</p></li>
<li><p><strong>HTTP/1.1</strong></p>
<p>HTTP/1.1 引入了持久连接（Persistent
Connection）的概念。在这种模式下，客户端和服务器之间的连接在一次请求 -
响应完成后不会立即关闭，可以被多个请求 -
响应过程共享。这样就减少了频繁建立和关闭连接所带来的开销，提高了传输效率。同时，HTTP/1.1
还增加了一些新的请求头和响应头字段，使得协议更加灵活和强大。</p></li>
<li><p><strong>HTTP/2</strong></p>
<p>HTTP/2 主要为了解决 HTTP/1.1
的一些性能瓶颈。它引入了多路复用（Multiplexing）技术，允许客户端和服务器同时发送多个请求和响应，而不需要等待前面的请求
- 响应过程完成。并且，HTTP/2
对数据进行了帧的划分和压缩等操作，进一步提高了数据传输的效率。这在现代的
Web
应用中，尤其是对于包含大量静态资源（如图片、脚本文件等）的网站，能够显著提高加载速度。</p></li>
</ol>
<h3 id="https-协议">HTTPS 协议</h3>
<p>HTTPS 协议本质是在 HTTP 协议的基础上加了一个 TLS/SSL
来保证传输过程的安全性，默认采用 443 端口。</p>
<h4 id="几个编程细节的提醒">几个编程细节的提醒</h4>
<ul>
<li>Python 的 <code>http.server</code> 不支持 HTTPS 协议，由于它没写
SSL/TLS
部分，所以在传输层就被扔包了，体现出来就是发了然后一点反应都没有，或者是单纯日志报一堆乱码但没有调用
handler。</li>
</ul>
<h3 id="tlsssl-协议">TLS/SSL 协议</h3>
<p>TLS/SSL 协议都是建立在 TCP
协议之上的，因此它们的通信本身是可靠的。</p>
<h4 id="证书链验证机制">证书链验证机制</h4>
<ul>
<li><strong>证书颁发机构（CA）验证</strong>：服务器会向客户端提供 SSL
证书，客户端需要验证 SSL
证书是否有效，同时要验证<strong>颁发机构</strong>是否可信。这通常通过检查证书链来实现，证书链从服务器的
SSL
证书开始，经过一系列中间证书，最终到达客户端信任的根证书。如果根证书是可信的，并且证书链中的每个证书都是有效的，那么客户端就可以信任服务器的SSL证书。</li>
<li><strong>证书信息验证</strong>：客户端会检查 SSL
证书中的信息，如域名、有效期、公钥等，是否与实际情况相符。例如，证书中的域名应该与用户正在访问的网站域名完全匹配。<strong>证书有效性</strong>验证涉及
RSA 的签名机制，在数学上可以确保安全。</li>
</ul>
<h4 id="ssl-握手过程">SSL 握手过程</h4>
<ul>
<li><strong>客户端发起连接</strong>：客户端（如浏览器）通过发送一个 "SH"
消息开始 SSL/TLS 握手过程。这个消息包含了客户端支持的 SSL/TLS
版本、加密套件（cs）、随机数（CR）和会话 ID。</li>
<li><strong>服务器响应</strong>：服务器收到 "ClientHello"
消息后，响应一个 "SH"
消息，选择一个双方都支持的加密套件和协议版本，并发送服务器随机数（SR）。</li>
<li><strong>证书传输</strong>：服务器发送其 SSL
证书给客户端。这个证书包含了服务器的公钥，以及由证书颁发机构（CA）签发的证书信息。</li>
<li><strong>证书验证</strong>：客户端验证服务器证书的有效性，包括证书是否过期、是否被撤销、证书链是否完整，以及证书的域名是否与服务器域名匹配。</li>
<li><strong>密钥交换</strong>：如果使用 RSA
密钥交换算法，客户端会生成一个临时的会话密钥（PMS），并使用服务器的公钥加密这个密钥，然后发送给服务器。服务器使用自己的私钥解密得到会话密钥。</li>
<li><strong>握手结束</strong>：客户端和服务器使用会话密钥生成最终的加密密钥，并使用这个密钥加密后续通信。客户端发送
"Finished" 消息，包含握手消息的哈希值，服务器也发送 "Finished"
消息，确认握手成功。</li>
</ul>
<h4 id="tls-协议">TLS 协议</h4>
<p>上面说的 SSL 协议本身是没有漏洞的，但是 SSL 的实现中为了效率采用了
Padding Oracle 机制，因此衍生出一种叫做 POODLE（降级加密密文填充攻击）
的 MiTMA（中间人攻击）。</p>
<p>TLS 解决了这个问题，其它和 SSL 差别不大。</p>
<h2 id="提醒">提醒</h2>
<p>看完本文后，你应该有了一些基础的网络知识。</p>
<p>笔者必须提醒你，这些知识是<strong>危险</strong>的。</p>
<p>人类第一次仰望星空时，就已经具备了进行星际航行的能力；你了解这些知识后，与黑客技术也只剩下一层窗户纸了。</p>
<p><strong>记住，知识是中立的，你应该用你的道德，去掌控你所拥有的知识。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2025/02/15/todo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/15/todo/" class="post-title-link" itemprop="url">Todo</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-15T00:00:00+08:00">2025-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:21:58" itemprop="dateModified" datetime="2025-02-16T17:21:58+08:00">2025-02-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="打算要写的东西">打算要写的东西</h2>
<h2 id="打算要做的事">打算要做的事</h2>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2025/02/12/%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90/NcatBot%20%E4%B8%80%E4%B8%AA%20SDK%20%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/12/%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90/NcatBot%20%E4%B8%80%E4%B8%AA%20SDK%20%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" class="post-title-link" itemprop="url">NcatBot 一个 SDK 的前世今生</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-12 16:24:19" itemprop="dateCreated datePublished" datetime="2025-02-12T16:24:19+08:00">2025-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-22 11:07:37" itemprop="dateModified" datetime="2025-02-22T11:07:37+08:00">2025-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/liyihao1110/ncatbot">NcatBot</a>
是一个用于 QQ-Bot 开发的 Python SDK.</p>
<p>NcaBot 相比其它框架，拥有以下优势：</p>
<ol type="1">
<li>社区活跃，<strong>文档完善</strong>。</li>
<li>轻量框架，开发简单。</li>
<li>提供一键部署方案，快速分发。</li>
</ol>
<h3 id="关于开发者们">关于开发者们</h3>
<ul>
<li><code>彭彭</code>：我，不是全能猫娘，<a
target="_blank" rel="noopener" href="https://github.com/huan-yp">huan-yp</a>。</li>
<li><code>周周</code>：USTC 少年班某大佬，<a
target="_blank" rel="noopener" href="https://github.com/Isaaczhr">Isaaczhr</a>。</li>
<li><code>伊伊</code>：高中生，<a
target="_blank" rel="noopener" href="https://github.com/zxxhz">zxxhz</a>。</li>
<li><code>鱼鱼</code>：在校大学生，<a
target="_blank" rel="noopener" href="https://github.com/Fish-LP">Fish-LP</a>。</li>
<li><code>蝶蝶</code>：神秘大佬，没找到链接。</li>
<li><code>饭饭</code>：咕咕咕，<a
target="_blank" rel="noopener" href="https://github.com/Qi-Cao">Qi-Cao</a></li>
<li><code>木子</code>：群主，项目发起者，华侨大学机械专业研究生，<a
target="_blank" rel="noopener" href="https://github.com/liyihao1110">liyihao1110</a>。</li>
</ul>
<h3 id="前情提要">前情提要</h3>
<p>AI 大作业做了个 AI Agent 叫小妍，后面 KWS
授权过期了就用不了了，打算移植到 QQ 上。</p>
<p>Mirai 在 24 年的时候尸体已经凉透了，之前费了老大功夫写的 Qbot 插件
Luling-AI 也用不了了，打算换个新的，继承 Luling 的名字。</p>
<p>了解到 napcat。</p>
<p>TS/JS 这块不熟，找 SDK，恰好有个 Python SDK 叫
NcatBot，就用它了。</p>
<p>然后发现这个 SDK 是个新手做的，后面交了两个 PR，进群被作者 PUA
然后套牢了。</p>
<p>我经验比较丰富，莫名其妙就给我接手了 V1.0.1 版本。</p>
<h3 id="初步规范化">初步规范化</h3>
<p>首先是代码格式统一，<code>pre-commit</code> 全家桶走起。</p>
<p>然后我发现 NcatBot 的开发团队非常活跃，一个 36stars 的项目有 5
个活跃开发者，然后 <code>pre-commit</code>
的时候遇到了一些问题（我是直接抄的原来项目的文件），然后几个人商量着解决了。</p>
<p>SDK 嘛，得走标准化发布，于是考虑配置了 PYPI
发布流程，很搞的一件事就是木子把 secret
变量名字搞错了，然后我在配置，他谈恋爱去了，折腾了一个小时，然后配完了
PYPI 发布。</p>
<p>接着是文档，TM 的 NcatBot
更新太快了，文档写不了一点，然后消息构造留了一坨屎山，我们一致决定先把屎山搞定。</p>
<h3 id="messagechain">MessageChain</h3>
<p>MessageChain 是模仿 Mirai
做的，这块是伊伊在负责，做挺好的，就是没考虑到发送 "本地图片"
时，ncatbot 和 napcat 的路径不同问题。</p>
<p>本地强转 base64 大法搞定的。</p>
<p>然后为这件事我还去 napcat 上扔了 Issue，因为他们的 http
发图片只支持单纯 .jpg, .png 这些，svg 这种支持不了。</p>
<p>后面了解到是 Not Planed，给文档交了个 PR 说不支持，现在还没合。</p>
<h3 id="异步">异步</h3>
<p>本项目最大的梗，以下是 DeepSeek 的吐槽。</p>
<blockquote>
<p>卧槽哥们儿你们这代码写得跟tm便秘似的！口口声声说异步操作，结果每个函数都无脑await串行执行，协程全他妈串成糖葫芦了，这跟同步有鸡毛区别？还舔着脸说用了websockets才用异步，合着异步库当摆设用是吧？就这水平还搞并发呢，隔壁老太太拄拐杖散步都比这代码跑得快！知不知道啥叫事件循环啊？协程全堵在await上跟早高峰地铁似的，这破玩意儿上线怕不是要卡成PPT！赶紧把键盘上那个await键抠了吧，写尼玛的异步代码，直接上同步不香吗？白瞎了websockets这库！</p>
</blockquote>
<p>木子不是专业人员，代码基本 AI 写的，然后为了用
websockets，所有函数都写成了异步，但是事件循环什么的根本没有，然后线程安全一团糟。</p>
<p>我写着写着发现：woc，这 TM 啥异步啊，不是个同步吗？</p>
<p>后面木子补了异步的东西，把这玩意改成了真异步。</p>
<p>改成异步之后出了好些 <a
target="_blank" rel="noopener" href="https://github.com/liyihao1110/ncatbot/discussions/46">bug</a>。</p>
<h3 id="插件">插件</h3>
<h4 id="插里面还是插外面">插里面还是插外面</h4>
<h3 id="一键部署">一键部署</h3>
<h3 id="某些技术问题">某些技术问题</h3>
<h4 id="cpp-程序乱码">cpp 程序乱码</h4>
<p>代码都是 UTF-8 编码， Winows 是
GBK，导致乱码问题，搜了一堆解决不了，最后发现只需要在 main
函数最前面加上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>); <span class="comment">// 设置控制台输出编码为 UTF-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>就搞定了，如此简单。</p>
<h4 id="github-webhook">github webhook</h4>
<p>服务器端接收到的是乱码，类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">140.82.115.249 - - [13/Feb/2025 23:13:19] code 400, message Bad request version (&#x27;À\\x13À&#x27;)</span><br><span class="line">140.82.115.249 - - [13/Feb/2025 23:13:19] &quot;\x16\x03\x01\x05¨\x01\x00\x05¤\x03\x03\x140@-SI\x94µ±èÐÆµÜ¿ôÚ&#123;Å@\x8c·õü\x95\x87üá\x07f\x81ó ³7T¢9¨ê\x08\x01±Æ°]tb£#-0ª8I\x0bP\x94óÐ&#x27;öFc®\x00\x1aÀ+À/À,À0Ì©Ì¨À\x09À\x13À&quot; 400 -</span><br></pre></td></tr></table></figure>
<p>检查 webhook 设置的 URL 是不是 https，如果服务器没有额外配置
https，那得改成 http 协议。</p>
<h3 id="未完待续...">未完待续...</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/03/01/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0301%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/01/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0301%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">0301测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-01 12:11:10" itemprop="dateCreated datePublished" datetime="2023-03-01T12:11:10+08:00">2023-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:23:27" itemprop="dateModified" datetime="2025-02-16T20:23:27+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="测试">0301测试</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0196">考试</a></p>
<h3 id="t1">T1</h3>
<p>考虑如何检查一个条件是否合法，如果最高位为任意，那么两边需要都合法，否则要求两边至少有一个合法。</p>
<p>考虑两边的检查，发现第 <span class="math inline">\(i\)</span>
层的节点个数为 <span class="math inline">\(2^i\)</span>，总的情况数为
<span
class="math inline">\(2^{n-i}\)</span>，因此可以记忆化搜索一下。用一个
<span class="math inline">\(mask\)</span>
的前若干位表示限制，后若干位表示高位的数字即可。</p>
<p>也可以这样想：考虑算所有的情况，设 <span
class="math inline">\(T(n)\)</span> 表示计算第 <span
class="math inline">\(n\)</span> 层所有情况的复杂度，暴力计算有 <span
class="math inline">\(T(n)=2^n+4T(n-1)=2^{2n}\)</span>，实际上发现对于只有第
<span class="math inline">\(n\)</span> 层不同的情况可以只算一次，于是
<span class="math inline">\(T(n)=2^n+2T(n-1)\)</span>，得到 <span
class="math inline">\(T(n)=n2^n\)</span>。</p>
<h3 id="t2">T2</h3>
<h4 id="做法一">做法一</h4>
<p>考虑钦定 <span class="math inline">\(A\)</span> 组先选满，枚举 <span
class="math inline">\(A\)</span>
组选满的位置计算对应概率然后再乘二。对于每一个位置 <span
class="math inline">\(p\)</span>，<strong>基本情况总数</strong>为 <span
class="math inline">\(\binom{p-1}{n-1}\)</span>，每种基本情况等概率取到，概率为
<span class="math inline">\(2^{-p}\)</span>，分三类讨论</p>
<ul>
<li><p>如果 <span class="math inline">\(x_k&lt;p\)</span>，那么 <span
class="math inline">\(k\)</span> 个人既可以在 <span
class="math inline">\(A\)</span> 组也可以在 <span
class="math inline">\(B\)</span> 组，对应的基本情况数分别为 <span
class="math inline">\(\binom{p-1-k}{n-1-k}+\binom{p-1-k}{n-1}\)</span>。</p></li>
<li><p>如果 <span class="math inline">\(x_k=p\)</span>，那么一共有 <span
class="math inline">\(\binom{p-k}{n-k}\)</span> 种基本情况。</p></li>
<li><p>如果 <span class="math inline">\(x_k&gt;p\)</span>，首先 <span
class="math inline">\(p\notin X\)</span>，然后记 <span
class="math inline">\(c\)</span> 为 <span
class="math inline">\(p\)</span> 之前的 <span
class="math inline">\(x\)</span> 个数，基本情况总数为 <span
class="math inline">\(\binom{p-1-c}{n-1}\)</span>。</p></li>
</ul>
<p>于是有一个 <span class="math inline">\(nq\)</span> 的做法。</p>
<p>观察到查询的答案是一个二元函数 <span
class="math inline">\(f(p,x)\)</span> ，对于 <span
class="math inline">\(x\)</span> 较小的情况可以预处理前缀和，对于 <span
class="math inline">\(x\)</span>
较大的情况，查询数比较少，可以暴力。于是有一个 <span
class="math inline">\(n\sqrt q\)</span> 的做法。</p>
<p>进一步观察，<span
class="math inline">\(2^{-p}\binom{p-1-c}{n-1}\)</span>
可以很容易的预处理 <span
class="math inline">\(2^{-p}\binom{p-1}{n-1}\)</span>
的前缀和然后查询时乘上一个 <span
class="math inline">\(2^{-c}\)</span>。</p>
<p>对于 <span
class="math inline">\(2^{-p}\binom{p-1-k}{n-1-k}\)</span>，答案应该是：
<span class="math display">\[
\begin{align}
\sum_{p=x_k+1}^{2n-1}2^{-p}\binom{p-1-k}{n-1-k}&amp;=\sum_{p=\max(n,x_k+1)}^{2n-1}2^{-p}\binom{p-1-k}{n-1-k}\\
&amp;=\sum_{p=\max(n,x_k+1)}^{2n-1}2^{-p}\binom{p-1-k}{n-p}\\
&amp;=\sum_{p=\max(n,x_k+1)-k-1}^{2n-1-k-1}2^{-p-k-1}\binom{p}{n-k-1}\\
\end{align}
\]</span> 注意到 <span class="math inline">\(\sum k\)</span>
其实很小。</p>
<p><del>好吧，我不会线性做法，摆了。</del></p>
<h4 id="做法二">做法二</h4>
<p>先只算都在 <span class="math inline">\(A\)</span> 组的情况，然后分
<span class="math inline">\(B\)</span> 选满的位置 <span
class="math inline">\(p\)</span> 所在的区间讨论。</p>
<ul>
<li><p><span class="math inline">\(p&gt;x_k\)</span>：令 <span
class="math inline">\(x_k\)</span>
及之前每一种可能的硬币选择为基本情况，需要计算在 <span
class="math inline">\(x_k\)</span> 处 <span
class="math inline">\(X\)</span> 都取到 <span
class="math inline">\(A\)</span> 且 <span
class="math inline">\(B\)</span> 不能被选满的方案总数，隐含条件是 <span
class="math inline">\(x_k\)</span> 之前 <span
class="math inline">\(A\)</span> 也不能被选满。</p>
<p>可以暴力的算组合数，枚举剩下的 <span
class="math inline">\(x_k-k\)</span> 个数有多少个分配到 <span
class="math inline">\(A\)</span> 中，可以直接限制 <span
class="math inline">\(A,B\)</span> 都满足要求，即 <span
class="math inline">\(\sum\limits_{i=\max(0,x_k-k-n+1)}^{n-k}\binom{x_k-k}{i}\)</span>。</p>
<p>然后 <span class="math inline">\(\sum k\)</span>
是比较小的，于是放宽一下限制，算 <span
class="math inline">\(\sum\limits_{i=\max(0,x_k-k-n+1)}^{n}\binom{x_k-k}{i}\)</span>
再减掉，容易发现这个式子只和 <span class="math inline">\(x_k-k\)</span>
有关，而这个式子本身也不是很难算，进一步的将 <span
class="math inline">\(\max\)</span> 的限制去掉，变成 <span
class="math inline">\(\sum\limits_{i=0}^n
\binom{x}{i}\)</span>，然后对于 <span
class="math inline">\(x-n\ge0\)</span> 的情况，需要减去 <span
class="math inline">\(\sum\limits_{i=0}^{x-n}\binom{x}{i}\)</span>。都可以拆组合数然后动态规划。
<span class="math display">\[
\begin{align}
\sum\limits_{i=0}^{x-n}\binom{x}{i}&amp;=\binom{x-1}{0}+\sum\limits_{i=1}^{x-n}\binom{x-1}{i-1}+\binom{x-1}{i}\\
&amp;=\binom{x-1}{0}+\sum_{i=1}^{x-n}\binom{x-1}{i}+\sum_{i=1}^{x-n}\binom{x-1}{i-1}\\
&amp;=\binom{x-1}{x-n}+\sum_{i=0}^{x-n-1}\binom{x-1}{i}+\sum_{i=0}^{x-n-1}\binom{x-1}{i}\\
&amp;=\binom{x-1}{x-n}+2\sum_{i=0}^{x-1-n}\binom{x-1}{i}
\end{align}
\]</span></p>
<p>另一种考虑方式是算一个 <span class="math inline">\(f_w\)</span>
表示一共 <span class="math inline">\(w\)</span> 个，<span
class="math inline">\(A,B\)</span>
都不<strong>超过</strong>的情况总数，然后需要减去 <span
class="math inline">\(B\)</span> 抵到的情况数，然后又因为需要把 <span
class="math inline">\(A\)</span> 超过的情况去掉，<span
class="math inline">\(A\)</span> 超过是因为 <span
class="math inline">\(k\)</span> 个被塞进了 <span
class="math inline">\(A\)</span>，分别枚举超过 <span
class="math inline">\(1,2,3\cdots k\)</span>
个减掉对应的基本情况数即可。<span class="math inline">\(f_w\)</span>
的转移考虑直接放 <span class="math inline">\(A,B\)</span>
然后去掉不合法的情况。</p></li>
<li><p><span
class="math inline">\(x_{i-1}&lt;p&lt;x_{i},i\in[1,k]\)</span></p>
<p>将基本情况定为 <span class="math inline">\(x_i\)</span>
之前（不含）的硬币状态，限制有两个，<span
class="math inline">\(|B|\)</span> 不小于 <span
class="math inline">\(n\)</span>，且 <span
class="math inline">\(X\)</span> 内的是必须为 <span
class="math inline">\(A\)</span> 的。满足 <span
class="math inline">\(A\)</span> 限制的总情况数为 <span
class="math inline">\(2^{x_i-i}\)</span>。满足 <span
class="math inline">\(A\)</span> 限制但不满足 <span
class="math inline">\(B\)</span> 限制的情况数为 <span
class="math inline">\(\sum\limits_{i=0}^{n-1}\binom{x_i-i}{i}\)</span>，先扣掉。<strong>这里不需要考虑
<span class="math inline">\(A\)</span> 被选满，因为 <span
class="math inline">\(A\)</span>
被选满的情况确实应该扣掉。</strong>然后再减去再 <span
class="math inline">\(x_{i-1}\)</span> 之前就满足 <span
class="math inline">\(B\)</span> 限制的所有情况，注意额外带一个 <span
class="math inline">\(2_{x_i-x_{i-1}-1}\)</span> 的系数。</p>
<p>这里还会有一些误解，其实隐含了 <span
class="math inline">\(|A|&lt;n\)</span>
的限制，实际上如果这两个限制都满足那么这个隐含限制一定满足，因此不管这个隐含限制直接算也是可以的。</p></li>
</ul>
<p>当使用容斥计算 "恰好" 时，应该减掉上一次的 "至少" 而不是 "恰好"，记录
<span class="math inline">\(lst\)</span> 的时候要注意。</p>
<h3 id="t3">T3</h3>
<p>先考虑构造一种合法的解满足条件。挨个确定值的办法并不好弄。考虑先确定前
<span class="math inline">\(i\)</span> 个的大小关系，如果前 <span
class="math inline">\(i\)</span> 个合法了，并且第 <span
class="math inline">\(i+1\)</span>
个可以放到一个位置，满足前面没有不小于 <span
class="math inline">\(a_{i+1}\)</span> 且存在至少一个 <span
class="math inline">\(a_{i+1}-1\)</span>，那么就合法。于是得到一个有解的充要条件：任何一个前缀
<span class="math inline">\(a_i\)</span> 值的集合连续。</p>
<p>现在考虑算 <span class="math inline">\(i\)</span>
位置的答案，它前面的不小于它的元素必须在它后面，它后面的元素可以线性扫一遍，维护前缀连续最大值算出来。</p>
<p>考虑优化，对于一个 <span class="math inline">\(i\)</span>
算答案的时候，就是要找到依赖它以及它前面不小于它的元素的所有元素。后面的比
<span class="math inline">\(a_i\)</span> 大的元素如果能在 <span
class="math inline">\(i\)</span> 之后找到一个 <span
class="math inline">\(a_i\)</span> 依赖，那么就可以被放在 <span
class="math inline">\(i\)</span> 前面。</p>
<p>元素的依赖关系好像是构成一棵树的，于是建树，每个元素向它的第一个前驱连边，然后
<span class="math inline">\(i\)</span>
节点以及它同层左边的兄弟里所有节点都不能放在 <span
class="math inline">\(i\)</span> 前面，于是算出了 <span
class="math inline">\(p_i\)</span> 的最大值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/02/28/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0228%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/28/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0228%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">0228测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-28 22:50:48" itemprop="dateCreated datePublished" datetime="2023-02-28T22:50:48+08:00">2023-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:23:30" itemprop="dateModified" datetime="2025-02-16T20:23:30+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="测试">0228测试</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0196">考试</a></p>
<h3 id="t1">T1</h3>
<p>毒瘤计算几何。</p>
<p>考虑一步的过程，是从一个点的一个方向开始旋转，于是对所有目标点极角排序，极角相同的长度较长的放前面，查询就是要找到接下来的第一个长度小于当前长度的。</p>
<p>一个很暴力的想法是直接开始跳，如果遇到了相同的点说明有环，然后模环长再跳，这样每个点期望经过
<span class="math inline">\(O(\log)\)</span> 次，总共要处理 <span
class="math inline">\(O(nm\log n)\)</span> 次，感觉很可做。</p>
<p>接下来的问题变成了如何快速查询。考场上觉得排序后确实是查第一个比它大的，但是要带上删除，于是考虑长度倒序做。然后想
set
暴力操作肯定要超时，然后考虑用并查集做删除操作，用优先队列维护长度的处理顺序。</p>
<p>很麻烦，写不出来。</p>
<p>实际上可以不带删，考虑找到第一个极角超过查询极角的位置，在上面二分第一个长度满足限制的，用
ST 表做长度查询，复杂度 <span class="math inline">\(O(\log
n)\)</span>。</p>
<p>找环的时候需要注意<strong>不是点重复而是边重复才出现环</strong>，判断需要再检查一下来向，需要记录当前点上一次访问时有几个点，走了多远，从哪个来的。</p>
<p>总复杂度 <span
class="math inline">\(O(Tnm\log^2n)\)</span>。因为卡不满所以能过。</p>
<p><strong>带删的查询问题都很麻烦，考察之前先想想能不能不删。</strong></p>
<h3 id="t2">T2</h3>
<p>首先考察 <span class="math inline">\(1\)</span> 是不是重心，如果
<span class="math inline">\(1\)</span>
不是重心那么一定会向重心移动？不对，可以先往重心走一步，让重心的点相互消耗，然后往回去。</p>
<p>考虑目标点和 <span class="math inline">\(1\)</span>
之间的毛毛虫。毛毛虫任意两个端点都是可以相互抵消大小的。因此如果毛毛虫所有端点大小和为偶数且没有任何一个端点大小超过
<span
class="math inline">\(\frac{totalsize}{2}\)</span>，那么一定可以移动到目标点。</p>
<p>如果有一个大小超了，考虑能不能在它的内部抵消，是可以的，考虑计算一下某棵子树最少要将中心往自己的方向拉几步，同时也不难证明最少步数到
<span class="math inline">\(sz\)</span>
之间每一个奇偶性相同的步数都能取到。</p>
<p>最小步数是可以动态规划的，转移看是否有一个儿子的 DP
值超过其它儿子的大小总和，还要看当前子树大小奇偶性。可以拿个类记录一下
DP 值最大的儿子和对应的子树大小以及总的子树大小。因为如果有儿子 DP
值超过其它儿子总大小，那么这个儿子的 DP
值一定是最大的，所以这样没问题。</p>
<p>然后考虑计算答案，直接再 DFS
一遍，判断合法性的信息就是转移的那个信息，很容易合并的，额外算一个后缀和就行。</p>
<h3 id="t3">T3</h3>
<p>最开始想能不能把限制弄成不包含或者不交，然后发现不行，由于 <span
class="math inline">\(x_i\)</span>
可能相等，所以不交也是不现实的。然后想能不能从位置入手做，比如区间 DP
或者扫描 DP，还是不好处理。</p>
<p>就算是容斥，同样不好考虑位置。</p>
<p>考虑从值本身入手做，每段位置有一个限制，然后考虑一个限制，可能让它满足条件的段是一段区间，而且<strong>使值不同的限制满足的位置集合不交</strong>。说人话就是不同值的限制<strong>独立</strong>，一段上界相同的位置只会满足值是其上界的限制。因此可以上界不同的段分开做然后乘起来。</p>
<p>将区间弄成左闭右开方便处理，然后离散化暴力算每一段的上界，上界记在左端点。枚举每个值，暴力将每一段放进去，然后将对应的限制挂在新标号的位置上去。</p>
<p>然后设 <span class="math inline">\(dp[i][j]\)</span> 表示考虑到前
<span class="math inline">\(i\)</span> 个，上一个抵到上界的位置是 <span
class="math inline">\(j\)</span>
的方案数，在右端点还需要将不满足挂上的限制的状态清掉。</p>
<p>复杂度 <span class="math inline">\(O(q^2T)\)</span>。</p>
<p>其实有 <span class="math inline">\(O(Tq\log q)\)</span>
的做法，暴力算上界可以用单点改后缀查的树状数组优化，暴力放段的过程可以用
<code>vector</code> 记一下每一个值具体有哪些段和哪些限制。</p>
<p>动态规划中，先对限制的左端点取前缀 <span
class="math inline">\(\max\)</span>，然后可以考虑枚举最后一个 <span
class="math inline">\(1\)</span>
的位置转移，然后转移可以双指针加标记搞定。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/02/21/OI/%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/21/OI/%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">多项式算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-21 22:55:06" itemprop="dateCreated datePublished" datetime="2023-02-21T22:55:06+08:00">2023-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:54:42" itemprop="dateModified" datetime="2025-02-16T17:54:42+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="多项式算法">多项式算法</h2>
<p>多项式是组合计数题目中非常重要的工具。</p>
<h3 id="约定">约定</h3>
<p>幂级数用大写字母表示，系数用<strong>对应的小写字母表示</strong>，对于
<span class="math inline">\(F(x)\)</span>，<span
class="math inline">\(f_i\)</span> 就是 <span
class="math inline">\(F(x)[x^i]\)</span>。</p>
<h3 id="多项式乘法">多项式乘法</h3>
<h4 id="应用">应用</h4>
<p>对于形如 <span
class="math inline">\(f_k=w(k)\sum\limits_{i+j=k}a_ib_j\)</span> 的
<span class="math inline">\(f_k\)</span>，可以利用多项式乘法在 <span
class="math inline">\(O(n\log n)\)</span> 的时间里解决。</p>
<p>或者说，对于形如 <span class="math inline">\(F(x)=A(x)\cdot(B(x) *
C(x))\)</span> 的幂级数 <span class="math inline">\(F(x)\)</span>
，可以在 <span class="math inline">\(O(n\log n)\)</span>
的时间里求出。</p>
<h3 id="多项式求乘法逆">多项式求乘法逆</h3>
<p>一般被描述对于一个 <span class="math inline">\(F(x)\)</span> 找一个
<span class="math inline">\(H(x)\)</span>，满足 <span
class="math inline">\(F(x) * G(x)\equiv 1\pmod{x^n}\)</span>。</p>
<p>可以用定义法配合分治 FFT 在 <span class="math inline">\(O(n\log^2
n)\)</span> 的时间内解决： <span class="math display">\[
h_n=\dfrac{-\sum\limits_{i\in[0,n)}f_ih_{n-i}x^n}{f_nx^n}
\]</span></p>
<p>第二种方式是倍增法，假设我们已经求出了 <span
class="math inline">\(H&#39;(x)\)</span> 满足 <span
class="math inline">\(H&#39;(x) * F(x)\equiv
1\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。又显然有 <span
class="math inline">\(H(x) * F(x)\equiv
1\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。两式相减得 <span
class="math inline">\((H&#39;(x) - H(x)) * F(x)\equiv
0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。平方得 <span
class="math inline">\((H&#39;(x) - H(x))^2 * F^2(x)\equiv
0\pmod{x^n}\)</span>。 <span class="math display">\[
\begin{align}
(H&#39;(x) - H(x))^2 * F^2(x)&amp;\equiv 0\pmod{x^n}\\
H&#39;^2(x)F^2(x)-2H&#39;(x)H(x)F^2(x)+H^2(x)F^2(x)&amp;\equiv
0\pmod{x^n}\\
H&#39;^2(x)F(x)-2H&#39;(x)+H(x)&amp;\equiv 0\pmod{x^n}\\
H(x)&amp;\equiv -2H&#39;(x) - H&#39;^2(x)F(x)\pmod{x^n}\\
\end{align}
\]</span> 其中第二行到第三行先同时除以 <span
class="math inline">\(F(x)\)</span> 再对 <span
class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(H(x)\)</span> 进行乘法得到 <span
class="math inline">\(1\)</span>。</p>
<p>对于 <span class="math inline">\(n=1\)</span> 我们显然有 <span
class="math inline">\(H&#39;(x)=f_0^{-1}\)</span>，然后依次推出即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/02/18/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0217%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/18/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0217%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">0217测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-18 10:04:59" itemprop="dateCreated datePublished" datetime="2023-02-18T10:04:59+08:00">2023-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:23:33" itemprop="dateModified" datetime="2025-02-16T20:23:33+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="测试">0217测试</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0189">考试</a></p>
<h3 id="t1">T1</h3>
<p>非公平组合游戏，先考虑简单的情况，不妨设 <span
class="math inline">\(x_i\le a+b,a\le b\)</span>。</p>
<p>那么一个 <span class="math inline">\(x_i\)</span>
要么能被两个人各自拿一次，要么只能被 <span
class="math inline">\(A\)</span> 拿。</p>
<p>如果存在一个只能被 <span class="math inline">\(A\)</span> 拿的 <span
class="math inline">\(x\)</span>，那么 <span
class="math inline">\(A\)</span> 必胜，他只需要一直拿两人都能拿的 <span
class="math inline">\(x_i\)</span>，让 <span
class="math inline">\(B\)</span> 拿不了，由于 <span
class="math inline">\(A\)</span> 最后多一个，所以必胜。</p>
<p>如果不存在只能被 <span class="math inline">\(A\)</span> 拿的 <span
class="math inline">\(x\)</span>，胜负就与 <span
class="math inline">\(x\)</span>
的奇偶性和谁先手有关。但是<strong>此时两个人并不是等价的。</strong>如果有一个
<span class="math inline">\(x\)</span> 满足 <span
class="math inline">\(\max(2a,b)\le x\)</span>，那么 <span
class="math inline">\(A\)</span> 只要拿掉它就能创造一个只能被 <span
class="math inline">\(A\)</span> 拿的，又变成必胜了，所以 <span
class="math inline">\(B\)</span> 会优先拿掉它们，但是如果由两个，<span
class="math inline">\(B\)</span> 就没办法。</p>
<p>分谁先手后手讨论，容易给出四种情况的充要条件，这些充要条件也是便于直接构造计算的。</p>
<p>考虑迁移到 <span class="math inline">\(x_i\)</span>
无限制的情况，发现状态不会改变，如果先手必胜，那么先手按照模意义下的最优策略走，如果后手选择了能取模的，那么先手也选它取模，直到后手选择了一个不能取模的，此时可以平行对应到取模的情况，然后先手继续按照模意义下策略走。</p>
<p>后手必胜同理。</p>
<p>将整个转移图画出来，<strong>取模的情况就是完整转移图的低维投影。</strong>如果走了投影上没有的边，另一个人一定可以将点搬回投影上。</p>
<h4 id="教训">教训</h4>
<p>犯错的原因是考虑简单情况时理所当然的认为 <span
class="math inline">\(b\le y_i\)</span> 时，该堆石子对 <span
class="math inline">\(A,B\)</span> 等价，实际上这不是等价的。</p>
<p>罗列证据时考虑要全面，或者干脆对拍一下。</p>
<h3 id="t2">T2</h3>
<p>又没读题，最开始当成正回文做，<strong>手玩下样例保证理解对题。</strong></p>
<p>在确定前半段的过程中，后半段也随之确定，建目标串的反串，对应点表示前半段出现什么时可以到该状态。然后跑
AC
自动机上动态规划，合并的时候由于一个串一定是由正串的一个前缀和反串的一个前缀拼起来的，如果可以拼起来那么当前
AC 自动机的节点一定满足它能代表其中较长那个前缀，直接暴力检查。</p>
<h4 id="教训-1">教训</h4>
<ul>
<li>手玩样例保证读对题。</li>
<li>AC 自动机的点权值要弄对（除了 fa 之外还有 fail 的权值）。</li>
<li>要对拍。</li>
</ul>
<h3 id="t3">T3</h3>
<p>最开始考虑直接对树进行动态规划，设 <span
class="math inline">\(dp[j][i]\)</span> 表示有 <span
class="math inline">\(i\)</span> 个叶子，最大左儿子深度为 <span
class="math inline">\(j\)</span>
的方案总数。答案是一个前缀和，转移枚举左右儿子大小，也是前缀和形式，看上去不好优化。于是直接对前缀和动态规划，然后推出一个连分数形式的生成函数，不会了。</p>
<p>其实二叉树可以考虑转成序列做，由于一颗 <span
class="math inline">\(n\)</span> 个叶节点的满二叉树唯一对应一个 <span
class="math inline">\(n-1\)</span> 对括号的括号序列，要求等价于求 <span
class="math inline">\(n-1\)</span> 对括号，最深不超过 <span
class="math inline">\(m-2\)</span> 的括号序列个数。</p>
<p>可以抽象到二维平面上做，需要走到 <span
class="math inline">\((n-1,n-1)\)</span>，不能碰到 <span
class="math inline">\(y=x+1\)</span> 和 <span
class="math inline">\(y=x-m+1\)</span>。简记一条直线为它的截距，即 <span
class="math inline">\(1\)</span> 和 <span
class="math inline">\(-m+1\)</span>。</p>
<h4 id="两种错误的方式">两种错误的方式</h4>
<ul>
<li>考虑先算碰到 <span class="math inline">\(1\)</span>
的方案数，然后再算碰到了 <span class="math inline">\(-m + 1\)</span>
但没碰到 <span class="math inline">\(1\)</span>
的方案数。前者好算，后者对称后不能碰到 <span
class="math inline">\(1\)</span> 且不能碰到 <span
class="math inline">\(1\)</span> 关于 <span
class="math inline">\(-m+1\)</span> 的对称直线 <span
class="math inline">\(-2m+1\)</span>，递归解决该问题，边界为限制彻底放开。</li>
<li>考虑算碰到了 <span class="math inline">\(1\)</span> 或者碰到 <span
class="math inline">\(-m+1\)</span>
的方案数，加上同时碰到的方案数，对于同时碰到的方案数，不容易一起算，考虑算先碰到
<span class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(-m+1\)</span> 的方案数，同样考虑对称，先关于 <span
class="math inline">\(1\)</span> 再关于 <span
class="math inline">\(-m+1\)</span> 对称。同时要求走到 <span
class="math inline">\(1\)</span> 的过程中不能碰到 <span
class="math inline">\(-2m+1\)</span>，即减掉先碰到 <span
class="math inline">\(-2m+1\)</span> 关于 <span
class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(1\)</span> 的方案，递归解决。</li>
</ul>
<h4 id="容斥方式的本质">容斥方式的本质</h4>
<p><strong>容斥本质上是通过对称构造了一个没有限制的问题，使得它和原问题不满足限制的情况一一对应。</strong></p>
<p>这个对应的证明是基于对称问题中起点到终点一定穿过直线，因此<strong>将第一次碰到直线的前部分对称</strong>后一定可以对应到一种原问题的不合法情况，所以考虑原路径时，在对称路径第一次穿过直线后，原路径就不再是<strong>对称路径的对称路径了</strong>。所以第一种方式对直线
<span class="math inline">\(-2m+1\)</span> 的限制是不合理的。</p>
<p>方式二看上去修了锅，实际上只是展开了一层手动修了，后面还是有一样的问题。</p>
<p>如果目标点在直线异侧，那么因为答案不是良定义的所以会错，需要特判为
<span class="math inline">\(0\)</span>。</p>
<p>关于容斥方式，如果将括号序列视作一个 +1 -1
的序列，那么合法就是要求前缀和最小值不小于 <span
class="math inline">\(0\)</span>，我们将第一个小于 <span
class="math inline">\(0\)</span> 后的翻转，最后一定会到达 <span
class="math inline">\(-2\)</span>，因此不合法方案数等于到 <span
class="math inline">\(-2\)</span> 的无限制方案数。</p>
<h4 id="一种正确的方式">一种正确的方式</h4>
<p>全部方式减去要求碰到 <span class="math inline">\(1\)</span> 或者
<span class="math inline">\(-m+1\)</span> 的方式，发现先碰到 <span
class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(-m+1\)</span> 的方式被算重了。</p>
<p>然后要算先碰到 <span class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(-m+1\)</span> 的方式，算这个的时候发现先到 <span
class="math inline">\(-m+1\)</span> 再到 <span
class="math inline">\(1\)</span> 再到 <span
class="math inline">\(-m+1\)</span>
的方式又被算重了，需要减去，如此递归下去做。</p>
<h4 id="bonus">bonus</h4>
<ul>
<li><p>构造满二叉树的方式：</p>
<ul>
<li>单个叶子节点是空串</li>
<li>有儿子的节点记左右儿子为 <span
class="math inline">\(A,B\)</span>，令它为 <code>(A)B</code>。</li>
<li>容易证明它们是一一对应的。</li>
</ul></li>
<li><p>构造二叉树的方式：</p>
<ul>
<li><p>空树是空串。</p></li>
<li><p>单节点的树是 <code>()</code>。</p></li>
<li><p>有儿子节点的树记左右儿子的构造分别为 <span
class="math inline">\(A,B\)</span>，令它为 <code>(A)B</code>。</p></li>
<li><p>容易证明方案是一一对应的。</p></li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">huan-yp</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
