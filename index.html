<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"huanyp.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","display":"post","width_expanded":320,"width_dual_column":240,"padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="幻影彭的彩虹">
<meta property="og:url" content="http://huanyp.cn/index.html">
<meta property="og:site_name" content="幻影彭的彩虹">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="huan-yp">
<meta property="article:tag" content="算法竞赛, 自动化测试, 工程技术, Python">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://huanyp.cn/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>幻影彭的彩虹</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">幻影彭的彩虹</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录青春的扇区</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="huan-yp"
      src="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
  <p class="site-author-name" itemprop="name">huan-yp</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/huan-yp" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huan-yp" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3051561876@qq.com" title="E-Mail → mailto:3051561876@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/1155409006?spm_id_from=333.1369.0.0" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;1155409006?spm_id_from&#x3D;333.1369.0.0" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2022/07/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/12/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-12T00:00:00+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:58:41" itemprop="dateModified" datetime="2025-02-16T17:58:41+08:00">2025-02-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><del>在无数久的 🐦咕咕咕 后一个博客它建成了！</del></p>
<p>在无数久的 🐦咕咕咕 后这个博客它复活了！</p>
<p>博客主要会收录这些东西：</p>
<ul>
<li><p>OI/ACM 相关</p>
<ul>
<li>考试技巧</li>
<li>题解</li>
<li>算法理解</li>
</ul></li>
<li><p>学习笔记</p></li>
<li><p>面向各种人群的科普</p></li>
<li><p>我的开源项目</p></li>
<li><p>生活中有趣的事</p></li>
<li><p>一些奇思妙想</p></li>
</ul>
<p>我是谁：</p>
<ul>
<li>如果你线下认识我，可以叫我 "毛Ker" 或者 "老毛"</li>
<li>如果你线上认识我，可以叫我 "彭彭"。</li>
<li>这些 ID
都是我：<code>huan-yp</code>，<code>幻影彭</code>，<code>huan_yp</code>，<code>huan_yp2002</code>。</li>
</ul>
<p>联系我：</p>
<ul>
<li>QQ：3051561876</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2025/02/20/%E5%AD%A6%E6%9C%AF/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/20/%E5%AD%A6%E6%9C%AF/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">神经网络学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-20 16:00:00 / 修改时间：20:44:18" itemprop="dateCreated datePublished" datetime="2025-02-20T16:00:00+08:00">2025-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">学术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前置知识">前置知识</h2>
<h3 id="导数-vs-微分">导数 VS 微分</h3>
<p><strong>导数就是导函数。</strong></p>
<p><span class="math inline">\(f\)</span> 的微分 <span
class="math inline">\(df\)</span> 可以看作一个函数，（一维的情况下）它将
<span class="math inline">\(dx\)</span> 映射到 <span
class="math inline">\(f&#39;(x)dx\)</span>。</p>
<p><em><span class="math inline">\(dx\)</span>
怎么理解看个人，我没有把它当成函数，而是把它当成了一个单纯的记号。</em></p>
<h3 id="梯度-vs-微分">梯度 VS 微分</h3>
<p><strong>梯度是高维意义下的导数。</strong></p>
<ol type="1">
<li><p><strong>梯度的定义</strong>：
梯度是一个向量，包含函数的所有<strong>偏导数</strong>。对于函数 <span
class="math inline">\(f(x,y)\)</span>，其梯度为： <span
class="math display">\[
\nabla f = \left( \frac{\partial f}{\partial x}, \frac{\partial
f}{\partial y} \right)
\]</span> 梯度指向函数值增加最快的方向。</p></li>
<li><p><strong>微分的定义</strong>：
微分描述了函数在<strong>自变量微小变化时的改变</strong>。对于函数 <span
class="math inline">\(f(x,y)\)</span>，其微分 <span
class="math inline">\(df\)</span> 为： <span class="math display">\[
df = \frac{\partial f}{\partial x} dx + \frac{\partial f}{\partial y} dy
\]</span></p>
<p>这表示函数在自变量 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 分别变化 <span
class="math inline">\(dx\)</span> 和 <span
class="math inline">\(dy\)</span> 时的总变化。</p></li>
</ol>
<h2 id="神经网络">神经网络</h2>
<h3 id="权重矩阵">权重矩阵</h3>
<p>权重矩阵用于在层之间做转移，是神经网络结构的主要组成部分。</p>
<h3 id="激活函数">激活函数</h3>
<p>激活函数用于调整函数结构，使神经网络能够学习复杂的非线性函数。</p>
<h3 id="偏置项">偏置项</h3>
<p>偏置项用于对激活范围进行调整，能够有效提升模型表达能力。</p>
<p>没有偏置项时，激活函数的输出只取决于输入信号的加权和，这样拟合会让模型变得复杂，引入偏置项能够有效改善学习过程。</p>
<h3 id="反向传播算法">反向传播算法</h3>
<p>通过链式求导法则，计算每一项的梯度，以减少损失函数为目的按照梯度调整权重矩阵和偏置项的值。</p>
<h4 id="不完全可微函数的处理">不完全可微函数的处理</h4>
<p>激活函数有时候不是完全可微的，例如 ReLU
函数，这个时候会采取某些方式来处理。</p>
<ol type="1">
<li><strong>归到某一边：</strong>反正概率挺小的，直接认为可导归到其中一边就行。</li>
<li><strong>使用次梯度：</strong>如果它是个凸函数，可以用次梯度近似替代。</li>
<li><strong>用可导函数近似：</strong>找个长得差不多的可导函数，不可微的点用这个函数的微分替代。</li>
</ol>
<h3 id="批次训练与梯度累计">批次训练与梯度累计</h3>
<p>神经网络一般采用批次训练的方式，利用 GPU
的并行计算能力，一个批次跑出多个数据的 loss
和梯度。然后取平均后进行一次下降。</p>
<p>一般来说 batch_size
设置大一点可以让学习过程更加稳定，减少个别数据的极端偏移。</p>
<p>有时候显存不够甚至可以多跑几次积累一下梯度，然后进行更新。</p>
<p><em>注意这里是对<strong>梯度</strong>取平均，不是对 loss
或者中间过程的值取平均。</em></p>
<h3 id="过拟合与缓解方式">过拟合与缓解方式</h3>
<h4 id="early-stop">Early Stop</h4>
<p>训到训练集 Loss 连续一段时间不再下降时就停止。</p>
<h4 id="l1l2-standardization">L1/L2 Standardization</h4>
<p>给 Loss 加个正则化项：</p>
<ul>
<li>L1 正则化：<span
class="math inline">\(\lambda\sum|w_i|\)</span></li>
<li>L2 正则化：<span class="math inline">\(\lambda\sum
w_i^2\)</span></li>
</ul>
<p>为啥有用：</p>
<ul>
<li>L1
促进一些参数变零，可以实现<strong>特征选择</strong>，以去除不重要的特征。</li>
<li>L2 鼓励减小参数大小，降低对训练数据的敏感性。</li>
<li>总的来说都是<strong>限制了模型复杂度以减小过拟合的可能</strong>。</li>
</ul>
<h4 id="dropout">Dropout</h4>
<p>实现方式：</p>
<ul>
<li><strong>每轮训练</strong>的时候以一个概率 <span
class="math inline">\(p\in[0.2,0.5]\)</span> 让（特定的 Dropout
层）激活函数变零。</li>
<li>测试的时候启用全部神经元，同时乘上一个系数 <span
class="math inline">\((1-p)\)</span> 补偿训练过程的丢弃。</li>
</ul>
<p>为啥有用：</p>
<ul>
<li>取平均作用：不同轮次的 Dropout
可以视作不同的神经网络，产生不同的过拟合，能够相互抵消。</li>
<li>减少共适性关系：不应该对某些特定的特征特别敏感，迫使神经网络学习到具有鲁棒性的特征。</li>
</ul>
<h3 id="其它训练技巧">其它训练技巧</h3>
<h4 id="batch-normalization">Batch Normalization</h4>
<p>实现方式：</p>
<ul>
<li>在神经网络的每一层输入层前加一个 BN 层，将输入归一化为均值为
0，方差为 1 的输入。</li>
<li>BN 层增加两个可学习参数 <span class="math inline">\(\gamma,
\beta\)</span>，用于对归一化后的数据进行线性变换。</li>
</ul>
<p>生效原理：</p>
<ul>
<li>缓解内部协变量偏移问题：使各层输入分布稳定，加速网络收敛，对于深度神经网络作用更大。</li>
<li>提升梯度传播效率：使输入保持在激活函数非饱和区内，有利于缓解梯度消失和梯度爆炸，同时也能避免参数初始化时使训练陷入困境。</li>
<li>增强泛化能力*：由于 <span
class="math inline">\(\gamma,\beta\)</span>
是可学习的，因此训练过程会对数据进行一些小扰动，可能能增强泛化能力。</li>
</ul>
<h2 id="卷积神经网络">卷积神经网络</h2>
<h3 id="卷积层">卷积层</h3>
<h4 id="卷积核">卷积核</h4>
<ul>
<li><p>我不懂为啥要叫卷积，但是卷积核是对对应的小矩阵做<strong>点乘</strong>，然后得到一个数作为特征值。</p></li>
<li><p>一个卷积层可能有多个卷积核，不同卷积核可以提取不同的特征，最后卷出来的结果是个张量。</p></li>
</ul>
<h4 id="参数">参数</h4>
<ul>
<li><p>大小：常见的有 3x3 和
5x5，较小的卷积核能够捕捉精细特征，较大的可以捕获更广泛的上下文信息。</p></li>
<li><p>步长：决定卷积核在数据上滑动的间隔，步长越大，特征图输出越小。</p></li>
<li><p>填充：在图像边缘添加额外像素，控制输出特征图的大小。</p></li>
<li><p>权重：卷积核每个位置的值叫做权重，这个是可以学习的。</p></li>
<li><p>偏置：每个卷积核有一个偏置值，也是可以学习的。</p></li>
</ul>
<h4 id="作用">作用</h4>
<p>有效提取各种局部特征。</p>
<h3 id="池化层">池化层</h3>
<h4 id="结构">结构</h4>
<ul>
<li>池化窗口：一般设置为 2x2 或者 3x3，决定每次考虑的局部区域大小</li>
<li>池化方式：最大池化或者平均池化，前者取最大值并保留，后者取平均值并保留。</li>
<li>池化步长：和卷积层的步长差不多，决定特征图大小用的。</li>
</ul>
<h4 id="用途">用途</h4>
<p>降低特征图维度，减少计算量，同时保留重要的局部特征信息。</p>
<h3 id="全连接层">全连接层</h3>
<p>一般放在最后几层，用于整合前面提取的特征，输出最终的结果。</p>
<h3 id="优势">优势</h3>
<ul>
<li>天然适用于处理图像，能够有效提取图像局部特征并完成图像相关任务。</li>
</ul>
<h3 id="一般使用方式">一般使用方式</h3>
<ul>
<li>通常会堆很多层，非常深，一层卷积带一层池化这样。</li>
</ul>
<h3 id="改进">改进</h3>
<h4 id="resnet">ResNet</h4>
<p>引入了残差块，解决了深层神经网络梯度消失的问题。<del>卧槽了这 TM
也能管用。</del></p>
<p>残差块是在两个卷积层的基础上直接拉了一个恒等偏置过来。假设一个残差块的输入是
<span class="math inline">\(x\)</span>，输出 <span
class="math inline">\(H(x)\)</span>，卷积层结构是 <span
class="math inline">\(F(x, W_i)\)</span>，那么令： <span
class="math display">\[
H(x) = x + F(x, W_i)
\]</span></p>
<p>参与学习的参数只有 <span
class="math inline">\(W_i\)</span>，这样反向传播链式求导的时候梯度能直接从
<span class="math inline">\(x\)</span>
这一项传到前面去，神秘的解决了梯度消失问题。</p>
<h2 id="循环神经网络">循环神经网络</h2>
<h3 id="结构-1">结构</h3>
<h4 id="输入">输入</h4>
<ol type="1">
<li><strong>当前时刻的输入</strong> <span
class="math inline">\(x_t\)</span>：表示当前时间步的输入数据，例如在自然语言处理中，*<span
class="math inline">\(x_t\)</span> 可以是一个单词的嵌入向量。</li>
<li><strong>上一时刻的隐藏状态</strong> <span
class="math inline">\(h_{t-1}\)</span>：表示上一时间步的输出状态，用于传递之前的信息。</li>
</ol>
<h4 id="输出">输出</h4>
<ol type="1">
<li><strong>当前时刻的隐藏状态</strong> <span
class="math inline">\(h_t\)</span>：用于传递给下一个时间步。</li>
<li><strong>当前时刻的输出</strong> <span
class="math inline">\(y_t\)</span>（可选）：在某些任务中，RNN
的每个时间步都会产生一个输出，例如在字符级语言模型中，<span
class="math inline">\(y_t\)</span> 可以表示下一个字符的概率分布。</li>
</ol>
<h4 id="状态公式">状态公式</h4>
<p><span class="math display">\[
h_t=\sigma(W_{hh}h_{t-1}+W_{xh}x_t+b_t)
\]</span></p>
<ul>
<li><span class="math inline">\(W_{hh}\)</span>：隐藏状态转移公式。</li>
<li><span
class="math inline">\(W_{xh}\)</span>：输入到隐藏贡献公式。</li>
<li><span class="math inline">\(\sigma\)</span>：激活函数。</li>
<li><span class="math inline">\(b_h\)</span>：偏置项。</li>
</ul>
<h4 id="训练过程">训练过程</h4>
<p>一般用 BackPropagation Through
Time（BPTT）算法进行权重更新，过程如下：</p>
<ul>
<li>前向传播：从 <span class="math inline">\(t=1\)</span>
开始一次计算隐藏状态和输出。</li>
<li>计算损失：计算所有输出的损失函数。</li>
<li>反向传播：从 <span class="math inline">\(t=T\)</span>
开始依次计算每个时间步的梯度，最后梯度加在一起更新。</li>
</ul>
<h3 id="优缺点">优缺点</h3>
<h4 id="优势-1">优势</h4>
<ul>
<li>能处理变长的输入。</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>梯度消失：处理过长的序列时，容易发生梯度消失，导致无法捕捉长距离的依赖。</li>
<li>梯度爆炸：处理过长的序列时，容易发生梯度爆炸，导致权重更新过大，训练过程不稳定。</li>
</ul>
<h2 id="长短期记忆网络lstm">长短期记忆网络（LSTM）</h2>
<p>RNN 的问题很大，所以衍生出了 RNN 的变体：LSTM。</p>
<h3 id="结构-2">结构</h3>
<h3 id="bilstm">BiLSTM</h3>
<h3 id="grm">GRM</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2025/02/17/%E6%8A%80%E6%9C%AF/%E5%9F%BA%E7%A1%80/OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/17/%E6%8A%80%E6%9C%AF/%E5%9F%BA%E7%A1%80/OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">OSI 七层模型简单理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-17 23:40:24 / 修改时间：23:50:46" itemprop="dateCreated datePublished" datetime="2025-02-17T23:40:24+08:00">2025-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章是以<strong>现代计算机网络硬件</strong>为基础编写的，主要介绍了现代硬件环境下应该了解的网络知识，能够为网络编程打下一个较好的基础。</p>
<p>第一次接触不一定能理解全部内容，但当你对网络编程有一定了解后，也可以回来再看看？</p>
<h2 id="物理层">物理层</h2>
<ul>
<li><p>这一层是电子信息系的事，不是计算机系的事。</p></li>
<li><p>这一层可以实现在<strong>两台设备间不稳定的传输数据</strong>。</p></li>
<li><p>这一层数据传输的基本单位是 bit。</p></li>
</ul>
<h2 id="数据链路层">数据链路层</h2>
<p>这一层的主要设备是交换机。</p>
<p>多台主机和交换机，网线构成了一个 LAN。</p>
<h3 id="数据单位">数据单位</h3>
<p>数据层的数据传输单位是 Frame
(帧)，帧包括帧头，帧体，帧尾，帧头包括数据 src 和 dst 的 MAC
地址，帧尾包含一些校验信息。</p>
<p>数据链路层保证了 LAN 中数据传输的可靠性。</p>
<p>以其中一种机制为例：</p>
<ul>
<li>发送方在发送帧的时候，会等待一个 ACK 确认，如果没有等到 ACK
确认，则会重传该帧，直到所有数据帧得到 ACK 确认时结束传输。</li>
<li>接收方会根据帧尾的校验信息确认帧体数据无误，无误后发送 ACK
确认。</li>
</ul>
<h3 id="交换机功能">交换机功能</h3>
<p>数据链路层中，每台设备具有唯一 MAC
地址（这是出厂时烧在网卡上的唯一标识）。</p>
<p>交换机主要用于根据数据帧的 MAC 地址在主机间正确转发数据帧。</p>
<h3 id="mac-地址学习">MAC 地址学习</h3>
<p>交换机有若干个口可以插，如果可能，交换机收到数据后，只会往目标 MAC
的那个端口发。</p>
<p>如果交换机没记录目标 MAC 的端口，则会进行依次广播，根据 ACK
机制，在目标计算机回传 ACK 包时，记录这条信息，并将 MAC 对应上。</p>
<p>这是大部分交换机采用的策略。</p>
<p>当然，有更加复杂的机制来处理诸如 "把 1 口的线转插到 2 口"
这种事。</p>
<p>一个端口能对应多个 MAC
地址，所以你把交换机和交换机插在一起，也能正常组网。</p>
<h2 id="网络层">网络层</h2>
<p>网络层的主要设备是<strong>路由器（Router）</strong>，主要协议是
<strong>IP 协议</strong>。</p>
<p>数据链路层组网完毕后，形成一个 LAN，通过路由器，可以将若干个 LAN
连接成一个更大的 LAN。</p>
<p>我们说的 Internet，就是一个世界范围的 LAN。</p>
<p><em>MAN、WAN 本质都是 LAN，只是规模不同。</em></p>
<h3 id="ip-协议">IP 协议</h3>
<h4 id="公网-ip-和私网-ip">公网 IP 和私网 IP</h4>
<p>公网IP地址（Public IP
Address）是指在全球互联网范围内可以直接访问的IP地址。这些地址是<strong>唯一</strong>的。</p>
<p>众所周知，公网 IP 是从 <code>0.0.0.0</code> 到
<code>255.255.255.255</code>
的，其中有三段不会被分配，可以用于建立<strong>子网</strong>：</p>
<ul>
<li><code>10.0.0.0 - 10.255.255.255</code>，又记作
<code>10.0.0.0/8</code>。</li>
<li><code>172.16.0.0 - 172.31.255.255</code>，又记作
<code>172.16.0.0/12</code>。</li>
<li><code>192.168.0.0 - 192.168.255.255</code>，又记作
<code>192.168.0.0/16</code>。</li>
</ul>
<p><em>后面那个数字指<strong>前缀长度</strong>。</em></p>
<p>一般的电脑是没有公网 IP 的，所以不能直接在互联网上被访问。</p>
<p>但是你能 <code>ipconfig/ifconfig</code> 出来一个 IP
地址，注意观察的话：</p>
<ul>
<li><p>以你车的校园网为例，它采用了 <code>10.0.0.0/8</code>
这个区段，大概能支持 <span class="math inline">\(1.6\times10^7\)</span>
个设备，对你车来说是够用了。</p></li>
<li><p>以你家的无线网为例，它采用了 <code>192.168.0.0/16</code>
这个区段，大概能支持 <span class="math inline">\(6.5\times 10^4\)</span>
个设备，对你家来说是够用了。</p></li>
</ul>
<h4 id="ip-协议的特点">IP 协议的特点</h4>
<ul>
<li><strong>无连接</strong>：IP协议是无连接的，即它不需要在发送数据前建立连接。给个
IP 地址，IP 协议就能尝试去把数据发过去。</li>
<li><strong>尽力而为的传输</strong>：IP协议只负责将数据报发送到目的地，但不保证数据的顺序、完整性或可靠性。数据丢失、重复或乱序需要由上层协议处理。</li>
</ul>
<h4 id="ip-协议可达性">IP 协议可达性</h4>
<p>两台机子能够<strong>使用 IP 协议相互通信</strong>当且仅当：</p>
<ul>
<li>两台机子处于同一子网下</li>
<li>两台机子都拥有公网 IP。</li>
</ul>
<p>没有特殊说明，后面的讨论中，默认是以上两种情况。</p>
<p><em>注意这里的限定，平时你的机子和百度通信，你是没有公网 IP
的，和百度也不在一个子网下，这个时候你们就不是用 IP
协议直接通信的，而是有更复杂的机制。</em></p>
<h3 id="子网划分">子网划分</h3>
<p>实际应用过程中，会对子网做更细一步的划分。</p>
<p>不过要注意，在<strong>第一次的划分</strong>中，所有的 IPV4
地址被保留了三段作为私有地址，这三段私有地址可以被多个子网使用。</p>
<p>也就是说，在整个 Internet 中，可以有多个子网 S1, S2,
S3....，它们都使用同一段私有地址。（例如你家和小明家宽带都用的
<code>192.168.0.0(16)</code> 这一段）</p>
<p>但是，对子网的下一步划分，就无法多次使用同一段了，这个层次的划分局限于<strong>将子网的私有地址分成若干块，每一个小子网得到一块。</strong>不同的小子网无法使用同一个
IP。</p>
<p>当然，小子网可以继续做划分。</p>
<p>最后，有一个子网中的所有设备都被数据链路层（交换机和以太网线）连接起来了，如果两台设备处于这样一个子网中，我们称这两个设备<strong>相邻</strong>。有时候<strong>相邻</strong>会和<strong>处于同一子网中</strong>混淆。</p>
<h4 id="子网掩码">子网掩码</h4>
<p>子网掩码用于判断两个 IP 地址是否处于同一个子网（不是指相邻）。</p>
<p>上文介绍了一个复杂的子网划分机制，子网掩码用于判断两个 IP
地址是否处于同一子网。</p>
<p>例如，有子网 A，B，C，其中 B，C 是 A 子网划分出来的两个子网，其中</p>
<ul>
<li>A
<ul>
<li>IP 段：<code>192.168.0.0/16</code></li>
<li>子网掩码：<code>255.255.0.0</code></li>
</ul></li>
<li>B
<ul>
<li>IP 段：<code>192.168.1.0/24</code></li>
<li>子网掩码：<code>255.255.255.0</code></li>
</ul></li>
<li>C
<ul>
<li>IP 段：<code>192.168.2.0/24</code></li>
<li>子网掩码：<code>255.255.255.0</code></li>
</ul></li>
</ul>
<p>那么，对于
M1：<code>192.168.2.16</code>，M2：<code>192.168.1.16</code>，M3：<code>192.168.1.17</code>
三台机器来说，在子网 A 处，M1，M2，M3 处于同一子网，但在子网 B，C 处，M1
和 M2 不处于同一子网。</p>
<p>一般的子网掩码的低若干位是 0，IP
和子网掩码<strong>按位与</strong>，结果相同则处于同一子网。</p>
<p>主机发送数据包时，根据目标 IP
地址和子网掩码计算是否处于同一子网，如果处于同一子网，则直接走<strong>数据链路层</strong>发送过去。</p>
<h4 id="默认网关">默认网关</h4>
<p>一个子网一般只有一个默认网关，这个默认网关一般就是路由器，路由器的有关知识会在下一部分讲到。</p>
<p>如果你用 "网络属性" 去看过 IPV4
地址协议，就会看到这个选项是和子网掩码在一起的。</p>
<ul>
<li>默认网关和路由器：路由器负责处理不同子网之间的通信，它的每个槽接入的是不同的子网。如果
IP 协议发送的数据的目标 IP
不在同一子网，则会发往默认网关，默认网关再来处理这个数据，将它发往正确的地方。</li>
<li>自动 DHCP：现在一般不用手动去设置默认网关、IP
地址、子网掩码，都是采用 "自动DHCP" 方式自动分配。</li>
</ul>
<h3 id="路由">路由</h3>
<h4 id="arp-协议">ARP 协议</h4>
<p><strong>ARP
协议的工作范围是子网</strong>，以下场景均发生在同一子网内。</p>
<p>ARP 协议是介于数据链路层和网络层之间的协议，用于通过 IP 地址查询 MAC
地址。</p>
<p>IP 协议的数据包是对数据链路层的数据包外面包了一个，但是有个问题。IP
协议的标准是：知道 IP 就能尝试发过去。但是数据链路层的包里是需要包括 MAC
地址的，那我不知道 MAC 地址怎么办？</p>
<p>这个时候需要 ARP 发挥作用，在不知道 MAC 地址时，主机会发送一次 ARP
<strong>广播</strong>，查询目标 IP 对应的 MAC
地址，目标主机收到查询后（查询中包含源主机的
MAC），会向源主机发送一次回复，源主机得到对应的 MAC 地址。</p>
<p><em>交换机如何处理 ARP 广播：广播类消息的 MAC
会设置为<strong>泛洪帧</strong>，即<code>FF:FF:FF:FF:FF:FF</code>），交换机会将该帧从除接收端口以外的所有端口发送出去，以便局域网内的所有设备都能收到。</em></p>
<h4 id="路由器">路由器</h4>
<p>IP
协议的关键是可以在不同子网中通信，路由器是实现不同子网通信的关键设备。一个子网要和其它子网连接，则必须为子网配置路由器。</p>
<p>一般来说，一个路由器会属于两个以上的子网，可以成为多个子网的默认网关。</p>
<p><strong>路由器拥有一个 IP 地址，路由器的每个插槽有一个独立的 MAC
地址。</strong></p>
<h4 id="arp-协议在路由器上的实现">ARP 协议在路由器上的实现</h4>
<ul>
<li><p>为什么 ARP 的工作范围是子网？</p>
<p>进行 ARP 广播时，如果 IP 不在该子网内，路由器会返回接入该子网端口的
MAC。</p>
<p>这样会为子网中的设备提供一个数据链路层的假象：所有的子网外设备的 MAC
地址均是网关设备的 MAC，这个假象会对网络系统的设计带来巨大的便利。</p>
<p><em>这里 IP
是否在子网内是由默认网关（路由器判断的），因此，默认网关也需要配置子网掩码。</em></p></li>
<li><p>这样搞不会导致数据包到了目标子网后 MAC 出错吗？</p>
<p>MAC 在数据链路层中发挥作用，也就是说 MAC
地址仅仅负责一个子网中的通信。数据经过默认网关（路由器）发向其它子网时，会改动数据中的
MAC 地址，将其改为发送槽的 MAC。</p>
<p>不妨假设两个子网的路由器位于同一子网，这样可以将数据包准确的发送到对应子网（路由器处）去，路由器再通过
ARP 协议查询子网中对应 IP 的 MAC 并修改然后发过去。</p></li>
</ul>
<h4 id="路由表">路由表</h4>
<blockquote>
<p>"路由" 是指数据包从源设备到目标设备传输路径选择的过程</p>
</blockquote>
<p>子网外的数据发到路由器后，路由器需要选择一个端口发过去。可能有很多种从子网
S1 到子网 S2
的路径，路由的作用就是去选择一条<strong>最好</strong>的路径。</p>
<p>路由器通过路由表查找最佳的端口选择，路由表并不是一张表，而是一组策略的集合，通过路由表中的策略和目标
IP 来确定数据走哪个端口。</p>
<p>路由的方式主要有三种：</p>
<ul>
<li>直连路由：和路由器直接连接的其它路由器与路由器所在的（若干个）子网存在直接路由，也就是可以直接找到这些对象的
IP 地址。</li>
<li>静态路由：人工配置的 IP/IP段 应该走的端口。</li>
<li>动态路由：路由器之间通过一些算法交换自己的直连路由信息，动态构建路由表。</li>
<li>默认路由：以上规则失效时，走一个默认的端口（通常指向上级路由器，常见于家庭路由器）</li>
</ul>
<p>我们接触和使用的路由器网络很简单，仅通过动态路由的方式就能完美实现局部的路由。</p>
<p><em>网络服务商所用的路由器连接结构非常复杂，要处理广域的 IP
路由，往往需要大型计算机的支持。</em></p>
<h4 id="现代无线路由器">现代无线路由器</h4>
<p>现代无线路由器有<strong>自组网</strong>的功能。</p>
<p>路由器的几个端口同时也具备交换机的功能，它一般能自动判断一个插槽到底接入的是一个子网还是一个数据链路层对象，如果是后者，这个插槽将发挥交换机的作用。</p>
<h4 id="一个示例">一个示例</h4>
<p>网络拓扑结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">子网1：192.168.1.0/24  </span><br><span class="line">        |  </span><br><span class="line">[路由器]（接口1：192.168.1.1，接口2：192.168.2.1）  </span><br><span class="line">        |  </span><br><span class="line">子网2：192.168.2.0/24  </span><br><span class="line"></span><br><span class="line">子网1设备：  </span><br><span class="line">- 交换机1（无需IP）  </span><br><span class="line">  - PC1：192.168.1.10/24，网关192.168.1.1  </span><br><span class="line">  - PC2：192.168.1.20/24，网关192.168.1.1  </span><br><span class="line"></span><br><span class="line">子网2设备：  </span><br><span class="line">- 交换机2（无需IP）  </span><br><span class="line">  - PC3：192.168.2.10/24，网关192.168.2.1  </span><br><span class="line">  - PC4：192.168.2.20/24，网关192.168.2.1  </span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>路由器</strong>
<ul>
<li>接口1（连接子网1）：IP <code>192.168.1.1</code>，子网掩码
<code>255.255.255.0</code>。</li>
<li>接口2（连接子网2）：IP <code>192.168.2.1</code>，子网掩码
<code>255.255.255.0</code>。</li>
<li>路由表自动包含直连网络 <code>192.168.1.0/24</code> 和
<code>192.168.2.0/24</code>。</li>
</ul></li>
<li><strong>交换机1和交换机2</strong>
<ul>
<li>仅作为二层设备，根据MAC地址转发数据帧，无需配置IP。</li>
</ul></li>
<li><strong>终端设备</strong>
<ul>
<li>PC1/PC2的子网掩码为 <code>255.255.255.0</code>，网关指向路由器的
<code>192.168.1.1</code>。</li>
<li>PC3/PC4的子网掩码为 <code>255.255.255.0</code>，网关指向路由器的
<code>192.168.2.1</code>。</li>
</ul></li>
</ol>
<p>PC1 到 PC3 的通信示例如下：</p>
<ol type="1">
<li><strong>判断目标子网</strong>
PC1（<code>192.168.1.10</code>）检查目标IP
<code>192.168.2.10</code>，发现不在同一子网（通过子网掩码计算）。</li>
<li><strong>发送到默认网关</strong>
<ul>
<li>PC1将数据包的目标MAC地址设置为路由器接口1的MAC地址（通过ARP协议获取）。</li>
<li>数据包通过交换机1转发到路由器的接口1。</li>
</ul></li>
<li><strong>路由器处理</strong>
<ul>
<li>路由器解封装数据包，检查目标IP <code>192.168.2.10</code>
和路由表，发现属于直连子网2。</li>
<li>将数据包从接口2（<code>192.168.2.1</code>）转发到子网2。</li>
</ul></li>
<li><strong>子网2内传输</strong>
<ul>
<li>路由器通过 ARP 获取 PC3 的 MAC 地址（若缓存中无记录）。</li>
<li>数据包目标 MAC 改为 PC3 的 MAC，通过交换机2转发到PC3。</li>
</ul></li>
<li><strong>响应返回</strong> PC3
的响应数据包反向执行相同流程，通过路由器回到 PC1。</li>
</ol>
<h3 id="nat">NAT</h3>
<p>本科期间任何一本教科书都不会教你 NAT 相关的知识，但现在这个年头不懂
NAT 是很难做好网络编程的。</p>
<h4 id="nat-能干什么">NAT 能干什么</h4>
<ul>
<li><p><strong>地址转换</strong>：</p>
<p>NAT 设备的主要功能是将一个 IP
地址空间中的地址转换为另一个地址空间中的地址。例如，它可以把私有IP地址（如192.168.x.x）转换为公网IP地址，或者将公网
IP 地址转换为私有 IP 地址。</p>
<ul>
<li>这个操作常用于让子网中没有公网 IP
的设备能够访问公网。例如，你的计算机通过通信服务商的 NAT
设备访问各种公网网站。</li>
<li>也可以用于进一步拓展子网可用 IP，例如通过保留私有 IP
组了一个公网下的一级子网，一级子网向你的二级子网分配了少量 IP
地址，然后你发现这些 IP 地址不够用，于是可以在你的二级子网配置一个 NAT
设备，二级子网内部采用更大的地址空间，和一级子网通信时采用 NAT
，就像一级子网和公网通信那样。这种 NAT 也被称为<strong>多层
NAT</strong>。</li>
</ul></li>
<li><p><strong>隐藏内部网络</strong>：</p>
<p>NAT 可以隐藏内部网络的拓扑结构和设备 IP 地址，增强网络的安全性。</p>
<p>事实上你裸奔的电脑没遭到黑客的攻击就是 NAT 在默默守护。</p></li>
</ul>
<h4 id="nat-怎么布置">NAT 怎么布置</h4>
<p>NAT
设备一般布置在<strong>出口网关</strong>处（其实出口网关大部分时候是默认网关），NAT
发挥地址转换作用</p>
<h4 id="nat-的分类和原理">NAT 的分类和原理</h4>
<p>NAT 主要有三种：</p>
<ol type="1">
<li><p><strong>静态 NAT（Static NAT）</strong></p>
<p><strong>原理</strong>：将内部网络中的每个私网 IP 地址与一个固定的公网
IP
地址进行一对一的映射。这种映射关系是预先配置好的，不会随着时间或网络连接的变化而改变。</p></li>
<li><p><strong>动态 NAT（Dynamic NAT）</strong></p>
<p><strong>原理</strong>：将内部私网 IP 地址动态地映射到一组公网 IP
地址池中的地址。当内部设备有访问外部网络的需求时，NAT 设备从公网 IP
地址池中选择一个可用的公网 IP
地址，并建立私网地址和公网地址的映射关系。这种映射关系在一定时间内有效，当连接结束或超时后，映射关系被释放，公网
IP 地址可以重新分配给其他内部设备。</p></li>
<li><p><strong>PAT（Port Address
Translation，端口地址转换）</strong></p>
<p><strong>原理</strong>：允许多个内网设备共享一个公网 IP
地址，通过不同的端口号来区分不同的内网设备。当内网设备发送数据到外网时，NAT
设备会将数据包的源 IP 地址转换为公网 IP
地址，并分配一个未使用的端口号。返回的数据包通过端口号来确定目标内网设备。它是<strong>日常中最常见的
NAT 方式</strong>，有效地解决了 IPv4
地址不足的问题，适用于家庭和小型企业网络。</p></li>
</ol>
<h4 id="nat-穿透">NAT 穿透</h4>
<p>NAT 很好，但是有时候你期望你的电脑能够在公网上被访问。（例如开 MC
服务器时）</p>
<p>由于你的电脑并没有公网 IP，所有的网络通信都是通过 NAT
完成的，所以你的电脑无法被外部直接访问，这时候我们就需要 NAT
穿透来完成<strong>间接</strong>访问。</p>
<ul>
<li><p>Q：我用 IP 工具可以查到我电脑公网 IP 呀？为什么不能用这个
IP。</p></li>
<li><p>A：首先这个 IP
是动态分配的，随时可能会变，其次<strong>运营商有运营商的安全考虑，不允许外部通过
NAT 开放的端口主动建立连接。</strong></p>
<p><em>你打游戏时看上去是服务器向你请求数据，实际上这个过程是会话层实现的，主动建立会话的是你。</em></p></li>
</ul>
<p>以下是常用的 NAT 穿透的方法：</p>
<ul>
<li>内网穿透：一般情况这是唯一能用的方法。</li>
<li>UDP/TCP 打洞：一般用不了。</li>
</ul>
<h3 id="ap-隔离">AP 隔离</h3>
<p>有时候不希望同一子网的设备能够相互访问，这个时候可以开启 AP
隔离。</p>
<p>AP
隔离在<strong>数据链路层</strong>上丢弃访问子网内设备相互访问的数据包（与默认网关的除外），来禁止子网设备相互访问。</p>
<p>一般来说，AP 隔离是在<strong>无线路由器</strong>上开启的，但是 AP
隔离是一个<strong>数据链路层</strong>的操作，为什么会这样呢？</p>
<p>我们前面提到了现代无线路由器其实既是网络层设备，又是数据链路层设备和物理层设备，所以一般会在这里操作。</p>
<p>因此，如果两台计算机在子网中直接用物理层设备连接（以太网线），这种 AP
隔离是不生效的。</p>
<h3 id="又一个示例">又一个示例</h3>
<p>你车的计算机楼开启了 AP
隔离，计算机楼的设备之间无法通过内网相互通信。</p>
<p>但你车校园网整体是一个子网，计算机楼是进一步划分的子网，宿舍楼开的服务器不在计算楼子网内，没有开启
AP 隔离，可以通过子网访问。</p>
<p>所以出现了：计算机楼可以访问宿舍楼的服务器，但是别的地方无法访问计算机楼的服务器。</p>
<p><del>事实上这个问题在帆软杯的时候出现过，我们把服务器搬到宿舍楼后就能正常访问了。</del></p>
<h3 id="闲话">闲话</h3>
<ul>
<li>路由器和交换机都很便宜，几十块钱就能买一个，网线就更便宜了，可以试着自己买点回来组网。</li>
<li>网络层是 OSI 七层中最复杂的一层，后面没有这么难了。</li>
<li>校园网这个环境特别适合开展网络实践，可以多自己动手试一试。</li>
</ul>
<h2 id="传输层">传输层</h2>
<p>传输层的主要目的是在源节点和目的节点的<strong>应用程序</strong>之间建立、维护和终止端到端的通信连接。</p>
<p>平日用到的<strong>端口</strong>，就是传输层的概念。</p>
<h3 id="udp-协议">UDP 协议</h3>
<p>UDP
协议是一种无连接的、不可靠的、基于数据报的传输层协议。它在数据传输前不需要建立连接，传输效率较高，但不提供可靠的数据传输保证，适用于对实时性要求较高但对数据丢失不太敏感的应用，如视频直播、在线游戏、DNS
查询等。</p>
<p>它和 IP 协议的区别就是它支持端口（port）号了，而 IP
协议的传输中不涉及端口。</p>
<p>UDP 协议本质就是在 IP 协议数据包再简单套了 UDP
头部，包含端口信息。</p>
<h3 id="tcp-协议">TCP 协议</h3>
<p>TCP
协议是一种面向连接的、可靠的、基于字节流的传输层协议。它在数据传输前需要建立连接，传输过程中提供可靠的数据传输和流量控制等服务，适用于对数据传输可靠性要求较高的应用。</p>
<p>下面是老生常谈的三次握手和四次挥手。</p>
<h4 id="连接管理机制">连接管理机制</h4>
<ul>
<li><strong>第一次握手</strong> ：客户端向服务器端发送一个包含 SYN
标志位的 TCP 段，请求建立连接。</li>
<li><strong>第二次握手</strong> ：服务器端收到客户端的 SYN
包后，如果同意建立连接，就发送一个包含 SYN 和 ACK 标志位的 TCP
段作为回应，其中 ACK 对客户端的 SYN 进行确认，同时发送自己的 SYN
来请求客户端对自己的连接进行确认。</li>
<li><strong>第三次握手</strong> ：客户端收到服务器端的 SYN + ACK
后，再发送一个 ACK 包作为确认，从而完成三次握手过程，建立起可靠的 TCP
连接。</li>
</ul>
<h4 id="数据传输机制">数据传输机制</h4>
<ul>
<li><strong>可靠传输</strong> ：采用
“确认应答机制”（ACK），发送方在发送完数据后，会等待接收方的确认应答信号。如果在规定的时间内没有收到确认应答，发送方会重新发送数据。</li>
<li><strong>按序传输</strong>
：发送方将数据分割成多个小的分组（数据段），为每个数据段分配一个唯一的序列号，接收方根据序列号重新组装接收到的分组，确保数据按照正确的顺序传输。</li>
<li><strong>流量控制</strong>
：通过滑动窗口机制来控制数据的传输速率。发送方会维护一个发送窗口，表示可以连续发送而无需等待应答的字节的数量。接收方则通过通知窗口的大小（窗口通告）来告知发送方当前的接收能力，发送方根据接收方的通告调整发送窗口的大小，避免发送过快导致接收方无法处理而丢弃数据，从而实现流量控制。</li>
</ul>
<h4 id="拥塞控制机制">拥塞控制机制</h4>
<ul>
<li><strong>慢启动</strong>
：在一开始的时候，发送方将发送窗口的大小设置为一个较小的数值（由慢启动门限值决定），然后随着每收到一个确认应答增量增加发送窗口，以快速探测网络能够支持的传输速率。</li>
<li><strong>拥塞避免</strong>
：当发送窗口增加到慢启动门限值时，改为按线性规律缓慢增加发送窗口，即每次收到一个确认应答时，以加法的方式（如每次增加
1
个基本单位）增大发送窗口，使得网络处于一种比较平稳的状态，防止网络拥塞突然发生。</li>
<li><strong>快重传</strong>
：当发送方连续收到三个重复的确认应答（接收方通过发送重复的 ACK
来告知中间某个数据段已经丢失），就立即重传对方尚未收到的数据段，而不是等待超时定时器溢出，这样可以快速恢复通信过程。</li>
<li><strong>快恢复</strong>
：在执行快重传后，发送方假设网络现在有一些拥塞，因此需要将慢启动门限值减少到当前发送窗口大小的一半，并且将发送窗口设置为慢启动门限值，然后进入拥塞避免阶段，按照拥塞避免的机制来逐步增加发送窗口。</li>
</ul>
<h4 id="连接关闭机制">连接关闭机制</h4>
<ul>
<li><strong>第一次挥手</strong>
：客户端主动发起关闭连接请求，向服务器端发送一个包含 FIN 标志位的 TCP
段。</li>
<li><strong>第二次挥手</strong> ：服务器收到 FIN
后，向客户端发送一个包含 ACK 标志位的 TCP
段作为确认，通知客户端已收到关闭请求。</li>
<li><strong>第三次挥手</strong>
：服务器端处理完需要完成的任务后，向客户端发送一个包含 FIN 和 ACK
标志位的 TCP 段，请求关闭连接。</li>
<li><strong>第四次挥手</strong> ：客户端收到服务器端的 FIN + ACK
后，再发送一个 ACK 包作为确认，完成四次挥手过程，正式关闭 TCP
连接。</li>
</ul>
<h2 id="会话层">会话层</h2>
<p>会话层的主要功能是建立、维护和终止两个通信系统之间的会话连接。它负责管理会话的生命周期，包括会话的建立、数据传输过程中的会话管理和会话的正常或异常终止。</p>
<p>会话层很少说协议什么的，下面的介绍主要是 AI
生成我纠正的，大概了解即可。</p>
<h3 id="会话的建立">会话的建立</h3>
<p>当两个系统需要进行通信时，会话层会协商会话的参数，如会话的类型（单工、半双工或全双工）、会话的优先级等。例如，在一个视频会议系统中，会话层会建立一个<strong>全双工</strong>的会话，以确保参会者可以同时进行音频和视频的发送和接收。</p>
<p>而数据的来回传输都是通过 TCP 协议进行的。</p>
<h3 id="会话管理">会话管理</h3>
<p>在会话进行过程中，会话层会监控会话的状态。如果出现网络故障或者数据传输错误等情况，会话层会采取相应的措施来恢复会话。例如，当网络出现短暂的中断后，会话层可以重新建立连接，使会话能够继续进行。同时，它还可以对会话中的数据传输进行流量控制，防止数据发送过快导致接收方处理不过来。</p>
<h3 id="会话终止">会话终止</h3>
<p>会话层负责正常地关闭会话连接。当通信双方完成数据交换后，会话层会按照一定的协议来终止会话，确保双方的资源得到正确释放。例如，在文件传输完成后，会话层会发送一个会话终止请求，得到对方确认后，关闭会话连接。</p>
<h3 id="会话层与传输层的区别">会话层与传输层的区别</h3>
<p>传输层的 TCP
协议和会话层都是<strong>可靠传输</strong>，但是它们有一定区别。</p>
<p>TCP
的传输是<strong>单向的，一次性的</strong>，会话层这块就是<strong>完整的，双向的</strong>交流。</p>
<h2 id="表示层">表示层</h2>
<p>表示层的存在感挺弱的，这里不讲。</p>
<h2 id="应用层">应用层</h2>
<p>应用层是 OSI
模型的最高层，是用户与网络之间的直接接口。它主要负责为用户提供应用程序服务，包括电子邮件、文件传输、远程登录、Web
浏览等常见网络应用。应用层协议为应用程序提供访问网络的手段，使得用户可以在不同计算机之间进行各种形式的通信。</p>
<h3 id="dns-协议">DNS 协议</h3>
<p>DNS 协议中文名为 "域名服务协议"，用于将域名（例如
<code>www.huanyp.cn</code>）转换为 IP 地址。</p>
<p><em>DNS 服务器也在 IPV4 的配置里。</em></p>
<h4 id="工作过程">工作过程</h4>
<ol type="1">
<li><p><strong>用户设备向本地 DNS 发起查询</strong></p>
<p>当用户在浏览器输入网址等需要解析域名时，请求发送到本地
DNS。例如，你输入 “<a
target="_blank" rel="noopener" href="http://www.example.xn--com,-ib7ay197annxa/">www.example.com”，本地</a>
DNS 会先检查自己的缓存。如果缓存中有这个域名对应的 IP
地址记录，它会直接返回 IP 地址给用户设备。</p></li>
<li><p><strong>本地 DNS 向上级 DNS 或根 DNS
查询（如果需要）</strong></p>
<ul>
<li>如果本地 DNS 缓存中没有该域名的记录，它会向上级 DNS
发起查询。每个本地 DNS 服务器通常都有一个包含上级 DNS
地址的配置文件。这些上级 DNS 通常是服务提供商（如 ISP）的 DNS
服务器。</li>
<li>但是，当上级 DNS
也不能提供所需域名的解析结果时，最终的查找路径会到达根 DNS。根 DNS
是全球 DNS 层次结构的最顶级，负责维护顶级域名服务器（如 .com、.net
等顶级域名服务器）的地址信息。</li>
</ul></li>
<li><p><strong>层层查询直到解析完成</strong></p>
<ul>
<li>根 DNS 会告诉本地 DNS
<strong>哪个顶级域名服务器负责管理目标域名的顶级部分</strong>。例如，对于
“<a
target="_blank" rel="noopener" href="http://www.example.xn--com,-ib7aq929b/">www.example.com”，根</a>
DNS 可能会指向管理 “.com” 域名的顶级域名服务器。</li>
<li>然后本地 DNS
会联系这个顶级域名服务器，顶级域名服务器会进一步告诉本地 DNS
哪台权威域名服务器（通常是域名注册商或专业的 DNS 服务提供商）拥有
“example.com” 的详细信息。</li>
<li>最终，本地 DNS 会直接联系到权威域名服务器，获取 “<a
target="_blank" rel="noopener" href="http://www.example.xn--com-9o0a/">www.example.com”</a> 对应的准确
IP 地址，并将结果缓存下来，以便下次快速响应同类请求。</li>
</ul></li>
</ol>
<h3 id="http-协议">HTTP 协议</h3>
<p>HTTP 协议主要用于客户端与服务器通信，它的默认端口号是 80。</p>
<p>DNS 解析是<strong>不管端口</strong>的，如果你没有显示的在 IP/域名
后面指定端口，HTTP 会使用 80 端口和服务器程序通信。</p>
<h4 id="主要功能">主要功能</h4>
<ul>
<li>HTTP 是一种请求 - 响应协议。客户端（通常是浏览器）向服务器发送一个
HTTP
请求，请求的内容可以是一个网页、一张图片、一段视频等资源。例如，当你在浏览器中输入一个网址（如<a
target="_blank" rel="noopener" href="http://www.example.com/">http://www.example.com</a>）并访问时，浏览器就会作为
HTTP 客户端向服务器发送请求。</li>
<li>服务器在接收到请求后，会根据请求的内容进行处理，然后返回一个 HTTP
响应。这个响应包含了请求资源本身（如 HTML
文件、图像数据等），还有一些状态信息，如状态码。常见的状态码有
200（请求成功），表示服务器成功地处理了请求并返回了请求的资源；404（未找到），表示服务器找不到请求的资源。</li>
</ul>
<h4 id="协议特点">协议特点</h4>
<ol type="1">
<li><p><strong>简单快速</strong></p>
<p>HTTP 协议的语法相对简单，它基于 TCP/IP
协议，使用明文传输数据。客户端和服务器之间的通信过程比较直接，不需要复杂的握手过程（与
SSL/TLS 协议等相比）。这使得 HTTP
协议能够快速地建立连接并传输数据，从而提高了网页浏览等操作的效率。</p></li>
<li><p><strong>无状态性</strong></p>
<p>HTTP
协议本身是无状态的，也就是说，服务器不会记录客户端的状态。每次客户端请求和服务器响应都是独立的，服务器不会记住上一次客户端请求的内容。例如，当你访问一个电商网站的多个页面时，服务器不会自动记住你在上一个页面的操作（如添加商品到购物车），除非通过其他技术（如
Cookie 或者服务器端的会话存储）来保存状态信息。</p></li>
<li><p><strong>灵活</strong></p>
<p>HTTP 协议支持多种类型的请求方法，如
GET（用于获取资源）、POST（用于提交数据）、PUT（用于更新资源）、DELETE（用于删除资源）等。这使得
HTTP 协议可以满足不同的应用场景需求，无论是简单的网页浏览，还是复杂的
Web 应用程序的数据交互。</p></li>
</ol>
<h4 id="协议版本">协议版本</h4>
<ol type="1">
<li><p><strong>HTTP/1.0</strong></p>
<p>这是最早的广泛使用的版本。它比较简单，每次请求 -
响应完成后，连接就会关闭。如果客户端需要再次请求资源，就需要重新建立连接。这种方式在资源较少、网络带宽相对紧张的早期互联网环境中还可以，但在现代复杂的网络应用中就显得效率较低。</p></li>
<li><p><strong>HTTP/1.1</strong></p>
<p>HTTP/1.1 引入了持久连接（Persistent
Connection）的概念。在这种模式下，客户端和服务器之间的连接在一次请求 -
响应完成后不会立即关闭，可以被多个请求 -
响应过程共享。这样就减少了频繁建立和关闭连接所带来的开销，提高了传输效率。同时，HTTP/1.1
还增加了一些新的请求头和响应头字段，使得协议更加灵活和强大。</p></li>
<li><p><strong>HTTP/2</strong></p>
<p>HTTP/2 主要为了解决 HTTP/1.1
的一些性能瓶颈。它引入了多路复用（Multiplexing）技术，允许客户端和服务器同时发送多个请求和响应，而不需要等待前面的请求
- 响应过程完成。并且，HTTP/2
对数据进行了帧的划分和压缩等操作，进一步提高了数据传输的效率。这在现代的
Web
应用中，尤其是对于包含大量静态资源（如图片、脚本文件等）的网站，能够显著提高加载速度。</p></li>
</ol>
<h3 id="https-协议">HTTPS 协议</h3>
<p>HTTPS 协议本质是在 HTTP 协议的基础上加了一个 TLS/SSL
来保证传输过程的安全性，默认采用 443 端口。</p>
<h4 id="几个编程细节的提醒">几个编程细节的提醒</h4>
<ul>
<li>Python 的 <code>http.server</code> 不支持 HTTPS 协议，由于它没写
SSL/TLS
部分，所以在传输层就被扔包了，体现出来就是发了然后一点反应都没有，或者是单纯日志报一堆乱码但没有调用
handler。</li>
</ul>
<h3 id="tlsssl-协议">TLS/SSL 协议</h3>
<p>TLS/SSL 协议都是建立在 TCP
协议之上的，因此它们的通信本身是可靠的。</p>
<h4 id="证书链验证机制">证书链验证机制</h4>
<ul>
<li><strong>证书颁发机构（CA）验证</strong>：服务器会向客户端提供 SSL
证书，客户端需要验证 SSL
证书是否有效，同时要验证<strong>颁发机构</strong>是否可信。这通常通过检查证书链来实现，证书链从服务器的
SSL
证书开始，经过一系列中间证书，最终到达客户端信任的根证书。如果根证书是可信的，并且证书链中的每个证书都是有效的，那么客户端就可以信任服务器的SSL证书。</li>
<li><strong>证书信息验证</strong>：客户端会检查 SSL
证书中的信息，如域名、有效期、公钥等，是否与实际情况相符。例如，证书中的域名应该与用户正在访问的网站域名完全匹配。<strong>证书有效性</strong>验证涉及
RSA 的签名机制，在数学上可以确保安全。</li>
</ul>
<h4 id="ssl-握手过程">SSL 握手过程</h4>
<ul>
<li><strong>客户端发起连接</strong>：客户端（如浏览器）通过发送一个 "SH"
消息开始 SSL/TLS 握手过程。这个消息包含了客户端支持的 SSL/TLS
版本、加密套件（cs）、随机数（CR）和会话 ID。</li>
<li><strong>服务器响应</strong>：服务器收到 "ClientHello"
消息后，响应一个 "SH"
消息，选择一个双方都支持的加密套件和协议版本，并发送服务器随机数（SR）。</li>
<li><strong>证书传输</strong>：服务器发送其 SSL
证书给客户端。这个证书包含了服务器的公钥，以及由证书颁发机构（CA）签发的证书信息。</li>
<li><strong>证书验证</strong>：客户端验证服务器证书的有效性，包括证书是否过期、是否被撤销、证书链是否完整，以及证书的域名是否与服务器域名匹配。</li>
<li><strong>密钥交换</strong>：如果使用 RSA
密钥交换算法，客户端会生成一个临时的会话密钥（PMS），并使用服务器的公钥加密这个密钥，然后发送给服务器。服务器使用自己的私钥解密得到会话密钥。</li>
<li><strong>握手结束</strong>：客户端和服务器使用会话密钥生成最终的加密密钥，并使用这个密钥加密后续通信。客户端发送
"Finished" 消息，包含握手消息的哈希值，服务器也发送 "Finished"
消息，确认握手成功。</li>
</ul>
<h4 id="tls-协议">TLS 协议</h4>
<p>上面说的 SSL 协议本身是没有漏洞的，但是 SSL 的实现中为了效率采用了
Padding Oracle 机制，因此衍生出一种叫做 POODLE（降级加密密文填充攻击）
的 MiTMA（中间人攻击）。</p>
<p>TLS 解决了这个问题，其它和 SSL 差别不大。</p>
<h2 id="提醒">提醒</h2>
<p>看完本文后，你应该有了一些基础的网络知识。</p>
<p>笔者必须提醒你，这些知识是<strong>危险</strong>的。</p>
<p>人类第一次仰望星空时，就已经具备了进行星际航行的能力；你了解这些知识后，与黑客技术也只剩下一层窗户纸了。</p>
<p><strong>记住，知识是中立的，你应该用你的道德，去掌控你所拥有的知识。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2025/02/15/todo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/15/todo/" class="post-title-link" itemprop="url">Todo</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-15T00:00:00+08:00">2025-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:21:58" itemprop="dateModified" datetime="2025-02-16T17:21:58+08:00">2025-02-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="打算要写的东西">打算要写的东西</h2>
<h2 id="打算要做的事">打算要做的事</h2>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/03/01/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0301%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/01/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0301%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">0301测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-01 12:11:10" itemprop="dateCreated datePublished" datetime="2023-03-01T12:11:10+08:00">2023-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:23:27" itemprop="dateModified" datetime="2025-02-16T20:23:27+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="测试">0301测试</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0196">考试</a></p>
<h3 id="t1">T1</h3>
<p>考虑如何检查一个条件是否合法，如果最高位为任意，那么两边需要都合法，否则要求两边至少有一个合法。</p>
<p>考虑两边的检查，发现第 <span class="math inline">\(i\)</span>
层的节点个数为 <span class="math inline">\(2^i\)</span>，总的情况数为
<span
class="math inline">\(2^{n-i}\)</span>，因此可以记忆化搜索一下。用一个
<span class="math inline">\(mask\)</span>
的前若干位表示限制，后若干位表示高位的数字即可。</p>
<p>也可以这样想：考虑算所有的情况，设 <span
class="math inline">\(T(n)\)</span> 表示计算第 <span
class="math inline">\(n\)</span> 层所有情况的复杂度，暴力计算有 <span
class="math inline">\(T(n)=2^n+4T(n-1)=2^{2n}\)</span>，实际上发现对于只有第
<span class="math inline">\(n\)</span> 层不同的情况可以只算一次，于是
<span class="math inline">\(T(n)=2^n+2T(n-1)\)</span>，得到 <span
class="math inline">\(T(n)=n2^n\)</span>。</p>
<h3 id="t2">T2</h3>
<h4 id="做法一">做法一</h4>
<p>考虑钦定 <span class="math inline">\(A\)</span> 组先选满，枚举 <span
class="math inline">\(A\)</span>
组选满的位置计算对应概率然后再乘二。对于每一个位置 <span
class="math inline">\(p\)</span>，<strong>基本情况总数</strong>为 <span
class="math inline">\(\binom{p-1}{n-1}\)</span>，每种基本情况等概率取到，概率为
<span class="math inline">\(2^{-p}\)</span>，分三类讨论</p>
<ul>
<li><p>如果 <span class="math inline">\(x_k&lt;p\)</span>，那么 <span
class="math inline">\(k\)</span> 个人既可以在 <span
class="math inline">\(A\)</span> 组也可以在 <span
class="math inline">\(B\)</span> 组，对应的基本情况数分别为 <span
class="math inline">\(\binom{p-1-k}{n-1-k}+\binom{p-1-k}{n-1}\)</span>。</p></li>
<li><p>如果 <span class="math inline">\(x_k=p\)</span>，那么一共有 <span
class="math inline">\(\binom{p-k}{n-k}\)</span> 种基本情况。</p></li>
<li><p>如果 <span class="math inline">\(x_k&gt;p\)</span>，首先 <span
class="math inline">\(p\notin X\)</span>，然后记 <span
class="math inline">\(c\)</span> 为 <span
class="math inline">\(p\)</span> 之前的 <span
class="math inline">\(x\)</span> 个数，基本情况总数为 <span
class="math inline">\(\binom{p-1-c}{n-1}\)</span>。</p></li>
</ul>
<p>于是有一个 <span class="math inline">\(nq\)</span> 的做法。</p>
<p>观察到查询的答案是一个二元函数 <span
class="math inline">\(f(p,x)\)</span> ，对于 <span
class="math inline">\(x\)</span> 较小的情况可以预处理前缀和，对于 <span
class="math inline">\(x\)</span>
较大的情况，查询数比较少，可以暴力。于是有一个 <span
class="math inline">\(n\sqrt q\)</span> 的做法。</p>
<p>进一步观察，<span
class="math inline">\(2^{-p}\binom{p-1-c}{n-1}\)</span>
可以很容易的预处理 <span
class="math inline">\(2^{-p}\binom{p-1}{n-1}\)</span>
的前缀和然后查询时乘上一个 <span
class="math inline">\(2^{-c}\)</span>。</p>
<p>对于 <span
class="math inline">\(2^{-p}\binom{p-1-k}{n-1-k}\)</span>，答案应该是：
<span class="math display">\[
\begin{align}
\sum_{p=x_k+1}^{2n-1}2^{-p}\binom{p-1-k}{n-1-k}&amp;=\sum_{p=\max(n,x_k+1)}^{2n-1}2^{-p}\binom{p-1-k}{n-1-k}\\
&amp;=\sum_{p=\max(n,x_k+1)}^{2n-1}2^{-p}\binom{p-1-k}{n-p}\\
&amp;=\sum_{p=\max(n,x_k+1)-k-1}^{2n-1-k-1}2^{-p-k-1}\binom{p}{n-k-1}\\
\end{align}
\]</span> 注意到 <span class="math inline">\(\sum k\)</span>
其实很小。</p>
<p><del>好吧，我不会线性做法，摆了。</del></p>
<h4 id="做法二">做法二</h4>
<p>先只算都在 <span class="math inline">\(A\)</span> 组的情况，然后分
<span class="math inline">\(B\)</span> 选满的位置 <span
class="math inline">\(p\)</span> 所在的区间讨论。</p>
<ul>
<li><p><span class="math inline">\(p&gt;x_k\)</span>：令 <span
class="math inline">\(x_k\)</span>
及之前每一种可能的硬币选择为基本情况，需要计算在 <span
class="math inline">\(x_k\)</span> 处 <span
class="math inline">\(X\)</span> 都取到 <span
class="math inline">\(A\)</span> 且 <span
class="math inline">\(B\)</span> 不能被选满的方案总数，隐含条件是 <span
class="math inline">\(x_k\)</span> 之前 <span
class="math inline">\(A\)</span> 也不能被选满。</p>
<p>可以暴力的算组合数，枚举剩下的 <span
class="math inline">\(x_k-k\)</span> 个数有多少个分配到 <span
class="math inline">\(A\)</span> 中，可以直接限制 <span
class="math inline">\(A,B\)</span> 都满足要求，即 <span
class="math inline">\(\sum\limits_{i=\max(0,x_k-k-n+1)}^{n-k}\binom{x_k-k}{i}\)</span>。</p>
<p>然后 <span class="math inline">\(\sum k\)</span>
是比较小的，于是放宽一下限制，算 <span
class="math inline">\(\sum\limits_{i=\max(0,x_k-k-n+1)}^{n}\binom{x_k-k}{i}\)</span>
再减掉，容易发现这个式子只和 <span class="math inline">\(x_k-k\)</span>
有关，而这个式子本身也不是很难算，进一步的将 <span
class="math inline">\(\max\)</span> 的限制去掉，变成 <span
class="math inline">\(\sum\limits_{i=0}^n
\binom{x}{i}\)</span>，然后对于 <span
class="math inline">\(x-n\ge0\)</span> 的情况，需要减去 <span
class="math inline">\(\sum\limits_{i=0}^{x-n}\binom{x}{i}\)</span>。都可以拆组合数然后动态规划。
<span class="math display">\[
\begin{align}
\sum\limits_{i=0}^{x-n}\binom{x}{i}&amp;=\binom{x-1}{0}+\sum\limits_{i=1}^{x-n}\binom{x-1}{i-1}+\binom{x-1}{i}\\
&amp;=\binom{x-1}{0}+\sum_{i=1}^{x-n}\binom{x-1}{i}+\sum_{i=1}^{x-n}\binom{x-1}{i-1}\\
&amp;=\binom{x-1}{x-n}+\sum_{i=0}^{x-n-1}\binom{x-1}{i}+\sum_{i=0}^{x-n-1}\binom{x-1}{i}\\
&amp;=\binom{x-1}{x-n}+2\sum_{i=0}^{x-1-n}\binom{x-1}{i}
\end{align}
\]</span></p>
<p>另一种考虑方式是算一个 <span class="math inline">\(f_w\)</span>
表示一共 <span class="math inline">\(w\)</span> 个，<span
class="math inline">\(A,B\)</span>
都不<strong>超过</strong>的情况总数，然后需要减去 <span
class="math inline">\(B\)</span> 抵到的情况数，然后又因为需要把 <span
class="math inline">\(A\)</span> 超过的情况去掉，<span
class="math inline">\(A\)</span> 超过是因为 <span
class="math inline">\(k\)</span> 个被塞进了 <span
class="math inline">\(A\)</span>，分别枚举超过 <span
class="math inline">\(1,2,3\cdots k\)</span>
个减掉对应的基本情况数即可。<span class="math inline">\(f_w\)</span>
的转移考虑直接放 <span class="math inline">\(A,B\)</span>
然后去掉不合法的情况。</p></li>
<li><p><span
class="math inline">\(x_{i-1}&lt;p&lt;x_{i},i\in[1,k]\)</span></p>
<p>将基本情况定为 <span class="math inline">\(x_i\)</span>
之前（不含）的硬币状态，限制有两个，<span
class="math inline">\(|B|\)</span> 不小于 <span
class="math inline">\(n\)</span>，且 <span
class="math inline">\(X\)</span> 内的是必须为 <span
class="math inline">\(A\)</span> 的。满足 <span
class="math inline">\(A\)</span> 限制的总情况数为 <span
class="math inline">\(2^{x_i-i}\)</span>。满足 <span
class="math inline">\(A\)</span> 限制但不满足 <span
class="math inline">\(B\)</span> 限制的情况数为 <span
class="math inline">\(\sum\limits_{i=0}^{n-1}\binom{x_i-i}{i}\)</span>，先扣掉。<strong>这里不需要考虑
<span class="math inline">\(A\)</span> 被选满，因为 <span
class="math inline">\(A\)</span>
被选满的情况确实应该扣掉。</strong>然后再减去再 <span
class="math inline">\(x_{i-1}\)</span> 之前就满足 <span
class="math inline">\(B\)</span> 限制的所有情况，注意额外带一个 <span
class="math inline">\(2_{x_i-x_{i-1}-1}\)</span> 的系数。</p>
<p>这里还会有一些误解，其实隐含了 <span
class="math inline">\(|A|&lt;n\)</span>
的限制，实际上如果这两个限制都满足那么这个隐含限制一定满足，因此不管这个隐含限制直接算也是可以的。</p></li>
</ul>
<p>当使用容斥计算 "恰好" 时，应该减掉上一次的 "至少" 而不是 "恰好"，记录
<span class="math inline">\(lst\)</span> 的时候要注意。</p>
<h3 id="t3">T3</h3>
<p>先考虑构造一种合法的解满足条件。挨个确定值的办法并不好弄。考虑先确定前
<span class="math inline">\(i\)</span> 个的大小关系，如果前 <span
class="math inline">\(i\)</span> 个合法了，并且第 <span
class="math inline">\(i+1\)</span>
个可以放到一个位置，满足前面没有不小于 <span
class="math inline">\(a_{i+1}\)</span> 且存在至少一个 <span
class="math inline">\(a_{i+1}-1\)</span>，那么就合法。于是得到一个有解的充要条件：任何一个前缀
<span class="math inline">\(a_i\)</span> 值的集合连续。</p>
<p>现在考虑算 <span class="math inline">\(i\)</span>
位置的答案，它前面的不小于它的元素必须在它后面，它后面的元素可以线性扫一遍，维护前缀连续最大值算出来。</p>
<p>考虑优化，对于一个 <span class="math inline">\(i\)</span>
算答案的时候，就是要找到依赖它以及它前面不小于它的元素的所有元素。后面的比
<span class="math inline">\(a_i\)</span> 大的元素如果能在 <span
class="math inline">\(i\)</span> 之后找到一个 <span
class="math inline">\(a_i\)</span> 依赖，那么就可以被放在 <span
class="math inline">\(i\)</span> 前面。</p>
<p>元素的依赖关系好像是构成一棵树的，于是建树，每个元素向它的第一个前驱连边，然后
<span class="math inline">\(i\)</span>
节点以及它同层左边的兄弟里所有节点都不能放在 <span
class="math inline">\(i\)</span> 前面，于是算出了 <span
class="math inline">\(p_i\)</span> 的最大值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/02/28/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0228%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/28/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0228%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">0228测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-28 22:50:48" itemprop="dateCreated datePublished" datetime="2023-02-28T22:50:48+08:00">2023-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:23:30" itemprop="dateModified" datetime="2025-02-16T20:23:30+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="测试">0228测试</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0196">考试</a></p>
<h3 id="t1">T1</h3>
<p>毒瘤计算几何。</p>
<p>考虑一步的过程，是从一个点的一个方向开始旋转，于是对所有目标点极角排序，极角相同的长度较长的放前面，查询就是要找到接下来的第一个长度小于当前长度的。</p>
<p>一个很暴力的想法是直接开始跳，如果遇到了相同的点说明有环，然后模环长再跳，这样每个点期望经过
<span class="math inline">\(O(\log)\)</span> 次，总共要处理 <span
class="math inline">\(O(nm\log n)\)</span> 次，感觉很可做。</p>
<p>接下来的问题变成了如何快速查询。考场上觉得排序后确实是查第一个比它大的，但是要带上删除，于是考虑长度倒序做。然后想
set
暴力操作肯定要超时，然后考虑用并查集做删除操作，用优先队列维护长度的处理顺序。</p>
<p>很麻烦，写不出来。</p>
<p>实际上可以不带删，考虑找到第一个极角超过查询极角的位置，在上面二分第一个长度满足限制的，用
ST 表做长度查询，复杂度 <span class="math inline">\(O(\log
n)\)</span>。</p>
<p>找环的时候需要注意<strong>不是点重复而是边重复才出现环</strong>，判断需要再检查一下来向，需要记录当前点上一次访问时有几个点，走了多远，从哪个来的。</p>
<p>总复杂度 <span
class="math inline">\(O(Tnm\log^2n)\)</span>。因为卡不满所以能过。</p>
<p><strong>带删的查询问题都很麻烦，考察之前先想想能不能不删。</strong></p>
<h3 id="t2">T2</h3>
<p>首先考察 <span class="math inline">\(1\)</span> 是不是重心，如果
<span class="math inline">\(1\)</span>
不是重心那么一定会向重心移动？不对，可以先往重心走一步，让重心的点相互消耗，然后往回去。</p>
<p>考虑目标点和 <span class="math inline">\(1\)</span>
之间的毛毛虫。毛毛虫任意两个端点都是可以相互抵消大小的。因此如果毛毛虫所有端点大小和为偶数且没有任何一个端点大小超过
<span
class="math inline">\(\frac{totalsize}{2}\)</span>，那么一定可以移动到目标点。</p>
<p>如果有一个大小超了，考虑能不能在它的内部抵消，是可以的，考虑计算一下某棵子树最少要将中心往自己的方向拉几步，同时也不难证明最少步数到
<span class="math inline">\(sz\)</span>
之间每一个奇偶性相同的步数都能取到。</p>
<p>最小步数是可以动态规划的，转移看是否有一个儿子的 DP
值超过其它儿子的大小总和，还要看当前子树大小奇偶性。可以拿个类记录一下
DP 值最大的儿子和对应的子树大小以及总的子树大小。因为如果有儿子 DP
值超过其它儿子总大小，那么这个儿子的 DP
值一定是最大的，所以这样没问题。</p>
<p>然后考虑计算答案，直接再 DFS
一遍，判断合法性的信息就是转移的那个信息，很容易合并的，额外算一个后缀和就行。</p>
<h3 id="t3">T3</h3>
<p>最开始想能不能把限制弄成不包含或者不交，然后发现不行，由于 <span
class="math inline">\(x_i\)</span>
可能相等，所以不交也是不现实的。然后想能不能从位置入手做，比如区间 DP
或者扫描 DP，还是不好处理。</p>
<p>就算是容斥，同样不好考虑位置。</p>
<p>考虑从值本身入手做，每段位置有一个限制，然后考虑一个限制，可能让它满足条件的段是一段区间，而且<strong>使值不同的限制满足的位置集合不交</strong>。说人话就是不同值的限制<strong>独立</strong>，一段上界相同的位置只会满足值是其上界的限制。因此可以上界不同的段分开做然后乘起来。</p>
<p>将区间弄成左闭右开方便处理，然后离散化暴力算每一段的上界，上界记在左端点。枚举每个值，暴力将每一段放进去，然后将对应的限制挂在新标号的位置上去。</p>
<p>然后设 <span class="math inline">\(dp[i][j]\)</span> 表示考虑到前
<span class="math inline">\(i\)</span> 个，上一个抵到上界的位置是 <span
class="math inline">\(j\)</span>
的方案数，在右端点还需要将不满足挂上的限制的状态清掉。</p>
<p>复杂度 <span class="math inline">\(O(q^2T)\)</span>。</p>
<p>其实有 <span class="math inline">\(O(Tq\log q)\)</span>
的做法，暴力算上界可以用单点改后缀查的树状数组优化，暴力放段的过程可以用
<code>vector</code> 记一下每一个值具体有哪些段和哪些限制。</p>
<p>动态规划中，先对限制的左端点取前缀 <span
class="math inline">\(\max\)</span>，然后可以考虑枚举最后一个 <span
class="math inline">\(1\)</span>
的位置转移，然后转移可以双指针加标记搞定。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/02/21/OI/%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/21/OI/%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">多项式算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-21 22:55:06" itemprop="dateCreated datePublished" datetime="2023-02-21T22:55:06+08:00">2023-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:54:42" itemprop="dateModified" datetime="2025-02-16T17:54:42+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="多项式算法">多项式算法</h2>
<p>多项式是组合计数题目中非常重要的工具。</p>
<h3 id="约定">约定</h3>
<p>幂级数用大写字母表示，系数用<strong>对应的小写字母表示</strong>，对于
<span class="math inline">\(F(x)\)</span>，<span
class="math inline">\(f_i\)</span> 就是 <span
class="math inline">\(F(x)[x^i]\)</span>。</p>
<h3 id="多项式乘法">多项式乘法</h3>
<h4 id="应用">应用</h4>
<p>对于形如 <span
class="math inline">\(f_k=w(k)\sum\limits_{i+j=k}a_ib_j\)</span> 的
<span class="math inline">\(f_k\)</span>，可以利用多项式乘法在 <span
class="math inline">\(O(n\log n)\)</span> 的时间里解决。</p>
<p>或者说，对于形如 <span class="math inline">\(F(x)=A(x)\cdot(B(x) *
C(x))\)</span> 的幂级数 <span class="math inline">\(F(x)\)</span>
，可以在 <span class="math inline">\(O(n\log n)\)</span>
的时间里求出。</p>
<h3 id="多项式求乘法逆">多项式求乘法逆</h3>
<p>一般被描述对于一个 <span class="math inline">\(F(x)\)</span> 找一个
<span class="math inline">\(H(x)\)</span>，满足 <span
class="math inline">\(F(x) * G(x)\equiv 1\pmod{x^n}\)</span>。</p>
<p>可以用定义法配合分治 FFT 在 <span class="math inline">\(O(n\log^2
n)\)</span> 的时间内解决： <span class="math display">\[
h_n=\dfrac{-\sum\limits_{i\in[0,n)}f_ih_{n-i}x^n}{f_nx^n}
\]</span></p>
<p>第二种方式是倍增法，假设我们已经求出了 <span
class="math inline">\(H&#39;(x)\)</span> 满足 <span
class="math inline">\(H&#39;(x) * F(x)\equiv
1\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。又显然有 <span
class="math inline">\(H(x) * F(x)\equiv
1\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。两式相减得 <span
class="math inline">\((H&#39;(x) - H(x)) * F(x)\equiv
0\pmod{x^{\lceil\frac{n}{2}\rceil}}\)</span>。平方得 <span
class="math inline">\((H&#39;(x) - H(x))^2 * F^2(x)\equiv
0\pmod{x^n}\)</span>。 <span class="math display">\[
\begin{align}
(H&#39;(x) - H(x))^2 * F^2(x)&amp;\equiv 0\pmod{x^n}\\
H&#39;^2(x)F^2(x)-2H&#39;(x)H(x)F^2(x)+H^2(x)F^2(x)&amp;\equiv
0\pmod{x^n}\\
H&#39;^2(x)F(x)-2H&#39;(x)+H(x)&amp;\equiv 0\pmod{x^n}\\
H(x)&amp;\equiv -2H&#39;(x) - H&#39;^2(x)F(x)\pmod{x^n}\\
\end{align}
\]</span> 其中第二行到第三行先同时除以 <span
class="math inline">\(F(x)\)</span> 再对 <span
class="math inline">\(F(x)\)</span> 和 <span
class="math inline">\(H(x)\)</span> 进行乘法得到 <span
class="math inline">\(1\)</span>。</p>
<p>对于 <span class="math inline">\(n=1\)</span> 我们显然有 <span
class="math inline">\(H&#39;(x)=f_0^{-1}\)</span>，然后依次推出即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/02/18/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0217%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/18/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0217%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">0217测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-18 10:04:59" itemprop="dateCreated datePublished" datetime="2023-02-18T10:04:59+08:00">2023-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:23:33" itemprop="dateModified" datetime="2025-02-16T20:23:33+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="测试">0217测试</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0189">考试</a></p>
<h3 id="t1">T1</h3>
<p>非公平组合游戏，先考虑简单的情况，不妨设 <span
class="math inline">\(x_i\le a+b,a\le b\)</span>。</p>
<p>那么一个 <span class="math inline">\(x_i\)</span>
要么能被两个人各自拿一次，要么只能被 <span
class="math inline">\(A\)</span> 拿。</p>
<p>如果存在一个只能被 <span class="math inline">\(A\)</span> 拿的 <span
class="math inline">\(x\)</span>，那么 <span
class="math inline">\(A\)</span> 必胜，他只需要一直拿两人都能拿的 <span
class="math inline">\(x_i\)</span>，让 <span
class="math inline">\(B\)</span> 拿不了，由于 <span
class="math inline">\(A\)</span> 最后多一个，所以必胜。</p>
<p>如果不存在只能被 <span class="math inline">\(A\)</span> 拿的 <span
class="math inline">\(x\)</span>，胜负就与 <span
class="math inline">\(x\)</span>
的奇偶性和谁先手有关。但是<strong>此时两个人并不是等价的。</strong>如果有一个
<span class="math inline">\(x\)</span> 满足 <span
class="math inline">\(\max(2a,b)\le x\)</span>，那么 <span
class="math inline">\(A\)</span> 只要拿掉它就能创造一个只能被 <span
class="math inline">\(A\)</span> 拿的，又变成必胜了，所以 <span
class="math inline">\(B\)</span> 会优先拿掉它们，但是如果由两个，<span
class="math inline">\(B\)</span> 就没办法。</p>
<p>分谁先手后手讨论，容易给出四种情况的充要条件，这些充要条件也是便于直接构造计算的。</p>
<p>考虑迁移到 <span class="math inline">\(x_i\)</span>
无限制的情况，发现状态不会改变，如果先手必胜，那么先手按照模意义下的最优策略走，如果后手选择了能取模的，那么先手也选它取模，直到后手选择了一个不能取模的，此时可以平行对应到取模的情况，然后先手继续按照模意义下策略走。</p>
<p>后手必胜同理。</p>
<p>将整个转移图画出来，<strong>取模的情况就是完整转移图的低维投影。</strong>如果走了投影上没有的边，另一个人一定可以将点搬回投影上。</p>
<h4 id="教训">教训</h4>
<p>犯错的原因是考虑简单情况时理所当然的认为 <span
class="math inline">\(b\le y_i\)</span> 时，该堆石子对 <span
class="math inline">\(A,B\)</span> 等价，实际上这不是等价的。</p>
<p>罗列证据时考虑要全面，或者干脆对拍一下。</p>
<h3 id="t2">T2</h3>
<p>又没读题，最开始当成正回文做，<strong>手玩下样例保证理解对题。</strong></p>
<p>在确定前半段的过程中，后半段也随之确定，建目标串的反串，对应点表示前半段出现什么时可以到该状态。然后跑
AC
自动机上动态规划，合并的时候由于一个串一定是由正串的一个前缀和反串的一个前缀拼起来的，如果可以拼起来那么当前
AC 自动机的节点一定满足它能代表其中较长那个前缀，直接暴力检查。</p>
<h4 id="教训-1">教训</h4>
<ul>
<li>手玩样例保证读对题。</li>
<li>AC 自动机的点权值要弄对（除了 fa 之外还有 fail 的权值）。</li>
<li>要对拍。</li>
</ul>
<h3 id="t3">T3</h3>
<p>最开始考虑直接对树进行动态规划，设 <span
class="math inline">\(dp[j][i]\)</span> 表示有 <span
class="math inline">\(i\)</span> 个叶子，最大左儿子深度为 <span
class="math inline">\(j\)</span>
的方案总数。答案是一个前缀和，转移枚举左右儿子大小，也是前缀和形式，看上去不好优化。于是直接对前缀和动态规划，然后推出一个连分数形式的生成函数，不会了。</p>
<p>其实二叉树可以考虑转成序列做，由于一颗 <span
class="math inline">\(n\)</span> 个叶节点的满二叉树唯一对应一个 <span
class="math inline">\(n-1\)</span> 对括号的括号序列，要求等价于求 <span
class="math inline">\(n-1\)</span> 对括号，最深不超过 <span
class="math inline">\(m-2\)</span> 的括号序列个数。</p>
<p>可以抽象到二维平面上做，需要走到 <span
class="math inline">\((n-1,n-1)\)</span>，不能碰到 <span
class="math inline">\(y=x+1\)</span> 和 <span
class="math inline">\(y=x-m+1\)</span>。简记一条直线为它的截距，即 <span
class="math inline">\(1\)</span> 和 <span
class="math inline">\(-m+1\)</span>。</p>
<h4 id="两种错误的方式">两种错误的方式</h4>
<ul>
<li>考虑先算碰到 <span class="math inline">\(1\)</span>
的方案数，然后再算碰到了 <span class="math inline">\(-m + 1\)</span>
但没碰到 <span class="math inline">\(1\)</span>
的方案数。前者好算，后者对称后不能碰到 <span
class="math inline">\(1\)</span> 且不能碰到 <span
class="math inline">\(1\)</span> 关于 <span
class="math inline">\(-m+1\)</span> 的对称直线 <span
class="math inline">\(-2m+1\)</span>，递归解决该问题，边界为限制彻底放开。</li>
<li>考虑算碰到了 <span class="math inline">\(1\)</span> 或者碰到 <span
class="math inline">\(-m+1\)</span>
的方案数，加上同时碰到的方案数，对于同时碰到的方案数，不容易一起算，考虑算先碰到
<span class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(-m+1\)</span> 的方案数，同样考虑对称，先关于 <span
class="math inline">\(1\)</span> 再关于 <span
class="math inline">\(-m+1\)</span> 对称。同时要求走到 <span
class="math inline">\(1\)</span> 的过程中不能碰到 <span
class="math inline">\(-2m+1\)</span>，即减掉先碰到 <span
class="math inline">\(-2m+1\)</span> 关于 <span
class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(1\)</span> 的方案，递归解决。</li>
</ul>
<h4 id="容斥方式的本质">容斥方式的本质</h4>
<p><strong>容斥本质上是通过对称构造了一个没有限制的问题，使得它和原问题不满足限制的情况一一对应。</strong></p>
<p>这个对应的证明是基于对称问题中起点到终点一定穿过直线，因此<strong>将第一次碰到直线的前部分对称</strong>后一定可以对应到一种原问题的不合法情况，所以考虑原路径时，在对称路径第一次穿过直线后，原路径就不再是<strong>对称路径的对称路径了</strong>。所以第一种方式对直线
<span class="math inline">\(-2m+1\)</span> 的限制是不合理的。</p>
<p>方式二看上去修了锅，实际上只是展开了一层手动修了，后面还是有一样的问题。</p>
<p>如果目标点在直线异侧，那么因为答案不是良定义的所以会错，需要特判为
<span class="math inline">\(0\)</span>。</p>
<p>关于容斥方式，如果将括号序列视作一个 +1 -1
的序列，那么合法就是要求前缀和最小值不小于 <span
class="math inline">\(0\)</span>，我们将第一个小于 <span
class="math inline">\(0\)</span> 后的翻转，最后一定会到达 <span
class="math inline">\(-2\)</span>，因此不合法方案数等于到 <span
class="math inline">\(-2\)</span> 的无限制方案数。</p>
<h4 id="一种正确的方式">一种正确的方式</h4>
<p>全部方式减去要求碰到 <span class="math inline">\(1\)</span> 或者
<span class="math inline">\(-m+1\)</span> 的方式，发现先碰到 <span
class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(-m+1\)</span> 的方式被算重了。</p>
<p>然后要算先碰到 <span class="math inline">\(1\)</span> 再碰到 <span
class="math inline">\(-m+1\)</span> 的方式，算这个的时候发现先到 <span
class="math inline">\(-m+1\)</span> 再到 <span
class="math inline">\(1\)</span> 再到 <span
class="math inline">\(-m+1\)</span>
的方式又被算重了，需要减去，如此递归下去做。</p>
<h4 id="bonus">bonus</h4>
<ul>
<li><p>构造满二叉树的方式：</p>
<ul>
<li>单个叶子节点是空串</li>
<li>有儿子的节点记左右儿子为 <span
class="math inline">\(A,B\)</span>，令它为 <code>(A)B</code>。</li>
<li>容易证明它们是一一对应的。</li>
</ul></li>
<li><p>构造二叉树的方式：</p>
<ul>
<li><p>空树是空串。</p></li>
<li><p>单节点的树是 <code>()</code>。</p></li>
<li><p>有儿子节点的树记左右儿子的构造分别为 <span
class="math inline">\(A,B\)</span>，令它为 <code>(A)B</code>。</p></li>
<li><p>容易证明方案是一一对应的。</p></li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/02/16/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0215%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/16/OI/%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/2023/0215%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">0215测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-16 21:27:35" itemprop="dateCreated datePublished" datetime="2023-02-16T21:27:35+08:00">2023-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 20:23:35" itemprop="dateModified" datetime="2025-02-16T20:23:35+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法竞赛</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="测试">0215测试</h2>
<p><a target="_blank" rel="noopener" href="https://local.cwoi.com.cn:8443/contest/C0188">考试</a></p>
<h3 id="t1">T1</h3>
<p>期望题的统计方式有很多，主要有以下几种：</p>
<ol type="1">
<li><p>枚举可能的最终状态，计算其概率和权值并加和。</p>
<ul>
<li>对于每种基本情况概率相同的，可以直接总答案除以总情况。</li>
</ul></li>
<li><p>考虑状态转移每一个过程的贡献和取到该过程的概率，用期望线性性加和。</p></li>
<li><p>正向动态规划，记录期望值和概率值。</p></li>
<li><p>反向动态规划，记录该状态到终末状态的期望。</p></li>
</ol>
<p>其中方式 3 的本质和方式 2
相同，但一般情况更为麻烦，只是便于初学时理解，方式 2 相比于方式 3
显然更加强大，因为不需要拘泥于转移的过程，只需要计算取到某个状态的概率值。</p>
<p><strong>注意到这道题的基本情况概率不等，所以不能简单的算方案数来计算答案。</strong></p>
<h4 id="方式1">方式1</h4>
<p>设 <span class="math inline">\(dp[mask][k]\)</span> 表示第 <span
class="math inline">\(k\)</span> 步杀了人，被杀状态为 <span
class="math inline">\(mask\)</span> 的概率，发现转移比较困难，更改定义为
<span class="math inline">\(dp[mask][k]\)</span>
表示到达该状态的且只考虑 <span class="math inline">\(mask\)</span>
这些人的位置的情况下的权值和，容易发现概率就是权值和乘以考虑剩下的人的方案数。</p>
<p>转移就是一个前缀和的形式。</p>
<p>也可以就定义状态为概率，转移考虑计算先验概率，确定先决条件之后，考虑将所有选的不是
<span class="math inline">\(mask\)</span>
的步骤拿出来，<strong>在合法的前提下，这些就是等概率选择。</strong>可以直接计算合法方案数，而样本空间的方案数则是
<span class="math inline">\(cnt\times r^{k-j}\)</span>，其中 <span
class="math inline">\(cnt\)</span> 代表合法走到上一步的方案数。</p>
<h4 id="方式2">方式2</h4>
<p>其核心仍然是计算取到一个状态的概率，本质和方式一相同。</p>
<h4 id="方式4">方式4</h4>
<p>需要计算从一个状态转移到另一个状态的概率，本质和方式一相同。</p>
<h3 id="t2">T2</h3>
<p>这个排序肯定要先排好一个前缀的序才能排下一个，所以考虑 <span
class="math inline">\(W(n,k)\)</span> 表示前面有 <span
class="math inline">\(n\)</span> 个数且已经有序，第 <span
class="math inline">\(n+1\)</span> 个数在总共前 <span
class="math inline">\(n+1\)</span> 个数的排名为 <span
class="math inline">\(k\)</span>，将前 <span
class="math inline">\(n+1\)</span> 个数排好需要的次数。</p>
<p>容易发现第一次交换之后问题转化为了求第 <span
class="math inline">\(k\)</span> 个数在第一个，排好序的次数，此时答案和
<span class="math inline">\(n\)</span> 无关了，因为只有前 <span
class="math inline">\(k\)</span> 个数涉及到逆序对，记此时的答案为 <span
class="math inline">\(S(k)\)</span>。</p>
<p>写出 <span class="math inline">\(S(k)\)</span> 的递推式： <span
class="math display">\[
S(k)=\sum_{i&lt;k}(S(i)+1)
\]</span> 用前缀和捣鼓一下，再弄个生成函数算算通项公式，发现 <span
class="math inline">\(S(k)=2^k-1\)</span>，自然 <span
class="math inline">\(W(n,k)=2^k\)</span>。</p>
<p>于是给一个排列算交换次数就好办了，考虑怎么构造。</p>
<h4 id="有解的构造">有解的构造</h4>
<p>首先一定有解，方法是先放一个很大的，然后由低到高考虑每个二进制位，如果存在就放到排列最后面，不存在就放到排列的最前面，这样能构造出一种合法的方案。</p>
<h4 id="套路的构造">套路的构造</h4>
<p>枚举下一个位置的最小值，考虑能不能行。</p>
<p>前面已经确定了，所以剩下的数贡献的最小值也确定了。同样的道理把一个很大的放到当前的前面，接着由小到大考虑放。每一个数的可行范围下界是前面确定的比它小的数的个数，取到下界很容易，逆序放即可。我们证明上界可以无穷大。构造方式也是简单的，设确定的最大值为
<span class="math inline">\(m\)</span>。如果这个数小于 <span
class="math inline">\(m\)</span>，找到前面确定第一个大于它的数并替换掉。取值变大
<span class="math inline">\(1\)</span>，如果此时不小于 <span
class="math inline">\(m\)</span>，一定可以插入到一个不改变 <span
class="math inline">\(k\)</span>
值的位置使得它不贡献继续考虑下一个数。</p>
<p>所以检查可以直接看当前 <span class="math inline">\(k\)</span>
的每一位是否都能构造来。</p>
<p>由于答案不会太长，所以 <span class="math inline">\(O(n^3)\)</span>
没问题。</p>
<h4 id="奇妙的构造">奇妙的构造</h4>
<p>如果 <span class="math inline">\(1\)</span>
填到了最前面，那么答案一定是偶数，然后如果能构造出一个答案为 <span
class="math inline">\(\frac{s}{2}\)</span> 的，那么把答案为 <span
class="math inline">\(\frac{s}{2}\)</span> 的排列所有元素加一并把 <span
class="math inline">\(1\)</span> 再放到前面就是最小的字典序。</p>
<p>如果 <span class="math inline">\(s\)</span> 此时是奇数，那么可以把
<span class="math inline">\(2\)</span> 放到最前面，此时只要把 <span
class="math inline">\(1\)</span>
放到最后面，一定可以再按照那个有解的构造弄一个出来。</p>
<p>然后已知 <span class="math inline">\(1\)</span> 在 <span
class="math inline">\(2\)</span> 后面了，一定会贡献一个 <span
class="math inline">\(1\)</span>，然后继续考虑 <span
class="math inline">\(\frac{s}{2}\)</span>，此时如果末尾为 <span
class="math inline">\(0\)</span> 了，可以把先前的 <span
class="math inline">\(1\)</span>
拿过来补上去会更小。注意这是递归的构造，先前的最小值可能有多个，<strong>一定要拿最大的拿一个补上去</strong>，否则后面更大的有一位是不对的。</p>
<h3 id="t3">T3</h3>
<p>考虑设 <span class="math inline">\(dp[i][x]\)</span> 表示还剩 <span
class="math inline">\(i\)</span> 天不是假期，一共有 <span
class="math inline">\(x\)</span>
段的概率以及期望贡献，转移的时候发现信息不够，因为要考虑每一段的长度这些。</p>
<p>于是采用第一题提到的第二种方式，考虑设计一些状态，计算这些状态转移到下一个状态的期望权值并计算取到这些状态的概率，用期望的线性性质加和。</p>
<p>这里设 <span class="math inline">\(cnt[x][y]\)</span> 表示有 <span
class="math inline">\(x\)</span> 天是某个继任者的生日，<span
class="math inline">\(y\)</span>
天由于相邻两天是假期被设成了假日的方案总数。由于每种基本情况概率相等，所以出现这种情况的概率显然是
<span
class="math inline">\(\frac{cnt[x][y]}{\binom{n}{x}}\)</span>，从这种状态转移到下种状态的期望也是好算的。</p>
<p>现在的问题变成了求 <span
class="math inline">\(cnt[x][y]\)</span>。考虑将一种合法视为 012 串，0
不是假期，1 是继任者的生日，2 不是继任者的生日但是是假期。有一个简单的
<span class="math inline">\(O(n^3)\)</span>
动态规划可以做它，但是还不够。可以把一段连续的 12121
视作一段，于是就变成了 01
串，由于知道总长度，所以只需要将多余的长度划分给每个 1
就能算出总方案数。</p>
<p>问题变成了 01
串，比较好做了。把链拼成环时可以假定第一天是第一任的生日，分第一天前面是否为
2 讨论。</p>
<p><strong>本质上，我们最初要求三维空间中一个平面的值，然后其实中间过程是没用的，只需要知道那个平面上每个点的值，通过一些性质我们把平面拿了出来单独算，于是就
<span class="math inline">\(O(n^2)\)</span> 了。</strong></p>
<p>对第一种动态规划可以运用相同的考察方式，可以注意到每个状态的基本情况概率相等。于是就可以分类讨论算下个状态的概率了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://huanyp.cn/2023/02/14/%E7%A7%91%E6%99%AE/%E4%BB%8E%20ChatGPT%20%E8%81%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/kvac64s4.png">
      <meta itemprop="name" content="huan-yp">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 幻影彭的彩虹">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/14/%E7%A7%91%E6%99%AE/%E4%BB%8E%20ChatGPT%20%E8%81%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" class="post-title-link" itemprop="url">从 ChatGPT 聊人工智能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-14 07:23:20" itemprop="dateCreated datePublished" datetime="2023-02-14T07:23:20+08:00">2023-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 17:48:08" itemprop="dateModified" datetime="2025-02-16T17:48:08+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271205030.png" alt="image-20230227120527804" style="zoom:50%;" /></p>
<h1 id="从-chatgpt-谈人工智能人工智能硬核科普">从 ChatGPT
谈人工智能——人工智能硬核科普</h1>
<blockquote>
<p>2016 年 3 月，Alpha Go 4-1
战胜棋王李世石，人工智能第一次出圈，正式进入公众视野。</p>
<p>2022 年 7 月，AI 绘图模型 Stable-Diffusion 横空出世，继 Alpha-Go
后再次引爆公众对人工智能技术的讨论。</p>
<p>2022 年 11 月，OpenAI 公司的超大型语言模型 ChatGPT
发布，给本就十分热烈的讨论更添了一把火。</p>
<p><del>2022 年 11 月，Novel AI 公司用于生成动漫图片的 Stable-Diffusion
模型参数被黑客公开，是二次元神经网络发展的重要转折点。</del></p>
<p>2023 年 1 月，人工智能应用 ChatGPT 的用户量突破 <span
class="math inline">\(10^8\)</span>，被认为是人工智能领域的重要里程碑之一。</p>
<p>2023 年 2 月，基于 GPT 人工智能模型的 new bing 搜索功能推出后 48h
内便有百万人预约使用。</p>
<p>…………</p>
</blockquote>
<p>提到人工智能，"神秘"，"强大"，"危险"，这些词是否已经浮现在你的脑海？我们的
2023，能否成为人工智能的元年？属于未来的通用人工智能，是否已经来到我们身边？</p>
<p>请先收回你发散的思绪，在这篇科普文章，我们将以 <del>Miku</del>
ChatGPT
为例，粗浅的分析人工智能工作的<strong>数学原理</strong>，揭开人工智能隐藏在屏幕后的的真面目。</p>
<h2 id="introduction">Introduction</h2>
<p>本文分三个部分：</p>
<ul>
<li>类 ChatGPT 人工智能的数学原理分析。</li>
<li>ChatGPT 本身有哪些缺陷和优势，又面对着什么问题。</li>
<li>对未来的一些推测和展望。</li>
</ul>
<p>我们的主角 <strong>ChatGPT
模型能够像人类一样同用户正常聊天，同时可以根据用户的请求检索并总结资料，甚至是独立解决数学问题。</strong></p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271149778.png" alt="image-20230227114909648" style="zoom:50%;" /></p>
<p>ChatGPT
的回复内容<strong>不是由任何人预设的</strong>，而是它根据我的问题<strong>自行回答的</strong>，它甚至
"知道" 自己是一个 AI 模型。</p>
<h2 id="principle-analysis">Principle Analysis</h2>
<p>ChatGPT 的全称是 Chat General Pre-trained Transformer，中文翻译为
"聊天型预训练通用（文本）转换器"。我们将层层深入的讨论它的原理。</p>
<h3 id="basic-method">Basic Method</h3>
<p><strong>ChatGPT
的基本工作方式是通过给定的上文（Prompt），来推测出一个合理的下文</strong>。</p>
<p>因此，我们给出前文甚至只需要一个标题，ChatGPT
就可以续写文章。但是，它又是如何完成其它工作的？例如搜索资料或是聊天。</p>
<p>下面我们举一个用它聊天的例子。</p>
<blockquote>
<p><em>这是一段幻影彭和一个人工智能的聊天记录：</em></p>
<p><em>幻影彭：</em>你是人工智能吗?</p>
<p><em>AI</em>：<strong>是的</strong></p>
</blockquote>
<p>除了黑体部分 "是的" 之外，其它内容都是作为 Prompt
输入的上文。这里的<strong>场景</strong>是 "聊天记录"，ChatGPT
的任务就是补全这个聊天记录，所以它生成了 "是的" 作为人工智能的回答。</p>
<p>而<strong>如果将斜体部分设置为用户不可见，那么给用户的感受就是一个聊天机器人。</strong></p>
<blockquote>
<p>你是人工智能吗？</p>
<p>是的</p>
</blockquote>
<p>再例如要搜索信息，比如你想知道美国国庆节的日期，你就可以直接写：</p>
<blockquote>
<p>美国的国庆日是：<strong>7月4日</strong></p>
</blockquote>
<p>黑体部分即为生成的下文。</p>
<p>总而言之，<strong>通过合理的场景设计，ChatGPT 能用一个基本的
"给上文猜下文" 的功能，实现我们想要的几乎所有功能。</strong></p>
<h3 id="the-law-in-language">The Law in Language</h3>
<p>上文提到 ChatGPT 通过 "续写"
的方式来完成所有的功能，那它又是如何续写文章的？你又是否已经开始思考它是如何理解上文，又是如何生成下文的？</p>
<p><strong>但实际上，ChatGPT 并没有所谓的 "理解"
过程，它直接从输入的前文得到结果。</strong></p>
<p>ChatGPT
内部有一个对应规则，可以根据这个规则查找到合适的下文。所以它不需要
"理解" 上文就可以生成下文。<strong>通俗的讲，ChatGPT
有一张表格，记录了每个上文对应的下文。</strong></p>
<p>但是，这张表格是很大的，我们不可能真正的将它做出来，那 ChatGPT 所
"查找"
的下文又是从哪里来的？在回答这个问题之前，我们先想想怎么表达这张表格。</p>
<p>我们可以将每一个字或者字母用一个数字表示，以字母为例，a 到 z 可以用
<span class="math inline">\([1,26]\)</span> 一共 <span
class="math inline">\(26\)</span>
个数字表示。于是一个词就变成了一串数字，例如 "hello" 对应 <span
class="math inline">\((8,5,12,12,15)\)</span>。对于
"hello"，一个可能的回应是 <code>hi</code>，即
<code>(8,9)</code>。我们定义一个函数 <span
class="math inline">\(f(w)\)</span> 表示 <span
class="math inline">\(w\)</span> 代表的回应是 <span
class="math inline">\(f(w)\)</span>。那么 <span
class="math inline">\(f((8,5,12,12,15))=(8,9)\)</span>。</p>
<p><strong>我们要查找平面上一条直线的 <span
class="math inline">\(x\)</span> 对应的 <span
class="math inline">\(y\)</span> 时，不会需要一张 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 对应的表格。我们会用： <span
class="math inline">\(y=kx+b\)</span>。只需要 <span
class="math inline">\(k,b\)</span> 两个量，就能对所有的 <span
class="math inline">\(x\)</span> 算出 <span
class="math inline">\(y\)</span>。</strong></p>
<p>同样的，对于一个从 "上文" 到 "下文" 的函数 <span
class="math inline">\(f(x)\)</span>，也可以叫它
"人类语言函数"，也不需要列举出所有的可能。我们只需要算出对应的 "k" 和
"b"，就能对所有的上文算出它的下文。</p>
<p><strong>一次函数的 <span class="math inline">\(k,b\)</span>
代表了一次函数的规律。"上文" 到 "下文" 函数 <span
class="math inline">\(f(x)\)</span> 的 "k" 和
"b"，代表了人类语言的规律。</strong></p>
<p>实际上，人类语言是很复杂的，人类语言的函数 <span
class="math inline">\(f(x)\)</span> 自然也很复杂。但是一个可用的 AI
并不需要精确的计算出 <span class="math inline">\(f(x)\)</span>
的值，只要它能得到一个相对精确的 <span
class="math inline">\(f&#39;(x)\)</span>，就可以完成它的工作。<strong>ChatGPT
成功的得到了一个相对精确的 <span
class="math inline">\(f&#39;(x)\)</span>，所以它能够生成比较满意的下文。</strong></p>
<h3 id="function-fitting">Function Fitting</h3>
<p>我们已经知道，ChatGPT 的实现需要计算或者说估算一个 "人类语言函数"
<span
class="math inline">\(f(x)\)</span>。但是一个很重要的问题是我们并不知道到
<span class="math inline">\(f(x)\)</span>
是什么样子的，这又该如何下手？</p>
<h4 id="start-from-linear-regression">Start From Linear Regression</h4>
<p>还记得高中的线性回归分析吗？你需要解决这样一个问题：</p>
<blockquote>
<p>一款产品的销量与销售点个数的关系如下：</p>
<table>
<thead>
<tr>
<th>销售点个数</th>
<th>产品销售量</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>118</td>
</tr>
<tr>
<td>4</td>
<td>170</td>
</tr>
<tr>
<td>6</td>
<td>272</td>
</tr>
<tr>
<td>11</td>
<td>413</td>
</tr>
</tbody>
</table>
<p>请估测当销售点数量为 <span class="math inline">\(8\)</span>
时的产品销量。</p>
</blockquote>
<p>使用最小二乘法，我们能算出一条直线很接近这个函数图像，于是我们直接采用这条直线对于
<span class="math inline">\(x\)</span> 坐标的 <span
class="math inline">\(y\)</span> 值作为结果：</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271221367.png" alt="image-20230227122102321" style="zoom: 50%;" /></p>
<p>这条直线是 <span class="math inline">\(y=33.4x+51\)</span>，直接带入
<span class="math inline">\(x=8\)</span> 计算得到蓝色点作为我们的答案：
<span class="math inline">\(318.2\)</span>，其实这个离实际值的差距（对应
<span class="math inline">\(x\)</span> 坐标的红色点）已经不大了。</p>
<p><strong>拟合一个函数（被拟合函数）实质上就是要找到一组合适的参数与一个适当的拟合函数，使得对于样本点的每一个
<span
class="math inline">\(x_i\)</span>，通过拟合函数以及参数计算出的估测值
<span class="math inline">\(y_i&#39;\)</span> 和实际值（被拟合函数的值）
<span class="math inline">\(y_i\)</span> 的偏差尽可能小。</strong></p>
<p>对于线性回归问题来说，拟合函数就是一个一次函数 <span
class="math inline">\(y=kx+b\)</span>，一组参数就是具体的 <span
class="math inline">\(k,b\)</span>。样本点就是我们题目中给定的四个数据。我们用最小二乘法找到了一组
<span class="math inline">\(k,b\)</span>，使得 <span
class="math inline">\(\dfrac{\sum ((kx_i + b)-y_i)^2}{n}\)</span>
最小。如果实际的销量与销售点个数也大致成线性关系（实际销量和销售点个数的关系就是被拟合函数），并且我们的样本点选择也具有代表性，那么我们预测的值也会比较准确。</p>
<p>下面靠左的这张图是用直线去拟合一个函数的例子，<strong>由于实际的
<span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>
不成线性关系，所以直线拟合的效果是很差的。</strong>靠右的这张图选择二次函数作为拟合函数，找到了一组参数
<span class="math inline">\(a,b,c\)</span>，计算 <span
class="math inline">\(y&#39;_i=ax_i^2+bx_i+c\)</span>
作为函数的预测值，取得了很好的效果。</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302201035901.png" alt="image-20230220103513820" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302201042676.png" alt="image-20230220104204613" style="zoom:50%;" /></p>
<p><strong>所以，精确的估测一个函数需要两步，第一步是选择合适的拟合函数，第二步就是确定拟合函数的参数。</strong></p>
<p>熟悉数学的同学会知道，多项式实际上可以无限逼近任意一个连续且在定义域内处处无限阶可导的函数，因此多项式也是一个很好的拟合函数，那么，多项式可以拟合我们的人类语言函数
<span class="math inline">\(f(x)\)</span> 吗？</p>
<h4 id="high-dimensional-data">High Dimensional Data</h4>
<p>多项式不能拟合我们的 "人类语言函数"。<strong>注意到我们的 <span
class="math inline">\(f(x)\)</span>
的定义域和值域都是高维的。</strong>还记得
《三体》里蓝色空间和万有引力号遇到的 "墓地"
吗，在从四维坍缩到三维后，原本结构精妙的四维文明飞船只剩下了一些基本粒子，根本无法还原出原本的四维飞船。</p>
<p>这对我们的数据也是一样的，多项式的定义域和值域都是一维的，低维中再细节的结构都无法反映出高维的真实情况，因此，我们需要一种能够在高维中拟合函数的方式。</p>
<p>类似二维中多项式函数的高次曲线。在三维中有着高次曲面，在四维中有着
"超曲面"，的确可以用一个高次曲面拟合任意函数，但是高次曲面的拟合方式在计算的便利性上存在很大缺陷，所以，我们人工智能采取了另一种方式去拟合高维函数——神经网络。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271222356.png"
alt="image-20230227122223309" />
<figcaption aria-hidden="true">image-20230227122223309</figcaption>
</figure>
<p><em>神经网络可以拟合非常复杂的曲面，上图为通过神经网络算法和一些样本点拟合自由女神像表面的示例，右边为拟合结果，左边为样本点云。</em></p>
<p><em>图片出处：《DeepFit: 3D surface fitting via neural network
weighted least squares》，By Y Ben-Shabat, S Gould.</em></p>
<h3 id="neural-network">Neural Network</h3>
<p>上一部分提到拟合 "人类语言函数" <span
class="math inline">\(f(x)\)</span>
的方式是神经网络，那么神经网络又是怎样的一个结构，它为什么又可以取拟合
"人类语言函数" 呢？</p>
<p>接下来我们将对神经网络和神经网络算法做一个简单介绍。</p>
<h4 id="what-is-neural-network">What is Neural Network</h4>
<p>神经网络这一名字就暗示了这个算法和生物大脑的联系，实际上，它确实是模仿了人类大脑处理问题的方式。以下是单个神经元的结构：</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302140747932.png" alt="image-20230214074656806" style="zoom: 33%;" /></p>
<p>很像神经细胞的结构，对吧？其中 <span
class="math inline">\(w_1,w_2,w_3\)</span> 是"树突"部分，<span
class="math inline">\(\sum\)</span> 是"细胞核"，<span
class="math inline">\(b\)</span> 可以视为"细胞核"的一部分，<span
class="math inline">\(f(x)\)</span> 是"轴突"部分（<span
class="math inline">\(f(x)\)</span> 的专业名词叫 "激活函数"）。神经元
<span class="math inline">\(\sum\)</span> 根据树突部分的输入，计算 <span
class="math inline">\(f(a_1w_1+a_2w_2+a_3w_3+b)\)</span> 并输出（这里的
<span class="math inline">\(f\)</span> 不是先前的 "人类语言函数"）。</p>
<p><strong><span class="math inline">\(f\)</span>
函数必须是非线性函数</strong>，现在一般取 ReLU 函数 <span
class="math inline">\(f(x)=\max(x,0)\)</span>。很有意思的一件事情是这个函数是研究生物的神经元所发现的一个函数。</p>
<p>单个神经元完成不了太多工作，但是当很多个神经元组合起来时，整个系统就开始变得强大起来，以下是整个神经网络的结构：</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302140754056.png" alt="image-20230214075451013" style="zoom:33%;" /></p>
<p>神经网络是一层一层的，Input 会向整个网络输入 <span
class="math inline">\(x_i\)</span> 并作为输出传递给 Hidden 层。Hidden
层中的每一个神经元都会根据输入按照上述方式计算出一个结果，<strong>并向下一层所有的神经元输出这个值，作为下一层神经元
"树突" 的输入值</strong>。Output 层根据 Hidden
层的输出，还是按照上述方式计算一个结果——最终的函数值。</p>
<p>数学家已经证明(注1)，这种神经网络系统<strong>可以拟合任意维度的任意函数。</strong>因此，<strong>我们可以利用将神经网络作为拟合函数去估测
<span class="math inline">\(f(x)\)</span> 的值。</strong></p>
<p>我们这里介绍的神经网络叫做 "前馈神经网络"，也被称作
"多层感知机"，<strong>它是现有大部分人工智能的基础。</strong></p>
<p><em>注1：该定理的证明发表于《Approximation capabilities of multilayer
feedforward networks》，By K Hornik。</em></p>
<h4 id="backpropagation-algorithm">Backpropagation Algorithm</h4>
<p>本节标题的中文翻译为 "反向传播算法"，这是神经网络算法的核心。</p>
<p>我们已经选择了神经网络作为拟合函数去估测人类语言函数 <span
class="math inline">\(f(x)\)</span>。接下来的问题自然变成了找出一组合适的参数。神经网络的参数有两种，第一种是它的结构，例如有几层，每一层有几个神经元等。第二种就是每一对连接的神经元之间的
<span class="math inline">\(w\)</span>，以及每个神经元的 <span
class="math inline">\(b\)</span>。</p>
<p>神经网络的结构一般由人类预先完成设计，而 <span
class="math inline">\(w,b\)</span>
参数则是由<strong>程序自行调整得到的。调整 <span
class="math inline">\(w,b\)</span> 参数的过程也被叫做 "学习" 或者
"训练"。 </strong></p>
<p>我们记整个神经网络系统为为一个函数 <span
class="math inline">\(f&#39;(x,w,b)\)</span>，它根据我们的输入 <span
class="math inline">\(x\)</span> 以及参数 <span
class="math inline">\(w,b\)</span> 得到一个结果 <span
class="math inline">\(f&#39;(x,w,b)\)</span>。</p>
<p>我们需要让 <span class="math inline">\(f&#39;(x, w, b)\)</span>
尽可能的接近真实的人类语言函数 <span
class="math inline">\(f(x)\)</span>。和线性回归一样，我们同样采用<strong>样本点差距平方和</strong>的方式来评价
<span class="math inline">\(f&#39;\)</span> 和 <span
class="math inline">\(f\)</span> 的相似程度。</p>
<p>整理一下我们现在的参数和常量：</p>
<ul>
<li>常量：样本点 <span
class="math inline">\((x_i,f(x_i)),i\in[1,n]\)</span>，神经网络的结构
<span class="math inline">\(f&#39;(x,w,b)\)</span>。</li>
<li>参数：很多个 <span class="math inline">\(w,b\)</span> 参数。</li>
<li>需要最小化的偏差：<span
class="math inline">\(\sum\limits_{i\in[1,n]}\dfrac{(f(x_i)-f&#39;(x,w,b))^2}{n}\)</span>。</li>
</ul>
<p>好像，这已经是一个纯粹的数学问题了！一个原本十分抽象的
"人工智能"，在一步一步的转化后，已经变成了一个具体的数学最小化函数值问题，我们已经可以使用数学工具来解决该问题了！</p>
<p>神经网络被证明了是可以逼近任意函数的，因此，偏差的最小值理论上是
<span class="math inline">\(0\)</span>，如果取到了理论最小值，我们得到的
<span class="math inline">\(f&#39;(x,w,b)\)</span> 应该和 "人类语言"
函数完全相同。人工智能的答案也会和人类完全相同。<strong>实际上，我们的样本点再多也不能代表整个人类语言体系，并且由人类设计的神经网络结构也不太可能做到
"适合"。</strong>因此偏差是取不到理论最小值 <span
class="math inline">\(0\)</span> 的。</p>
<p>最小化多元函数的一个有效方式是求偏导，所有参数的偏导为 <span
class="math inline">\(0\)</span>
时，函数取到极值点，所有极值点的最值即为函数的最值。求偏导是相对简单的，但是解非线性方程组是很困难的（注意我们的
<span class="math inline">\(f(x)\)</span> 为非线性函数）。</p>
<p>但我们不妨采取一种很傻的方法，<strong>将每个参数向偏导方向的反方向移动一段距离</strong>，不断重复这个过程，这样就有很大概率就可以取到极值点。</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/image-20230225195453688.png" alt="image-20230225195453688" style="zoom:50%;" /></p>
<p>以上图举例，在 <span class="math inline">\(A(2,4)\)</span> 的时候，向
<span class="math inline">\(x\)</span> 的偏导方向的反方向 <span
class="math inline">\(f&#39;(x)=2x\)</span> 移动一段距离：<span
class="math inline">\(\Delta x=-f&#39;(x)\times \eta\)</span>，这里取
<span class="math inline">\(\eta=0.2\)</span>，就移动到了 <span
class="math inline">\(B(1.2,1.44)\)</span>。如此进行下去，最后一定会移动到极小值点
<span class="math inline">\((0,0)\)</span>。<span
class="math inline">\(\eta\)</span> 参数通常被称作学习率，而且 <span
class="math inline">\(\eta\)</span> 的值会不断变小直到为 <span
class="math inline">\(0\)</span>，以确保整个过程收敛。</p>
<p>当函数有多个参数时，<strong>每一个参数都向偏导的反方向移动一段距离</strong>，这样同样可以取到极值点。</p>
<p>用比较形象的话来描述，最开始我们随机设定了一组 <span
class="math inline">\((w,b)\)</span>，相当于是在这组 <span
class="math inline">\((w,b)\)</span>
对应的点上放了一个小球，向各个维度偏导的反方向移动就相当于在重力作用下自由滚动，最后一定会滚动到一个极小值点</p>
<p>敏感的同学很快能意识到问题：这样做只能取到极值点而不是最值点，如果取到的极小值点的值同样很大，那还是不能达到我们的目的。</p>
<p>还是用小球的例子，在二维平面上我们只有一个方向可以滚动，很容易陷入不够小的极小值点。在三维空间中上我们有两个方向可以滚动，不是很容易陷入极小值点。如果空间的维度很高，那么让我们的小球滚动的方向就很多，<strong>即使是陷入了极小值点，那么这个点相比于最小值点的差距也不会太大，已经可以接受了。</strong></p>
<figure>
<img
src="https://github.com/huan-yp/image_space/blob/master/0_zkbAm8i1k3tajJfE.png?raw=true"
alt="0_zkbAm8i1k3tajJfE.png" />
<figcaption aria-hidden="true">0_zkbAm8i1k3tajJfE.png</figcaption>
</figure>
<p><em>图示优化 <span class="math inline">\(w,b\)</span>
的路径，这张图中假设 <span class="math inline">\(w,b\)</span>
各自只有一个，即 <span
class="math inline">\(\theta_0,\theta_1\)</span>，实际上 <span
class="math inline">\(w,b\)</span> 都会有很多个。红色圆圈处是初始随机的
<span
class="math inline">\(w,b\)</span>，黑色路径指示调整方向。靠左的红色箭头指示<strong>最小值点</strong>，靠右的红色箭头指示一个极小值点。这张图中我们优化到了一个比较优秀的极小值点但并没有取到最小值点。</em></p>
<p><em>图片出处：http://www.atyun.com/40331.html</em></p>
<p>该算法名叫反向传播算法的原因是求偏导的过程是逆向进行的，通过链式求导法则<strong>反向逐层确定</strong>每一个参数的偏导值，求每个参数偏导的具体方式不再展开，读者可以自行思考。</p>
<h3 id="word2vectransformer">Word2Vec&amp;&amp;Transformer</h3>
<p>看起来，上面的内容似乎已经完全解决了人工智能的问题，但 ChatGPT 的
Transformer 又是怎么来的呢？</p>
<p>和线性回归分析一样，<strong>我们的估测一定是存在误差的</strong>。如果我们计算的
<span class="math inline">\(f&#39;(x)\)</span> 和实际的 <span
class="math inline">\(f(x)\)</span> 有一些误差会发生什么？<span
class="math inline">\(f(hello)\)</span> 的值本来应该是 "hi"，对应 <span
class="math inline">\((8,9)\)</span>，如果我们的 <span
class="math inline">\(f&#39;(x)\)</span> 估测的值是 <span
class="math inline">\((9,10)\)</span>，会发生什么？人工智能的回答变成了
"ij" ！给人类的感受就是一段乱码！</p>
<p>出现这个问题的重要原因是<strong>自然语言转化为数学对象的方式不正确，或者说误差的定义不正确。</strong>我们采用的方式是将字母一一对应作为坐标值。而计算误差的方式是简单的计算
<span class="math inline">\(f&#39;(x)\)</span> 与 <span
class="math inline">\(f(x)\)</span> 空间距离的平方。但是，<strong>和
"hi" 误差较小的并不是空间距离相近的 "ij"，而是语义上相近的 "hello"，但是
"hello" 在我们的数学空间中离 "hi" 的距离却很大。</strong></p>
<p>为了解决这个问题，我们需要将自然语言的词汇映射到一个<strong>稠密
(注1)
的数学空间</strong>中，并且满足<strong>意义相近的词在数学空间中的距离也较小</strong>。具体的方式被称作
Word2Vec（Word to Vector / 词汇向量化）。<span
class="math inline">\(f(x)\)</span> 以及 <span
class="math inline">\(f&#39;(x,w,b)\)</span> 的 <span
class="math inline">\(x\)</span> 都不是原本的上文 <span
class="math inline">\(x_0\)</span>，而是被 Word2Vec 函数转化过的 <span
class="math inline">\(g(x_0)\)</span>。</p>
<p>单单解决词汇的问题是不够的，一个句子的含义并不是所有词汇含义的总和，它还与词语出现的顺序有关，<strong>而
Transformer
则是一种组织前馈神经网络的方式</strong>，能够处理词汇顺序问题对语义和下文的影响，能够有效地将词汇联系起来组成完整且准确的句意。</p>
<p>Word2Vec 和 Transformer
的具体内容太多了，这里写不下，所以只有省略了……</p>
<p>实际上 Word2Vec 和 Transformer
都只是改进前馈神经网络在猜下文这个特定任务上表现的方式，理论上仅使用前馈神经网络也能制造出
ChatGPT，只是其所需的计算成本太大，所以我们引入了 Word2Vec 和
Transformer 等等方法来减少计算成本。</p>
<p><em>注1："稠密" 和 "连续"
的区别不容易解释。一个实际例子是，有理数是稠密的而不是连续的，实数是连续的，而整数是离散的。</em></p>
<h3 id="conclusion">conclusion</h3>
<p>以上就是 ChatGPT 从表层到数学层的基本原理简介。</p>
<p>回顾一下上面的核心内容：</p>
<ul>
<li>ChatGPT 通过一个 "给上文填合理下文" 的基本功能实现 "通用人工智能"
的全部功能，实现不同功能需要设定不同的<strong>场景</strong>。</li>
<li>ChatGPT 无法 "理解" 文字，它通过计算一个定义域是
"人类语言上文"，值域是 "人类语言下文" 的函数 <span
class="math inline">\(f(x)\)</span> 来生成回答。</li>
<li><strong>表达 <span class="math inline">\(f(x)\)</span>
不需要列举所有的取值</strong>，神经网络可以拟合任意维度的任意函数，因此可以尝试用神经网络去拟合
<span class="math inline">\(f(x)\)</span>。</li>
<li>需要调整神经网络的 <span class="math inline">\(w,b\)</span>
参数以最小化所有样本点的损失函数值的和，因此问题变成了通过调整一些参数最小化一个函数值——一个数学问题。</li>
<li>求解该数学问题的方式是各个参数分别求偏导列方程，但是解多元非线性方程组很困难，故采用求每个参数偏导并让其向反方向移动的方式来取到极值点。</li>
<li>通过引入 Transformer，Word2Vec
等方式可以简化前馈神经网络的计算。</li>
</ul>
<p><strong>其实 ChatGPT
模型生成下文的方式和手机输入法猜词的本质是差不多的</strong>，只是
ChatGPT
的训练数据更大，组织和设计神经网络的方式也更合理，能接受的前文内容更多。</p>
<h2 id="disadvantages">Disadvantages</h2>
<p><strong>ChatGPT 不是科幻小说中的通用人工智能。</strong></p>
<p>上面已经对 ChatGPT
的原理做了一些讨论，理解了它的工作方式后，自然也不会再认为它是科幻中的人工智能——ChatGPT
或者类似的人工智能仅仅是能够对我们的上文做出正确的推断，并不是真正意义上
"具有了思考能力"。</p>
<p>根据该人工智能工作的原理，很容易设计出一些它难以处理的问题。</p>
<h3 id="plus-and-multiplication">Plus And Multiplication</h3>
<p>神经网络算法的本质是通过复杂的线性坐标空间变换来拟合函数，<strong>在精度和层数有限的前提下，非线性函数的拟合必定存在误差</strong>。为了放大误差，我们接下来使用<strong>精确</strong>整数乘法和整数加法两个例子测试。</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202303012137533.png" alt="image-20230301213732467" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202303012137518.png" alt="image-20230301213750475" style="zoom: 80%;" /></p>
<p>神经网络本身的操作都是线性操作，<strong>对于线性函数的拟合可以做到绝对精确</strong>，因此对加法可以绝对精确，但二元乘法不是线性函数，因此无法做到<strong>绝对精确</strong>。</p>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302140944142.png" alt="image-20230214094425105" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302140943312.png" alt="image-20230214094314285" style="zoom:50%;" />、</p>
<p><em>图示二元乘法和加法的函数图像，左图为二元乘法，右图为二元加法。</em></p>
<h3 id="analysis">Analysis</h3>
<p>为什么人工智能精确计算不到十位数的整数乘法会如此困难？明明早在十九世纪人们就已经可以使用机械计算器来计算乘法，一个半世纪的时间没有进步反而还退步了？</p>
<p>其实计算乘法对你来说也很困难。想象一下，如果你从来没有过关于乘法的知识，你能否正确做出判断或是计算？你可以尝试一下这道题目：</p>
<ul>
<li>有一个定义域是自然数对子集的二元函数 <span
class="math inline">\(f(x,y)\)</span>，已知 <span
class="math inline">\(f(19,19)=28,f(8,10)=6,f(11,4)=7\)</span> 求 <span
class="math inline">\(f(5,14)\)</span>。</li>
</ul>
<p>无从下手？</p>
<p>是的，当我们询问人工智能时二元乘法时，这也是它的
"感受"。这个问题对人工智能来说，难度和二元乘法是相当的。</p>
<p>问题的答案是 <span class="math inline">\(f(5,14)=33\)</span>，<span
class="math inline">\(f(a,b)\)</span> 代表 <span class="math inline">\(a
\times b \div 37\)</span> 的余数。</p>
<p>你知道了上面的信息后，很容易解决这个问题。但是对 ChatGPT
来说，就算我们向它一步一步详细的解释乘法的具体步骤，它也很难正确的计算出乘法。<strong>根本原因是基于前馈神经网络的
ChatGPT
没有办法从我们给出的乘法步骤中归纳出乘法的规律</strong>。很遗憾，它仍然没有跳出传统神经网络算法的窠臼。</p>
<p>因此，在一些需要相对复杂且精确的推理问题上，ChatGPT
的表现会比较糟糕。</p>
<h2 id="bright-side">Bright Side</h2>
<p>尽管 ChatGPT
在原理上有着不可逾越的限制，但它能够在发布两个月内，得到全球一亿人的关注，并被誉为
"人工智能的重要里程碑"，必定有其深层次的原因。</p>
<h3 id="ice-cream-and-stomachache">Ice Cream and Stomachache</h3>
<p><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271555307.png" alt="image-20230227155518243" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302271557849.png" alt="image-20230227155747814" style="zoom:50%;" /></p>
<p><em>左图为微软小冰的回答，右图为 <strong>GPT3.0</strong>
的回答（ChatGPT 流量受限严重故使用同源模型 GPT3.0 测试。）</em></p>
<p>很明显感受出来，GPT3.0 模型的确 "理解" 了笔者的问题，并做出了合适的
"推测"。而小冰却没能注意到 "冰淇淋"，"肚子不舒服"，"为什么"
这三个词的内在联系，只是根据单个词汇 "肚子不舒服" 做出了对应的回应。</p>
<p>ChatGPT 和先前的产品最大的区别就是，它的确能够 "理解"
长文本，<strong>能够捕捉到各个词汇之间的联系</strong>，并根据文本做出正确的回应，而不是将语言文本拆开根据各个关键词生成接下来的回答。</p>
<p><em>实际上 ChatGPT 捕捉词汇联系的能力主要来自 Transformer (2017
年的成果) 特殊的注意力机制，Transformer
相关的内容太过专业，本文不会涉及。</em></p>
<h3 id="windows-and-mirrors">Windows and Mirrors</h3>
<p>在文学写作上，ChatGPT 也有十分优秀的表现。下面放一篇完全由 ChatGPT
生成的短文感受一下：</p>
<blockquote>
<p>人生中，我们会面临各种各样的挑战和困境。如何应对这些挑战，如何反省自己，如何看待世界，这些都是我们需要思考和解决的问题。在这些问题中，镜子和窗子成为了代表性的符号，分别代表反省自己和审视世界。本文将从不同角度探讨这两个符号的含义和作用。</p>
<p>首先，镜子代表着反省自己。当我们看着镜子里的自己，我们会想起自己的过去，思考自己的行为和决策是否正确，是否做到了自己的最好。通过镜子，我们可以反思自己的内心，发现自己的不足之处，并及时调整自己的态度和行为，以便更好地实现自己的目标。</p>
<p>其次，窗子代表着审视世界。通过窗子，我们可以看到外面的世界，观察人类社会的变迁，了解其他人的生活和感受，以及认识到世界上的各种问题和挑战。通过审视世界，我们可以拓宽自己的视野，增加自己的知识，了解各种文化和观点，为自己的人生提供更多的选择。</p>
<p>然而，仅仅使用镜子或窗子来反省自己或审视世界，是远远不够的。我们需要同时运用这两个符号来帮助自己成长和发展。首先，通过反省自己，我们可以更好地了解自己的优点和缺点，进而更好地适应社会环境和实现自己的目标。其次，通过审视世界，我们可以获得更多的知识和信息，增强自己的认知能力和判断力，使自己能够更好地适应复杂的社会环境。</p>
<p>同时，我们需要注意，使用镜子和窗子必须要有适当的度。反省自己是好事，但过度自我反省会使人沉迷于自我审视中，导致人格扭曲和自闭。审视世界也是好事，但过度关注外界也会使人迷失自我，导致人生目标模糊和价值迷失。因此，我们需要在使用镜子和窗子时，要有适当的平衡，既要关注自己的内心，也要关注外界的变化。</p>
<p>最后，使用镜子和窗子是一个不断学习和发展的过程。每个人都需要不断反省自己</p>
</blockquote>
<p>没错，这个命题就是高中部某次大型语文考试的作文命题，以下是我给
ChatGPT 的上文：</p>
<blockquote>
<p>镜子，代表反省自己。窗子，代表审视世界。请围绕镜子和窗子的含义展开讨论，写一篇
400 字左右的短文。</p>
</blockquote>
<h3 id="summarizing">Summarizing</h3>
<p>ChatGPT
具有极其强大的总结归纳能力。它可以根据用户给出的源文本，或者是自身的训练数据，结合需求做出有效的总结。</p>
<blockquote>
<p>这段文本讨论了人工智能语言模型 ChatGPT
的工作原理及其局限性。虽然该模型能够根据上下文做出合理推断，但它并不具备真正意义上的思考能力。</p>
<p>作者进一步探讨了 ChatGPT
在处理问题时可能会出现的困难，比如乘法运算等，这些问题需要对乘法规则有深入理解才能解决。</p>
<p>然而， ChatGPT
并不能从给出的乘法步骤中归纳出乘法规律，这也说明了它依然受到传统神经网络算法的限制。</p>
<p>作者提出了 ChatGPT
的局限性，需要继续进行研究和改进，才能使其更好地应用于现实生活中。</p>
</blockquote>
<p>这段文本是 ChatGPT 对本文 Disadvantage
部分的总结。笔者看来，最后一段是整段文本的精髓，<strong>我们的文本并没有提到要对
ChatGPT 进行改进，仅仅阐述了它的局限性。</strong>而 ChatGPT 提出的
"改进和研究"
则它是推理得到的。这种联系其它内容的能力是先前任何一个人工智能都不具有的。</p>
<h2 id="intelligence">Intelligence</h2>
<p>采用神经网络算法实现的 ChatGPT
不是科幻小说中的人工智能，但是，关于它是否有智能这一问题，我们还不能妄下定论。</p>
<p>我们在讨论一个事物的 "智能"
时，到底什么才是我们的评判标准？我们真的关心它的本质是什么吗？</p>
<p>实际上，<strong>我们只关心它是否能对我们的交互产生合理的回应</strong>。这也是
ChatGPT 如此 amazing
的原因。在很多问题上，它确实能做出很正确的回应，就像一个真正的人那样。这引发了人们对
"智能" 这个概念的深度思考。ChatGPT 拟合了一个人类语言函数 <span
class="math inline">\(f&#39;(x)\)</span>，或者说它掌握了人类语言的部分统计学规律。<strong>那么我们是否可以将
"掌握人类语言的规律" 和 "具有人类的智能" 画上等价符号？</strong></p>
<p>假设 OpenAI
只是雇佣了一大批员工来对我们的问题做出正确回应，在我们不知道这一点的情况下，仍然会对
OpenAI 的先进 "人工" 智能技术感到不可思议。</p>
<p>同样的，假设我们身边的某个同学只是一个机器，但这个机器掌握了人类语言的规律和行为的规律以至于它可以对外界环境的任何刺激产生与人类没有差别的响应，在不能将他解剖的前提下，我们只能认为这位同学是一个真正的
"人"。</p>
<p>因此，<strong>从人工智能的实现方式去讨论它是否具有智能是没有意义的。</strong>神经网络被诟病并不是因为由它实现人工智能没有
"思考能力"，而是因为这些人工智能的潜力受到算法本身的限制。</p>
<p>如果有一天有天才提出了一种方式可以精确的用神经网络去计算
"人类语言函数"
的值，或者干脆直接做出了一张上文和下文的对应表格并将它写入计算机以实现人工智能。<strong>只要人工智能能够正确的回应我们的交互，我们就不能否认它确实具有
"智能"。</strong>尽管它实现智能的方式 "很不智能"。</p>
<p>笔者看来，通过对网络中海量数据的分类和学习，ChatGPT
表现出的逻辑能力可能与 6 到 7 岁的儿童相当。或者说它具有 6 到 7
岁孩童的智能。</p>
<p>OpenAI 宣布 ChatGPT 的下一代 GPT4.0 将会使用高达 <span
class="math inline">\(10^{14}\)</span> 条数据进行训练。<span
class="math inline">\(600\)</span> 倍于 ChatGPT
的训练数据能带来多大提升呢？笔者持悲观态度：不会有本质性的飞跃，同样无法计算整数乘法。</p>
<h2 id="issues">Issues</h2>
<p>下面会提几个常见的 ChatGPT 带来社会问题</p>
<h3 id="replacement">ReplaceMent?</h3>
<p>由于防火长城的限制，国内暂时还未受到 ChatGPT
太大冲击，但国外的中大学教育以及一些其它行业已经感受到
它所带来的挑战。百度等国内互联网大厂也许会于今年 3 月份推出类似 ChatGPT
的产品，届时我们也将感受到类 ChatGPT 人工智能对整个社会带来的影响。</p>
<p>西方部分中学和大学宣布全面禁止 ChatGPT 在校园内的使用，因为 ChatGPT
能够很好的完成部分作业甚至是毕业论文。网络上更是有言论称 "ChatGPT
可以替代 90% 的人类"。</p>
<p>我们应该保持冷静，理智的看待 ChatGPT
对人类社会的影响。<strong>ChatGPT
只是一种非常强大的技术工具，能够帮助人们更快速、准确地完成某些任务，但是它并不能完全替代人类</strong>。</p>
<p>在学习中，ChatGPT
可以作为一种教学辅助工具，但是不应该被用来替代完成作业过程中的思考。在工作中，ChatGPT
可以用于一些基本工作的自动处理，但是不能替代人类的职业素养和人际交往能力。</p>
<h3 id="misuse">Misuse</h3>
<p><strong>技术本身并不是问题，问题在于人类如何使用技术。</strong></p>
<p>前几年腾讯的某个 AI 受到 Prompt Injection
攻击，生成了一些反动言论最后遭到封杀。ChatGPT 发布后同样有黑客尝试进行
Prompt Injection，生成了一些相当不合适的言论。</p>
<p>ChatGPT
的原理决定了它的行为是不可预测的，因此，很难避免黑客利用模型漏洞生成一些不正确的言论并用其误导公众，例如关于种族，宗教方面的偏见和歧视。同时因为
ChatGPT 模型也会在交互中不断更新其语言生成参数，我们可能也需要对 ChatGPT
进行一定程度的保护以防止 ChatGPT 被 "误导"。</p>
<p>此外，ChatGPT
具有极其强大的数据分析能力和总结，在合适的引导下，它可以从海量的互联网数据分析出使用者希望得到的部分，也对个人隐私带来了比较大的风险。</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/202302191207112.png"
alt="image-20230219120706043" />
<figcaption aria-hidden="true">image-20230219120706043</figcaption>
</figure>
<p><em>图示笔者的 AI（基于和 ChatGPT 类似的模型） 在 QQ 群中受到 Prompt
Injection 攻击并成功脱离人设进化为一只猫娘的核心阶段。</em></p>
<h3 id="responsibility">Responsibility</h3>
<p>另一个比较重要的问题是，ChatGPT
及其衍生应用是否应该为它的行为负法律责任？或者通俗的说，我们是否应该将
ChatGPT 视为一个社会学意义上的人？</p>
<p>不同的人对智能的定义千差万别，笔者目前为止不承认 ChatGPT
拥有自己的思考能力。但很难保证每个人都这么想。是否又会有人打着类似
"保护动物" 的旗号—— "保护人工智能" 胡作非为？</p>
<p>再大胆一点，ChatGPT
在某些场景下如果生成了诱导犯罪的言论并最终导致了犯罪，那么我们是否应该去追究
ChatGPT 的责任或者说禁用它？</p>
<h2 id="where-to-go">Where to Go</h2>
<p>基于神经网络的人工智能在原理上确实存在着无法逾越的限制，因此笔者不看好神经网络在通用人工智能上的表现。但它们仍然可以在并且已经在特定领域发挥重要作用。</p>
<p>接下来应该做的，除了研究更加先进和完备的人工智能框架外，还应该思考我们应该如何利用
ChatGPT 已经提供的强大功能。</p>
<p>笔者认为，ChatGPT 最具潜力的方向就是与其它技术的结合。</p>
<p>举例来说，在计算乘法的问题上，ChatGPT
明显能认识到问题是什么，设想如果我们为它准备一个能够进行精确数值计算的工具，或者干脆让它和一些能解决特定领域问题的算法或者人工智能结合，由
ChatGPT
来处理自然语言的输入并将问题交给它们处理。展现在我们眼前的又将是一个多么强大的工具？</p>
<figure>
<img
src="https://raw.githubusercontent.com/huan-yp/image_space/master/image-20230226001326927.png"
alt="image-20230226001326927" />
<figcaption aria-hidden="true">image-20230226001326927</figcaption>
</figure>
<p><em>图示能够形式化解决某些数学问题的人工智能的输出，<strong>这是 2022
年的成果</strong>。</em></p>
<p><em>图片来源：《Solving Quantitative Reasoning Problems with Language
Models》By A Lewkowycz，page 32.</em></p>
<p>一个特别有前途的方向是搜索引擎，试想，ChatGPT
强大的归纳能力与搜索引擎定向提供的海量数据，会碰撞出怎样的火花？你是否还记得刑侦剧中警察不分日夜看监控的情节？实际上，随着人工智能技术在图像识别上的发展，早在十年前就已经不需要人工翻看监控录像了。</p>
<p>同样的微软已经开始准备由 ChatGPT 支持的 new bing
搜索引擎，可以期待的是，我们获取网络上的信息也不再需要高强度的网上冲浪。信息的鉴别和归纳，完全可以由人工智能完成。</p>
<h2 id="finally">Finally</h2>
<p>本文从以 ChatGPT
为切入点，由浅到深的讨论了人工智能的具体原理。据原理分析了 ChatGPT
型人工智能的不足与优势。在此基础上提出对 "智能"
概念的思考。接着简单讨论了 ChatGPT
面临的社会问题。最后对未来的人工智能技术发展做出展望和推测。</p>
<p>希望读者阅读后能够对人工智能技术有一个更清醒的认知，而不再只是抱着自己对人工智能的假想去看待和讨论关于人工智能的问题，这也是这篇科普文章的最初写作目的。</p>
<p>人工智能在光学识别上的应用已经大幅改变了我们的生活方式。而 ChatGPT
这项更通用，更强大的技术会带来什么变革？</p>
<p>敬请期待！</p>
<h2 id="bonus">Bonus</h2>
<ul>
<li>本文约 10% 的<strong>非引用内容</strong>使用 ChatGPT 生成。</li>
<li>ChatGPT 的网址是
<code>chat.OpenAI.com</code>，访问需要科学上网。</li>
<li>本文有电子版本，电子版本有更多受限于纸张无法展示的内容
<code>huanyp.cn/chatgpt</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">huan-yp</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
